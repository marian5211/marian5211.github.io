<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[堆排序]]></title>
      <url>/2018/01/31/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章系统设计】从用户系统理解数据库和缓存]]></title>
      <url>/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ul>
<li>Design User System用户系统<ul>
<li>Mencached 优化数据库查询软件</li>
<li>Authentication 用户验证</li>
<li>SQL VS NoSQL 如何选取数据库</li>
<li>Friendship 存储好友关系（不用graph DB用什么）</li>
</ul>
</li>
<li>How to Scale?<ul>
<li>Sharding</li>
<li>Consistent Hashing(第5节)</li>
<li>Replica(第5节)</li>
</ul>
</li>
</ul>
<h2 id="4S分析"><a href="#4S分析" class="headerlink" title="4S分析"></a>4S分析</h2><ul>
<li><p>Scenario场景</p>
<ul>
<li><p>注册、登录、查询、用户修改信息</p>
<p>哪个需求量最大？查询最大，因为用户登录时给他展示的各种信息邓邓就是通过查询出来的结果</p>
</li>
<li><p>支持100M DAU(每日登录用户数)</p>
</li>
<li><p>注册，登录，信息修改QPS约：</p>
<ul>
<li>100M*0.1/86400 ~ 100</li>
<li>0.1=平均每个用户每天登陆+注册+信息修改</li>
<li>Peak = 100*3 = 300</li>
</ul>
</li>
<li><p>查询的QPS约为：</p>
<ul>
<li>100M*100/86400 ~ 100k</li>
<li>100 = 平均每个用户每天查询与用户信息相关的操作次数（查看好友、发信息，更新消息主页等）</li>
<li>Peak = 100k*3 = 300K</li>
</ul>
</li>
</ul>
</li>
<li><p>Service服务</p>
<ul>
<li>一个AuthService 负责登录注册</li>
<li>一个UserService 负责用户信息与存储</li>
<li>一个FriendshipService存储好友关系</li>
</ul>
</li>
<li><p>Storage:QPS与常用数据存储系统</p>
<ul>
<li>MySQL/PostgreSQL等数据库性能<ul>
<li>约1kQPS</li>
</ul>
</li>
<li>MongoDB/Cassandra等硬盘性NoSQL数据库<ul>
<li>约10QPS</li>
</ul>
</li>
<li>Redis/memcached等内存型NoSQL数据库性能<ul>
<li>100k~1mQPS</li>
</ul>
</li>
</ul>
<p>根据上面的QPS分析，注册、登录、信息修改300QPS，用mysql应该就够了</p>
<p>用户查询适合什么样的数据存储系统？</p>
</li>
</ul>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p><strong>用户系统特点：读非常多，写非常少，一定要用Cache进行优化</strong></p>
<ul>
<li>Cache 是什么？<ul>
<li>缓存，把之后可能要查询的东西先存一下<ul>
<li>下次用的时候直接从这里拿，无需重新计算和存取数据库</li>
</ul>
</li>
<li>可以理解为一个Java中的HashMap</li>
<li>key-value的结构</li>
</ul>
</li>
<li>有哪些常用的Cache软件？<ul>
<li>memcached（不支持数据持久化）</li>
<li>Redis(支持数据持久化)</li>
</ul>
</li>
<li>Cache一定存在内存中么？<ul>
<li>不是</li>
<li>Cache是用于连接不同的介质，解决速度差异的问题</li>
<li>File System有时候也是一种cache</li>
<li>CPU也有Cache</li>
<li>内存是硬盘和CPU的cache</li>
</ul>
</li>
<li>Cache一定是Server Cache 么?<ul>
<li>不，浏览器也可能有客户端的cache</li>
</ul>
</li>
</ul>
<h2 id="Mem-Cache"><a href="#Mem-Cache" class="headerlink" title="Mem-Cache"></a>Mem-Cache</h2><p>内存中的Cache</p>
<p>Memcached：一个内存cache软件，就看成hashmap用</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-31-00-30-58.png" alt=""> </p>
<p>35:41</p>
<p>缓存淘汰算法：</p>
<ol>
<li>LRUCache</li>
<li>LFUCache</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java常用笔记]]></title>
      <url>/2018/01/27/Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="JAVA集合类ArrayList删除指定值元素"><a href="#JAVA集合类ArrayList删除指定值元素" class="headerlink" title="JAVA集合类ArrayList删除指定值元素"></a>JAVA集合类ArrayList删除指定值元素</h2><h3 id="错误做法："><a href="#错误做法：" class="headerlink" title="错误做法："></a>错误做法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i = 0, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    if(list.get(i) == 1) &#123;  </div><div class="line">       list.remove(i);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为删除了元素，但是未改变迭代的下标，这样当迭代到最后一个的时候就会抛异常。</p>
<h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>)&#123;  </div><div class="line">       list.remove(i);  </div><div class="line">       len--;</div><div class="line">       i--;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>更好的一个做法</li>
</ul>
<p>List接口内部实现了Iterator接口，提供开发者一个iterator()得到当前list对象的一个iterator对象。所以我们还有一个更好的做法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </div><div class="line">    <span class="keyword">int</span> i = iterator.next();  </div><div class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </div><div class="line">        iterator.remove();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="比较、排序Comparator-Comparable"><a href="#比较、排序Comparator-Comparable" class="headerlink" title="比较、排序Comparator/Comparable"></a>比较、排序Comparator/Comparable</h2><h3 id="1-自定义的类后面需要按指定属性实现排序等操作"><a href="#1-自定义的类后面需要按指定属性实现排序等操作" class="headerlink" title="1.自定义的类后面需要按指定属性实现排序等操作"></a>1.自定义的类后面需要按指定属性实现排序等操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">	String name;</div><div class="line">	<span class="keyword">double</span> salary;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.salary);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-已有模板，定义排序顺序（最大堆、最小堆）"><a href="#2-已有模板，定义排序顺序（最大堆、最小堆）" class="headerlink" title="2.已有模板，定义排序顺序（最大堆、最小堆）"></a>2.已有模板，定义排序顺序（最大堆、最小堆）</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//先定义一个比较器</span></div><div class="line">Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1,Integer e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1 - e2;<span class="comment">//最小堆，默认</span></div><div class="line">         	<span class="comment">//return e2-e1;最大堆</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure>
<p>Long型数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章系统设计】新鲜事系统]]></title>
      <url>/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/design-twitter" target="_blank" rel="external">Design Twitter</a>    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTwitter</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,User&gt; UsersList;</div><div class="line">        <span class="keyword">int</span> tweetTimeStamp = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> id;</div><div class="line">            <span class="keyword">int</span> userId;</div><div class="line">            <span class="keyword">int</span> timeStamp;</div><div class="line">            Tweet(<span class="keyword">int</span> id,<span class="keyword">int</span> useId,<span class="keyword">int</span> timeStamp)&#123;</div><div class="line">                <span class="keyword">this</span>.id = id;</div><div class="line">                <span class="keyword">this</span>.userId = useId;</div><div class="line">                <span class="keyword">this</span>.timeStamp = timeStamp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> uid;</div><div class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;Integer&gt; followers = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//被谁关注</span></div><div class="line">            List&lt;Integer&gt; followees = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//关注了谁</span></div><div class="line">            User(<span class="keyword">int</span> uid)&#123;</div><div class="line">                <span class="keyword">this</span>.uid = uid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</div><div class="line">            UsersList = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Compose a new tweet. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">            &#125;</div><div class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(tweetId,userId,tweetTimeStamp);</div><div class="line">            UsersList.get(userId).tweets.add(tweet);</div><div class="line">            tweetTimeStamp++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">            List&lt;Integer&gt; feeds = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">                <span class="keyword">return</span> feeds;</div><div class="line">            &#125;</div><div class="line">            Comparator&lt;Tweet&gt; cmp = <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet t1,Tweet t2)</span></span>&#123;</div><div class="line">                    <span class="keyword">return</span> t2.timeStamp - t1.timeStamp;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Queue&lt;Tweet&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>,cmp);</div><div class="line">            <span class="comment">//先处理自己的新鲜事</span></div><div class="line">            List&lt;Tweet&gt; ownTweets = UsersList.get(userId).tweets;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = ownTweets.size()-<span class="number">1</span>;i &gt;= ownTweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                heap.add(ownTweets.get(i));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//处理关注的人的新鲜事</span></div><div class="line">            List&lt;Integer&gt; followees = UsersList.get(userId).followees;</div><div class="line">            <span class="keyword">for</span>(Integer followee : followees)&#123;</div><div class="line">                List&lt;Tweet&gt; tweets = UsersList.get(followee).tweets;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tweets.size()-<span class="number">1</span>;i &gt;= tweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                    heap.add(tweets.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty())&#123;</div><div class="line">                feeds.add(heap.poll().id);</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> feeds;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果没有用户，新建用户</span></div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followeeId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followeeId);</div><div class="line">                UsersList.put(followeeId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followerId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followerId);</div><div class="line">                UsersList.put(followerId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || UsersList.get(followerId).followees.contains(followeeId))&#123;<span class="keyword">return</span>;&#125;</div><div class="line">            <span class="comment">//更新用户关注和被关注列表</span></div><div class="line">            UsersList.get(followeeId).followers.add(followerId);</div><div class="line">            UsersList.get(followerId).followees.add(followeeId);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || !UsersList.containsKey(followeeId) || !UsersList.containsKey(followerId) ||</div><div class="line">                    !UsersList.get(followerId).followees.contains(followeeId) || !UsersList.get(followeeId).followers.contains(followerId))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator =  UsersList.get(followeeId).followers.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator.next();</div><div class="line">                <span class="keyword">if</span>(i == followerId)&#123;</div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator2 =  UsersList.get(followerId).followees.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator2.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator2.next();</div><div class="line">                <span class="keyword">if</span>(i == followeeId)&#123;</div><div class="line">                    iterator2.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Twitter obj = <span class="keyword">new</span> Twitter();</div><div class="line">        obj.postTweet(<span class="number">1</span>,<span class="number">5</span>);</div><div class="line">        List&lt;Integer&gt; param_2 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.follow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        obj.postTweet(<span class="number">2</span>,<span class="number">6</span>);</div><div class="line">        List&lt;Integer&gt; param_3 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.unfollow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        List&lt;Integer&gt; param_4 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        DesignTwitter test = <span class="keyword">new</span> DesignTwitter();</div><div class="line">        test.test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这里有个问题，就是follow unfollow post这些都是用户的操作，应该放在用户类里面的，然后再外部调用。有时间重写一下。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java垃圾回收机制]]></title>
      <url>/2018/01/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】图与搜索]]></title>
      <url>/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><ul>
<li><p>graph</p>
<ul>
<li>Clone Graph</li>
<li>Topological Sorting</li>
</ul>
</li>
<li><p>Search</p>
<ul>
<li><p>DFS</p>
</li>
<li><p>BFS:（O(m+n)m为边树，n为点数)</p>
<ul>
<li><p>遍历图</p>
<p>树的BFS需要用队列，在图中除了要用队列还需要用到hash表，用来存储节点是否被访问过</p>
<p>BFS还可以用于求深度，最短路径</p>
</li>
<li><p>简单图求最短路径</p>
</li>
<li><p>拓扑排序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BFS例题"><a href="#BFS例题" class="headerlink" title="BFS例题"></a>BFS例题</h2><h3 id="1-Clone-Graph"><a href="#1-Clone-Graph" class="headerlink" title="1. Clone Graph"></a>1. <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">Clone Graph</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p>
<p>OJ’s undirected graph serialization:</p>
<p>Nodes are labeled uniquely.</p>
<p> We use <code>#</code>as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.</p>
<p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p>
<ol>
<li>First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.</li>
<li>Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.</li>
<li>Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.</li>
</ol>
<p>Visually, the graph looks like the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      /   \</div><div class="line">&gt;     0 --- 2</div><div class="line">&gt;          / \</div><div class="line">&gt;          \_/</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定图中的一个节点，克隆整个图</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>考点：</p>
<ol>
<li>从一个点出发，把整张图的所有节点找到（BFS）nodes</li>
<li>获得nodes之后复制所有的点，将新老节点建立映射关系，存入hashmap中</li>
<li>根据老节点之间的关系和新老节点的映射关系，复制所有的边</li>
<li>最后返回给定的node对应的新节点</li>
</ol>
<p>还可以用DFS：</p>
<p>递归调用复制节点和邻居关系。</p>
<p>DFS的输入是旧结点，返回值是新节点。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphClone</span> </span>&#123;</div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> label;</div><div class="line">         List&lt;UndirectedGraphNode&gt; neighbors;</div><div class="line">         UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</div><div class="line">     &#125;</div><div class="line">     HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//用于存储新旧节点映射关系</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; oldNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//旧结点</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; newNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新节点</span></div><div class="line"></div><div class="line">    <span class="comment">//bfs获取图中所有的点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node)</span></span>&#123;</div><div class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        HashSet&lt;UndirectedGraphNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        queue.add(node);</div><div class="line">        set.add(node);</div><div class="line">        <span class="comment">//BFS</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            UndirectedGraphNode temp = queue.poll();</div><div class="line">            UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(temp.label);</div><div class="line">            oldNodes.add(temp);<span class="comment">//加入旧点集</span></div><div class="line">            newNodes.add(newNode);<span class="comment">//加入新点集</span></div><div class="line">            nodeMap.put(temp,newNode);<span class="comment">//加入mapping</span></div><div class="line"></div><div class="line">            <span class="comment">//遍历当前节点的所有邻居</span></div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : temp.neighbors)&#123;</div><div class="line">                <span class="comment">//如果已经加入结合了，跳过</span></div><div class="line">                <span class="keyword">if</span>(set.contains(neighbor))&#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果还未加入</span></div><div class="line">                queue.add(neighbor);</div><div class="line">                set.add(neighbor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取图中所有的节点</span></div><div class="line">        bfs(node);</div><div class="line">        <span class="comment">//复制所有的边</span></div><div class="line">        <span class="keyword">for</span>(UndirectedGraphNode oldNode : oldNodes)&#123;</div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : oldNode.neighbors)&#123;</div><div class="line">                nodeMap.get(oldNode).neighbors.add(nodeMap.get(neighbor));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回node对应的新节点</span></div><div class="line">        <span class="keyword">return</span> nodeMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DFS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">dfs</span><span class="params">(UndirectedGraphNode node,HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(map.containsKey(node))&#123;</div><div class="line">        <span class="keyword">return</span> map.get(node);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新建节点</span></div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node,newNode);</div><div class="line">    <span class="comment">//遍历邻居节点</span></div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">        newNode.neighbors.add(dfs(neighbor,map));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">    HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(node,map);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h3><p>下面这个图假设是一种上课顺序，比如上1之前必须上0。求这个图的任意一个拓扑排序（按照这个顺序上课则可以上完所有课）</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></a></p>
<p>拓扑排序很好的参考资料：<a href="http://www.stoimen.com/blog/2012/10/01/computer-algorithms-topological-sort-of-a-graph/" target="_blank" rel="external">Topological Sort of a Graph</a></p>
<p>拓扑排序的思路如下：</p>
<ol>
<li>统计当前入度为0的点，加入队列</li>
<li>将当前所有入度为0的点删掉，并将这些点的下一点的连线删掉，将其下一个节点的入度减1</li>
<li>重复1和2，直到所有的点都被删掉</li>
<li>如果不能拓扑排序说明图中一定有环</li>
</ol>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" alt="img"></a></p>
<h3 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a><a href="http://www.lintcode.com/en/problem/topological-sorting/" target="_blank" rel="external">Topological Sorting</a></h3><blockquote>
<p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p>
<ul>
<li>For each directed edge <code>A -&gt; B</code> in graph, A must before B in the order list.</li>
<li>The first node in the order can be any node in the graph with no nodes direct to it.</li>
</ul>
<p>Find any topological order for the given graph.</p>
<p>Example</p>
<p>For graph as follow:</p>
</blockquote>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></p>
<blockquote>
<p>The topological order can be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [0, 1, 2, 3, 4, 5]</div><div class="line">&gt; [0, 2, 3, 1, 5, 4]</div><div class="line">&gt; ...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>核心就是根据拓扑排序给出一条合理的路径，能够遍历图中所有的点，且不违背箭头顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    HashMap&lt;DirectedGraphNode,Integer&gt; degreeIn = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    Queue&lt;DirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    ArrayList&lt;DirectedGraphNode&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//计算入度出度</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode nodeFrom : graph) &#123;</div><div class="line">        <span class="keyword">for</span> (DirectedGraphNode nodeEnd : nodeFrom.neighbors) &#123;</div><div class="line">            <span class="comment">//计算NodeEnd入度</span></div><div class="line">            <span class="keyword">if</span> (!degreeIn.containsKey(nodeEnd)) &#123;</div><div class="line">                degreeIn.put(nodeFrom, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                degreeIn.put(nodeEnd, degreeIn.get(nodeEnd) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs</span></div><div class="line">    <span class="comment">//queue.add(graph.get(0));</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">        <span class="keyword">if</span>(!degreeIn.containsKey(node))&#123;</div><div class="line">            queue.offer(node);</div><div class="line">            results.add(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        DirectedGraphNode node = queue.poll();</div><div class="line">        <span class="comment">//results.add(node);</span></div><div class="line">        <span class="keyword">for</span>(DirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">            degreeIn.put(neighbor,degreeIn.get(neighbor)-<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(degreeIn.get(neighbor) == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(neighbor);</div><div class="line">                results.add(neighbor);</div><div class="line">                <span class="comment">//numNodes--;</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule" target="_blank" rel="external">Course Schedule</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0]]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0],[0,1]]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
</blockquote>
<p>给定课程门数，和课程之间的依赖关系，判断是否可以无冲突完成课程。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>BFS和DFS都可以做</p>
<p>BFS：</p>
<p>拓扑排序的思想，如果最后所有的点都被访问到了，就是可以的，反之不可以。</p>
<p>DFS：</p>
<p>用DFS的核心思想就是遇到某条路径上有环就可以返回false，不用继续判断了。所以需要用一个visited数组来保存节点的访问状态。当沿着某一条路径前进时遇到之前已经访问过的节点，就返回false，如果一直没有出现环则在最后返回true。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] classDegreeIn = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录入度</span></div><div class="line">        <span class="keyword">int</span>[] classDegreeOut = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录出度</span></div><div class="line">        HashMap&lt;Integer,List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            classDegreeIn[edgeEnd]++;</div><div class="line">            classDegreeOut[edgeFrom]++;</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom,<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom,listTemp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//寻找入度为0的点入栈</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numCourses;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(classDegreeIn[i] == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(i);</div><div class="line">                counter++;</div><div class="line">                <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">                hasVisited[i] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> classID = queue.poll();</div><div class="line">            <span class="keyword">if</span>(edges.getOrDefault(classID,<span class="keyword">new</span> ArrayList&lt;&gt;()).size() == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历classID的所有邻居，将其入度-1</span></div><div class="line">            <span class="keyword">for</span>(Integer neighbor : edges.get(classID))&#123;</div><div class="line">                classDegreeIn[neighbor]--;</div><div class="line">                <span class="comment">//如果入度为0,入栈</span></div><div class="line">                <span class="keyword">if</span>(classDegreeIn[neighbor] == <span class="number">0</span>)&#123;</div><div class="line">                    queue.add(neighbor);</div><div class="line">                    counter++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter == numCourses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DFS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used,HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges,Integer node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(used[node])&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(edges.containsKey(node)) &#123;</div><div class="line">            used[node] = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(Integer next: edges.get(node))&#123;</div><div class="line">                <span class="keyword">if</span>(!dfs(used,edges,next))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            used[node] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line"></div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom, <span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom, listTemp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Integer node : edges.keySet())&#123;</div><div class="line">            <span class="keyword">if</span>(!dfs(used,edges,node))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p>
</blockquote>
<p>求从起点到终点的最短路径长度</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>求路径长度一般用BFS，从起点开始把相差一个字母的单词一次入队列，知道遇到结束词时， 此时bfs的深度就是最短路径长度。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(beginWord);</div><div class="line">        <span class="keyword">int</span> step = <span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> queueSize = queue.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;</div><div class="line">                String temp  = queue.peek();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">                        <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;</div><div class="line">                            <span class="keyword">return</span> step;</div><div class="line">                        &#125;</div><div class="line">                        queue.add(wordList.get(j));</div><div class="line">                        isUsed[j] = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                queue.poll();</div><div class="line">            &#125;</div><div class="line">            step++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">        <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a><a href="https://leetcode.com/problems/word-ladder-ii" target="_blank" rel="external">Word Ladder II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>Return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</div><div class="line">&gt;   ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>返回所有的路径长度最短的合法路径。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>找到合法路径，考虑用BFS，找到所有合法的路径，考虑用DFS，这道题目要求找到路径最短的所有合法路径，所以是一道BFS和DFS的综合题目。</p>
<p>如果只用DFS找的话，要遍历所有的路径，势必会超时（我试了，真的超时）</p>
<p>所以采用dfs和bfs结合的办法：</p>
<p>先从endWord到beginWord用BFS找到最短的路径是多少，同时标记经过的点到endWord的最短距离是多少</p>
<p>然后再用DFS从beginWord到endWord找到确定的路径，此时只需要遍历之前遍历过的点，其余的没有经过的点无需遍历，而且可以按距离顺序来遍历，将所有合法的路径加入的结果结合中。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] disToBegin;<span class="comment">//记录距离起点的距离</span></div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs从后向前寻找最短路径长度,标记点到终点的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(endWord);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//endword深度为0</span></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            depth++;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                String temp = queue.poll();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;wordList.size();i++)&#123;</div><div class="line">                    String word = wordList.get(i);</div><div class="line">                    <span class="comment">//如果单词已经加入过队列了，或者和当前节点相差不为1，跳过</span></div><div class="line">                    <span class="keyword">if</span>(word.equals(endWord) || disToBegin[i] &gt; <span class="number">0</span> || !isValid(temp,word))&#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(word.equals(beginWord))&#123;</div><div class="line">                        <span class="keyword">return</span> depth;<span class="comment">//begin节点深度</span></div><div class="line">                    &#125;</div><div class="line">                    queue.add(word);</div><div class="line">                    disToBegin[i] = depth;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从前向后dfs确定具体路径</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String tempWord, String endWord,List&lt;String&gt; wordList,<span class="keyword">int</span> depth)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            temp.add(endWord);</div><div class="line">            results.add(temp);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disToBegin.length;i++)&#123;</div><div class="line">            String wordNext = wordList.get(i);</div><div class="line">            <span class="comment">//寻找深度和字母都符合的单词</span></div><div class="line">            <span class="keyword">if</span>(disToBegin[i] != depth || !isValid(tempWord,wordNext))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(wordNext);</div><div class="line">            dfs(wordNext,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//List&lt;String&gt; words = new ArrayList&lt;&gt;(wordList);</span></div><div class="line">        wordList.add(beginWord);</div><div class="line">        disToBegin = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</div><div class="line">        <span class="keyword">int</span> depth = bfs(beginWord,endWord,wordList);</div><div class="line">        result.add(beginWord);</div><div class="line">        dfs(beginWord,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DFS排列组合"><a href="#DFS排列组合" class="headerlink" title="DFS排列组合"></a>DFS排列组合</h2><p>排列：</p>
<p><a href="https://leetcode.com/problems/permutations" target="_blank" rel="external">Permutations</a>   </p>
<p><a href="https://leetcode.com/problems/permutations-ii" target="_blank" rel="external">Permutations II</a>   </p>
<p>组合：</p>
<h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning" target="_blank" rel="external">Palindrome Partitioning</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,<br>Return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>DFS，对字符串进行分割</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            i++;j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//规定左段包含i,右段不包含i</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end;i++)&#123;</div><div class="line">            String left = s.substring(start,i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(!Palindrome(left))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(left);</div><div class="line">            helper(s,i+<span class="number">1</span>,end);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        helper(s,<span class="number">0</span>,s.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/combination-sum" target="_blank" rel="external">Combination Sum</a> </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>找所有方案的问题一般都是DFS，90%的DFS是排列或者组合。</p>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 <a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="external">Matrix</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.</p>
<p><strong>Example 1: </strong><br>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2: </strong><br>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 1 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 2 1</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>计算每个点距离最近的0的距离</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一:</p>
<p>用BFS，先将所有0的位置放入队列，然后出队列，将其周围点置位1，如队列，然后出队，将其周围点置为2，以此类推。</p>
<p>方法二：</p>
<p>动态规划，先从左上到右下计算每个点离最近的0的距离</p>
<p>然后从右下到左上再来一遍</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">  <span class="keyword">int</span> rows = matrix.length;</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">        dist[i][j] = <span class="number">0</span>;</div><div class="line">        queue.add(i*cols+j);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        dist[i][j] = -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size&gt;<span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> location = queue.poll();</div><div class="line">      <span class="keyword">int</span> row = location/cols;</div><div class="line">      <span class="keyword">int</span> col = location%cols;</div><div class="line">      <span class="keyword">int</span>[] rdelta = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">      <span class="keyword">int</span>[] cdelta = &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> new_row = row+rdelta[i];</div><div class="line">        <span class="keyword">int</span> new_col = col+cdelta[i];</div><div class="line">        <span class="keyword">if</span>(new_row &gt;=<span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_col &lt; cols &amp;&amp; dist[new_row][new_col] == -<span class="number">1</span>)&#123;</div><div class="line">          dist[new_row][new_col] = depth;</div><div class="line">          queue.add(new_row * cols + new_col);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dist;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dist;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="comment">//First pass: check for left and top</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</div><div class="line">                    dist[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    dist[i][j] = rows+cols;</div><div class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//Second pass: check for bottom and right</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Pacific-Atlantic-Water-Flow"><a href="#Pacific-Atlantic-Water-Flow" class="headerlink" title="Pacific Atlantic Water Flow"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="external">Pacific Atlantic Water Flow</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p>
<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>
<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The order of returned grid coordinates does not matter.</li>
<li>Both <em>m</em> and <em>n</em> are less than 150.</li>
</ol>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 5x5 matrix:</div><div class="line">&gt;</div><div class="line">&gt;   Pacific ~   ~   ~   ~   ~ </div><div class="line">&gt;        ~  1   2   2   3  (5) *</div><div class="line">&gt;        ~  3   2   3  (4) (4) *</div><div class="line">&gt;        ~  2   4  (5)  3   1  *</div><div class="line">&gt;        ~ (6) (7)  1   4   5  *</div><div class="line">&gt;        ~ (5)  1   1   2   4  *</div><div class="line">&gt;           *   *   *   *   * Atlantic</div><div class="line">&gt; Return:</div><div class="line">&gt; [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>矩阵左上是pacific 右下是atlantic,找出所有水能够同时流向两个ocean的位置</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用dfs，对pacific ocean从边缘的每一个点向内dfs搜索可以到达的点，就是考虑每一个点的上下左右四个邻居是否比自己高，如果比自己高而且之前还没有遍历过，就继续dfs。对atlantic做同样的操作。两边都可以到达的加入结果集。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] pacific,<span class="keyword">boolean</span>[][] used)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; rows || j &gt; cols)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        pacific[i][j] = <span class="keyword">true</span>;</div><div class="line">        used[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span>[] r_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] c_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> id = <span class="number">0</span> ; id  &lt; <span class="number">4</span>; id++)&#123;</div><div class="line">            <span class="keyword">int</span> new_row = i + r_delta[id];</div><div class="line">            <span class="keyword">int</span> new_col = j + c_delta[id];</div><div class="line">            <span class="keyword">if</span>(new_row &gt;= <span class="number">0</span> &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &lt; cols &amp;&amp; !used[new_row][new_col] &amp;&amp;matrix[new_row][new_col] &gt;= matrix[i][j])&#123;</div><div class="line">                <span class="comment">//pacific[new_row][new_col] = true;</span></div><div class="line">                dfs(matrix,new_row,new_col,pacific,used);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] pacific = n，ew <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理pacific</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[0][i] = true;</span></div><div class="line">            dfs(matrix,<span class="number">0</span>,i,pacific,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][0] = true;</span></div><div class="line">            dfs(matrix,i,<span class="number">0</span>,pacific,used);</div><div class="line">        &#125;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理atlantic</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[rows-1][i] = true;</span></div><div class="line">            dfs(matrix,rows-<span class="number">1</span>,i,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][cols-1] = true;</span></div><div class="line">            dfs(matrix,i,cols-<span class="number">1</span>,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//两个都是true的位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])&#123;</div><div class="line">                    results.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="external">Minesweeper</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定棋盘和点击的点，返回点击之后的棋盘</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>分两种情况讨论，如果点到的地雷，就显示地雷即可；</p>
<p>如果没有点到地雷，则要从这个点开始dfs计算其周围的每个点周围的8个点处有多少个地雷，如果没有就改成B，如果有的话显示数字。对于显示数字的点就无需继续dfs其周围的点了。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minesweeper</span> </span>&#123;</div><div class="line">    <span class="comment">//计算某个位置周围有多少个地雷</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calSweeper</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">            <span class="keyword">if</span>(i+x_delta[ii] &lt; <span class="number">0</span> || j+y_delta[ii] &lt; <span class="number">0</span> || i+x_delta[ii] &gt;= rows || j+y_delta[ii] &gt;= cols)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(board[i+x_delta[ii]][j+y_delta[ii]] == <span class="string">'M'</span>)&#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="comment">//如果出界了，返回</span></div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || board[i][j] == <span class="string">'B'</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'E'</span>)&#123;</div><div class="line">            <span class="keyword">int</span> sum = calSweeper(board,i,j);</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'B'</span>;</div><div class="line">                <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">                <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">                    <span class="comment">//如果还没点过，计算它周围有多少个地雷</span></div><div class="line">                    dfs(board,i+x_delta[ii],j+y_delta[ii]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                board[i][j] = Integer.toString(sum).charAt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="comment">//如果点到地雷</span></div><div class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)&#123;</div><div class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没点到地雷</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(board,click[<span class="number">0</span>],click[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Minesweeper test = <span class="keyword">new</span> Minesweeper();</div><div class="line">        <span class="keyword">char</span>[][] board = &#123;&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'M'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;&#125;;</div><div class="line">        <span class="keyword">char</span>[][] result = test.updateBoard(board,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">0</span>&#125;);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="external">Minimum Height Trees</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p>
<p><strong>Example 1:</strong></p>
<p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         0</div><div class="line">&gt;         |</div><div class="line">&gt;         1</div><div class="line">&gt;        / \</div><div class="line">&gt;       2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[1]</code></p>
<p><strong>Example 2:</strong></p>
<p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0  1  2</div><div class="line">&gt;       \ | /</div><div class="line">&gt;         3</div><div class="line">&gt;         |</div><div class="line">&gt;         4</div><div class="line">&gt;         |</div><div class="line">&gt;         5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[3, 4]</code></p>
</blockquote>
<p>选取图中某一点作为root，使得形成的树高度最小，返回所有高度最小的root点。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用BFS计算了每一个点作为root的深度，超时了。。。。</p>
<p>逐层去掉叶子节点，留下的就是作为root树高最小的节点。思路不难，但还是写了好久</p>
<p>步骤：</p>
<ol>
<li>存储图中节点的度数和点边关系</li>
<li>把度数为1的节点加入叶子节点集合</li>
<li>遍历叶子节点，将与之相连的节点的度数-1，然后将叶子节点删除，同时，如果有节点的度数为1，说明是下一层的叶子节点，加入新叶子集合</li>
<li>当新叶子集合的大小&lt;=2时，说明找到了最终的MHT的root</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界条件处理</span></div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            res.add(<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储点边关系</span></div><div class="line">        List&lt;HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            map.add(<span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="keyword">int</span>[] edgesNum = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储节点的度数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;edges.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> node1 = edges[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> node2 = edges[i][<span class="number">1</span>];</div><div class="line">            edgesNum[node1]++;</div><div class="line">            edgesNum[node2]++;</div><div class="line">            map.get(node1).add(node2);</div><div class="line">            map.get(node2).add(node1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> counter = n;</div><div class="line">      <span class="comment">//叶子节点加入结合</span></div><div class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(edgesNum[i] == <span class="number">1</span>)&#123;</div><div class="line">                leaves.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//遍历叶子节点，将与之相连的点的度数-1，删去叶子节点</span></div><div class="line">        <span class="keyword">while</span> (counter &gt; <span class="number">2</span>)&#123;</div><div class="line">            counter -= leaves.size();</div><div class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存储下一轮的新叶子节点</span></div><div class="line">            <span class="keyword">for</span>(Integer leave : leaves)&#123;</div><div class="line">                edgesNum[leave]--;</div><div class="line">                <span class="keyword">for</span>(Integer node : map.get(leave))&#123;</div><div class="line">                    edgesNum[node]--;</div><div class="line">                    <span class="keyword">if</span>(edgesNum[node] == <span class="number">1</span>)&#123;<span class="comment">//遇到度数为1的节点就是下一轮的叶子节点</span></div><div class="line">                        newLeaves.add(node);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            leaves = newLeaves;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="The-Maze"><a href="#The-Maze" class="headerlink" title="The Maze"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="external">The Maze</a></h3><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>There is a <strong>ball</strong> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <strong>up</strong>, <strong>down</strong>, <strong>left</strong> or <strong>right</strong>, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s <strong>start position</strong>, the <strong>destination</strong> and the <strong>maze</strong>, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of <strong>empty spaces</strong> traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p><strong>Example 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (4, 4)</div><div class="line">&gt;</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: One shortest way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</div><div class="line">&gt;              The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (3, 2)</div><div class="line">&gt;</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: There is no way for the ball to stop at the destination.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>矩阵中1是障碍，0是通的，小球从start滚到destination，不遇到障碍或者边界小球不会停下来，返回小球是否可以从start滚到end</p>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>BFS，小球从起点开始可以向上下左右四个方向滚，每次滚到障碍或者边界处，滚到终点就返回true</p>
<p>另外需要一个数组记录小球是否到过该节点，如果到过，后续就无需再走这里了。</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">if</span>(node[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; node[<span class="number">1</span>] == destination[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">while</span>(newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>)&#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]])&#123;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii],newStartY - y_delta[ii]&#125;);</div><div class="line">                    visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="The-Maze-II"><a href="#The-Maze-II" class="headerlink" title="The Maze II"></a><a href="https://leetcode.com/problems/the-maze-ii" target="_blank" rel="external">The Maze II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>跟上一题一样，这个题要求返回从起点滚到终点的最短路径长度。如果滚不到就返回-1</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>用一个二维数组记录地图中的点到start的距离。BFS更新计算start到能够到达的点的最小距离，最后返回二维数组中的终点的值。</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;distance.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; distance[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                distance[i][j] = Integer.MAX_VALUE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录走了多少步</span></div><div class="line">                <span class="keyword">while</span> (newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>) &#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果这条路径到达该点比之前的距离短，更新该点的最短距离</span></div><div class="line">                <span class="keyword">if</span> (distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count &lt; distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]]) &#123;</div><div class="line">                    distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]] = distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii], newStartY - y_delta[ii]&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] &lt; Integer.MAX_VALUE ? distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】BFS问题]]></title>
      <url>/2018/01/20/%E3%80%90leetcode%E3%80%91BFS%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares" target="_blank" rel="external">Perfect Squares</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>典型的BFS题目</p>
<p>方法：</p>
<p>需要一个队列记录当前剩余的和。</p>
<p>首先将n加入队列，然后n出队列，计算小于他的最大平方数，然后递减计算剩余的数字差，如如队列，层数+1</p>
<p>当队列中有某一层出现剩余的和为0的时候说明找到了一条合法相加形式，此时就是所需的最少数组组合，返回此时的depth即可。</p>
<p>优化：DP</p>
<p>dp[n]：记录n可以由几个平方数加和得到</p>
<p>递推公式：dp[n] = min(dp[n-1]+1,dp[n-4]+1,dp[n-9]+1,……)</p>
<p>初始化：</p>
<p>​    dp[0] = 0;</p>
<p>​    dp[1] = 1;</p>
<p>返回值：dp[n]</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(n);</div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = queue.poll();</div><div class="line">      <span class="comment">//计算小于等于n的最大的平方数</span></div><div class="line">      <span class="keyword">int</span> maxSquare = (<span class="keyword">int</span>) Math.sqrt(temp);</div><div class="line">      <span class="keyword">while</span>(maxSquare &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> sumLeft = temp - maxSquare*maxSquare;</div><div class="line">        <span class="keyword">if</span>(sumLeft == <span class="number">0</span>)&#123;<span class="comment">//和等于0了</span></div><div class="line">          <span class="keyword">return</span> depth;</div><div class="line">        &#125;</div><div class="line">        queue.add(sumLeft);</div><div class="line">        maxSquare--;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//动态规划</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)&#123;</div><div class="line">    <span class="keyword">int</span> dpMinTemp = dp[i-<span class="number">1</span>] +<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= i;j++)&#123;</div><div class="line">      dpMinTemp = Math.min(dpMinTemp,dp[i - j*j] +<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    dp[i] = dpMinTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】DFS问题]]></title>
      <url>/2018/01/20/%E3%80%90leetcode%E3%80%91DFS%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p>
<p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p>
<p>如上图的例子，DFS访问数组为：ABDECFG。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p>
<p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p>
<p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     struct TreeLinkNode &#123;</div><div class="line">&gt;       TreeLinkNode *left;</div><div class="line">&gt;       TreeLinkNode *right;</div><div class="line">&gt;       TreeLinkNode *next;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>For example,<br>Given the following perfect binary tree,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2    3</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4  5  6  7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>After calling your function, the tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1 -&gt; NULL</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2 -&gt; 3 -&gt; NULL</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4-&gt;5-&gt;6-&gt;7 -&gt; NULL</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>就是将同一层上的节点的next指向右边的节点</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>tag是DFS，但我一开始想到的是BFS。</p>
<ol>
<li>BFS：</li>
</ol>
<p>将每一层节点加入队列，出队列时，左边节点的next指向右边节点。</p>
<p>但DFS会更快一些</p>
<ol>
<li>DFS：</li>
</ol>
<p>用DFS的核心思想是对于一个节点来说，将其左孩子的next指向右孩子，其右孩子的next指向其本身next节点的左孩子。</p>
<p>题目要求不能引入额外的空间，所以更应该用dfs的</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersinEachNode</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> val;</div><div class="line">         TreeLinkNode left, right, next;</div><div class="line">         TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">     &#125;</div><div class="line">	<span class="comment">//BFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">        Queue&lt;TreeLinkNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> len = queue.size();</div><div class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//如果是本层最后一个了，其next指向NULL</span></div><div class="line">                TreeLinkNode temp = queue.poll();</div><div class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">                    temp.next = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果不是本层最后一个，其next指向下一个节点</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    temp.next = queue.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.right);</div><div class="line">                &#125;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//DFS</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfshelper</span><span class="params">(TreeLinkNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            root.left.next = root.right;</div><div class="line">            <span class="keyword">if</span>(root.next !=<span class="keyword">null</span>)&#123;</div><div class="line">                root.right.next = root.next.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                root.right.next = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            dfshelper(root.left);</div><div class="line">            dfshelper(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//DFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDFS</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">         root.next = <span class="keyword">null</span>;</div><div class="line">         dfshelper(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:</p>
<p>Given the below binary tree and </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \      \</div><div class="line">&gt;         7    2      1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
</blockquote>
<p>给定二叉树和一个整数sum,返回二叉树中是否存在一条从root到叶子的路径，长度为sum</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>DFS，分别对节点的左右孩子做DFS，sum需减掉当前节点的值。</p>
<p>当遇到叶子节点，且该点的值==sum时，即找到了一条合法路径，返回true</p>
<p>这里需要注意的是测试样例中有负数的情况，所以不能根据剩余的sum值进行剪枝。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfshelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//sum == root且root是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(sum == root.val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.left, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.right, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dfshelper(root,sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Path Sum II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:</p>
<p>Given the below binary tree and </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \    / \</div><div class="line">&gt;         7    2  5   1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;    [5,4,11,2],</div><div class="line">&gt;    [5,8,4,5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>跟上一题一样的，这次要把合法路径全都记录下来返回。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(root.val);</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.add(root.val);</div><div class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.left,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.right,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        helper(root,sum);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii" target="_blank" rel="external">Path Sum III</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</div><div class="line">&gt;</div><div class="line">&gt;       10</div><div class="line">&gt;      /  \</div><div class="line">&gt;     5   -3</div><div class="line">&gt;    / \    \</div><div class="line">&gt;   3   2   11</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 3  -2   1</div><div class="line">&gt;</div><div class="line">&gt; Return 3. The paths that sum to 8 are:</div><div class="line">&gt;</div><div class="line">&gt; 1.  5 -&gt; 3</div><div class="line">&gt; 2.  5 -&gt; 2 -&gt; 1</div><div class="line">&gt; 3. -3 -&gt; 11</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>跟前面两道的不同是：起止点不一定是root和leaf可以是树中的任意两点</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>方法一：双层递归</p>
<p>对树中的每一个节点都进行搜索，从该点开始是否有合法路径。</p>
<p>可以转化为，对根节点搜索sum合法路径，然后对根节点的左右节点分别搜索sum合法路径，其中对其左右节点搜索合法路径时，也需要对其自身和其左右节点分别搜索，这是外层递归</p>
<p>搜索路径长度本身又是一层递归，每次减掉当前节点val，这是第二层递归</p>
<p>方法二：前缀长度</p>
<p>计算从root到每一个节点的路径长度，存储在一个hashmap中，key为root到树种节点的路径长度，value为出现次数。</p>
<p>当计算到某一个节点时，从root到该节点的路径长度为len，则以该节点为结尾的合法路径的个数为map中key为sum-len的value值。</p>
<p>注意：每次回退时需要将root到这点的路径长度在hashmap中的value-1。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>方法一：双层递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果到当前点已经是合法路径了，res+1</span></div><div class="line">        <span class="keyword">if</span>(root.val == sum)&#123;</div><div class="line">            res++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//接续沿着左右节点寻找是否还有合法路径</span></div><div class="line">        res += helper(root.left,sum - root.val);</div><div class="line">        res += helper(root.right,sum - root.val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：前缀搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum,<span class="keyword">int</span> fromR)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = fromR + root.val;</div><div class="line">        res += map.getOrDefault(temp - sum,<span class="number">0</span>);</div><div class="line">        map.put(temp,map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</div><div class="line">        res = res + helper(root.left,sum,temp)+helper(root.right,sum,temp);</div><div class="line">        map.put(temp,map.get(temp)-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path-Sum-IV"><a href="#Path-Sum-IV" class="headerlink" title="Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv" target="_blank" rel="external">Path Sum IV</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>If the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.</p>
<p>For each integer in this list:</p>
<ol>
<li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li>
<li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree.</li>
<li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li>
</ol>
<p>Given a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 215, 221]</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is:</div><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   5   1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 5) + (3 + 1) = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 221]</div><div class="line">&gt; Output: 4</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is: </div><div class="line">&gt;     3</div><div class="line">&gt;      \</div><div class="line">&gt;       1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 1) = 4.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>以数组的形式给定一棵二叉树，用三位数表示节点，其中百位代表层数，十位代表在某一层中从左到右的位置，各位代表节点数值，计算从root到每一个leaf的路径长度之和。</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>假设一个几点的百位和十位是xy，则其左孩子和右孩子分别是：</p>
<p>left：(x+1)(2y-1)</p>
<p>right：(x+1)(2y)</p>
<p>可以根据这个性质，将数组中的节点放入hashmap中，key为百位十位，value为节点值。然后在map中寻找左右节点进行DFS，当遍历到叶子节点时，将本条路径长度加入路径长度总和。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> root,<span class="keyword">int</span> res)</span></span>&#123;</div><div class="line">  res += map.get(root);</div><div class="line">  <span class="keyword">int</span> left = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>;</div><div class="line">  <span class="comment">//如果左右都没有了路径了，是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(!map.containsKey(left) &amp;&amp; !map.containsKey(right))&#123;</div><div class="line">    sum += res;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果左边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(left))&#123;</div><div class="line">    dfs(map,left,res);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果右边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(right))&#123;</div><div class="line">    dfs(map,right,res);</div><div class="line">  &#125;</div><div class="line">  res -= map.get(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;nums.length;i++)&#123;</div><div class="line">    map.put(nums[i]/<span class="number">10</span>,nums[i] % <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">  dfs(map,<span class="number">11</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">Flatten Binary Tree to Linked List</a></h4><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;         / \</div><div class="line">&gt;        2   5</div><div class="line">&gt;       / \   \</div><div class="line">&gt;      3   4   6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;       \</div><div class="line">&gt;        3</div><div class="line">&gt;         \</div><div class="line">&gt;          4</div><div class="line">&gt;           \</div><div class="line">&gt;            5</div><div class="line">&gt;             \</div><div class="line">&gt;              6</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>将二叉树压到一条右子树上</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是要将每个节点左子树的前序遍历插入到右子树前面。</p>
<p>所以我的思路是如果遇到节点root有右子树，就先把右子树存下来，然后dfs处理左子树，当左子树处理完之后，再将右子树插入到左子树。</p>
<p>DSF的时候，把原来的左子树放到节点的右边，然后节点向下移动，递归处理左子树。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreetoLinkedList</span> </span>&#123;</div><div class="line">    TreeNode temp;<span class="comment">//记录当前节点</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果右节点不空，先把右边节点存下来</span></div><div class="line">        TreeNode right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            right = <span class="keyword">new</span> TreeNode(root.right.val);</div><div class="line">            right.left = root.right.left;</div><div class="line">            right.right = root.right.right;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果左子树非空，将左子树挪到右边，左子树置为空，temp下移，继续dfs temp的左子树</span></div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = temp.left;</div><div class="line">            temp.left = <span class="keyword">null</span>;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果右节点非空，将之前记录下来的右子树放到temp右边，然后temp下移，继续dfs</span></div><div class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = right;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        temp = root;</div><div class="line">        dfs(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[回文问题]]></title>
      <url>/2018/01/19/%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="最长回文子串-Longest-Palindromic-Substring"><a href="#最长回文子串-Longest-Palindromic-Substring" class="headerlink" title="最长回文子串 Longest Palindromic Substring"></a>最长回文子串 <a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="external">Longest Palindromic Substring</a></h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】数据结构]]></title>
      <url>/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ul>
<li>线性数据结构<ul>
<li>Queue</li>
<li>Stack</li>
<li>HashTable</li>
</ul>
</li>
<li>树形数据结构<ul>
<li>Heap/Priority Queue</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
<h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><ul>
<li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li>
<li>考点：宽度优先搜索BFS</li>
<li>多做做BFS就可以了</li>
</ul>
<h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><ul>
<li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li>
<li>考点：非递归实现DFS</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="external">Min Stack</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>getMin() — Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; MinStack minStack = new MinStack();</div><div class="line">&gt; minStack.push(-2);</div><div class="line">&gt; minStack.push(0);</div><div class="line">&gt; minStack.push(-3);</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -3.</div><div class="line">&gt; minStack.pop();</div><div class="line">&gt; minStack.top();      --&gt; Returns 0.</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -2.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>要求实现一个stack能够在0(1)时间内实现push(x),pop(),top(),getMin()获取最小值</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>额外维护一个stack，存储最小值</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; queue;</div><div class="line">    Stack&lt;Integer&gt; minqueue;</div><div class="line">    <span class="comment">//int min = Integer.MAX_VALUE;</span></div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        minqueue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">if</span>(minqueue.isEmpty())&#123;</div><div class="line">            min = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (x &lt; minqueue.peek()) &#123;</div><div class="line">                min = x;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> min = minqueue.peek();</div><div class="line">        &#125;</div><div class="line">        minqueue.add(min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.pop();</div><div class="line">        minqueue.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minqueue.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="external">Implement Queue using Stacks</a></h3><blockquote>
<p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) — Push element x to the back of queue.</li>
<li>pop() — Removes the element from in front of queue.</li>
<li>peek() — Get the front element.</li>
<li>empty() — Return whether the queue is empty.</li>
</ul>
</blockquote>
<p>用stack实现queue</p>
<p>stack：先进后出</p>
<p>queue：先进先出</p>
<p>需要两个stack实现一个queue。</p>
<p>push时先将元素压入stack1，然后当pop时，如果stack2非空，就从stack2中pop出一个，否则将stack1中元素全部加入stcak2之后再pop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack1;</div><div class="line">    Stack&lt;Integer&gt; stack2;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x to the back of queue. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        stack1.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the front element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; stack1.isEmpty())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">Largest Rectangle in Histogram</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="img"></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="img"></p>
<p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return <code>10</code>.</p>
</blockquote>
<p>求直方图中的最大举行的面积。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：</p>
<p>两个指针i和j分别从前往后扫描，k在i和j之间扫描，找i和j中间最低的柱子Kmin，计算Kmin*(j-i)的最大值。时间复杂度<script type="math/tex">O(n^3)</script></p>
<p>优化：</p>
<p>K从左向右遍历，在每一位置，向左看，找到左边第一个比它小的位置i，向右看，找到右边第一个比他小的位置j，此时矩形面积为<script type="math/tex">K*(j-i-1)</script> ，找到最小的即可。时间复杂度<script type="math/tex">O(n^2)</script></p>
<p>Stack：</p>
<p>对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左以及向右第一个小于bar n的bar的索引位置。</p>
<p>我们可以从左到右遍历所有bar，并将其push到一个stack中，如果当前bar的高度小于栈顶bar，我们pop出栈顶的bar，同时以该bar计算矩形面积。那么我们如何知道该bar的ln和rn呢？rn就是当前遍历到的bar的索引，而ln则是弹出当前元素之后的栈顶bar的索引，因为此时栈顶中的元素都是递增的。</p>
<p>为了更好的处理最后一个bar的情况，我们在实际中会插入一个高度为0的bar，这样就能pop出最后一个bar并计算了。</p>
<p>stack中存储的是下标！！！</p>
<p>时间复杂度<script type="math/tex">O(n)</script></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.length;i++)&#123;</div><div class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> size = heights[stack.pop()] * (i-stack.peek()-<span class="number">1</span>);</div><div class="line">                max = Math.max(max,size);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> size = heights[stack.pop()] * (heights.length-stack.peek()-<span class="number">1</span>);</div><div class="line">            max = Math.max(max,size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="external">Maximal Rectangle</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>题目给定一个01矩阵，要求求出矩阵中面积最大的全1矩阵。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://upload-images.jianshu.io/upload_images/424375-2a5a361549e471e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>把每一行看作直方图的底，可以把这个题转化成上一道题，对每一行建立一个直方图，利用stack求直方图中的最大矩形，返回全局最大矩形的面积。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calMax</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span>[] heights)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights.length;j++)&#123;</div><div class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[j] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> area = heights[stack.pop()] * (j - stack.peek()- <span class="number">1</span>);</div><div class="line">                max = Math.max(max,area);</div><div class="line">            &#125;</div><div class="line">            stack.push(j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> area = heights[stack.pop()] * (heights.length - stack.peek()- <span class="number">1</span>);</div><div class="line">            max = Math.max(max,area);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;matrix.length;i++)&#123;</div><div class="line">            <span class="comment">//计算本行heights</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</div><div class="line">                    heights[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heights[j] += <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxArea = Math.max(maxArea,calMax(matrix,heights));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="external">Implement Stack using Queues</a></h3><blockquote>
<p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>empty() — Return whether the stack is empty.</li>
</ul>
</blockquote>
<p>题目要求用队列实现栈。</p>
<p>方法一：</p>
<p>用两个queue实现，push时间复杂度<script type="math/tex">O(1)</script> , pop时间复杂度<script type="math/tex">O(n)</script></p>
<p>push的时候加入queue1:</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-45-34.png" alt=""> </p>
<p>pop的时候利用queue1，每次pop的时候将queue1中的元素放到queue2，保留一个pop，然后再把queue1和queue2交换，此时queue2又是空的了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-48-38.png" alt=""> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue1.add(x);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.poll();</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.peek();</div><div class="line">  queue2.add(queue1.remove());</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p>用两个queue实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p>
<p>push时先将元素push进queue2,然后将queue2中元素加入queue2，然后交换queue1和queue2</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-02.png" alt=""> </p>
<p>pop时直接pop q1中元素</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-27.png" alt=""> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue2.add(x);</div><div class="line">  <span class="keyword">while</span>(!queue1.isEmpty())&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">  &#125;</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.poll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.peek();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法三：</p>
<p>用一个队列实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</div><div class="line">    Queue&lt;Integer&gt; queue;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x onto stack. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">            queue.add(queue.poll());</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.poll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the top element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="哈希表Hash"><a href="#哈希表Hash" class="headerlink" title="哈希表Hash"></a>哈希表Hash</h1><h3 id="hash-特性"><a href="#hash-特性" class="headerlink" title="hash 特性"></a>hash 特性</h3><ul>
<li>支持操作：Insert/Find/Delete,时间复杂度都是<script type="math/tex">O(1)</script></li>
<li>Hash Table/Hash Map/Hash Set的区别是什么？<ul>
<li>hash set 只有key没有value</li>
<li>hash table是线程安全的数据结构，hash map线程不安全</li>
<li>多线程和多进程的区别：线程之间共享同一片内存</li>
<li>hash table有锁，可以保证同一时间只有一个进程对其进行操作，因此是线程安全的</li>
</ul>
</li>
</ul>
<h3 id="hash-Table实现"><a href="#hash-Table实现" class="headerlink" title="hash Table实现"></a>hash Table实现</h3><p>通过一个Hash function将key映射到一个大数组中，查找的时候计算下标，直接获取<script type="math/tex">O(1)</script></p>
<p>Hash function的设计：</p>
<ul>
<li>无冲突</li>
<li>大数组的长度大概是key数量的10倍以上才是安全的</li>
</ul>
<p>Hash 函数解决冲突的两种办法：</p>
<ol>
<li><p>open hashing</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-20-31.png" alt=""> </p>
<p>每个位置可以维护一个链表，插入时，遇到冲突就加到链表里；查找时，查找下标对应的链表</p>
</li>
<li><p>closed hashing</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-23-30.png" alt=""> </p>
<p>占坑，如果hash函数计算完发现自己的坑被占了，就依次向后找到空位放进去；查找时，hash函数计算应该在的位置，如果不是该元素，继续向后寻找直到空</p>
</li>
</ol>
<p>rehashing问题</p>
<p>当已经存储的元素个数已经超过大数组的1/10l了就需要扩大hash表数组了，这就是rehashing问题。</p>
<p>需要把hash表中现有的元素全部扫描一遍，重新计算其在新的大hash表中的位置，放到新位置。</p>
<h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul>
<li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p>
</li>
<li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p>
</li>
<li><p>Heap结构：</p>
<p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p>
</li>
</ul>
<ul>
<li><p>MaxHeap vs MinHeap</p>
<ul>
<li>MaxHeap：父亲节点比左右孩子都大</li>
<li>MinHeap：父亲节点比左右孩子都小</li>
</ul>
<p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p>
</li>
<li><p>堆的存储</p>
<p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p>
<p>对于元素A[i]：</p>
<ul>
<li>父节点：A[i-2/2] (右移1)</li>
<li>左孩子：A[2i+1] (左移1，可得到2i)</li>
<li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li>
</ul>
</li>
<li><p>插入操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">	<span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">     	 <span class="number">1</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		<span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     	<span class="number">100</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		</div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>	</div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">100</span>	</div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure>
<p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p>
<p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p>
<p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p>
<p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p>
</li>
</ul>
<h2 id="leetcode相关习题"><a href="#leetcode相关习题" class="headerlink" title="leetcode相关习题"></a>leetcode相关习题</h2><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number" target="_blank" rel="external">Ugly Number</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p>
<p>Note that <code>1</code> is typically treated as an ugly number.</p>
</blockquote>
<p>检验输入数组num是否是unly number：因子只有2,3,5</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>思路就是把num中的2、3、5全部除掉，最后==1了就是ugly number，如果最后不是1，说明还有其他因数，因此返回false</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="external">Ugly Number II</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>从1开始分别乘{2,3,5}，得到2,3,5是ugly number，然后对于2，依次乘2,3,5，得到4,6,10是ugly number，此时ugly number有：1,2,3,4,5,6,10，1,2处理过了，继续处理3，由此，我们需要一个最小堆来维护现有ugly number中还未与2,3,5相乘的最小的，相乘之后加入该堆，同时需要一个hashmap记录已经计算过的ugly number，以免重复入堆。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumberII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">                <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div><div class="line">        Long[] prime = &#123;Long.valueOf(<span class="number">2</span>),Long.valueOf(<span class="number">3</span>),Long.valueOf(<span class="number">5</span>)&#125;;</div><div class="line">        heap.add(Long.valueOf(<span class="number">1</span>));</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</div><div class="line">            Long ugly = heap.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i:prime)&#123;</div><div class="line">                <span class="keyword">if</span>(!set.contains(ugly*i))&#123;</div><div class="line">                    heap.add(ugly*i);</div><div class="line">                    set.add(ugly*i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> heap.peek().intValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BFS & DFS]]></title>
      <url>/2018/01/16/BFS-DFS/</url>
      <content type="html"><![CDATA[<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p>
</blockquote>
<p>给定起始单词和结束单词，利用wordlist中的单词爬梯子，每次只允许改变一个字母，返回能够到达结束词的最短路径长度</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一开始用了回溯，相当于暴力了所有可能，超时了，看了解答，这道题应该用广度优先搜索（BFS）：</p>
<p>需要用到队列<code>Queue</code></p>
<p>因为要求最短路径，如果我们用深度优先搜索的话必须遍历所有的路径才能确定哪个是最短的，而用广度优先搜索的话，一旦搜到目标就可以提前终止了，而且根据广度优先的性质，我们肯定是先通过较短的路径搜到目标。另外，为了避免产生环路和重复计算，我们找到一个存在于字典的新的词时，就要把它从字典中移去。这么做是因为根据广度优先，我们第一次发现词A的路径一定是从初始词到词A最短的路径，对于其他可能再经过词A的路径，我们都没有必要再计算了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line"><span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">      diffSum++;</div><div class="line">      <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(beginWord);</div><div class="line">  <span class="keyword">int</span> step = <span class="number">2</span>;<span class="comment">//记录层数</span></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> queueSize = queue.size();<span class="comment">//当前queue长度</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;<span class="comment">//遍历queue中元素，将其后续节点入队列</span></div><div class="line">      String temp  = queue.peek();</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">        <span class="comment">//如果该词与队列顶端元素只相差一个字母，入队列，标记为使用过</span></div><div class="line">        <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">          <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;<span class="comment">//一旦找到了endword结束搜索，返回当前层数</span></div><div class="line">            <span class="keyword">return</span> step;</div><div class="line">          &#125;</div><div class="line">          queue.add(wordList.get(j));</div><div class="line">          isUsed[j] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      queue.poll();</div><div class="line">    &#125;</div><div class="line">    step++;<span class="comment">//层数+1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">  isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">  <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【DSP系统】Java UDP通信模拟监听模块]]></title>
      <url>/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ul>
<li>无连接，不可靠，会造成数据丢失</li>
<li>速度快，因为无需进行三次握手</li>
<li>限制数据传输大小64K</li>
</ul>
<h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p>发送端模拟ADx发送竞价请求，这里采用从文件中按行读取数据，然后发送给接收端的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//DatagramSocket类表示用来发送和接收(udp)数据报包的套接字。</span></div><div class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</div><div class="line"></div><div class="line">  <span class="comment">//获取本机ip地址</span></div><div class="line">  String localIp = InetAddress.getLocalHost().getHostAddress();</div><div class="line"></div><div class="line">  <span class="comment">//读取文件名</span></div><div class="line">  String fileName = <span class="string">"D://datasets//ipinyou.contest.dataset//ipinyou.contest.dataset//training2nd//training2nd//conv.20130610.txt"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// read file content from file</span></div><div class="line">  <span class="comment">//StringBuffer sb= new StringBuffer("");</span></div><div class="line">  FileReader reader = <span class="keyword">new</span> FileReader(fileName);</div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">  String str = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//sb.append(str+"/n");</span></div><div class="line">    System.out.println(str);</div><div class="line"></div><div class="line">    <span class="comment">//需要发送的数据</span></div><div class="line">    <span class="comment">//byte[] buf = "Hello Udp".getBytes();</span></div><div class="line">    <span class="keyword">byte</span>[] buf = str.getBytes();</div><div class="line"></div><div class="line">    <span class="comment">//将数据传送到本地ip，端口为9999</span></div><div class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getByName(localIp), <span class="number">9999</span>);</div><div class="line"></div><div class="line">    <span class="comment">//发送数据报包</span></div><div class="line">    ds.send(dp);</div><div class="line">  &#125;</div><div class="line">  br.close();</div><div class="line">  reader.close();</div><div class="line"></div><div class="line">  <span class="comment">//关闭资源</span></div><div class="line">  ds.close();</div><div class="line">  System.out.println(<span class="string">"Done."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenModule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建udp服务对象，指定接收端口号为9999的报包</span></div><div class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</div><div class="line"></div><div class="line">        <span class="comment">//构造空的数据报包， 用于存储待会接收到的数据报包</span></div><div class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//接收数据</span></div><div class="line">            ds.receive(dp);</div><div class="line"></div><div class="line">            <span class="comment">//显示数据</span></div><div class="line">            String ipAddress = dp.getAddress().getHostAddress();</div><div class="line">            <span class="keyword">int</span> port = dp.getPort();</div><div class="line">            String datas = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line">            <span class="comment">//System.out.println(ipAddress + "::" + datas + "::" + port);</span></div><div class="line">            System.out.println(datas);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ds.close();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行时先运行接收端，后运行发送端</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[DSP系统mysql数据库搭建]]></title>
      <url>/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h2><h3 id="执行sql脚本方法："><a href="#执行sql脚本方法：" class="headerlink" title="执行sql脚本方法："></a>执行sql脚本方法：</h3><ol>
<li>cmd执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：</div><div class="line">mysql –uroot –p123456 -D database_name &lt; d:\<span class="built_in">test</span>\ss.sql</div></pre></td></tr></table></figure>
<ol>
<li>进入mysql的控制台后，使用source命令执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">Mysql&gt;</span><span class="bash"><span class="built_in">source</span> 【sql脚本文件的路径全名】 或 Mysql&gt;\. 【sql脚本文件的路径全名】，示例：</span></div><div class="line">source d:\test\ss.sql 或者 \. d:\test\ss.sql</div></pre></td></tr></table></figure>
<h3 id="从文件导入数据表"><a href="#从文件导入数据表" class="headerlink" title="从文件导入数据表"></a>从文件导入数据表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx;</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx (colA,colB);</div></pre></td></tr></table></figure>
<h3 id="auto-increment实现自动递增编号"><a href="#auto-increment实现自动递增编号" class="headerlink" title="auto_increment实现自动递增编号"></a>auto_increment实现自动递增编号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1.建表</div><div class="line">CREATE TABLE IF NOT EXISTS `Bid`(</div><div class="line">  `ID` bigint primary key not NULL auto_increment,</div><div class="line">  `BidId` varchar(255) DEFAULT NULL,</div><div class="line">)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</div><div class="line"><span class="meta">#</span><span class="bash"> AUTO_INCREMENT=0设置开始值</span></div><div class="line">2.导入数据</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE Bid (BidId);</div><div class="line">！！需要注意：利用auto_increment生成的列不能导入数据，只导入后面的字段</div></pre></td></tr></table></figure>
<h3 id="从一个表选取部分数据插入到另一个表"><a href="#从一个表选取部分数据插入到另一个表" class="headerlink" title="从一个表选取部分数据插入到另一个表"></a>从一个表选取部分数据插入到另一个表</h3><p>两个表都带有auto_increment列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `bid_1458`;</div><div class="line">CREATE TABLE bid_1458 LIKE bid;</div><div class="line">insert into bid_1458 (colA,colB) select colA,colB from bid where AdvertiserID=1458;</div></pre></td></tr></table></figure>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="shell脚本调用sql"><a href="#shell脚本调用sql" class="headerlink" title="shell脚本调用sql"></a>shell脚本调用sql</h3><ol>
<li>脚本中执行mysql命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1、通过mysql的 -e 参数实现</div><div class="line">mysql -uuser -ppasswd -e "show databases;show databases;"</div><div class="line"></div><div class="line">2、通过echo实现</div><div class="line">echo "show databases;show databases"|mysql -uuser -ppassword</div><div class="line"></div><div class="line">3、通过EOF指定要执行的sql</div><div class="line">mysql -uroot  -ppassword &lt;&lt;EOF</div><div class="line">show databases;</div><div class="line">show databases;</div><div class="line">EOF</div><div class="line"></div><div class="line">关于EOF的说明：</div><div class="line">在主shell执行命令，进入其他的命令（如mysql），后面的输入，想作为其他命令（如mysql）的输入，而不是主shell的输入，使用&lt;&lt;EOF，告诉主shell，后续的输入，是其他命令或者子shell的输入，直到遇到EOF为止，再回到主shell。</div></pre></td></tr></table></figure>
<ol>
<li>脚本中执行mysql的sql文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1. mysql -uroot -ppassword -e "source /root/temp.sql" </div><div class="line">2. mysql -uroot -ppassword &lt;/root/temp.sql</div></pre></td></tr></table></figure>
<h3 id="shell脚本字符串连接"><a href="#shell脚本字符串连接" class="headerlink" title="shell脚本字符串连接"></a>shell脚本字符串连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">AAA="abc"</div><div class="line">BBB="def"</div><div class="line">CCC=$AAA$BBB"ghi"</div><div class="line">echo $ccc</div></pre></td></tr></table></figure>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">echo $contetn &gt; write.txt#写入</div><div class="line">echo $contetn &gt;&gt; write.txt#追加写入</div></pre></td></tr></table></figure>
<h2 id="ipinyou2nd数据分析"><a href="#ipinyou2nd数据分析" class="headerlink" title="ipinyou2nd数据分析"></a>ipinyou2nd数据分析</h2><h3 id="广告主"><a href="#广告主" class="headerlink" title="广告主"></a>广告主</h3><p>一共有5个广告主，其中有转化数据的只有3个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; select distinct AdvertiserId from click;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3476 |</div><div class="line">|         3358 |</div><div class="line">|         3386 |</div><div class="line">|         3427 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select distinct AdvertiserId from conv;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3358 |</div><div class="line">|         3476 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">3 rows in set (0.06 sec)</div><div class="line">其中3476的数据相对较少</div></pre></td></tr></table></figure>
<p>AdvertiserID_3476</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">bid:<span class="number">6712268</span></div><div class="line">impression:<span class="number">1970360</span></div><div class="line">click:<span class="number">1092</span></div><div class="line">conv:<span class="number">27</span></div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】数与数组]]></title>
      <url>/2017/12/24/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol>
<li>Sorted Array<ul>
<li>merge two sorted array<ul>
<li>Intersection of Two Arrays</li>
<li>Multiply Two Arrays</li>
</ul>
</li>
<li>median of two sorted array</li>
</ul>
</li>
<li>Subarray<ul>
<li>Best Time to Buy and Sekk Stoocks I,II,III</li>
<li>Subarrat I,II,III,IV</li>
</ul>
</li>
<li>Two pointers<ul>
<li>Two Sum,3Sum,4Sum,kSum,3Sum Closest</li>
<li>Partition Array</li>
</ul>
</li>
</ol>
<h1 id="排序数组Sorted-Array"><a href="#排序数组Sorted-Array" class="headerlink" title="排序数组Sorted Array"></a>排序数组Sorted Array</h1><h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><blockquote>
<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong><br>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p>
</blockquote>
<p>给定两个排序数组nums1,nums2，合并到nums1</p>
<p>三个指针i,j,k分别指向nums1元素结尾，nums2结尾，nums1数组结尾</p>
<p>依次向前遍历，比较大小，插入nums1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(j &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(i &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">                k--</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="external">Intersection of Two Arrays</a></h3><blockquote>
<p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
</blockquote>
<p>给定两个数组，返回交集，返回的交集中在原数组中的相对位置保持不变，元素只出现一次。</p>
<p>方法:</p>
<ol>
<li>把两个数组排序</li>
<li>两指针分别遍历两个数组比较大小，如果两指针指向的元素相等，且与result中前一个元素不相等，加入result</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</div><div class="line">                <span class="keyword">if</span>(index == <span class="number">0</span> || nums1[i] != result[index-<span class="number">1</span>])&#123;</div><div class="line">                    result[index] = nums1[i];</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;nums2[j])&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                j++ ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>;idx &lt; index;idx++) &#123;</div><div class="line">            res[idx] = result[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Sparse-Matrix-Multiplication"><a href="#Sparse-Matrix-Multiplication" class="headerlink" title="Sparse Matrix Multiplication"></a><a href="https://leetcode.com/problems/sparse-matrix-multiplication/" target="_blank" rel="external">Sparse Matrix Multiplication</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank" rel="external">sparse matrices</a> <strong>A</strong> and <strong>B</strong>, return the result of <strong>AB</strong>.</p>
<p>You may assume that <strong>A</strong>‘s column number is equal to <strong>B</strong>‘s row number.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A = [</div><div class="line">&gt;   [ 1, 0, 0],</div><div class="line">&gt;   [-1, 0, 3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; B = [</div><div class="line">&gt;   [ 7, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 1 ]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</div><div class="line">&gt; AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</div><div class="line">&gt;                   | 0 0 1 |</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>逐个遍历计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">  <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">  <span class="keyword">int</span> A_rows = A.length;</div><div class="line">  <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span> B_rows = B.length;</div><div class="line">  <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A_cols;k++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i][k] != <span class="number">0</span> &amp;&amp; B[k][j] != <span class="number">0</span>)&#123;</div><div class="line">          result[i][j] = result[i][j] + A[i][k] * B[k][j];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优化</p>
<ol>
<li>遍历矩阵B，把B中值不为0的位置（注意是位置不是值）按每一列存下来</li>
<li>遍历A矩阵，寻找B中对应位置不为0的元素做乘积</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply2(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexB = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexA = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">    <span class="keyword">int</span> A_rows = A.length;</div><div class="line">    <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span> B_rows = B.length;</div><div class="line">    <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">    <span class="comment">//按列将B中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; B_cols;col++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; B_rows;row++)&#123;</div><div class="line">            <span class="keyword">if</span>(B[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(row);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexB.add(rowIndex);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//按行将A中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; A_rows;row++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; A_cols;col++)&#123;</div><div class="line">            <span class="keyword">if</span>(A[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(col);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexA.add(rowIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历矩阵A.B</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">           <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">           <span class="keyword">int</span> jj = <span class="number">0</span>;;</div><div class="line">           <span class="keyword">while</span>(ii &lt; nonZeroIndexA.get(i).size() &amp;&amp; jj &lt; nonZeroIndexB.get(j).size())&#123;</div><div class="line">               <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) == nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   result[i][j] += A[i][nonZeroIndexA.get(i).get(ii)] * B[nonZeroIndexB.get(j).get(jj)][j];</div><div class="line">                   ii++;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) &lt; nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   ii++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> &#123;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>在前面的课程里讲过可以利用堆Heap</p>
<p>方法二：</p>
<p>利用quickselect的方法，来源于quicksort</p>
<p>quicksort核心思想：每次选一个数字作为基准，比它小的放到左边，比它大的放到右边，然后再递归对左右两边数组做quicksort</p>
<p>步骤：从数组中选取一个数字作为“基准”pivot，找第K大的元素时可以跟基准比较：</p>
<ol>
<li>pivot左边元素个数 = K-1，该基准元素就是第K大元素</li>
<li>pivot左边元素个数 &gt; K-1，丢弃右边全部元素，在左边元素中继续寻找</li>
<li>pivot左边元素个数 &lt; K-1，丢弃左边全部元素，在右边元素中继续寻找</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="comment">//快速排序，寻找pivot应该放置的位置</span></div><div class="line">  <span class="keyword">int</span> i = start;</div><div class="line">  <span class="keyword">int</span> j = end;</div><div class="line">  <span class="keyword">int</span> pivot = nums[i];</div><div class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    nums[i] = nums[j];</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    nums[j]</div><div class="line">  nums[i] = pivot;</div><div class="line">  <span class="comment">//start~i-1的元素都小于等于pivot，一共用i-start个</span></div><div class="line">  <span class="comment">//i+1到end的元素都大于等于pivot，一共end-i个</span></div><div class="line">  <span class="keyword">if</span>(i-start == k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> quickselect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length+<span class="number">1</span>-k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Median"><a href="#Median" class="headerlink" title="Median"></a><a href="http://www.lintcode.com/en/problem/median/" target="_blank" rel="external">Median</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a unsorted array with integers, find the median of it.</p>
<p>A median is the middle number of the array after it is sorted.</p>
<p>If there are even numbers in the array, return the <code>N/2</code>-th number after sorted.</p>
<p>Example</p>
<p>Given <code>[4, 5, 1, 2, 3]</code>, return <code>3</code>.</p>
<p>Given <code>[7, 9, 4, 5]</code>, return <code>5</code>.</p>
</blockquote>
<p>返回给定数组中位数</p>
<p>和上一题思路一样，K=nums.length/2</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = start;</div><div class="line">    <span class="keyword">int</span> j = end;</div><div class="line">    <span class="keyword">int</span> pivot = nums[i];</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        nums[i] = nums[j];</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        nums[j] = nums[i];</div><div class="line">    &#125;</div><div class="line">    nums[i] = pivot;</div><div class="line">    <span class="keyword">if</span>(i - start == k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length - nums.length/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>这道题在二分法里面讲过了，先将找中点的问题转化成找第k大的问题，然后继续沿用二分法中的思路。详见<a href="https://siyaozhang.github.io/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二分法</a></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthInTwo</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> start1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> start2,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//end1中没有元素了，返回nums2中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start1 &gt;= nums1.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//end2中没有元素了，返回nums1中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start2 &gt;= nums2.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums1[start1+k-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line"><span class="comment">//边界条件，递归出口</span></div><div class="line">      <span class="keyword">if</span>(k ==<span class="number">1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//nums1中剩余元素不足K/2个,nums2的前K/2个元素一定在前k个中，</span></div><div class="line">      <span class="comment">// 去掉nums2的前K/2个元素</span></div><div class="line">      <span class="keyword">if</span>(nums1.length - start1 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(nums2.length - start2 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">     </div><div class="line">      <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt; nums2[start2 + k/<span class="number">2</span> - <span class="number">1</span>])&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> len = nums1.length+nums2.length;</div><div class="line">      <span class="comment">//偶数个元素</span></div><div class="line">      <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">int</span> k1 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>);</div><div class="line">          <span class="keyword">int</span> k2 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">          <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//奇数个元素</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="子数组-Subarray"><a href="#子数组-Subarray" class="headerlink" title="子数组 Subarray"></a>子数组 Subarray</h1><h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p>
</blockquote>
<p>最大子数组，找到子数组（连续），和最大</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>前缀和数组prefixSum：<code>sum[i] = SUM(nums[0~i])</code></p>
<p>数组中从i到j的数组和：<code>sum[i~j] = sum[j]-sum[i-1]</code></p>
<p>以当前位置i为结尾的最大子数组是sum[i]-min(sum[0]~sum[i-1])</p>
<p>所以思路就是：从前向后遍历，三个变量存储信息：</p>
<ol>
<li>从起点到当前元素的和，前缀和</li>
<li>截止目前的最大子数组</li>
<li>前面的最小和</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录前缀和</span></div><div class="line">  <span class="keyword">int</span> min_before = <span class="number">0</span>;<span class="comment">//记录前面最小和,初始化为0,</span></div><div class="line">  <span class="keyword">int</span> max = Integer.MIN_VALUE;<span class="comment">//记录最大子数组</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    sum += nums[i];<span class="comment">//从0到当前元素的前缀和</span></div><div class="line">    max = Math.max(max,sum-min_before);<span class="comment">//更新最大子数组</span></div><div class="line">    min_before = Math.min(min_before,sum);<span class="comment">//更新前面最小和</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维数组的Maximum-Subarray"><a href="#二维数组的Maximum-Subarray" class="headerlink" title="二维数组的Maximum Subarray"></a>二维数组的Maximum Subarray</h3><p>前缀和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  i-1  i           x</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">j-1*---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line"> j *-[i,j]-*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">y  *---*---*---*-[x,y]</div><div class="line"></div><div class="line"></div><div class="line">sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</div></pre></td></tr></table></figure>
<h3 id="Range-Sum-Query-2D-Immutable"><a href="#Range-Sum-Query-2D-Immutable" class="headerlink" title="Range Sum Query 2D - Immutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-immutable" target="_blank" rel="external">Range Sum Query 2D - Immutable</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given matrix = [</div><div class="line">&gt;   [3, 0, 1, 4, 2],</div><div class="line">&gt;   [5, 6, 3, 2, 1],</div><div class="line">&gt;   [1, 2, 0, 1, 5],</div><div class="line">&gt;   [4, 1, 0, 1, 7],</div><div class="line">&gt;   [1, 0, 3, 0, 5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">&gt; sumRegion(1, 1, 2, 2) -&gt; 11</div><div class="line">&gt; sumRegion(1, 2, 2, 4) -&gt; 12</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>You may assume that the matrix does not change.</li>
<li>There are many calls to <em>sumRegion</em> function.</li>
<li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li>
</ol>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>利用二维数组的前缀和，给定左上和右下的坐标为(row1, col1)， (row2, col2)</p>
<p>那么和为sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] Matrix;</div><div class="line">    <span class="keyword">int</span>[][] Sum;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.Matrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">this</span>.Sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        Sum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix.length;i++)&#123;</div><div class="line">            Sum[i][<span class="number">0</span>] = Sum[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            Sum[<span class="number">0</span>][i] = Sum[<span class="number">0</span>][i-<span class="number">1</span>] + matrix[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; matrix.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                Sum[i][j] = Sum[i-<span class="number">1</span>][j] + Sum[i][j-<span class="number">1</span>] - Sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row2][col1 -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2] - Sum[row2][col1 -<span class="number">1</span>] + Sum[row1-<span class="number">1</span>][col1 -<span class="number">1</span> ];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Range-Sum-Query-2D-Mutable"><a href="#Range-Sum-Query-2D-Mutable" class="headerlink" title="Range Sum Query 2D - Mutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-mutable" target="_blank" rel="external">Range Sum Query 2D - Mutable</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given matrix = [</div><div class="line">  [3, 0, 1, 4, 2],</div><div class="line">  [5, 6, 3, 2, 1],</div><div class="line">  [1, 2, 0, 1, 5],</div><div class="line">  [4, 1, 0, 1, 7],</div><div class="line">  [1, 0, 3, 0, 5]</div><div class="line">]</div><div class="line"></div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">update(3, 2, 2)</div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 10</div></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The matrix is only modifiable by the <em>update</em> function.</li>
<li>You may assume the number of calls to <em>update</em> and <em>sumRegion</em> function is distributed evenly.</li>
<li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> delta = val  - Matrix[row][col];<span class="comment">//更新值和原来差值</span></div><div class="line">  <span class="keyword">this</span>.Matrix[row][col] = val;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = row;i &lt; Matrix.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = col;j  &lt; Matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">      Sum[i][j] += delta;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最小子数组"><a href="#最小子数组" class="headerlink" title="最小子数组"></a><a href="http://www.lintcode.com/en/problem/minimum-subarray/" target="_blank" rel="external">最小子数组</a></h3><blockquote>
<p>Given an array of integers, find the subarray with smallest sum.</p>
<p>Return the sum of the subarray.</p>
<p>Example</p>
<p>For <code>[1, -1, -2, 1]</code>, return <code>-3</code>.</p>
</blockquote>
<p>和最大子数组相同的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArray</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> minsub = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">int</span> maxbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size();i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        minsub = Math.min(minsub,sum - maxbefore);</div><div class="line">        maxbefore = Math.max(maxbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minsub;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p>
<p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p>
</blockquote>
<p>求和大于等于s的连续子数组的最小长度</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口来做。</p>
<p>两个指针i和j分别指向子数组的头和尾</p>
<p>sumi代表从nums[0]到nums[i]的和</p>
<p>sumj代表从nums[0]到nums[j]的和</p>
<p>如果sumj-sumi &gt;= s，将i向后移动，直至sumj-sumi &lt; s，此时子数组和&gt;=s的长度为j-i+2，更新最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sumj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sumi = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length;j++)&#123;</div><div class="line">            sumj += nums[j];</div><div class="line">            <span class="keyword">int</span> delta = sumj - sumi;</div><div class="line">            <span class="keyword">while</span>(delta &gt;= s)&#123;</div><div class="line">                sumi += nums[i];</div><div class="line">                i++;</div><div class="line">                delta = sumj - sumi;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//跳出时sumj-sumi &lt; s</span></div><div class="line">            <span class="keyword">if</span>(sumj &gt;= s)&#123;</div><div class="line">                minlen = Math.min(minlen,j-i+<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen != Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> minlen;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Subarray-II"><a href="#Maximum-Subarray-II" class="headerlink" title="Maximum Subarray II"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-ii/" target="_blank" rel="external">Maximum Subarray II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of integers, find two non-overlapping subarrays which have the largest sum.<br>The number in each subarray should be contiguous.<br>Return the largest sum.</p>
<p>Example</p>
<p>For given <code>[1, 3, -1, 2, -1, 2]</code>, the two subarrays are <code>[1, 3]</code> and <code>[2, -1, 2]</code> or <code>[1, 3, -1, 2]</code> and <code>[2]</code>, they both have the largest sum <code>7</code>.</p>
</blockquote>
<p>求数组中两个不相交的最大子数组的和最大</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两个数组不相交，两个数组中间必然存在一个分割线，分割线左边求一个maxsubarray，右边求一个maxsubarray，两个子数组的和加在一起，就是当前分割线的最大子数组和</p>
<p>从左向右遍历分割线，分别求左边和右边的最大子数组，求和，记录最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubarray</span><span class="params">(List&lt;Integer&gt; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (start == end) &#123;</div><div class="line">        <span class="keyword">return</span> nums.get(start);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">int</span> minbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        maxSum = Math.max(maxSum,sum - minbefore);</div><div class="line">        minbefore = Math.min(minbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTwoSubArrays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> sum = MaxSubarray(nums,<span class="number">0</span>,i) + MaxSubarray(nums,i+<span class="number">1</span>,nums.size()-<span class="number">1</span>);</div><div class="line">        maxSum = Math.max(maxSum,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray" target="_blank" rel="external">Maximum Product Subarray</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p>
</blockquote>
<p>求乘积最大的子数组</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>子数组乘积最大值的可能性为：累乘的最大值碰到了一个正数；或者，累乘的最小值（负数），碰到了一个负数。所以每次要保存累乘的最大（正数）和最小值（负数）。同时还有一个选择起点的逻辑，如果之前的最大和最小值同当前元素相乘之后，没有当前元素大（或小）那么当前元素就可作为新的起点，比如遇到了0。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//局部最大最小</span></div><div class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">    <span class="comment">//全局最大</span></div><div class="line">    <span class="keyword">int</span> global_max = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//计算局部最大和最小与当前数字的乘积</span></div><div class="line">        <span class="keyword">int</span> a = max * nums[i];</div><div class="line">        <span class="keyword">int</span> b = min * nums[i];</div><div class="line">        <span class="comment">//更新局部最大和最小，必在a,b,nums[i]之中</span></div><div class="line">        max = Math.max(Math.max(a,b),nums[i]);</div><div class="line">        min = Math.min(Math.min(a,b),nums[i]);</div><div class="line">        <span class="comment">//更新全局最大</span></div><div class="line">        global_max = Math.max(global_max,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>  global_max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大子数组差"><a href="#最大子数组差" class="headerlink" title="最大子数组差"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-difference/" target="_blank" rel="external">最大子数组差</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array with integers.</p>
<p>Find two <em>non-overlapping</em> subarrays <em>A</em> and <em>B</em>, which <code>|SUM(A) - SUM(B)|</code> is the largest.</p>
<p>Return the largest difference.</p>
<p>The subarray should contain at least one number</p>
<p>Example</p>
<p>For <code>[1, 2, -3, 1]</code>, return <code>6</code>.</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两个不相交的数字，中间必然存在分割线，对分割线左右两边一编求最大一边求最小，<code>|SUM(A) - SUM(B)|</code>最大有两种情况：</p>
<ol>
<li>max_sum(A) - min_sum(B)</li>
<li>min_sum(A) - max_sum(B)</li>
</ol>
<p>遍历分割线，计算，取1,2的绝对值的最大值</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        max = Math.max(max,sum - min_before);</div><div class="line">        min_before = Math.min(min_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        min = Math.min(min,sum - max_before);</div><div class="line">        max_before = Math.max(max_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDiffSubArrays</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max_abs = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> left_max = maxSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> left_min = minSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> right_max = maxSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> right_min = minSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> max = Math.max(Math.abs(left_max - right_min),Math.abs(left_min - right_max));</div><div class="line">        max_abs = Math.max(max_abs,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max_abs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子数组之和"><a href="#子数组之和" class="headerlink" title="子数组之和"></a><a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">子数组之和</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p>
<p>There is at least one subarray that it’s sum equals to zero.</p>
<p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p>
</blockquote>
<p>返回和为0的子数组开始和结尾所对应的idx</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>计算出每一个位置的前缀和，然后二重循环计算每一个子数组的和sum[i,j]，遇到有等于0的就返回，时间复杂度<script type="math/tex">O(n^2)</script>，超时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            prefixSum[i] = sum;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        prefixSum[nums.length] = sum;</div><div class="line">        System.out.println(prefixSum);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(prefixSum[i] - prefixSum[j] == <span class="number">0</span>)&#123;</div><div class="line">                    result.add(j);</div><div class="line">                    result.add(i-<span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>改进，利用HashMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">根据给的例子：[-3, 1, 2, -3, 4]，其累加和:</div><div class="line"></div><div class="line">nums [-3, 1,  2, -3,  4]</div><div class="line">      0   1   2   3   4</div><div class="line">sum  [-3，-2， 0， -3， 1]</div><div class="line">       i           j</div><div class="line">1. i=2出现了一个数0 -&gt; sum[0,i] = 0  ,是一个答案</div><div class="line"></div><div class="line">2. 同时在i,j发现两个-3   -&gt; sum[i+1,j] = 0 ,是一个答案</div><div class="line">因此前缀和中如果有0或者有两个相等的，即为所求</div></pre></td></tr></table></figure>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="number">0</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">            result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k" target="_blank" rel="external">Subarray Sum Equals K</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:nums = [1,1,1], k = 2</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the array is in range [1, 20,000].</li>
<li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li>
</ol>
</blockquote>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>跟上一题类似的思路，利用HashMap，存储前缀和的值和出现的次数，当有相同的前缀和出现时，result增加的数量就是当前map里面改值出现的次数。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="comment">//如果之前出现过该值</span></div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">                result += map.get(sum-k);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                map.put(sum,map.get(sum)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果之前没有出现过该值，加入map</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map.put(sum,<span class="number">1</span>);<span class="comment">//key是前缀和，value是出现次数，初始化为1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Maximum-Size-Subarray-Sum-Equals-k"><a href="#Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="Maximum Size Subarray Sum Equals k"></a><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k" target="_blank" rel="external">Maximum Size Subarray Sum Equals k</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>nums</em> and a target value <em>k</em>, find the maximum length of a subarray that sums to <em>k</em>. If there isn’t one, return 0 instead.</p>
<p><strong>Note:</strong><br>The sum of the entire <em>nums</em> array is guaranteed to fit within the 32-bit signed integer range.</p>
<p><strong>Example 1:</strong></p>
<p>Given <em>nums</em> = <code>[1, -1, 5, -2, 3]</code>, <em>k</em> = <code>3</code>,<br>return <code>4</code>. (because the subarray <code>[1, -1, 5, -2]</code> sums to 3 and is the longest)</p>
<p><strong>Example 2:</strong></p>
<p>Given <em>nums</em> = <code>[-2, -1, 2, 1]</code>, <em>k</em> = <code>1</code>,<br>return <code>2</code>. (because the subarray <code>[-1, 2]</code> sums to 1 and is the longest)</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(<em>n</em>) time?</p>
</blockquote>
<p>计算和为k的子数组的最大长度</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>利用hashmap将出现过的前缀和第一次出现所在的index记录下来，在hashmap中寻找sum[i]-k，若找到，子数组的长度为<code>i - map.get(sum-k)</code> ，记录下满足条件的子数组的最大长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//用以记录子数组的最大长度</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="comment">//如果之前出现过sum-k</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">            maxlen = Math.max(maxlen,i - map.get(sum-k));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该值在map中没有出现过</span></div><div class="line">        <span class="keyword">if</span>(!map.containsKey(sum))&#123;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是index</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subarray-Sum-Closest"><a href="#Subarray-Sum-Closest" class="headerlink" title="Subarray Sum Closest "></a><a href="http://www.lintcode.com/en/problem/subarray-sum-closest/" target="_blank" rel="external">Subarray Sum Closest </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number</p>
<p>Example</p>
<p>Given <code>[-3, 1, 1, -3, 5]</code>, return <code>[0, 2]</code>, <code>[1, 3]</code>, <code>[1, 1]</code>, <code>[2, 2]</code> or <code>[0, 4]</code>.</p>
</blockquote>
<p>给定数组，返回和最接近0的子数组的开始和结束位置的index</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>计算前缀和，排序，取每一个位置的前缀和和相邻前缀和的差的最大值，记录其起点终点，取最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param nums: A list of integers</span></div><div class="line"><span class="comment">     * @return: A list of integers includes the index of the first number and the index of the last number</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">node</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> sum;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.sum = sum;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(node b)</span> </span>&#123;<span class="comment">// Comparable接口中的方法</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sum- b.sum; <span class="comment">// 按书的id比较大小，用于默认排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        node[] prefixSum = <span class="keyword">new</span> node[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            prefixSum[i] = <span class="keyword">new</span> node(sum,i);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(prefixSum);</div><div class="line">        <span class="keyword">int</span> min = Math.abs(prefixSum[<span class="number">0</span>].sum);</div><div class="line">        <span class="keyword">int</span> min_a = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> min_b = prefixSum[<span class="number">0</span>].idx;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum);</div><div class="line">                min_a = -<span class="number">1</span>;</div><div class="line">                min_b = prefixSum[i].idx;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum);</div><div class="line">                min_a = prefixSum[i].idx;</div><div class="line">                min_b = prefixSum[i-<span class="number">1</span>].idx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> min_idx = Math.min(min_a,min_b);</div><div class="line">        <span class="keyword">int</span> max_idx = Math.max(min_a,min_b);</div><div class="line">      result[<span class="number">0</span>] = min_idx+<span class="number">1</span>;</div><div class="line">      result[<span class="number">1</span>] = max_idx;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a><a href="https://leetcode.com/problems/contiguous-array" target="_blank" rel="external">Contiguous Array</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1,0]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>计算从0到i位中0的个数<code>zeroSum</code>和1的个数<code>oneSum</code>，以及0比1多多少<code>zeroMoreThanOne</code></p>
<p>利用hashmap将zeroMoreThanOne和index存储起来，当遇到zeroMoreThanOne == 0或者map.containsKey(zeroMoreThanOne )时说明遇到了01数量相等的子数组，记录最大长度</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存储0比1多多少idx</span></div><div class="line">    <span class="keyword">int</span> zeroSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> oneSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> zeroMoreThanOne = <span class="number">0</span>;</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">            zeroSum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            oneSum++;</div><div class="line">        &#125;</div><div class="line">        zeroMoreThanOne = zeroSum - oneSum;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(zeroMoreThanOne))&#123;</div><div class="line">            <span class="keyword">int</span> len = i - map.get(zeroMoreThanOne);</div><div class="line">            maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            map.put(zeroMoreThanOne,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Continuous-Increasing-Subsequence"><a href="#Longest-Continuous-Increasing-Subsequence" class="headerlink" title="Longest Continuous Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence" target="_blank" rel="external">Longest Continuous Increasing Subsequence</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,4,7]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </div><div class="line">&gt; Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,2,2,2]</div><div class="line">&gt; Output: 1</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [2], its length is 1. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
</blockquote>
<p>求最长递增子数组</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从前向后遍历，两个变量<code>maxlen</code>，<code>len_local</code> 分别记录全局最长递增子数组和局部最长递增子数组的长度，如果</p>
<ol>
<li>nums[i]&gt;nums[i-1]，len_local++,更新maxlen</li>
<li>nums[i]&gt;nums[i-1]，len_local重置为1</li>
</ol>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> len_local = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">            len_local++;</div><div class="line">            maxlen = Math.max(maxlen,len_local);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            len_local = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Degree-of-an-Array"><a href="#Degree-of-an-Array" class="headerlink" title="Degree of an Array"></a><a href="https://leetcode.com/problems/degree-of-an-array" target="_blank" rel="external">Degree of an Array</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a non-empty array of non-negative integers <code>nums</code>, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 2, 3, 1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The input array has a degree of 2 because both elements 1 and 2 appear twice.</div><div class="line">&gt; Of the subarrays that have the same degree:</div><div class="line">&gt; [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</div><div class="line">&gt; The shortest length is 2. So return 2.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,2,3,1,4,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<p><code>nums.length</code> will be between 1 and 50,000.</p>
<p><code>nums[i]</code> will be an integer between 0 and 49,999.</p>
</blockquote>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用hashmap存储元素出现的次数和第一次出现的idx，从前向后遍历，更新出现次数最多的元素和最小子数组长度</p>
<p>方法二：遍历数组，用left[val]和right[val]存储val出现的第一次和最后一次，记录出现次数最多的元素和最短长度</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> earlyIdx;</div><div class="line">    <span class="keyword">int</span> nums;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> nums)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.earlyIdx = idx;</div><div class="line">        <span class="keyword">this</span>.nums = nums;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;<span class="comment">//记录元素出现的最多次数</span></div><div class="line">    <span class="keyword">int</span> minlen = <span class="number">1</span>;<span class="comment">//记录最短长度</span></div><div class="line">    HashMap&lt;Integer,node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//如果之前有此元素了</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</div><div class="line">            <span class="comment">//算上这次跟当前出现最多次数的元素一样</span></div><div class="line">            <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> == maxNum) &#123;</div><div class="line">                minlen = Math.min(minlen,i - map.get(nums[i]).earlyIdx+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//算上这次比当前出现最多次数的元素还多</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> &gt; maxNum) &#123;</div><div class="line">                maxNum = map.get(nums[i]).nums + <span class="number">1</span>;<span class="comment">//更新最多次数</span></div><div class="line">                minlen = i - map.get(nums[i]).earlyIdx+<span class="number">1</span>;<span class="comment">//更新最短长度</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//更新map</span></div><div class="line">            node newNode = <span class="keyword">new</span> node(map.get(nums[i]).earlyIdx,map.get(nums[i]).nums+<span class="number">1</span>);</div><div class="line">            map.put(nums[i],newNode);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(nums[i],<span class="keyword">new</span> node(i,<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water</a></h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<p>给定数组<em>a1</em>, <em>a2</em>, …, <em>an</em>,表示边界高度，选取其中两个作为边界，求能够容纳水的最大量。</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>若选取i,j作为边界，能够容纳的水量是：<script type="math/tex">(j-i) * min(a_i,a_j)</script></p>
<p>步骤：</p>
<ol>
<li>初始化：i指向height[0],j指向height[len-1]</li>
<li>两指针由外向内移动，记录最大的容水量：<ol>
<li>如果height[i] &lt; height[j],i++</li>
<li>如果height[i] &gt;= height[j],j—</li>
</ol>
</li>
</ol>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">            max = Math.max(max,(j-i) *height[i]);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            max = Math.max(max,(j-i) * height[j]);</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Array-Nesting"><a href="#Array-Nesting" class="headerlink" title="Array Nesting"></a><a href="https://leetcode.com/problems/array-nesting" target="_blank" rel="external">Array Nesting</a></h3><blockquote>
<p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p>
<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: A = [5,4,0,3,1,6,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt; Explanation: </div><div class="line">&gt; A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</div><div class="line">&gt;</div><div class="line">&gt; One of the longest S[K]:</div><div class="line">&gt; S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>N is an integer within the range [1, 20,000].</li>
<li>The elements of A are all distinct.</li>
<li>Each element of A is an integer within the range [0, N-1].</li>
</ol>
</blockquote>
<p>求数组中能够成环的最大长度</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>i从头向后遍历，以i为入口访问环，把访问过的标记为-1，记录最大长度</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//记录最大长度</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums.length;i ++)&#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//记录以i为入口的环长度</span></div><div class="line">            <span class="keyword">int</span> j = i;</div><div class="line">            <span class="keyword">while</span>(nums[j] != -<span class="number">1</span>)&#123;</div><div class="line">                len++;</div><div class="line">                <span class="keyword">int</span> temp = j;</div><div class="line">                j = nums[j];</div><div class="line">                nums[temp] = -<span class="number">1</span>;<span class="comment">//访问过的元素标记</span></div><div class="line">            &#125;</div><div class="line">           maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Pivot-Index"><a href="#Find-Pivot-Index" class="headerlink" title="Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index" target="_blank" rel="external">Find Pivot Index</a></h3><blockquote>
<p>Given an array of integers <code>nums</code>, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 7, 3, 6, 5, 6]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.</div><div class="line">&gt; Also, 3 is the first index where this occurs.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 2, 3]</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: </div><div class="line">&gt; There is no index that satisfies the conditions in the problem statement.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>先计算数组的全部元素和<code>sum</code> ，再遍历一次，计算前缀和<code>prefixsum</code>，二者做差是右边的和，prefixsum-nums[i]是左边的和，二者相等就返回</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">    sum += nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> prefixsum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    prefixsum += nums[i];</div><div class="line">    <span class="keyword">if</span>(sum - prefixsum == prefixsum - nums[i])&#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="external">Product of Array Except Self</a></h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>要分三种情况讨论：</p>
<ol>
<li>如果没有0，计算总乘积、当前乘积</li>
<li>有1个0，除了0位置不为0，其余位置都是0</li>
<li>有2个以上0，所有位置都为0</li>
</ol>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="keyword">int</span> zeros = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> zeroloc = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">      zeros += <span class="number">1</span>;</div><div class="line">      zeroloc = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      product *= nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(zeros == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;res.length;i++)&#123;</div><div class="line">      res[i] = product/nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(zeros == <span class="number">1</span>)&#123;</div><div class="line">    res[zeroloc] = product;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h1><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">Best Time to Buy and Sell Stock</a></h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 1, 5, 3, 6, 4]</div><div class="line">&gt; Output: 5</div><div class="line">&gt;</div><div class="line">&gt; max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 6, 4, 3, 1]</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div><div class="line">&gt; In this case, no transaction is done, i.e. max profit = 0.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p> 第i天卖出所获的最大利润为：</p>
<p>prices[i] - min(prices[0]~prices[i-1])</p>
<p>步骤：从前向后遍历，更新到当前天的价格最低值，更新到当前天的利润最大值</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//记录最大利润</span></div><div class="line">  <span class="keyword">int</span> maxprofit = Integer.MIN_VALUE;</div><div class="line">  <span class="comment">//记录当前最低价格，初始化不能是0，应该是第一天的价格</span></div><div class="line">  <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">    maxprofit = Math.max(maxprofit,prices[i] - minprice);<span class="comment">//更新最大利润</span></div><div class="line">    minprice = Math.min(minprice,prices[i]);<span class="comment">//更新最低价格</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxprofit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a></h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p>相比Best Time to Buy and Sell Stock I，可以多次买卖，计算可获得的最大利润</p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>计算每一天跟前一天的价格差，将价格差大于0 的利润累加，就是获得的最大利润</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> delta = prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(delta &gt; <span class="number">0</span>)&#123;</div><div class="line">            max += delta;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
</blockquote>
<p>可以交易两次，设计算法求出最大利润</p>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>可以交易两次，可将数组分成左右两段，分别计算左段和右段的最大值</p>
<p>可以采用两次遍历，第一次从左向右，计算从0到i的最大利润，存在<code>maxprofits[i]</code>里。</p>
<p>第二次从右向左，计算从i到0的最大利润</p>
<p>maxprofit[i] = maxprofitfromleft[i]+maxprofitfromright[i]</p>
<p>以第i天为分割点的最大利润 = 从0到i的最大利润+从i到末尾的最大利润之和</p>
<p>以第i天为分割点在左右同时计算，包含了只交易一次，即第i天不买不卖的操作</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxresult = <span class="number">0</span>;<span class="comment">//最终结果</span></div><div class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitfromleft = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] maxprofits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];<span class="comment">//记录从0到i的最大利润</span></div><div class="line">        <span class="comment">//计算从前到i最大利润</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">            minprice = Math.min(minprice,prices[i]);</div><div class="line">            maxprofitfromleft = Math.max(maxprofitfromleft,prices[i] - minprice);</div><div class="line">            maxprofits[i] = maxprofitfromleft;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//计算从后到i最大利润+从前导i-1最大利润和</span></div><div class="line">        <span class="keyword">int</span> maxprice = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitformright = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</div><div class="line">            maxprice = Math.max(maxprice,prices[i]);<span class="comment">//从后向前最高价格</span></div><div class="line">            maxprofitformright = Math.max(maxprofitformright,maxprice - prices[i]);<span class="comment">//从后向前最大利润</span></div><div class="line">            maxresult = Math.max(maxresult,maxprofitformright + maxprofits[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxresult;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="external">Best Time to Buy and Sell Stock with Transaction Fee</a></h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<p>Return the maximum profit you can make.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The maximum profit can be achieved by:</div><div class="line">&gt; Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>不限制交易次数，但需支付交易费用，求最大利润</p>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：</div><div class="line">cash:在第i天不持股所获最大利润</div><div class="line">hold:在第i天持股所获最大利润</div><div class="line"></div><div class="line">转移方程：</div><div class="line">在第i天cash状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天cash，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天hold，第i天卖出，收益prices[i]</div><div class="line">在第i天hold状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天hold，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天cash，第i天买入，扣去prices[i]和交易费用fee</div><div class="line">因此状态转移方程为：</div><div class="line">temp = cash</div><div class="line">cash = max(cash,hold + price[i])</div><div class="line">hold = max(hold,cash - price[i] - fee)</div><div class="line">  </div><div class="line">返回值：</div><div class="line">cash 最后一天结束时不持股的最大利润</div><div class="line"></div><div class="line">初始化：</div><div class="line">cash = <span class="number">0</span> 第<span class="number">0</span>天不持股，利润为<span class="number">0</span></div><div class="line">hold = -prices[<span class="number">0</span>] - fee 为了使第一天买入时利润为<span class="number">0</span>，将第<span class="number">0</span>天持股，利润设置为 ：-prices[<span class="number">0</span>] - fee</div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>] - fee;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        	<span class="keyword">int</span> temp = cash;</div><div class="line">            cash = Math.max(cash,hold + prices[i]);</div><div class="line">            hold = Math.max(hold,temp - prices[i] - fee);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cash;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，第i天买入，花费prices[i]+fee</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]-fee)</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[<span class="number">0</span>][<span class="number">1</span>] = -Infinity; </div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> profit[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  profit[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>] - fee;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">    profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">    profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] - fee);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="external">Best Time to Buy and Sell Stock with Cooldown</a></h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; prices = [1, 2, 3, 0, 2]</div><div class="line">&gt; maxProfit = 3</div><div class="line">&gt; transactions = [buy, sell, cooldown, buy, sell]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>买卖股票存在一天的冷却期，卖出股票后第二天不可以买入，需要冷却一天，求最大利润。</p>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">2</span>天不持股，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>] = T[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">1</span>] = T[-<span class="number">1</span>][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>],-prices[<span class="number">1</span>]);</div><div class="line">        profit[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">2</span>]);</div><div class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i-<span class="number">2</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit[prices.length+<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="external">Best Time to Buy and Sell Stock IV</a></h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p>
</blockquote>
<p>最多可以买卖k次，求最大收益</p>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>动态规划的思想，下面是一种通用解法，前面的题目也同样适用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][k][<span class="number">0</span>]表示到第i天，交易k次，第i天不持股</div><div class="line">T[i][k][<span class="number">1</span>]表示到第i天，交易k次，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，之前操作k次，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，之前操作k次，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，之前操作k次，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，之前操作k-<span class="number">1</span>次，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][k][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">0</span>],T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][k][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">1</span>]，T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = T[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">0</span>][<span class="number">1</span>] = T[-<span class="number">1</span>][k][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][k][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div></pre></td></tr></table></figure>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(prices.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(prices[i] &gt;= prices[i-<span class="number">1</span>])&#123;</div><div class="line">        profit += prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> profit;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[][][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= prices.length;i++)&#123;<span class="comment">//前i天无操作，持股，不可能</span></div><div class="line">    profit[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k;i++)&#123;<span class="comment">//没有股票持股，不可能</span></div><div class="line">    profit[<span class="number">0</span>][i][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">1</span> ; kk &lt;= k ; kk++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">      profit[i][kk][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">0</span>],profit[i-<span class="number">1</span>][kk][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">      profit[i][kk][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">1</span>],profit[i-<span class="number">1</span>][kk-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][k][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Two-Sum问题"><a href="#Two-Sum问题" class="headerlink" title="Two Sum问题"></a>Two Sum问题</h1><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum</a></h3><blockquote>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">&gt;</div><div class="line">&gt; Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">&gt; return [0, 1].</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>方法一：遍历，用hash表存储下来，然后遍历数组i,在hash表中查找是否有target-i</p>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">11</span>  <span class="number">18</span> ,target=<span class="number">16</span></div><div class="line">↑                ↑</div><div class="line">i                j</div><div class="line">步骤：</div><div class="line"><span class="number">1</span>. 排序，需要把元素在原来数组中的idx存下来</div><div class="line"><span class="number">2</span>. 两个指针i,j，i指向头，j指向尾</div><div class="line"><span class="number">3</span>.<span class="keyword">if</span>(nums[i]+nums[j] &lt; targert) i++</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] &gt; targert) j--</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] == targert) <span class="keyword">return</span></div></pre></td></tr></table></figure>
<p>若给定数组是有序的<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="external">Two Sum II - Input array is sorted</a>用方法二就非常简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    Arrays.sort(nums);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = i;</div><div class="line">            result[<span class="number">1</span>] = j;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum</a></h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1, 0, 1],</div><div class="line">&gt;   [-1, -1, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法一：hash + 遍历 , 空间<script type="math/tex">O(n)</script> + 时间<script type="math/tex">O(n^2)</script></p>
<p>方法二：排序后two pointer，空间<script type="math/tex">O(1)</script> + 时间<script type="math/tex">O(n^2)</script></p>
<ol>
<li>排序</li>
<li>求a+b+c = target<br>固定a ， 然后对b + c利用Two Sum方法</li>
<li>需要注意的是遍历时要跳过重复的元素</li>
</ol>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length -<span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到了一组解</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] == <span class="number">0</span>)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        result.add(nums[a]);</div><div class="line">        result.add(nums[b]);</div><div class="line">        result.add(nums[c]);</div><div class="line">        results.add(result);</div><div class="line">        b++;</div><div class="line">        c--;</div><div class="line">        <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] == nums[b - <span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[c] == nums[c + <span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c]+ nums[a] &lt; <span class="number">0</span>)&#123;</div><div class="line">        b++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        c--;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a><a href="https://leetcode.com/problems/3sum-closest" target="_blank" rel="external">3Sum Closest</a></h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line">&gt;</div><div class="line">&gt;     The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>跟上一题一样的思路，计算nums[b] + nums[c] + nums[a] - target的值：</p>
<ol>
<li>nums[b] + nums[c] + nums[a] - target == 0，最小差为0，直接返回</li>
<li>nums[b] + nums[c] + nums[a] - target &lt; 0,跟新最小差，b++</li>
<li>nums[b] + nums[c] + nums[a] - target &gt; 0,跟新最小差，c—</li>
</ol>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="keyword">int</span> min_delta = Integer.MAX_VALUE;<span class="comment">//记录最小差值</span></div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录最小差值时三个数字和</span></div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到和target相等的情况</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] - target == <span class="number">0</span>)&#123;</div><div class="line">        sum = target;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        b++;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        c--;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[c] == nums[c+<span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3Sum-Smaller"><a href="#3Sum-Smaller" class="headerlink" title="3Sum Smaller"></a><a href="https://leetcode.com/problems/3sum-smaller" target="_blank" rel="external">3Sum Smaller</a></h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of <em>n</em> integers <em>nums</em> and a <em>target</em>, find the number of index triplets <code>i, j, k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p>
<p>For example, given <em>nums</em> = <code>[-2, 0, 1, 3]</code>, and <em>target</em> = 2.</p>
<p>Return 2. Because there are two triplets which sums are less than 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [-2, 0, 1]</div><div class="line">&gt; [-2, 0, 3]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Follow up:</strong><br>Could you solve it in <em>O</em>(<em>n</em>2) runtime?</p>
</blockquote>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>这道题没有说清楚，重复的元素也可以，步骤如下：</p>
<ol>
<li>排序</li>
<li>从0到len-3遍历a，b从a+1到len-2，c从len-1到b+1</li>
<li>确定a和b的位置之后，c从后向前遍历，寻找第一个满足nums[b] + nums[c] + nums[a] &lt; target的位置，则从当前的b+1到找到的c的位置之间的c-b个位置都可以作为c，使得nums[b] + nums[c] + nums[a] &lt; target</li>
</ol>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++) &#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (b &lt; c) &#123;</div><div class="line">      <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &gt;= target) &#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[b] + nums[c] + nums[a] &lt; target,或者b==c了</span></div><div class="line">      <span class="comment">//找到了第一个c的位置使得nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        res += c - b;<span class="comment">//b+1~c之间的元素都可以做c满足nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a><a href="https://leetcode.com/problems/4sum" target="_blank" rel="external">4Sum</a></h3><blockquote>
<p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1,  0, 0, 1],</div><div class="line">&gt;   [-2, -1, 1, 2],</div><div class="line">&gt;   [-2,  0, 0, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>跟前面一样的思路，固定a，b对c,d做2Sum</p>
<h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b = a+<span class="number">1</span>;b &lt; nums.length - <span class="number">2</span>;b++)&#123;</div><div class="line">      <span class="comment">//跳过重复元素</span></div><div class="line">      <span class="keyword">if</span>(b &gt; a+<span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//c和d做TwoSum</span></div><div class="line">      <span class="keyword">int</span> c = b+<span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> d = nums.length-<span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span>(c &lt; d)&#123;</div><div class="line">        <span class="comment">//找到了一组解</span></div><div class="line">        <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] == target)&#123;</div><div class="line">          ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">          result.add(nums[a]);</div><div class="line">          result.add(nums[b]);</div><div class="line">          result.add(nums[c]);</div><div class="line">          result.add(nums[d]);</div><div class="line">          results.add(result);</div><div class="line">          c++;</div><div class="line">          d--;</div><div class="line">          <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[c] == nums[c - <span class="number">1</span>])&#123;</div><div class="line">            c++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[d] == nums[d + <span class="number">1</span>])&#123;</div><div class="line">            d--;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] &lt; target)&#123;</div><div class="line">          c++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          d--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4Sum-II"><a href="#4Sum-II" class="headerlink" title="4Sum II"></a><a href="https://leetcode.com/problems/4sum-ii" target="_blank" rel="external">4Sum II</a></h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; A = [ 1, 2]</div><div class="line">&gt; B = [-2,-1]</div><div class="line">&gt; C = [-1, 2]</div><div class="line">&gt; D = [ 0, 2]</div><div class="line">&gt;</div><div class="line">&gt; Output:</div><div class="line">&gt; 2</div><div class="line">&gt;</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The two tuples are:</div><div class="line">&gt; 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</div><div class="line">&gt; 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给四个数组，从每个数组中选一个数字，和为0的选择方案有多少</p>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>方法一：直接遍历四个数组，复杂度<script type="math/tex">O(n^4)</script></p>
<p>方法二：AB为一组，CD为一组，用两个hashmap记录两组中出现的和及其出现次数，互为相反数的和为0。</p>
<p>改进：存储两个hashmap再遍历速度很慢，所以只计算AB的和存入hashmap，然后计算CD时去AB的hashmap中寻找-sum出现的次数累加到result上即可。</p>
<h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Integer,Integer&gt; mapab = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="comment">//计算AB的和，存入hashmap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sumab = A[i]+B[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(sumab))&#123;</div><div class="line">                    mapab.put(sumab,mapab.get(sumab)+<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    mapab.put(sumab,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum = C[i] + D[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(-sum))&#123;</div><div class="line">                    result += mapab.get(-sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Triangle-Number"><a href="#Valid-Triangle-Number" class="headerlink" title="Valid Triangle Number"></a><a href="https://leetcode.com/problems/valid-triangle-number" target="_blank" rel="external">Valid Triangle Number</a></h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,3,4]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation:</div><div class="line">&gt; Valid combinations are: </div><div class="line">&gt; 2,3,4 (using the first 2)</div><div class="line">&gt; 2,3,4 (using the second 2)</div><div class="line">&gt; 2,2,3</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>选取三个数组作为三边长度，返回能够组成三角形的选取方案数</p>
<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>构成三角形条件：两边之和大于第三边</p>
<ol>
<li>排序，两个小边之和大于第三边</li>
<li>固定a，遍历b、c，寻找第一个nums[a] + nums[b] &gt; nums[c]的位置</li>
<li>bc之间的位置都可以作为c，使得nums[a] + nums[b] &gt; nums[c]，result+= c-b。</li>
</ol>
<h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &lt;= nums[c])&#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[a] + nums[b] &gt; nums[c]或者b==c</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &gt; nums[c])&#123;</div><div class="line">        result += c-b;</div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Partition类问题"><a href="#Partition类问题" class="headerlink" title="Partition类问题"></a>Partition类问题</h1><p>不开额外的空间，用两个指针分成两个、三个部分，利用quicksort的思想</p>
<h3 id="partition-Array"><a href="#partition-Array" class="headerlink" title="partition Array"></a><a href="http://www.lintcode.com/en/problem/partition-array/" target="_blank" rel="external">partition Array</a></h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <code>nums</code> of integers and an int <code>k</code>, partition the array (i.e move the elements in “nums”) such that:</p>
<ul>
<li>All elements &lt; <em>k</em> are moved to the <em>left</em></li>
<li>All elements &gt;= <em>k</em> are moved to the <em>right</em></li>
</ul>
<p>Return the partitioning index, i.e the first index <em>i</em> nums[<em>i</em>] &gt;= <em>k</em>.</p>
<p>Example</p>
<p>If nums = <code>[3,2,2,1]</code> and <code>k=2</code>, a valid answer is <code>1</code>.</p>
</blockquote>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>利用quicksort的思想，两指针一前一后向中间遍历，前面遇到大的，后面遇到小的交换，最后判断nums[j]和target的大小关系，返回结果。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-02-10-28-18.png" alt=""> </p>
<h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; k)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= k)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;<span class="comment">//j右边都&gt;=k</span></div><div class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[i];</div><div class="line">            nums[i] = nums[j];</div><div class="line">            nums[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[j] &gt;= k)&#123;</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个指针，利用快速排序</p>
<h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a><a href="https://leetcode.com/problems/sort-colors" target="_blank" rel="external">Sort Colors</a></h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
</blockquote>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>方法一：计数排序，遍历，记录0,1,2出现的个数，然后重新输出，时间复杂度<script type="math/tex">O(n)</script></p>
<p>方法二：两次partition，先把0分一堆，1，2分一堆，然后再把1,2分开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColorsPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">1</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">1</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">    <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对右半段，分成成左边都&lt;2，右边&gt;=2</span></div><div class="line">  j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">2</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">2</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇了</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法三：背程序，三个指针三分法。</p>
<ol>
<li>i，j指向头和尾，mid在中间</li>
<li>mid向后遍历，遇到0与i交换，遇到2与j交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(mid &lt;= j)&#123;</div><div class="line">    <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">1</span>)&#123;</div><div class="line">      mid++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      mid++;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[j];</div><div class="line">      nums[j] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort-Colors-II"><a href="#Sort-Colors-II" class="headerlink" title="Sort Colors II"></a><a href="http://www.lintcode.com/en/problem/sort-colors-ii/" target="_blank" rel="external">Sort Colors II</a></h3><blockquote>
<p>Given an array of <em>n</em> objects with <em>k</em> different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k.</p>
<p>Example</p>
<p>Given colors=<code>[3, 2, 2, 1, 4]</code>, <code>k=4</code>, your code should sort colors in-place to <code>[1, 2, 2, 3, 4]</code>.</p>
</blockquote>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors2</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(colors.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = colors.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kk = <span class="number">2</span>;</div><div class="line">    <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">    <span class="keyword">while</span>(kk &lt;= k)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[i] &lt; kk)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[j] &gt;= kk)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">            <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">            <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">                <span class="keyword">int</span> temp = colors[i];</div><div class="line">                colors[i] = colors[j];</div><div class="line">                colors[j] = temp;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        j = colors.length-<span class="number">1</span>;</div><div class="line">        kk++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort-Letters-by-Case"><a href="#Sort-Letters-by-Case" class="headerlink" title="Sort Letters by Case"></a><a href="http://www.lintcode.com/en/problem/sort-letters-by-case/" target="_blank" rel="external">Sort Letters by Case</a></h3><h4 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string which contains only letters. Sort it by lower case first and upper case second.</p>
<p>For <code>&quot;abAcD&quot;</code>, a reasonable answer is <code>&quot;acbAD&quot;</code></p>
</blockquote>
<p>给一串字母，把小写的排在左边，大写的排在右边</p>
<h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortLetters</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</div><div class="line">  <span class="comment">// write your code here</span></div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = chars.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[i] &gt;= <span class="string">'a'</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[j] &lt;= <span class="string">'Z'</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">      <span class="keyword">char</span> temp = chars[i];</div><div class="line">      chars[i] = chars[j];</div><div class="line">      chars[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interleaving-Positive-and-Negative-Numbers"><a href="#Interleaving-Positive-and-Negative-Numbers" class="headerlink" title="Interleaving Positive and Negative Numbers"></a><a href="http://www.lintcode.com/en/problem/interleaving-positive-and-negative-numbers/" target="_blank" rel="external">Interleaving Positive and Negative Numbers</a></h3><blockquote>
<p>Given an array with positive and negative integers. Re-range it to interleaving with positive and negative integers.</p>
<p>Example</p>
<p>Given <code>[-1, -2, -3, 4, 5, 6]</code>, after re-range, it will be <code>[-1, 5, -2, 4, -3, 6]</code> or any other reasonable answer.</p>
</blockquote>
<p>把正的和负的先都挑出来，然后交替放入数组。如果正的多余负的，先放正的，否则先放负的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rerange</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] zheng = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="keyword">int</span>[] fu = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> zhengi = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fui = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; A.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)&#123;</div><div class="line">            fu[fui] = A[i];</div><div class="line">            fui++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            zheng[zhengi] = A[i];</div><div class="line">            zhengi++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fui &lt; zhengi)&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = zheng[zhengj];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = fu[fuj];</div><div class="line">        i++;</div><div class="line">        <span class="keyword">if</span>(A.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Two-pointer问题"><a href="#Two-pointer问题" class="headerlink" title="Two pointer问题"></a>Two pointer问题</h1><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>
<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>
<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code>is a <em>subsequence</em> and not a substring.</p>
</blockquote>
<p>给定一个字符串，计算不包含重复字母的最长子串</p>
<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口做，窗口边界left、right，用数组<code>int[] map = new int[256]</code>存储当前窗口内出现的元素，用maxlen、len_local记录最大长度和当前窗口长度</p>
<ol>
<li>初始化left,right=0</li>
<li>right向后滑动，直至遇到窗口中已经存在该元素</li>
<li>left向后滑动，窗口缩小，直至将已经出现过的元素挪到窗口外面</li>
<li>循环更新local长度和全局最大长度</li>
</ol>
<h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> s.length();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  <span class="keyword">int</span> len_local = <span class="number">0</span>;<span class="comment">//局部长度</span></div><div class="line">  <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">  <span class="keyword">while</span>(right &lt; s.length())&#123;</div><div class="line">    <span class="comment">//如果字母还未出现过</span></div><div class="line">    <span class="keyword">if</span>(map[s.charAt(right)] == <span class="number">0</span>)&#123;</div><div class="line">      <span class="comment">//存入字母表</span></div><div class="line">      map[s.charAt(right)]++;</div><div class="line">      <span class="comment">//更新局部长度和全局最大长度</span></div><div class="line">      len_local++;</div><div class="line">      maxlen = Math.max(maxlen,len_local);</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//出现过</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//寻找之前该元素出现的位置</span></div><div class="line">      <span class="keyword">while</span> (s.charAt(left) != s.charAt(right))&#123;</div><div class="line">        <span class="comment">//路上把滑窗缩减的字母从字母表中去掉</span></div><div class="line">        map[s.charAt(left)]--;</div><div class="line">        left++;</div><div class="line">        len_local--;</div><div class="line">      &#125;<span class="comment">//跳出时left和right字母相等</span></div><div class="line">      left++;</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">Implement strStr()</a></h3><h4 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</div><div class="line">&gt; Output: -1</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h4><p>方法一：双指针遍历比较判断每一个字符是否一样</p>
<p>方法二：<code>return haystack.indexOf(needle);</code></p>
<p>方法三：<code>haystack.substring(i, i + needle.length()).equals(needle)</code></p>
<h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(j &lt; haystack.length())&#123;</div><div class="line">    <span class="comment">//遇到相等的字母</span></div><div class="line">    <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(k))&#123;</div><div class="line">      <span class="comment">//j和k同时向后移动</span></div><div class="line">      <span class="keyword">while</span>(j &lt; haystack.length() &amp;&amp; k &lt; needle.length() &amp;&amp; haystack.charAt(j) == needle.charAt(k))&#123;</div><div class="line">        j++;</div><div class="line">        k++;</div><div class="line">      &#125;<span class="comment">//跳出时或者到头了或者有不相等的了</span></div><div class="line">      <span class="comment">//如果k到头了，说明已经包含了needls</span></div><div class="line">      <span class="keyword">if</span>(k == needle.length())&#123;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//j到头了，剩下的字符串不够长了，不可能包含了</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == haystack.length())&#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        i++;</div><div class="line">        j = i;</div><div class="line">        k = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不是相等的字母，ij向后移动</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      i++;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Vowels-of-a-String"><a href="#Reverse-Vowels-of-a-String" class="headerlink" title="Reverse Vowels of a String"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="external">Reverse Vowels of a String</a></h3><h4 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong><br>Given s = “hello”, return “holle”.</p>
<p><strong>Example 2:</strong><br>Given s = “leetcode”, return “leotcede”.</p>
<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>
</blockquote>
<p>对换元音字母</p>
<h4 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h4><p>两指针一前一后向中间遍历，遇到元音对换即可。</p>
<p>这里需要注意的是java的String是不可更改的，需要用StringBuilder复制一份再做修改：<code>result.setCharAt(i,s.charAt(j))</code>;</p>
<h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseVowelsofaString</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span></div><div class="line">                || ch == <span class="string">'A'</span> || ch == <span class="string">'E'</span> || ch == <span class="string">'I'</span> || ch == <span class="string">'O'</span> || ch == <span class="string">'U'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(s);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(i)))&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(j)))&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">char</span> temp = s.charAt(i);</div><div class="line">            result.setCharAt(i,s.charAt(j));</div><div class="line">            result.setCharAt(j,temp);</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="external">Valid Palindrome</a></h3><h4 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.</p>
</blockquote>
<p>有效回文串，判断字符串中的有效字符是否可以构成有效回文串，其中有效字符仅包括字母和数字，大小写算同一个字母</p>
<h4 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h4><p>步骤</p>
<ol>
<li>需要一个确定是否是有效字符的函数<code>isvalid</code>,利用java中的<code>Character.isLetter()</code>和<code>Character.isDigit()</code></li>
<li>两指针一前一后遍历，遇到无效字符跳过，比较两指针指向的字符是否相等，如果不相等直接返回false</li>
</ol>
<h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isvalid</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Character.isLetter(c) || Character.isDigit(c);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(i)))&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//全是invalid字符的情况</span></div><div class="line">    <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(j)))&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    i++;j--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Palindrome-II"><a href="#Valid-Palindrome-II" class="headerlink" title="Valid Palindrome II"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="external">Valid Palindrome II</a></h3><h4 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;aba&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;abca&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt; Explanation: You could delete the character &apos;c&apos;.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定字符串，判断如果最多可以去掉一个字符，改字符串是否可以成为回文串</p>
<h4 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h4><p>跟上一题的思路有点不太一样，没有想到巧妙的方法</p>
<p>两指针指向头尾，如果两个指针指向元素相等，则i++;j—</p>
<p>如果两指针指向元素不相等，那么s[i+1]~s[j]和s[i]~s[j-1]中必然有一个是回文串</p>
<h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否是回文串</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(start == end)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = start;</div><div class="line">  <span class="keyword">int</span> right = end;</div><div class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    left++;</div><div class="line">    right--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> isPalindrome(s,i,j-<span class="number">1</span>) || isPalindrome(s,i+<span class="number">1</span>,j);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Word-in-Dictionary-through-Deleting"><a href="#Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="Longest Word in Dictionary through Deleting"></a><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="external">Longest Word in Dictionary through Deleting</a></h3><h4 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;apple&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;a&quot;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个字符串s和一个字符串数组d,返回d中字符串是s的子序列的最长字符串，如果有长度相同的则返回在字母表中顺序最靠前的</p>
<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>遍历d中的字符串，看其是否能够由s的子序列构成，如果能，更新最大长度，如果和当前最大长度相等，取字典序小的</p>
<h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否能够是s的子序列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issubqueue</span><span class="params">(String s,String stemp)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> si = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> stempi = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; stempi &lt; stemp.length())&#123;</div><div class="line">    <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; s.charAt(si) != stemp.charAt(stempi))&#123;</div><div class="line">      si++;</div><div class="line">    &#125;<span class="comment">//跳出时si==len或者遇到相等的了</span></div><div class="line">    <span class="keyword">if</span>(si == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    si++;</div><div class="line">    stempi++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> stempi == stemp.length();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  String result = <span class="keyword">new</span> String();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.size();i++)&#123;</div><div class="line">    String stemp = d.get(i);</div><div class="line">    <span class="keyword">int</span> len = stemp.length();</div><div class="line">    <span class="keyword">boolean</span> flag = issubqueue(s,stemp);</div><div class="line">    <span class="keyword">if</span>(flag)&#123;</div><div class="line">      <span class="keyword">if</span>(len &gt; maxlen)&#123;</div><div class="line">        maxlen = len;</div><div class="line">        result= stemp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(len == maxlen &amp;&amp; stemp.compareTo(result) &lt; <span class="number">0</span>)&#123;</div><div class="line">        result = stemp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里判断t是否是s的子序列存在优化的空间，可以利用Java的String中的indexOf(char,indexfrom)来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//s是否包含t</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(String s,String t)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(t.length() &gt; s.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length();i++)&#123;</div><div class="line">    pos = s.indexOf(t.charAt(i),pos);</div><div class="line">    <span class="keyword">if</span>(pos != -<span class="number">1</span>)&#123;</div><div class="line">      pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutation-in-String"><a href="#Permutation-in-String" class="headerlink" title="Permutation in String"></a><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="external">Permutation in String</a></h3><h4 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</div><div class="line">&gt; Output:True</div><div class="line">&gt; Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</div><div class="line">&gt; Output: False</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定字符串s1和s2，返回s2中是否包含一个子串，使得该子串可以由s1中字母的某种排列方式构成。</p>
<h4 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h4><p>滑动窗口法，窗口长度设置为s1的长度，在s2中寻找s1的排列子串</p>
<p>窗口向右滑动，直到窗口内出现的字母以及每个字母出现的次数和s1中一样，此时找到了满足条件的子数组。</p>
<p>将s1中出现的字母和每个字母出现的次数记录在一个hashtable中，因为只有26个字母，可以用一个长度为26的数组记录每个字母出现的次数</p>
<h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span>[] s1map,<span class="keyword">int</span>[] s2map)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] != s2map[i])&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(isSame(s1map,s2map))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    s2map[s2.charAt(s1.length()+i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isSame(s1map,s2map);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>这里判断字符串相等还有可以优化的空间，用变量count表示当前窗口内和s1出现相同次数的字母的个数，当count == 26，则所有的字母都出现相同次数了，找到了解。当滑窗向后移动时，需要更新count</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion2</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] == s2map[i])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">int</span> r = s2.charAt(s1.length()+i) - <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">int</span> l = s2.charAt(i) - <span class="string">'a'</span>;</div><div class="line">    <span class="comment">//所有字母出现次数相等</span></div><div class="line">    <span class="keyword">if</span>(count == <span class="number">26</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//窗口将右边元素加入</span></div><div class="line">    s2map[r]++;</div><div class="line">    <span class="keyword">if</span>(s1map[r] == s2map[r])&#123;<span class="comment">//新加入元素后这个元素变得个数相等了</span></div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s2map[r] == s1map[r]+<span class="number">1</span>)&#123;<span class="comment">//新加入元素后比s1多一个了</span></div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">////窗口将左边元素去掉</span></div><div class="line">    s2map[l]--;</div><div class="line">    <span class="keyword">if</span>(s1map[l] == s2map[l])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1map[l] == s2map[l]+<span class="number">1</span>)&#123;</div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count == <span class="number">26</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subarray-Product-Less-Than-K"><a href="#Subarray-Product-Less-Than-K" class="headerlink" title="Subarray Product Less Than K"></a><a href="https://leetcode.com/problems/subarray-product-less-than-k" target="_blank" rel="external">Subarray Product Less Than K</a></h3><h4 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Your are given an array of positive integers <code>nums</code>.</p>
<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">&gt; Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h4><p>滑窗+两指针i,j题:</p>
<p>如果窗口内乘积&gt;=k，i++,窗口缩小</p>
<p>如果滑窗内乘积&lt;k，窗口内包含的以j为结束的子数组个数为j-i+1</p>
<h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(start &lt; end &amp;&amp; end &lt; nums.length)&#123;</div><div class="line">    product *= nums[end];</div><div class="line">    <span class="keyword">while</span> (start &lt; end &amp;&amp; product &gt;= k)&#123;</div><div class="line">      product /= nums[start];</div><div class="line">      start++;</div><div class="line">    &#125;</div><div class="line">    count += end - start +<span class="number">1</span>;</div><div class="line">    end++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Wiggle-Sort-II"><a href="#Wiggle-Sort-II" class="headerlink" title="Wiggle Sort II"></a><a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote>
<p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
</blockquote>
<h4 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>这道题给了我们一个无序数组，让我们排序成摆动数组，满足nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…，并给了我们例子。我们可以先给数组排序，然后在做调整。调整的方法是找到数组的中间的数，相当于把有序数组从中间分成两部分，然后从前半段的末尾取一个，在从后半的末尾取一个，这样保证了第一个数小于第二个数，然后从前半段取倒数第二个，从后半段取倒数第二个，这保证了第二个数大于第三个数，且第三个数小于第四个数，以此类推直至都取完。</p>
<p>follow up：要求空间复杂度O(1)，没做上，要问下邓邓</p>
<h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Super-Ugly-Number"><a href="#Super-Ugly-Number" class="headerlink" title="Super Ugly Number"></a><a href="https://leetcode.com/problems/super-ugly-number" target="_blank" rel="external">Super Ugly Number</a></h3><h4 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to find the nth super ugly number.</p>
<p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list <code>primes</code> of size <code>k</code>. For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]</code>is the sequence of the first 12 super ugly numbers given <code>primes</code> = <code>[2, 7, 13, 19]</code> of size 4.</p>
<p><strong>Note:</strong><br>(1) <code>1</code> is a super ugly number for any given <code>primes</code>.<br>(2) The given numbers in <code>primes</code> are in ascending order.<br>(3) 0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 106, 0 &lt; <code>primes[i]</code> &lt; 1000.<br>(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.</p>
</blockquote>
<p>给定n和素数序列，返回第n个ugly number:因子只能出现在素数序列中</p>
<h4 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h4><p>用上面的hashmap+heap的方法会超时，看了九章的答案和网上大神们给出的答案，才看明白啥意思</p>
<p>以上一题prime只有三个数字2,3,5为例，我们知道丑陋数序列可以拆分为下面3个子列表：</p>
<p>(1) <strong>1x2</strong>,  2x2, <strong>2x2</strong>, 3x2, <strong>3x2</strong>, <strong>4x2</strong>, 5x2…</p>
<p>(2) 1x3,  <strong>1x3</strong>, 2x3, 2x3, <strong>2x3</strong>, 3x3, <strong>3x3</strong>…</p>
<p>(3) 1x5,  1x5, 1x5, <strong>1x5,</strong> 2x5, 2x5, 2x5…</p>
<p>仔细观察上述三个列表，我们可以发现每个子列表都是一个丑陋数分别乘以2,3,5，而要求的丑陋数就是从已经生成的序列中取出来的，我们每次都从三个列表中取出当前最小的那个加入序列，比如第一次，ugly number当前只有1，分别于2,3,5相乘之后得到2,3,5三个数字，此时除1外，最小的是2，因此先把2加入ugly number 里，然后此时2就可以与当前ugly number中比1大的下一个数字相乘，与上一轮的3,5，进行比较了，。。。</p>
<p>因此，上面的规律总结起来就是：</p>
<ol>
<li>一共进行n轮计算和选择</li>
<li>每轮计算a*b，其中b是给定的prime列表中的数字，a是ugly number中的数字</li>
<li>每一轮选择本轮（本列）最小的元素加入ugly number,下一轮该行所选取的”a”的idx后移一位。</li>
</ol>
<h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] uglyNumbers = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];</div><div class="line">        uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; primes.length;j++)&#123;</div><div class="line">                min = Math.min(min,primes[j] * uglyNumbers[idx[j]]);</div><div class="line">            &#125;</div><div class="line">            uglyNumbers[i] = min;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; primes.length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(min == primes[j] * uglyNumbers[idx[j]])&#123;</div><div class="line">                    idx[j]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> uglyNumbers[n-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="external">Meeting Rooms II</a></h3><h4 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p>
</blockquote>
<p>给定一个interval序列，代表会议的开始和结束时间，返回需要的最大会议室数量，也就是同时开会的最大数量。</p>
<h4 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h4><p>方法一：扫描线的思路+heap实现</p>
<p>将会议的开始和结束时间排序，然后从较小的开始遍历，初始sum=0,遇到start+1,遇到end-1，过程中最大的sum即为同时召开的最大会议数量。要注意的是，遇到同一时刻既有会议开始也有会议结束时应该先访问end，将sum-1,然后再访问start.</p>
<p>需要用小顶堆维护会议开始和结束时间，小顶堆的判断依据为time和Start or End</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p>将所有开始时间和结束时间分别放入两个数组，分别排序，然后两指针一个指向开始数组i，一个指向结束数组j，初始化sum = 0;</p>
<p>i后移时sum++;</p>
<p>j后移时sum—;</p>
<p>当指向开始数组的指针&gt;=结束数组指针所指的值时，结束数组向后移动一位，否则开始指针后移。</p>
<h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</div><div class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> time,<span class="keyword">boolean</span> isStart)&#123;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(tmp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].start,<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].end,<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(heap.poll().isStart)&#123;</div><div class="line">                sum++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;sum--;&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">        starts[i] = intervals[i].start;</div><div class="line">        ends[i] = intervals[i].end;</div><div class="line">    &#125;</div><div class="line">    Arrays.sort(starts);</div><div class="line">    Arrays.sort(ends);</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; starts.length &amp;&amp; j &lt; ends.length)&#123;</div><div class="line">        <span class="keyword">if</span>(starts[i] &lt; ends[j])&#123;</div><div class="line">            sum++;</div><div class="line">            max = Math.max(max,sum);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">            sum--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="The-Skyline-Problem"><a href="#The-Skyline-Problem" class="headerlink" title="The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem" target="_blank" rel="external">The Skyline Problem</a></h3><h4 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p>
<p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt="Buildings"> </p>
<p><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt="Skyline Contour"></p>
<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p>
<p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>
</blockquote>
<p>给定建筑物的坐标和高度，有重叠，计算轮廓</p>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>扫描线</p>
<h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】课程笔记——链表]]></title>
      <url>/2017/12/11/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>考点重要程度：链表 -&gt; DFS/BFS -&gt;DP</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>test:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//print() 打印完整链表</span></div><div class="line">ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line"></div><div class="line">ListNode head = node1;</div><div class="line">node1.next = node2;</div><div class="line">node2.next = node3;</div><div class="line"></div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line">node1 = node2;</div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line"></div><div class="line">ListNode包括一个值和一个指针，head占<span class="number">4</span>Byte(<span class="number">32</span>bit)空间，head实际上是一个指针，通过head所指向的地址去找对应节点存储的值和下一个指针。</div><div class="line"></div><div class="line">链表结构：</div><div class="line">    [<span class="number">1</span>,] -&gt;  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,]  </div><div class="line">      ↑        ↑       ↑</div><div class="line">   head,n1     n2     n3</div><div class="line">   <span class="number">4</span><span class="keyword">byte</span>     <span class="number">4</span><span class="keyword">byte</span>   <span class="number">4</span><span class="keyword">byte</span></div><div class="line">   </div><div class="line">node1和node2都是指向节点的指针，如果令node1 = node2,那么只是node1存储的地址和node2存储的地址一样了，但是链表的机构没有改变，所以输出依然是:</div><div class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span> </div><div class="line">  </div><div class="line">如果要改变链表的结构，需要node.next = balabala</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h2><h3 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>删掉链表中有重复的节点，保留一个</p>
<p>因为删除某个节点node，需要让node的前序节点.next = node.next，因此需要构造一个dummy node，让其指向前序节点，这样需要删除head的时候就可以令dummy.next = node.next。初始化时令dummy.next=head</p>
<p>最后返回dummy.next</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev;<span class="comment">//用于记录重复元素第一次出现的位置</span></div><div class="line">  ListNode curt = head;<span class="comment">//用于向后遍历链表</span></div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      prev = curt;<span class="comment">//记录第一个出现的元素</span></div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，curt继续后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="external">Remove Duplicates from Sorted List II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>删除链表中重复出现的节点，全部删掉一个都不保留</p>
<p>因为删除某个节点node，需要让node的前序节点.next = node.next，删除全部重复的元素可能删掉head元素，因此需要构造一个dummy node，让其指向head的前序节点，也就是dummy.next = head。这样需要删除head的时候就可以令dummy.next = head.next。</p>
<p>最后反回dummy.next</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//虚拟节点用于指向head</span></div><div class="line">  dummy.next = head;</div><div class="line"></div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，prev和curt都后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev = prev.next;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="external">Reverse Linked List</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Reverse a singly linked list.、</p>
<p>Hint:</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
</blockquote>
<p>链表反转</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑</div><div class="line"> prev   curt</div><div class="line"> </div><div class="line"><span class="number">1</span>. 用temp记录下curt.next（因为后面要修改curt.next）</div><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"> </div><div class="line"><span class="number">2</span>. 将curt.next指向其前序节点prev，此时原来的后续链断掉:</div><div class="line"> <span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"><span class="number">3</span>. 将prev移到curt位置，curt移动到原来的curt.next,即temp:</div><div class="line"><span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">         ↑      ↑       ↑</div><div class="line">        prev   curt    temp</div><div class="line"></div><div class="line">ListNode temp = curt.next;</div><div class="line">curt.next = prev</div><div class="line">prev = curt;</div><div class="line">curt = temp;</div></pre></td></tr></table></figure>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev = <span class="keyword">null</span>;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    ListNode temp = curt.next;</div><div class="line">    curt.next = prev;</div><div class="line">    prev = curt;</div><div class="line">    curt = temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii" target="_blank" rel="external">Reverse Linked List II</a></h3><blockquote>
<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<p><strong>Note:</strong><br>Given <em>m</em>, <em>n</em> satisfy the following condition:<br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
</blockquote>
<p>将链表的第m-n位置上的元素反转</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[<span class="number">1</span>,]-&gt;[<span class="number">2</span>,]-&gt;...-&gt;[m-<span class="number">1</span>,]-&gt;[m,]-&gt;...-&gt;[n,]-&gt;[n+<span class="number">1</span>,]-&gt;...</div><div class="line">翻转m和n之间的部分，分为三个步骤：</div><div class="line"><span class="number">1</span>. 找到m-<span class="number">1</span>和m的点，设为prev和curt</div><div class="line"><span class="number">2</span>. 将m~n反转</div><div class="line"><span class="number">3</span>. 把m-<span class="number">1</span>.next指向n;把m.next指向n.next</div></pre></td></tr></table></figure>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-12-00-49-23.png" alt=""></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt = head;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第m个节点</span></div><div class="line">        <span class="keyword">while</span> (i &lt; m)&#123;</div><div class="line">            curt = curt.next;</div><div class="line">            prev = prev.next;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时prev指向第m-1个节点，curt指向第m个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//记录下m节点和m-1节点位置，用于反转后连接</span></div><div class="line">        ListNode m_node = curt;</div><div class="line">        ListNode m_prev = prev;</div><div class="line"></div><div class="line">        <span class="comment">//将m到n反转</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= n)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时curt指向第n+1个节点，prev指向第n个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//将m的前序节点的next指向第n个节点</span></div><div class="line">        m_prev.next = prev;</div><div class="line">        <span class="comment">//将m节点的next指向第n+1个节点</span></div><div class="line">        m_node.next = curt;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a><a href="https://leetcode.com/problems/partition-list" target="_blank" rel="external">Partition List</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
<p>给定一个链表和一个数x，将链表中比x小的排在左边，大于等于x的数字排在右边，数字的相对顺序保持不变</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>将链表排成两队，小于x的一队，大于等于x的一队，然后把两个链表连起来。</p>
<p>链表的结构会发生变化，所以需要两个dummy node，一个用来指向小的队dummy_low，一个用来指向大的队dummy_high。</p>
<p><strong>解题步骤：</strong></p>
<ol>
<li>遍历数组，将比x小的元素放到dummy_low队伍后面，将比x大的元素放到dummy_high队伍后面</li>
<li>结束后将两个链表连接起来：dummy_low.next指向dummy_high.next</li>
<li>将链表结尾置空：tail.next = null,否则会保留原始节点的next。</li>
<li>返回dummy_low.next;</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        ListNode next;</div><div class="line"></div><div class="line">        ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">establish</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode curt = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item : array)&#123;</div><div class="line">            ListNode node = <span class="keyword">new</span> ListNode(item);</div><div class="line">            curt.next = node;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        curt.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        ListNode dummy_low = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode dummy_high = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line"></div><div class="line">        ListNode prev_low = dummy_low;<span class="comment">//用于向小链表插入</span></div><div class="line">        ListNode prev_high = dummy_high;<span class="comment">//用于向大链表插入</span></div><div class="line"></div><div class="line">        <span class="comment">//分别放到两个队伍里</span></div><div class="line">        ListNode curt = head;</div><div class="line">        <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt.val &lt; x)&#123;</div><div class="line">                prev_low.next = curt;</div><div class="line">                prev_low = prev_low.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev_high.next = curt;</div><div class="line">                prev_high = prev_high.next;</div><div class="line">            &#125;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将两链表连接</span></div><div class="line">        prev_low.next = dummy_high.next;</div><div class="line">        prev_high.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy_low.next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">            System.out.println(head.val);</div><div class="line">            System.out.println(<span class="string">" -&gt; "</span>);</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        PartitionList test = <span class="keyword">new</span> PartitionList();</div><div class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line">        ListNode head = test.establish(array);</div><div class="line">        head = test.partition(head,x);</div><div class="line">        test.printList(head);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">Merge Two Sorted Lists</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">&gt; Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>链表结构可能改变， 所以需要dummy node</p>
<p>需要一个prev指针记录当前节点，初始化指向dummy_node两个curt指针分别指向两个链表当前节点，用于比较，将比较小的接在prev后面，知道两个curt中有一个为空，将另一个链表的后面直接接到prev后面。</p>
<p>最后返回dummy.next</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt1 = l1;</div><div class="line">        ListNode curt2 = l2;</div><div class="line">        <span class="keyword">while</span> (curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt1.val &lt; curt2.val)&#123;</div><div class="line">                prev.next = curt1;</div><div class="line">                curt1 = curt1.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                prev.next = curt2;</div><div class="line">                curt2 = curt2.next;</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a><a href="https://leetcode.com/problems/sort-list" target="_blank" rel="external">Sort List</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
<p>将链表排序，时间复杂度为 <em>O</em>(<em>n</em> log <em>n</em>)</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>时间复杂度为nlogn的排序：quick sort\merge sort\heap sort</p>
<p>quick sort和merge sort的区别：</p>
<ol>
<li><p>算法流程</p>
<p>quik sort：整体有序 -&gt; 局部有序、不稳定排序</p>
<ul>
<li>整体有序：选定一个元素，比它小的都在它左边，比它大的都在它右边</li>
<li>局部有序：然后再对左段和右段分别做快排</li>
</ul>
<p>merge sort：局部有序 -&gt; 整体有序、稳定排序</p>
<ul>
<li>局部有序：选取中点将序列分成左右两段，对左右两边分别排序</li>
<li>整体有序：将左右两边sort list 进行merge操作使得整个list有序</li>
</ul>
</li>
</ol>
<ol>
<li><p>排序的稳定性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[2 , 1&apos; , 1&apos;&apos;, 1&apos;&apos;&apos; , 4 , 3&apos; , 3&apos;&apos;]</div><div class="line">merge sort的merge操作不会改变元素的相对顺序，所以是稳定排序</div><div class="line">quick sort会改变元素的相对位置，所以不是稳定排序</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>时间复杂度</p>
<p>quick sort平均时间复杂度<script type="math/tex">O(nlogn)</script>，最坏时间复杂度<script type="math/tex">O(n^2)</script></p>
<p>merge sort时间复杂度：<script type="math/tex">O(nlogn)</script></p>
</li>
<li><p>空间复杂度</p>
<p>quick sort：<script type="math/tex">O(1)</script></p>
<p>merge sort：<script type="math/tex">O(n)</script> ，但是在链表中不需要开辟额外的空间</p>
</li>
</ol>
<p><strong>解题步骤：</strong></p>
<p>merge sort</p>
<p>​    具体步骤：</p>
<ol>
<li>merge sort在链表中找中点，有两种方法：<ol>
<li>遍历一遍，得到链表的长度n，则中间位置是n/2，再从头遍历一遍，到n/2的位置停止，找到中点</li>
<li>设置两个错位指针，一个slow一个fast，初始化都指向head，slow每次向右移动一位，fast每次向右移动两位，fast移动到末尾的时候，head指向中间，取到链表中点</li>
</ol>
</li>
<li>对左右两段递归进行排序</li>
<li>merge两段有序链表</li>
</ol>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">merge sort:</div><div class="line"><span class="comment">//寻找链表中点,中间偏前</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  ListNode slow = head;</div><div class="line">  ListNode fast = head;</div><div class="line">  <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//merge两段有序链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode left_h,ListNode right_h)</span></span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt_l = left_h;</div><div class="line">  ListNode curt_r = right_h;</div><div class="line">  <span class="keyword">while</span> (curt_l != <span class="keyword">null</span> &amp;&amp; curt_r != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(curt_l.val &lt; curt_r.val)&#123;</div><div class="line">      prev.next = curt_l;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_l = curt_l.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev.next = curt_r;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_r = curt_r.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_l == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_r;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_r == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_l;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归调用merge sort</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//寻找链表中点mid</span></div><div class="line">  ListNode mid = findMid(head);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点.next之后的链表排序</span></div><div class="line">  ListNode right = sortList(mid.next);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点之前包括中点的链表排序</span></div><div class="line">  mid.next = <span class="keyword">null</span>;</div><div class="line">  ListNode left = sortList(head);</div><div class="line"></div><div class="line">  <span class="comment">//merge两段有序链表</span></div><div class="line">  ListNode res = merge(left,right);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="external">Reorder List</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,</p>
<p>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,</p>
<p>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p>
</blockquote>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>题目需要从后向前访问链表，但是链表是单向的，所以需要reverse反转操作，再和原链表merge。</p>
<p><strong>具体步骤：</strong></p>
<ol>
<li>找到链表中点，mid</li>
<li>将mid之后的链表反转</li>
<li>将mid之前的链表和mid之后反转的链表做merge操作</li>
</ol>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//找到中间位置的元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    ListNode slow = head;</div><div class="line">    ListNode fast = head;</div><div class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//链表反转</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode prev = <span class="keyword">null</span>;</div><div class="line">    ListNode curt = head;</div><div class="line">    <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">        ListNode temp = curt.next;</div><div class="line">        curt.next = prev;</div><div class="line">        prev = curt;</div><div class="line">        curt = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prev;</div><div class="line">&#125;</div><div class="line"><span class="comment">//交替merge</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">    ListNode prev = left;</div><div class="line">    ListNode curt1 = left.next;</div><div class="line">    ListNode curt2 = right;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">            curt2 = curt2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">            curt1 = curt1.next;</div><div class="line">        &#125;</div><div class="line">        prev = prev.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">        prev.next = curt2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = curt1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="comment">//边界条件</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//找到mid</span></div><div class="line">    ListNode mid = findMid(head);</div><div class="line"></div><div class="line">    <span class="comment">//将mid之后的部分反转</span></div><div class="line">    ListNode right = reverse(mid.next);</div><div class="line">    mid.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//前半部分和反转后的后半部分merge</span></div><div class="line">    merge(head,right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Fast-slow-pointer"><a href="#Fast-slow-pointer" class="headerlink" title="Fast-slow pointer"></a>Fast-slow pointer</h2><h3 id="1-Middle-of-Linked-List"><a href="#1-Middle-of-Linked-List" class="headerlink" title="1. Middle of Linked List"></a>1. Middle of Linked List</h3><p>寻找指针链表中点，快慢指针，快指针每次走两步，慢指针每次走一步，快指针走到链表结尾时，慢指针在中间</p>
<h3 id="2-Remove-Nth-Node-From-End-of-List"><a href="#2-Remove-Nth-Node-From-End-of-List" class="headerlink" title="2 .Remove Nth Node From End of List"></a>2 .<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">Remove Nth Node From End of List</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line">&gt;</div><div class="line">&gt;    After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p>
</blockquote>
<p>删除掉从末尾开始第n个节点</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>两个指针，fast先走n+！步slow再出发，当fast==null时，slow指向倒数第n+1个节点，删掉slow后面的节点：slow.next = slow.next.next</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    dummy.next = head;</div><div class="line">    ListNode slow = dummy;</div><div class="line">    ListNode fast = dummy;</div><div class="line">    <span class="comment">//fast先走n+1步</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</div><div class="line">        fast = fast.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast、slow同时向后遍历</span></div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</div><div class="line">        fast =fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    slow.next = slow.next.next；</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Linked-List-Cycle"><a href="#3-Linked-List-Cycle" class="headerlink" title="3. Linked List Cycle"></a>3. <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>给定一个链表，判断是否有圈</p>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>判断node是否有被重复访问</p>
<p>从head出发，把所有访问过的点放到一个hash表里，空间复杂度O(n)</p>
<p>方法二：</p>
<p>一个快指针一个慢指针，如果路径上有环，快慢指针一定会相遇</p>
<p>初始化：slow = head;fast = head.next</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ListNode fast = head.next;</div><div class="line">    ListNode slow = head;</div><div class="line">    <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">        <span class="comment">//fast走到null</span></div><div class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow =slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast和slow相遇了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-Linked-List-Cycle-II"><a href="#4-Linked-List-Cycle-II" class="headerlink" title="4. Linked List Cycle II"></a>4. <a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">Linked List Cycle II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p><strong>Note:</strong> Do not modify the linked list.</p>
<p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>是否有环，如果有，找到环的入口</p>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>slow从快慢指针相遇的地方出发，fast指针从初始地方出发，两个指针每次走一步，直到相遇，就是环的入口</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  ListNode fast = head.next;</div><div class="line">  ListNode slow = head;</div><div class="line">  <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">    <span class="comment">//fast走到null</span></div><div class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    fast = fast.next.next;</div><div class="line">    slow = slow.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//fast和slow相遇了</span></div><div class="line">  slow = head;</div><div class="line">  fast = fast.next;</div><div class="line">  <span class="keyword">while</span>(slow != fast)&#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-Rotate-List"><a href="#5-Rotate-List" class="headerlink" title="5. Rotate List"></a>5. <a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="external">Rotate List</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</div><div class="line">&gt; return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>将链表向后移k次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Given <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL and k = <span class="number">2</span>,</div><div class="line">            ↑  ↑  ↑</div><div class="line">node.next=head ↑  ↑</div><div class="line">      dummy.next tail.next=head</div></pre></td></tr></table></figure>
<p>求解步骤：</p>
<ol>
<li>求链表长度len，如果k&gt;len,k = k%len;</li>
<li>找到从后往前数第k个元素，也就是从前往后数第len-k个元素node，和末尾元素tail</li>
<li>tail.next = dummy.next;dummy.next = node.next;node.next = null</li>
</ol>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">           <span class="keyword">return</span> head;</div><div class="line">       &#125;</div><div class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">       dummy.next = head;</div><div class="line">       ListNode tail = dummy;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>)&#123;</div><div class="line">           tail = tail.next;</div><div class="line">           len++;</div><div class="line">       &#125;</div><div class="line">       k = k % len;</div><div class="line">       ListNode node = dummy;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt;= len - k)&#123;</div><div class="line">           node = node.next;</div><div class="line">           i++;</div><div class="line">       &#125;</div><div class="line">       tail.next = dummy.next;</div><div class="line">       dummy.next = node.next;</div><div class="line">       node.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">Merge k Sorted Lists</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>
<p>merge k 个有序链表</p>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>一共三种方法，都需要掌握：</p>
<p>方法一：heap</p>
<p>用PriorityQueue实现</p>
<p>第一个参数 - 第二个参数：升序，最小堆</p>
<p>第二个参数 - 第一个参数：降序，最大堆</p>
<p>初始化：将链表头放进去</p>
<p>每次弹出最小的元素，放到结果链表后面，然后将其next入堆，重复上述</p>
<p>N：所有数的个数</p>
<p>K：链表个数</p>
<p>时间复杂度：<script type="math/tex">O(NlogK)</script> ，heap中最多有k各元素，插入操作时间复杂度是<script type="math/tex">O(logk)</script></p>
<p>空间复杂度：<script type="math/tex">O(K)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//heap</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> k = lists.length;</div><div class="line">        PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</div><div class="line">           <span class="comment">// @Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</div><div class="line">            ListNode head = lists[i];</div><div class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(head);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</div><div class="line">            ListNode curt = minHeap.poll();</div><div class="line">            prev.next = curt;</div><div class="line">            <span class="keyword">if</span>(curt.next != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(curt.next);</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：分治法</p>
<p>merge k 个链表</p>
<ul>
<li>拆分成merge前k/2个链表得到list1和merge后k/2个链表得到list2</li>
<li>合并list1和 list2，得到结果</li>
</ul>
<p>递归调用求解上述子问题</p>
<p>时间复杂度：<script type="math/tex">O(NlogK)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     result</div><div class="line">     ↗    ↖</div><div class="line">   ↗      ↗ ↖</div><div class="line">↗  ↖    ↗   ↗  ↖</div><div class="line"><span class="number">1</span>	<span class="number">2</span> |	<span class="number">3</span> |	<span class="number">4</span>	<span class="number">5</span></div><div class="line"> </div><div class="line"></div><div class="line">    <span class="comment">//分治</span></div><div class="line">    <span class="comment">//merge两个List</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergeTwoList</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode prev1 = left;</div><div class="line">        ListNode prev2 = right;</div><div class="line">        <span class="keyword">while</span>(prev1 != <span class="keyword">null</span> &amp;&amp; prev2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(prev1.val &lt; prev2.val)&#123;</div><div class="line">                prev.next = prev1;</div><div class="line">                prev1 = prev1.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev.next = prev2;</div><div class="line">                prev2 = prev2.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev2 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//分治法mergek个数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">divideMergeKList</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(start == end)&#123;</div><div class="line">            <span class="keyword">return</span> lists[start];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分成两部分</span></div><div class="line">        ListNode left = divideMergeKList(lists,start,start+(end-start)/<span class="number">2</span>);</div><div class="line">        ListNode right = divideMergeKList(lists,start+(end-start)/<span class="number">2</span>+<span class="number">1</span>,end);</div><div class="line">        <span class="comment">//合并两部分结果返回</span></div><div class="line">        <span class="keyword">return</span> MergeTwoList(left,right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">DividemergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> len = lists.length;</div><div class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> divideMergeKList(lists,<span class="number">0</span>,len-<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法三：两两合并</p>
<p>1、2合并，3、4合并，….n</p>
<p>向上递归合并</p>
<p>时间复杂度：<script type="math/tex">O(NlogK)</script></p>
<p>如果是1、2合并，然后忽然3合并，…n</p>
<p>时间复杂度O(NK)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//两两合并</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsOneByOne</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(lists.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  List&lt;ListNode&gt; newlists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length;i++) &#123;</div><div class="line">    newlists.add(lists[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (newlists.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">    List&lt;ListNode&gt; listTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+<span class="number">1</span> &lt; newlists.size();i+=<span class="number">2</span>)&#123;</div><div class="line">      listTemp.add(MergeTwoList(newlists.get(i),newlists.get(i+<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newlists.size() % <span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">      listTemp.add(newlists.get(newlists.size()-<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    newlists = listTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newlists.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">Copy List with Random Pointer</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
</blockquote>
<p>给定一个链表，每个节点除包含一个next指针以外，还有一个指向任意节点的random pointer，clone链表</p>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>hash_map</p>
<p>先按next指针复制链表，把原链表老节点和新链表新节点的映射关系存入hash_map，再遍历一遍原链表，按照hash_map中的对应关系，把random pointer在对应的新节点中标出。</p>
<p>空间复杂度<script type="math/tex">O(n)</script></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">       RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">       RandomListNode prevNew = dummy;</div><div class="line">       RandomListNode prev = head;</div><div class="line">       HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">       <span class="comment">//将链表和next指针复制，对应点存入hashmap</span></div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           RandomListNode temp = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">           prevNew.next = temp;</div><div class="line">           map.put(prev,prevNew.next);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//复制random poiner</span></div><div class="line">       prev = head;</div><div class="line">       prevNew = dummy.next;</div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           prevNew.random = map.get(prev.random);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-57-14.png" alt=""> </p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList2</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">  RandomListNode prev = head;</div><div class="line">  <span class="comment">//将每个元素都复制一份，插在原来元素的后面一位上</span></div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    RandomListNode node = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">    node.next = prev.next;</div><div class="line">    prev.next = node;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//加入random pointer</span></div><div class="line">  prev = head;</div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(prev.random != <span class="keyword">null</span>)&#123;</div><div class="line">      prev.next.random = prev.random.next;</div><div class="line">    &#125;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//删掉原来元素；</span></div><div class="line">  RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">  dummy.next = head;</div><div class="line">  prev = dummy;</div><div class="line">  RandomListNode curt = head;</div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt.next;</div><div class="line">    curt.next = curt.next.next;</div><div class="line">    prev = prev.next;</div><div class="line">    curt = curt.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-55-46.png" alt=""> </p>
<h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">Palindrome Linked List</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
</blockquote>
<p>给定链表，判读是否是回文串，要求时间复杂度<script type="math/tex">O(n)</script>，空间复杂度<script type="math/tex">O(1)</script></p>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>利用stack，先进后出的性质：</p>
<ol>
<li>找到终点，过程中将前半部分链表入栈</li>
<li>继续向后遍历，出栈，对比元素是否一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeStack</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="comment">//空链表和只有一个元素</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//快慢指针寻找中点,前半部分元素入栈</span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        stack.push(head.val);</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            stack.push(mid.val);</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是奇数个元素，将mid弹出，无须比较</span></div><div class="line">        <span class="keyword">if</span>(tail.next == <span class="keyword">null</span>)&#123;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        mid = mid.next;</div><div class="line">        <span class="keyword">while</span>(mid != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = stack.peek();</div><div class="line">            <span class="keyword">if</span>(temp != mid.val)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">            mid = mid.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<ol>
<li>先找到中点</li>
<li>将后半部分的链表反转</li>
<li>对比前后两部分是否一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//快慢指针寻找中点</span></div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//反转后半个链表</span></div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        ListNode curt = mid.next;</div><div class="line">        <span class="keyword">while</span>(curt !=  <span class="keyword">null</span>)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">        &#125;</div><div class="line">        mid.next = prev;</div><div class="line">        <span class="comment">//对比两段元素是否一致</span></div><div class="line">        ListNode first = head;</div><div class="line">        ListNode second = mid.next;</div><div class="line">        <span class="keyword">while</span>(second != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(first.val != second.val)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            first = first.next;</div><div class="line">            second = second.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">160.Intersection of Two Linked Lists</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A:          a1 → a2</div><div class="line">&gt;                    ↘</div><div class="line">&gt;                      c1 → c2 → c3</div><div class="line">&gt;                    ↗            </div><div class="line">&gt; B:     b1 → b2 → b3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>begin to intersect at node c1.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
</blockquote>
<p>找到两个链表相交的地方</p>
<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>是个技巧题，想到了就能做出来，想不到就做不出来</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-22-20-02-17.png" alt=""> </p>
<p>方法：</p>
<p>两个指针分别遍历，一个先A后B，一个先B后A，两指针指向节点相等即为相交处</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode n1 = headA;</div><div class="line">        ListNode n2 = headB;</div><div class="line">        <span class="comment">//记录是否遍历第二个链表</span></div><div class="line">        <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//两个指针都遍历结束了，没有相交节点</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; flag1)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n1遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; !flag1)&#123;</div><div class="line">                 n1 = headB;</div><div class="line">                 flag1 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n2遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n2 == <span class="keyword">null</span> &amp;&amp; !flag2)&#123;</div><div class="line">                n2 = headA;</div><div class="line">                flag2 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (n1 == n2)&#123;</div><div class="line">                <span class="keyword">return</span> n1;</div><div class="line">            &#125;</div><div class="line">            n1 = n1.next;</div><div class="line">            n2 = n2.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> idx = Math.abs(nums[i]);</div><div class="line">            <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> idx;</div><div class="line">            &#125;</div><div class="line">            nums[idx] = -nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DeepFM论文笔记]]></title>
      <url>/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>线性模型不好捕捉交叉特征，FM由于模型复杂性，通常只能捕捉到两维特征交互，NN捕获低维特征能力弱。wide&amp;deep模型能够同时获取低维特征，但是需要低纬、高维两部分特征分开输入模型，而且wide部分的特征也是需要专门的特征工程进行的。</p>
<a id="more"></a>
<p>现有模型要么偏重于处理低维度模型，或者高维度模型，或者需要依赖于专门的特征工程。本文我们提出一种end to end的方法可以同时获取高维度和低维度特征，无需额外的特征工程，可以将原有特征直接输入模型，主要贡献如下：</p>
<ol>
<li>整合FM和DNN，提出了DeepFM模型，像FM一样学习低维度交互特征，像DNN一样学习高维度交互特征，DeepFM可以endtoend训练不需要额外的特征工程</li>
<li>DeepFM训练高效，因为deep和wide使用同一输入和embedding向量，而在wide&amp;deep模型里，输入向量维度很大，因为有很多人工构造的成对的交叉特征，大大增加了模型的复杂程度</li>
<li>用benchmark和商用数据集测试后均发现DeepFM效果好于其他CTR预估模型。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】二分法]]></title>
      <url>/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="classical-Binary-Search"><a href="#classical-Binary-Search" class="headerlink" title="classical Binary Search"></a>classical Binary Search</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定一个排序数组和一个元素n，返回元素n的位置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>34</td>
<td>55</td>
<td>89</td>
</tr>
</tbody>
</table>
</div>
<p>查找元素5的位置</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>初始化:</p>
<p>​    start = 0;end = 8;mid = 4</p>
<ol>
<li>nums[mid] = 13;start = 0;end = 4,mid = 2</li>
<li>nums[mid] = 5;find it!</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">数据规模为n:</div><div class="line">T(n) = T(n/<span class="number">2</span>)+O(<span class="number">1</span>)</div><div class="line">其中O(<span class="number">1</span>)为比较的时间复杂度，T(n/<span class="number">2</span>)为比较之后</div><div class="line">时间复杂度是:O(logn)</div></pre></td></tr></table></figure>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>递归：</p>
<ul>
<li>优点：代码简洁</li>
<li>缺点：递归利用栈空间，递归层数过多会导致栈溢出</li>
</ul>
</li>
<li><p>while循环</p>
<ul>
<li>优点：占用空间小</li>
<li>缺点：代码可读性稍差，不够简洁</li>
</ul>
<p>面试的时候用什么？</p>
<p>如果用递归的方式写会好理解很多，就用递归写，不然就不用递归，在工程上，递归很容易导致栈溢出。</p>
</li>
</ol>
<p>这道题用最好用非递归的方式写，因为是很简短的</p>
<h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><ul>
<li>start + 1 &lt; end</li>
<li>mid = start +(end - start)/2;如果用(start + end)/2，如果start和end都很大相加就有可能溢出</li>
<li>A[mid] = &lt; &gt; 三种情况讨论</li>
<li>A[start] A[end]?target</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="comment">//中值</span></div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="comment">//三种情况讨论</span></div><div class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//结果</span></div><div class="line">        <span class="keyword">if</span> (nums[start] == target) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nums[end] == target) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a><a href="https://leetcode.com/problems/search-for-a-range" target="_blank" rel="external">Search for a Range</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>需要分别找到n<strong>第一次出现的位置</strong>和<strong>最后一次出现的位置</strong>，返回即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span>[] result = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="comment">//第一次出现的位置，在前半段，end前移</span></div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = end;</div><div class="line">        &#125;</div><div class="line">        start = <span class="number">0</span>;</div><div class="line">        end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找最后一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="comment">//第一次出现的位置，在后半段，start后移</span></div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            result[<span class="number">1</span>] = end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            result[<span class="number">1</span>] = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a><a href="https://leetcode.com/problems/search-insert-position" target="_blank" rel="external">Search Insert Position</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 5</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 2</div><div class="line">&gt; Output: 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 7</div><div class="line">&gt; Output: 4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 0</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>二分法的问题一般都是找满足条件的firstposition和lastposition.</p>
<p>这道题是需要找到firstposition &gt;= targrt，第一个&gt;=target的位置。</p>
<p>while结束后，需要找firstposition的话先判断start，找lastposition的话先判断end。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="comment">//找到了</span></div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没找到target,在start和end中找比target大的</span></div><div class="line">        <span class="comment">//start&gt;=tartget</span></div><div class="line">        <span class="keyword">if</span>(nums[start] &gt;= target)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//end&gt;=tartget</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[end] &gt;= target)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums中所有元素都比target小</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> end+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a><a href="https://leetcode.com/problems/search-a-2d-matrix" target="_blank" rel="external">Search a 2D Matrix</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,   3,  5,  7],</div><div class="line">&gt;   [10, 11, 16, 20],</div><div class="line">&gt;   [23, 30, 34, 50]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <strong>target</strong> = <code>3</code>, return <code>true</code>.</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两种做法：</p>
<ol>
<li><p>先按每行的首个数字二分确定target所在的行，再在这行里二分。</p>
</li>
<li><p>看成一维数组，二分查找，其中看成一维数组的序号n和二维数组中行号、列号对应关系为：</p>
<p>r = n/columns;</p>
<p>c = n%columns;</p>
</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchA2DMatrix</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">//空矩阵判断</span></div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = rows*cols -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span> &lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> r = mid/cols;</div><div class="line">            <span class="keyword">int</span> c = mid%cols;</div><div class="line">            <span class="keyword">if</span> (matrix[r][c] == target)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matrix[start/cols][start%cols]==target)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matrix[end/cols][end%cols]==target)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-a-2D-Matrix-II"><a href="#Search-a-2D-Matrix-II" class="headerlink" title="Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii" target="_blank" rel="external">Search a 2D Matrix II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,   4,  7, 11, 15],</div><div class="line">&gt;   [2,   5,  8, 12, 19],</div><div class="line">&gt;   [3,   6,  9, 16, 22],</div><div class="line">&gt;   [10, 13, 14, 17, 24],</div><div class="line">&gt;   [18, 21, 23, 26, 30]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <strong>target</strong> = <code>5</code>, return <code>true</code>.</p>
<p>Given <strong>target</strong> = <code>20</code>, return <code>false</code>.</p>
</blockquote>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ul>
<li>方法一：</li>
</ul>
<p>从对角线开始二分找， 找到第一个&gt;=target的位置，将大矩形分割成4个小矩形，分两种情况讨论：</p>
<ol>
<li>元素 = target，返回true</li>
<li>元素 &gt; target，左上角的矩阵中元素 &lt; target，右下角矩阵中的元素都 &gt; target，都不可能有符合条件的值了，所以只需继续在左下角和右上角的矩阵中继续寻找。</li>
</ol>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-08-13-20-33.png" alt=""> </p>
<p>​    时间复杂度分析：</p>
<p><script type="math/tex">T(n) = 2T(n/4)+O(log\sqrt{n})</script>，其中<script type="math/tex">\sqrt{n}</script>为对角线元素个数。</p>
<ul>
<li><p>方法二：</p>
<p>矩阵特点：每一行和每一列递增</p>
<p>从左下角往右上角找，有如下三种情况：</p>
</li>
</ul>
<ol>
<li>元素 = target，返回true</li>
<li>元素 &lt; target，下一步向右走，因为右边的元素都大于当前元素，上方元素小于当前元素</li>
<li>元素 &gt; target，下一步向上走，因为右边的元素都大于当前元素，上方元素小于当前元素</li>
</ol>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-08-09-51-55.png" alt=""> </p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> r = rows-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(r &gt;=<span class="number">0</span> &amp;&amp; c &lt;cols)&#123;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c]==target)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &lt; target)&#123;</div><div class="line">                c++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &gt; target)&#123;</div><div class="line">                r--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div></pre></td></tr></table></figure>
<h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a><a href="https://leetcode.com/problems/first-bad-version" target="_blank" rel="external">First Bad Version</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>有1到n个版本，找到第一个错误版本的位置。利用从第一个错误的开始之后后面的都是错的，用二分查找到第一个错误版本。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = n;</div><div class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">        <span class="keyword">int</span> mid = start+(end=start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(isBadVersion(mid))&#123;</div><div class="line">            end = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isBadVersion(start))&#123;</div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isBadVersion(end))&#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Peak-Element"><a href="#Find-Peak-Element" class="headerlink" title="Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p>
<p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>
</blockquote>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>给定一个数组，返回peak的元素（左边右边都比自己小），如果有多个返回任意一个即可，要求时间复杂度为O(logn)</p>
<p>遇到O(logn)要考虑到二分法：</p>
<p>二分法选取mid元素，其跟左右元素的关系有如下四中情况：</p>
<ol>
<li>两边元素都比mid小，mid就是peak,，返回</li>
<li>两边元素都比mid大，左右都有可能有peak，任选一边二分</li>
<li>左边小又边大，右边一定有peak，继续对右边二分</li>
<li>左边大右边小，左边一定有peak，继续对左边二分</li>
</ol>
<p>需要注意的地方：</p>
<p>因为要将元素跟其左边和右边的元素比较，所以为了<strong>避免越界，初始需要将start设为1，end设为length-1</strong>；还需要把两个边界值设为负无穷，确保边界值也可以被选上。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length+<span class="number">2</span>];</div><div class="line">    nums2[<span class="number">0</span>] = -Long.MAX_VALUE;</div><div class="line">    nums2[nums.length+<span class="number">1</span>] = -Long.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        nums2[i+<span class="number">1</span>] = nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = nums2.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">        <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>((nums2[mid] &gt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &gt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            <span class="keyword">return</span> mid-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((nums2[mid] &lt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &lt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nums2[mid] &gt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &lt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            end = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums2[start] &lt; nums2[end])&#123;</div><div class="line">        <span class="keyword">return</span>  end-<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> start-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="external">Find Minimum in Rotated Sorted Array</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">递增数组：</div><div class="line">              ↗</div><div class="line">            ↗</div><div class="line">          ↗</div><div class="line">        ↗</div><div class="line">      ↗</div><div class="line">    ↗</div><div class="line">  ↗</div><div class="line">↗</div><div class="line">旋转数组：</div><div class="line">旋转数组，分成两段上升数组：</div><div class="line">              ↗|</div><div class="line">            ↗  |</div><div class="line">          ↗    |</div><div class="line">        ↗      |</div><div class="line">      ↗        |</div><div class="line">---------------|------------------</div><div class="line">               |    ↗</div><div class="line">               |  ↗</div><div class="line">               |↗</div><div class="line">      ↑     ↑        ↑</div><div class="line">    start  mid      end</div><div class="line">用二分法，判断mid与end的大小，确定mid位于两段上升数组的哪一段：</div><div class="line"><span class="number">1</span>. nums[mid] &lt; nums[end]:</div><div class="line">	mid在后段上升数组中，end = mid</div><div class="line"><span class="number">2</span>. nums[mid] &gt; nums[end]:</div><div class="line">	mid在前段上升数组中，start = mid</div></pre></td></tr></table></figure>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">    <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</div><div class="line">      end = mid;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</div><div class="line">      start = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(nums[start] &gt; nums[end])&#123;</div><div class="line">    <span class="keyword">return</span> nums[end];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> nums[start];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii" target="_blank" rel="external">Find Minimum in Rotated Sorted Array II</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<blockquote>
<p><em>Follow up</em> for “Find Minimum in Rotated Sorted Array”:<br>What if <em>duplicates</em> are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
</blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
</blockquote>
<p>延续上一题，有重复数字的旋转数组，找到最小的值。</p>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>如果存在重复元素，无法使用二分查找使得时间复杂度为O(logn)，最坏时间复杂度只能是o(n)。</p>
<p>证明方法：<strong>黑盒测试</strong></p>
<p>假设给定的数组中有一个1和n-1个2，此时mid=2，无法判断1在哪边。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] &lt; min)&#123;</div><div class="line">      min = nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array" target="_blank" rel="external">Search in Rotated Sorted Array</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>给定一个旋转递增数组和一个数，返回数在数组中的位置。</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>二分法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">递增数组：</div><div class="line">              ↗</div><div class="line">            ↗</div><div class="line">          ↗</div><div class="line">        ↗</div><div class="line">      ↗</div><div class="line">    ↗</div><div class="line">  ↗</div><div class="line">↗</div><div class="line"></div><div class="line">旋转数组，分成两段上升数组：</div><div class="line">              ↗|</div><div class="line">            ↗  |</div><div class="line">          ↗    |</div><div class="line">        ↗      |</div><div class="line">      ↗        |</div><div class="line">---------------|------------------</div><div class="line">               |    ↗</div><div class="line">               |  ↗</div><div class="line">               |↗</div><div class="line">      ↑     ↑        ↑</div><div class="line">    start  mid      end</div><div class="line">二分法，mid和end比较：</div><div class="line"><span class="number">1</span>. nums[mid] &gt; nums[end]：</div><div class="line">	mid在第一段上升区间，跟target比较：</div><div class="line">		<span class="number">1</span>. 如果target在start和mid之间，end= mid</div><div class="line">		<span class="number">2</span>. 否则，start = mid,继续做二分查找，仍然是一个search in rotated sorted array问题</div><div class="line"><span class="number">2</span>. nums[mid] &lt; nums[end]：</div><div class="line">	mid在第二段上升区间，跟target比较：</div><div class="line">		<span class="number">1</span>. 如果target在mid和end之间，end= mid</div><div class="line">		<span class="number">2</span>. 否则，start = mid,继续做二分查找，仍然是一个search in rotated sorted array问题</div></pre></td></tr></table></figure>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(target == nums[mid])&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//mid在第一个上升区间</span></div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</div><div class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[start])&#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">///mid在第二个上升区间</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])&#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii" target="_blank" rel="external">Search in Rotated Sorted Array II</a></h3><p>有重复元素，无法二分查找，时间复杂度为O(n)，遍历查找即可。</p>
<h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p> Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p> <strong>Note:</strong><br> You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p>
</blockquote>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>合并连个有序数组，把S2并入S1，假设S1有足够大的空间。</p>
<p>考点：从后往前合并，因为后面的空间是空的，不会覆盖原有元素。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> end1 = m-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end2 = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = m+n-<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (end1 &gt;=<span class="number">0</span> &amp;&amp; end2&gt;=<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(nums1[end1] &lt; nums2[end2])&#123;</div><div class="line">                nums1[end] = nums2[end2];</div><div class="line">                end2--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[end] = nums1[end1];</div><div class="line">                end1--;</div><div class="line">            &#125;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1元素剩下了</span></div><div class="line">        <span class="keyword">if</span> (end1 &gt;= <span class="number">0</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2元素剩下了</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span> (end2 &gt;= <span class="number">0</span>)&#123;</div><div class="line">                nums1[end] = nums2[end2];</div><div class="line">                end--;</div><div class="line">                end2--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>令nums1.length = m;nums2.length = n;总长度m+n。先确定中位数m是多少:</p>
<ol>
<li><p>(m+n)%2 == 0:</p>
<p>m=(m+n)/2,(m+n)/2+1</p>
</li>
<li><p>(m+n)%2 == 1:</p>
<p> m=(m+n)/2</p>
</li>
</ol>
<p>问题转化为找<strong>两个有序数组的第K大</strong>的问题，如果用merge的方法获得merge之后的排序数组需要O(m+n)的时间复杂度，题目要求使用O(log(m+n))的时间复杂度，所以需要使用二分法：</p>
<p>如果A[k/2] &lt;= B[k/2]：A的前k/2个数一定都在A、B合并后的前K个数中，去掉A的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>如果A[k/2] &gt; B[k/2]：B的前k/2个数一定都在A、B合并后的前K个数中，去掉B的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>如果A[k/2]越界，A中剩余元素不足k/2个，则B中前k/2个元素一定在前K个中，去掉B的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>如果B[k/2]越界，B中剩余元素不足k/2个，则A中前k/2个元素一定在前K个中，去掉A的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p>
<p>边界条件判断：</p>
<ol>
<li>nums1中没有元素了,直接返回nums2中的第k个</li>
<li>nums2中没有元素了,直接返回nums1中的第k个</li>
<li>k == 1，递归出口，直接返回min(nums1[start1],nums2[start2])</li>
</ol>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianOfTwoSortedArrays</span> </span>&#123;</div><div class="line">    <span class="comment">//两个sorted array merge 寻找第k大的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> k,<span class="keyword">int</span> start1,<span class="keyword">int</span> start2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> end1 = nums1.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end2 = nums2.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1空了，</span></div><div class="line">        <span class="keyword">if</span>(start1 &gt; end1)&#123;</div><div class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2空了</span></div><div class="line">        <span class="keyword">if</span>(start2 &gt; end2)&#123;</div><div class="line">            <span class="keyword">return</span> nums1[start1 + k -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1的前k/2个元素已经超过nums1中剩余的所有元素个数</span></div><div class="line">        <span class="comment">//那么nums2的前k/2个元素都包含在前k个元素中</span></div><div class="line">        <span class="keyword">if</span>(start1 + k/<span class="number">2</span> - <span class="number">1</span> &gt; end1)&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1,start2+k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2的前k/2个元素已经超过nums2中剩余的所有元素个数</span></div><div class="line">        <span class="comment">//那么nums1的前k/2个元素都包含在前k个元素中</span></div><div class="line">        <span class="keyword">if</span>(start2 + k/<span class="number">2</span> - <span class="number">1</span> &gt; end2)&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1+k/<span class="number">2</span>,start2);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums和nums2的前k/2个元素都没有超过个字的末尾</span></div><div class="line">        <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt;nums2[start2+k/<span class="number">2</span>-<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1+k/<span class="number">2</span>,start2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1,start2+k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len1 = nums1.length;</div><div class="line">        <span class="keyword">int</span> len2 = nums2.length;</div><div class="line">        <span class="keyword">int</span> k = (len1+len2)/<span class="number">2</span>;<span class="comment">//中位数</span></div><div class="line">        <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> k1 = findKth(nums1,nums2,k,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">            <span class="keyword">int</span> k2 = findKth(nums1,nums2,k+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        MedianOfTwoSortedArrays test = <span class="keyword">new</span> MedianOfTwoSortedArrays();</div><div class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">double</span> res = test.findMedianSortedArrays(nums1,nums2);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Wood-Cut"><a href="#Wood-Cut" class="headerlink" title="Wood Cut"></a><a href="http://www.lintcode.com/en/problem/wood-cut/" target="_blank" rel="external">Wood Cut</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given n pieces of wood with length <code>L[i]</code> (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L &amp; k, return the maximum length of the small pieces.</p>
<h5 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h5><p>You couldn’t cut wood into float length.</p>
<p>If you couldn’t get &gt;= <em>k</em> pieces, return <code>0</code>.</p>
<p>Example</p>
<p>For <code>L=[232, 124, 456]</code>, <code>k=7</code>, return <code>114</code>.</p>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>给定一些长度为L[i]的木料，将他们据成k段，返回满足条件的最大长度。</p>
<p>先找到木料中最长的那块，长度为m然后对m进行二分法，判断这些木料是否可以据成长度为mid，个数&gt;=k个木料：</p>
<ol>
<li>如果可以，start = mid，进一步二分看是否可以据成更长的</li>
<li>如果不可以，end = mid，进一步二分据成更短的小段</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param L: Given n pieces of wood with length L[i]</span></div><div class="line"><span class="comment">     * @param k: An integer</span></div><div class="line"><span class="comment">     * @return: The maximum length of the small pieces</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] L,<span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;L.length;i++)&#123;</div><div class="line">            sum += L[i]/len;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">woodCut</span><span class="params">(<span class="keyword">int</span>[] L, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到最长的wood，</span></div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(L[i] &gt; max)&#123;</div><div class="line">                max = L[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//对要切割的wood长度做二分法</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = max;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(count(L,mid) &gt;= k)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count(L,end) &gt;= k)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count(L,start) &gt;= k)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Count-of-Smaller-Numbers-After-Self"><a href="#Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/" target="_blank" rel="external">Count of Smaller Numbers After Self</a></h3><h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title=" Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="external"> Sqrt(x)</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>.</p>
<p><strong>x</strong> is guaranteed to be a non-negative integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 4</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 8</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>输入数字x，返回根号x，只保留整数部分</p>
<p>思路就是找到最后一个number k，满足条件k^2 &lt; x，则k就是结果</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = x;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(mid * mid &lt;= x)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(end*end &lt;= x)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Rotate-Array"><a href="#Rotate-Array" class="headerlink" title="Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="external">Rotate Array</a></h3><blockquote>
<p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p>
<p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p>
</blockquote>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>三步翻转法：</p>
<ol>
<li><p>翻转左半段</p>
<p>4,3,2,1,5,6,7</p>
</li>
<li><p>翻转右半段</p>
<p>4,3,2,1,7,6,5</p>
</li>
<li><p>翻转整体</p>
<p>5,6,7,1,2,3,4</p>
</li>
</ol>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        k = k % nums.length;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - k - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        start = nums.length - k;</div><div class="line">        end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        start = <span class="number">0</span>;</div><div class="line">        end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reverse-Words-in-a-String-II"><a href="#Reverse-Words-in-a-String-II" class="headerlink" title="Reverse Words in a String II"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/description/" target="_blank" rel="external">Reverse Words in a String II</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p>
<p>The input string does not contain leading or trailing spaces and the words are always separated by a single space.</p>
<p>For example,<br>Given s = “<code>the sky is blue</code>“,<br>return “<code>blue is sky the</code>“.</p>
<p>Could you do it <em>in-place</em> without allocating extra space?</p>
</blockquote>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>三步翻转法</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(end &lt; str.length)&#123;</div><div class="line">        <span class="keyword">while</span>(end &lt; str.length &amp;&amp; str[end] != <span class="string">' '</span>)&#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> stop = end-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= stop)&#123;</div><div class="line">            <span class="keyword">char</span> temp = str[start];</div><div class="line">            str[start] = str[stop];</div><div class="line">            str[stop] = temp;</div><div class="line">            start++;</div><div class="line">            stop--;</div><div class="line">        &#125;</div><div class="line">        start = end+<span class="number">1</span>;</div><div class="line">        end = end+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    start = <span class="number">0</span>;</div><div class="line">    end = str.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">        <span class="keyword">char</span> temp = str[start];</div><div class="line">        str[start] = str[end];</div><div class="line">        str[end] = temp;</div><div class="line">        start++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">Find the Duplicate Number</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Note:</strong></p>
<ol>
<li>You <strong>must not</strong> modify the array (assume the array is read only).</li>
<li>You must use only constant, <em>O</em>(1) extra space.</li>
<li>Your runtime complexity should be less than <code>O(n2)</code>.</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ol>
</blockquote>
<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>题目说有个n+1长的数组，里面的元素的范围在1~n，所以必定会有重复的元素，要求我们找出重复的元素。</p>
<ol>
<li><p>baseline：</p>
<p>遍历，时间复杂度<script type="math/tex">O(n^2)</script>，超时</p>
</li>
<li><p>二分法：</p>
<p>start = 1;end = n</p>
<p>mid = (1+n)/2;</p>
<p>遍历数组，记录值&lt;=mid的元素个数sum，分两种情况讨论：</p>
<p>​    a. sum &lt;= mid，在1~mid之间的数组少于mid，说明重复数字在mid+1~len-1里，故令left = mid+1</p>
<p>​    b. sum &gt; mid，在1~mid之间的数组多于mid，说明重复数字在1~mid里，故令right = mid</p>
</li>
</ol>
<p>方法二:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">2</span></div><div class="line">实质：用下标idx的正负表示该数字idx是否出现过，如果出现过idx对应的数字为负数，否则为正数</div><div class="line">从左向右遍历，把遇到的数字在数组中的下标标记为负值，当遇到下标对应的值已经为负数时，返回该下标：</div><div class="line">i = <span class="number">0</span> , val = <span class="number">1</span>,将nums[<span class="number">1</span>]标记为负数</div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	<span class="number">3</span>	<span class="number">2</span></div><div class="line">i = <span class="number">1</span> ，val = abs(-<span class="number">2</span>) = <span class="number">2</span> , 将nums[<span class="number">2</span>]标记为负数</div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	-<span class="number">3</span>	<span class="number">2</span></div><div class="line">i = <span class="number">2</span> ，val = abs(-<span class="number">3</span>) = <span class="number">3</span> , 将nums[<span class="number">3</span>]标记为负数</div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	-<span class="number">3</span>	-<span class="number">2</span></div><div class="line">i = <span class="number">3</span> ，val = abs(-<span class="number">2</span>) = <span class="number">2</span> , 此时nums[<span class="number">2</span>] &lt; <span class="number">0</span>，则返回<span class="number">2</span></div><div class="line">idx: <span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line">val: <span class="number">1</span>	-<span class="number">2</span>	-<span class="number">3</span>	-<span class="number">2</span></div></pre></td></tr></table></figure>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(left &lt;right)&#123;</div><div class="line">    <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录在1~mid之间的数字有多少个</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt;= mid)&#123;</div><div class="line">        sum++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在1~mid之间的数组少于mid，说明重复数字在mid+1~len-1里</span></div><div class="line">    <span class="keyword">if</span>(sum &lt;= mid)&#123;</div><div class="line">      left = mid + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在1~mid之间的数组多于mid，说明重复数字在1~mid里</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      right = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WAND算法]]></title>
      <url>/2017/12/07/WAND%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-24-15.png" alt="所致"> </p>
<a id="more"></a>
<p><strong>sort()</strong>：把terms按照posting单钱所指向的documentID排序，比如：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-30-11.png" alt=""> </p>
<p>图中黄颜色的数字就是posting当前所指的documentID</p>
<p>pTerm：从上到下累加发现大于U的那个term</p>
<p>pivot:pTerm这一行当前所指的documentID</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】二叉树与分治法]]></title>
      <url>/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>数组：内存空间连续，支持下标访问，访问时间复杂度<script type="math/tex">O(1)</script></p>
<p>链表：内存空间不联系，不支持下表访问，访问时间复杂度<script type="math/tex">O(n)</script></p>
<h2 id="树形分析法求解时间复杂度："><a href="#树形分析法求解时间复杂度：" class="headerlink" title="树形分析法求解时间复杂度："></a>树形分析法求解时间复杂度：</h2><script type="math/tex; mode=display">T(n) = T(n/2)+O(1)   ->  O(logn)</script><script type="math/tex; mode=display">T(n) = T(n/2)+O(n) -> O(n)</script><script type="math/tex; mode=display">T(n) = 2T(n/2) + O(1) -> O(n)</script><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(<span class="number">1</span>) -&gt; O(n)</div><div class="line">O(<span class="number">1</span>)：一次拆分所需时间</div><div class="line"> --	 			        n</div><div class="line">  |               ↙             ↘       ················O(<span class="number">1</span>)拆分所需时间</div><div class="line">  |            n/<span class="number">2</span>                n/<span class="number">2</span></div><div class="line">log(n)      ↙       ↘          ↙       ↘	················O(<span class="number">2</span>)</div><div class="line">  |       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span></div><div class="line">  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘	················O(<span class="number">4</span>)</div><div class="line">  |    n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>   n/<span class="number">8</span>  n/<span class="number">8</span>   			</div><div class="line">  |			················				················O(n)</div><div class="line">  | n/n	n/n	n/n		·············	n/n	n/n	n/n</div><div class="line"> --</div><div class="line"> O(<span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+....+n) = O(<span class="number">2</span>n-<span class="number">1</span>) = O(n)</div><div class="line"> 由此如果T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(<span class="number">1</span>)，则时间复杂度为O(n)</div></pre></td></tr></table></figure>
<a id="more"></a>
<script type="math/tex; mode=display">T(n) = 2T(n/2) + O(n) -> O(n*logn)</script><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(n) -&gt; O(n)</div><div class="line">O(n)：一次拆分所需时间</div><div class="line"> --	 			        n</div><div class="line">  |               ↙             ↘       ··············O(n)拆分所需时间</div><div class="line">  |            n/<span class="number">2</span>                n/<span class="number">2</span></div><div class="line">log(n)      ↙       ↘          ↙       ↘	··············O(n/<span class="number">2</span>)*<span class="number">2</span>=O(n)</div><div class="line">  |       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span></div><div class="line">  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘	·············O(n/<span class="number">4</span>)*<span class="number">4</span>=O(n)</div><div class="line">  |    n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>   n/<span class="number">8</span>  n/<span class="number">8</span>   			</div><div class="line">  |			················				·············O(n/n)*n=O(n)</div><div class="line">  | n/n	n/n	n/n		·············	n/n	n/n	n/n</div><div class="line"> --</div><div class="line"> O(n+n+...+n)*logn = O(nlogn)</div><div class="line"> 由此如果T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(n)，则时间复杂度为O(nlogn)</div></pre></td></tr></table></figure>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>树的遍历三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     <span class="number">1</span></div><div class="line">    ↙ ↘</div><div class="line">  <span class="number">2</span>     <span class="number">3</span></div><div class="line"> ↙ ↘</div><div class="line"><span class="number">4</span>   <span class="number">5</span></div><div class="line">- 前序遍历（根左右）: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span></div><div class="line">- 中序遍历（左根右）: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></div><div class="line">- 后序遍历（左右根）: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="1-前序遍历Binary-Tree-Preorder-Traversal"><a href="#1-前序遍历Binary-Tree-Preorder-Traversal" class="headerlink" title="1.前序遍历Binary Tree Preorder Traversal"></a>1.前序遍历<a href="https://leetcode.com/problems/binary-tree-preorder-traversal" target="_blank" rel="external">Binary Tree Preorder Traversal</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[1,2,3]</code>.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>递归法</p>
<p>首先遍历根节点，然后对其左节点做前序遍历，对其右节点做前序遍历。</p>
<p><strong>递归三要素</strong>：</p>
<ul>
<li>定义：要做什么事情，这道题就是先遍历父亲节点，然后左节点、右节点</li>
<li>拆分：差分成同样的问题，但规模变小，本题就是拆成左子树和右子树，对左子树和右字数分别做前序遍历</li>
<li>结束条件：遇到空节点停止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">  traverse(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    result.add(root.val);</div><div class="line">    traverse(root.left,result);</div><div class="line">    traverse(root.right,result);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分治法</p>
<p>分而治之，先分开求结果，再合并</p>
<p>先得到左子树的结果，再得到右子树的结果，然后将左子、右子树、root结果合并得到最终结果。</p>
<p>通常来说，分治法的函数是有返回值的。</p>
<p><strong>分治法三要素：</strong></p>
<ul>
<li>定义：要做什么事情</li>
<li>拆分与合并问题：</li>
<li>结束条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">divide</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="comment">//结束条件</span></div><div class="line">  <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分问题，获取子问题结果</span></div><div class="line">  ArrayList&lt;Integer&gt; leftres = divide(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; righttres = divide(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//合并子问题</span></div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  result.add(root.val);</div><div class="line">  result.addAll(leftres);</div><div class="line">  result.addAll(righttres);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>非递归方法</p>
<p><strong>阅读理解并背诵</strong></p>
<p>利用stack实现树的前序遍历，每次弹出栈顶元素，先后压入其右孩子和左孩子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        List&lt;Integer&gt; preorder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> preorder;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根节点入栈</span></div><div class="line">        stack.push(root);</div><div class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</div><div class="line">            TreeNode node = stack.pop();</div><div class="line">            preorder.add(node.val);</div><div class="line">            <span class="comment">//右孩子入栈</span></div><div class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(node.right);</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//左孩子入栈</span></div><div class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(node.left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> preorder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="中序遍历Binary-Tree-Inorder-Traversal"><a href="#中序遍历Binary-Tree-Inorder-Traversal" class="headerlink" title="中序遍历Binary Tree Inorder Traversal"></a>中序遍历<a href="https://leetcode.com/problems/binary-tree-inorder-traversal" target="_blank" rel="external">Binary Tree Inorder Traversal</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[1,3,2]</code>.</p>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">        <span class="comment">//终止条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分问题</span></div><div class="line">        helper(root.left,result);</div><div class="line">        result.add(root.val);</div><div class="line">        helper(root.right,result);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">        helper(root,result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//终止条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//拆分</span></div><div class="line">        ArrayList&lt;Integer&gt; leftRes = inorderTraversal(root.left);</div><div class="line">        ArrayList&lt;Integer&gt; rightRes = inorderTraversal(root.right);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        result.addAll(leftRes);</div><div class="line">        result.add(root.val);</div><div class="line">        result.addAll(rightRes);</div><div class="line"></div><div class="line">        <span class="comment">//返回结果</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归方法，很重要！！！！！！！！！！！！！！！</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        TreeNode curt = root;</div><div class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.empty()) &#123;</div><div class="line">            <span class="keyword">while</span> (curt != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.add(curt);</div><div class="line">                curt = curt.left;</div><div class="line">            &#125;</div><div class="line">            curt = stack.pop();</div><div class="line">            result.add(curt.val);</div><div class="line">            curt = curt.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="后序遍历Binary-Tree-Postorder-Traversal"><a href="#后序遍历Binary-Tree-Postorder-Traversal" class="headerlink" title="后序遍历Binary Tree Postorder Traversal"></a>后序遍历<a href="https://leetcode.com/problems/binary-tree-postorder-traversal" target="_blank" rel="external">Binary Tree Postorder Traversal</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return <code>[3,2,1]</code>.</p>
</blockquote>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="comment">//终止条件</span></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分问题</span></div><div class="line">  helper(root.left,result);</div><div class="line">  helper(root.right,result);</div><div class="line">  result.add(root.val);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">  helper(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//分治法</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//拆分</span></div><div class="line">  ArrayList&lt;Integer&gt; leftRes = postorderTraversal(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; rightRes = postorderTraversal(root.right);</div><div class="line">  <span class="comment">//合并</span></div><div class="line">  result.addAll(leftRes);</div><div class="line">  result.addAll(rightRes);</div><div class="line">  result.add(root.val);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分治法相比于遍历法的优点："><a href="#分治法相比于遍历法的优点：" class="headerlink" title="分治法相比于遍历法的优点："></a>分治法相比于遍历法的优点：</h3><ol>
<li>无需全局变量存储结果，无需helper函数</li>
<li>可并行</li>
</ol>
<h3 id="二叉树三种遍历的非递归实现"><a href="#二叉树三种遍历的非递归实现" class="headerlink" title="二叉树三种遍历的非递归实现"></a>二叉树三种遍历的非递归实现</h3><h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>三种遍历的非递归解决思路核心思想是一致的：</p>
<ol>
<li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li>
<li>使用同样的顺序将“左”节点入栈</li>
<li>在合适的时机转向（转向后，“右”节点即成为“左”节点）、访问节点、或出栈</li>
</ol>
<p>比如{1,2,3}，当cur位于节点1时，1、2属于“左”节点，3属于“右”节点。DFS的非递归实现本质上是在协调入栈、出栈和访问，三种操作的顺序。上述统一使得我们不再需要关注入栈顺序，仅需要关注出栈和访问（第3点），随着更详细的分析，你将更加体会到这种简化带来的好处。</p>
<p>将对节点的访问定义为<code>results.add(node.val);</code>，分析如下：</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历的顺序是：根-&gt;左-&gt;右，按照上面提到的思路，可以简化为左-&gt;右</p>
<p>从root节点开始访问，依次向下访问左节点(cur指向当前节点)，此时立即将这些“左”节点输出到结果中，同时把他们压入栈，便于后续访问其右节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">    results.add(cur.val);</div><div class="line">    stack.push(cur);</div><div class="line">    cur = cur.left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面循环结束意味着我们已经访问过所有的“左”节点，现在需要将这些节点出栈，转到其“右”节点，此时右节点也变成了“左”节点，需要对其进行上面的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">    cur = stack.pop();</div><div class="line">    <span class="comment">// 转向</span></div><div class="line">    cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">nonRecursion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈和cur都为空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先序与中序的区别只在于对“左”节点的处理上，前序遍历是先访问实际根，再访问左节点，而中序是先访问实际左节点，再访问实际根节点，所以需要将中序改为出栈时才访问这个节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">  stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">  cur = cur.left;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">  cur = stack.pop();</div><div class="line">  results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">  cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">nonRecursion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈和cur都为空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">              	results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历的实际访问顺序是：左右根</p>
<p>入栈顺序不变，需考虑转向和出栈时机。</p>
<p>对于实际的根，需要保证先后访问了左子树、右子树之后，才能访问根。实际的右节点、左节点、根节点都会成为“左”节点入栈，所以我们只需要<strong>在出栈之前，将该节点视作实际的根节点，并检查其右子树是否已被访问</strong>即可。如果不存在右子树，或右子树已被访问了，那么可以访问根节点，出栈，并不需要转向；如果还没有访问，就转向，使其“右”节点成为“左”节点，等着它先被访问之后，再来访问根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNodeWithFlag</span> </span>&#123;</div><div class="line">        TreeNode node;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        TreeNodeWithFlag(TreeNode node,<span class="keyword">boolean</span> flag) &#123;</div><div class="line">            <span class="keyword">this</span>.flag = flag;</div><div class="line">            <span class="keyword">this</span>.node = node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNodeWithFlag&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈空或cur空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(<span class="keyword">new</span> TreeNodeWithFlag(cur,<span class="keyword">false</span>));<span class="comment">//左节点入栈，标记为右子树未访问</span></div><div class="line">                cur = cur.left;<span class="comment">//继续访问左子树</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                <span class="keyword">if</span>(stack.peek().flag)&#123;<span class="comment">//右子树已经处理过</span></div><div class="line">                    results.add(stack.peek().node.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                    stack.pop();<span class="comment">//弹出</span></div><div class="line">                    cur = <span class="keyword">null</span>;<span class="comment">//左右根节点都已处理过，不转向，继续弹栈</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//右子树没有处理过</span></div><div class="line">                    stack.peek().flag = <span class="keyword">true</span>;<span class="comment">//标记为已处理</span></div><div class="line">                    cur = stack.peek().node.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h2><h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="external">Maximum Depth of Binary Tree</a></h3><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p>给定一个数，求出树的最大深度</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="comment">//终止条件</span></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分成求解左子树和右子树的最大深度</span></div><div class="line">  <span class="keyword">int</span> leftDepth = maxDepth(root.left);</div><div class="line">  <span class="keyword">int</span> rihtDepth = maxDepth(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//合并，根节点的最大深度=max(左子树最大深度，右子树最大深度)+1</span></div><div class="line">  <span class="keyword">int</span> res = Math.max(leftDepth,rihtDepth)+<span class="number">1</span>;</div><div class="line">  <span class="comment">//返回结果</span></div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree" target="_blank" rel="external">Balanced Binary Tree</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
</blockquote>
<p>判断二叉树是否是平衡二叉树：</p>
<ol>
<li>左右子树平衡</li>
<li>左子树和右子树的高度差不超过1</li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">考虑某一个时间成立或者不成立需要考虑多个因素的时候，需要定义一个<span class="class"><span class="keyword">class</span> <span class="title">ResultType</span>把这两个值包进去，存储中间结果。</span></div><div class="line"><span class="class">	//定义<span class="title">resultType</span></span></div><div class="line"><span class="class">	<span class="title">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isBalanced;<span class="comment">//是否平衡</span></div><div class="line">        <span class="keyword">int</span> maxDepth;<span class="comment">//最大深度</span></div><div class="line">        ResultType(<span class="keyword">boolean</span> isBalanced,<span class="keyword">int</span> maxDepth)&#123;</div><div class="line">            <span class="keyword">this</span>.isBalanced = isBalanced;</div><div class="line">            <span class="keyword">this</span>.maxDepth = maxDepth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="comment">//结束条件</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分成分别计算左子树的右子树信息</span></div><div class="line">        ResultType leftRes = helper(root.left);</div><div class="line">        ResultType rightRes = helper(root.right);</div><div class="line">        </div><div class="line">        <span class="comment">//如果左右有一个不是平衡树</span></div><div class="line">        <span class="keyword">if</span>(!leftRes.isBalanced || !rightRes.isBalanced)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//都是平衡树，但深度差&gt;1</span></div><div class="line">        <span class="keyword">if</span>(Math.abs(leftRes.maxDepth-rightRes.maxDepth) &gt;<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//都是平衡树，深度差&lt;=1，node节点最大深度=max(左、右子树深度)+1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.max(rightRes.maxDepth,leftRes.maxDepth)+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root).isBalanced;<span class="comment">//返回根节点是否是平衡。</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="external">Lowest Common Ancestor of a Binary Tree</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         _______3______</div><div class="line">&gt;        /              \</div><div class="line">&gt;     ___5__          ___1__</div><div class="line">&gt;    /      \        /      \</div><div class="line">&gt;    6      _2       0       8</div><div class="line">&gt;          /  \</div><div class="line">&gt;          7   4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>For example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p>
</blockquote>
<p>给一棵二叉树和二叉树上的两个点，返回其最近公共祖先</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">如果二叉树中存储了父亲节点，则可以从两个点出发往上寻找至root:</div><div class="line">比如<span class="number">5</span>和<span class="number">1</span>：</div><div class="line"><span class="number">5</span>:[<span class="number">5</span>,<span class="number">3</span>]</div><div class="line"><span class="number">1</span>:[<span class="number">1</span>,<span class="number">3</span>]</div><div class="line">得到路径之后从后向前遍历，<span class="number">3</span>,<span class="number">3</span>一样，<span class="number">5</span>,<span class="number">1</span>不一样了，所以最近公共祖先是<span class="number">3</span></div><div class="line"></div><div class="line">再比如<span class="number">5</span>和<span class="number">4</span>：</div><div class="line"><span class="number">5</span>:[<span class="number">5</span>,<span class="number">3</span>]</div><div class="line"><span class="number">4</span>:[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</div><div class="line">从后向前遍历，发现<span class="number">3</span>,<span class="number">5</span>之后不一样了，所以公共祖先是<span class="number">5</span></div><div class="line"></div><div class="line">如果没有存储父亲节的信息，给定root节点和连个点n1,n2:</div><div class="line">        _______3______</div><div class="line">       /              \</div><div class="line">    ___5__          ___1__</div><div class="line">   /      \        /      \</div><div class="line">   <span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></div><div class="line">         /  \</div><div class="line">         <span class="number">7</span>   <span class="number">4</span></div><div class="line">n1和n2的分布情况有以下几种：</div><div class="line"><span class="number">1</span>.其中有一个是root -&gt; 返回root</div><div class="line"><span class="number">2</span>.全在左子树 -&gt; 返回左子树root</div><div class="line"><span class="number">3</span>.全在右子树 -&gt; 返回右子树root</div><div class="line"><span class="number">4</span>.一个在左子树、一个在右子树 -&gt; 返回root</div><div class="line"><span class="number">5</span>.这两个点不在这棵树里 -&gt; 返回<span class="keyword">null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;<span class="comment">//其中有一个是根节点</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分,分别在左、右子树中寻找LCA</span></div><div class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;<span class="comment">//一个在左子树，一个在右子树，则LCA为root</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;<span class="comment">//两个节点都在左子树</span></div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;<span class="comment">//两个节点都在右子树</span></div><div class="line">            <span class="keyword">return</span> right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="comment">//左右子树的LCA都是null,都没有这俩节点</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Binary-Tree-Maximum-Path-Sum-II"><a href="#Binary-Tree-Maximum-Path-Sum-II" class="headerlink" title="Binary Tree Maximum Path Sum II"></a>Binary Tree Maximum Path Sum II</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，从根节点root出发，求最大路径和，可以在任一点结束</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">如果是求从root到leaf的最大路径，就用分治法，从上到下，每个节点的最大路径是其左子树和右子树的最大路径的最大值:</div><div class="line">root.val + Math.max(maxleft,maxright)</div><div class="line">如果二叉树上的节点值有负数，那么最大路径就有可能不到leaf就结束了，所以在计算节点最大路径时，如果其左右子树最大路径的最大值为负数，则该节点到leaf的最大路径长度应该为<span class="number">0</span>：</div><div class="line">root.val + Math.max(<span class="number">0</span>,Math.max(maxleft,maxright))</div></pre></td></tr></table></figure>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum2</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> maxleft = maxPathSum2(root.left);</div><div class="line">  <span class="keyword">int</span> maxright = maxPathSum2(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//root-&gt;leaf</span></div><div class="line">  <span class="comment">//return root.val + Math.max(maxleft,maxright);</span></div><div class="line"></div><div class="line">  <span class="comment">//root-&gt;any</span></div><div class="line">  <span class="keyword">return</span> root.val + Math.max(<span class="number">0</span>,Math.max(maxleft,maxright));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的题目复杂度基本都是O(n)，分析：</p>
<p>一共有多少个点<em>每个点上的时间复杂度 = n </em> O(1) = O(n)</p>
<h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="external">Binary Tree Maximum Path Sum</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return <code>6</code>.</p>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">跟LCA问题思考方式类似，考虑某一点root的最大路径的位置可能有如下三种情况：</div><div class="line"><span class="number">1</span>.都在左子树中(root.left:any-&gt;any)</div><div class="line"><span class="number">2</span>.都在右子树中(root.right:any-&gt;any)</div><div class="line"><span class="number">3</span>.跨过root节点左右子树中都有(root:any-&gt;any)</div><div class="line">对三种情况取个最大，就是该root节点的最大路径长度</div><div class="line"></div><div class="line">对于第三种情况，可以分为三个子问题：</div><div class="line">A:从左子节点出发的最大路径长度（root.left-&gt;any）</div><div class="line">root</div><div class="line">B:从右子节点出发的最大路径长度（root.right-&gt;any）</div><div class="line">对三个子问题求和，就是跨过此root节点的最大路径长度</div><div class="line"></div><div class="line"></div><div class="line">这里需要同时计算any-&gt;any和root-&gt;any，所以需要定义一个ResultType存储每个节点的any-&gt;any和root-&gt;any</div></pre></td></tr></table></figure>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> root2any;</div><div class="line">    <span class="keyword">int</span> any2any;</div><div class="line">    ResultType(<span class="keyword">int</span> root2any,<span class="keyword">int</span> any2any)&#123;</div><div class="line">        <span class="keyword">this</span>.any2any = any2any;</div><div class="line">        <span class="keyword">this</span>.root2any = root2any;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    <span class="comment">//题目要求至少要包含一个node，所以此时不满足条件，应返回负无穷</span></div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(Integer.MIN_VALUE,Integer.MIN_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//divide</span></div><div class="line">    ResultType leftRes = helper(root.left);</div><div class="line">    ResultType rightRes = helper(root.right);</div><div class="line"></div><div class="line">    <span class="comment">//conquer</span></div><div class="line">    <span class="comment">//root到左边或右边</span></div><div class="line">    <span class="keyword">int</span> root2any = Math.max(<span class="number">0</span>,Math.max(leftRes.root2any,rightRes.root2any)) + root.val;</div><div class="line"></div><div class="line">    <span class="comment">//包含完全在左边、完全在右边和跨过root三种情况</span></div><div class="line">    <span class="comment">//完全在左边和完全在右边的情况</span></div><div class="line">    <span class="keyword">int</span> any2any = Math.max(leftRes.any2any,rightRes.any2any);</div><div class="line">    </div><div class="line">    <span class="comment">//跨过root,分别在两边的情况</span></div><div class="line">    any2any = Math.max(any2any,</div><div class="line">            Math.max(<span class="number">0</span>,leftRes.root2any) </div><div class="line">            + Math.max(<span class="number">0</span>,rightRes.root2any)</div><div class="line">            + root.val</div><div class="line">            );</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(root2any,any2any);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> helper(root).any2any;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h2><h3 id="二叉搜索树的基本性质"><a href="#二叉搜索树的基本性质" class="headerlink" title="二叉搜索树的基本性质"></a>二叉搜索树的基本性质</h3><ol>
<li><p>从定义出发</p>
<p>左子树都比跟节点小</p>
<p>右子树都比根节点大</p>
<p>遇到重复的元素，可以自行定义放在左子树还是右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">	<span class="number">1</span></div><div class="line">  ↙   ↘ ...... 是BST</div><div class="line"> <span class="number">1</span>     <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="number">1</span></div><div class="line">  ↙   ↘ ......不是BST</div><div class="line"> <span class="number">1</span>     <span class="number">1</span></div><div class="line">因为BST的定义是比根节点小（包括相等）的要么都在左边，要么都在右边</div></pre></td></tr></table></figure>
</li>
<li><p>从效果出发</p>
<p><strong>BST的中序遍历是升序序列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例：</div><div class="line">	<span class="number">2</span></div><div class="line">  ↙   ↘ </div><div class="line"> <span class="number">1</span>     <span class="number">4</span>           中序遍历：<span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></div><div class="line">   	 ↙   ↘ </div><div class="line">	<span class="number">3</span>     <span class="number">5</span></div></pre></td></tr></table></figure>
<p>利用BST的这个性质，可以做排序：<br>比如给定一个无序序列[2,1,4,3,5]<br>可以构造一个BST，然后再中序遍历，输出序列就是有序序列了</p>
<p>因此，<strong>BST又叫排序二叉树</strong></p>
<p>相关练习题：</p>
<p>Binary Search Tree 的insert、remove等</p>
</li>
<li><p>性质</p>
<ul>
<li><p>如果一棵二叉树的中序遍历不是升序，则一定不是BST</p>
</li>
<li><p>如果一棵二叉树的中序遍历是升序，也未必是BST</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">比如：</div><div class="line">    <span class="number">1</span></div><div class="line">  ↙   ↘ </div><div class="line"> <span class="number">1</span>     <span class="number">1</span></div><div class="line">中序遍历得到[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，是升序序列，但是不是BST</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>存在重复元素时，要么都在左子树要么都在右子树，不可以两边都有</p>
</li>
</ul>
</li>
</ol>
<h3 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree" target="_blank" rel="external">Validate Binary Search Tree</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     2</div><div class="line">&gt;    / \</div><div class="line">&gt;   1   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Binary tree </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [2,1,3]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>, return true.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     1</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Binary tree </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [1,2,3]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>, return false.</p>
</blockquote>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>给定一个二叉树，判断是否是二叉搜索树，两种思路:</p>
<ol>
<li>根据二叉搜索树的性质，中序遍历是升序序列，可以对给定二叉树进行中序遍历，输出序列如果是升序序列则是二叉搜索树，可以利用二叉树的非递归中序遍历，每次弹栈时跟前一个元素进行比较，如果小于等于前一个元素就直接返回false。</li>
<li>分治法递归判断，需要存储节点以下是否是BST，以及节点以下部分的最大最小值，和root节点进行比较，是否满足左子树所有元素都小于root,右子树所有节点都大于root。</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//分治法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isValid;</div><div class="line">        <span class="keyword">long</span> min;</div><div class="line">        <span class="keyword">long</span> max;</div><div class="line">        ResultType(<span class="keyword">boolean</span> isValid,<span class="keyword">long</span> min,<span class="keyword">long</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.isValid = isValid;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">            <span class="keyword">this</span>.min = min;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Long.MAX_VALUE,Long.MIN_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分</span></div><div class="line">        ResultType leftValid = helper(root.left);</div><div class="line">        ResultType rightValid = helper(root.right);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">if</span>(leftValid.isValid &amp;&amp; rightValid.isValid)&#123;<span class="comment">//左右子树都是BST</span></div><div class="line">            <span class="keyword">if</span>(leftValid.max &lt; root.val &amp;&amp; rightValid.min &gt; root.val)&#123;<span class="comment">//左边元素都比root小，右边元素都比root大</span></div><div class="line">                ResultType res = <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.min(leftValid.min,root.val),Math.max(rightValid.max,root.val));</div><div class="line">                <span class="keyword">return</span> res;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,Math.min(leftValid.min,root.val),Math.max(rightValid.max,root.val));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,Long.MIN_VALUE,Long.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root).isValid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归中序遍历</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> last = Integer.MIN_VALUE;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ||!stack.empty())&#123;</div><div class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(cur);</div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">                <span class="keyword">if</span>(cur.val &lt;= last)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator" target="_blank" rel="external">Binary Search Tree Iterator</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>
<p><strong>Note: </strong><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p>
</blockquote>
<p>设计实现一个带有下列属性的二叉查找树的迭代器：</p>
<ol>
<li>元素按照递增的顺序被访问（比如中序遍历）</li>
<li>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</li>
</ol>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [3, 6, 7, 8, 9, 10, 11, 12]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     10</div><div class="line">   /    \</div><div class="line">  6      11</div><div class="line"> / \       \</div><div class="line">3   9       12</div><div class="line">   /</div><div class="line">  8</div><div class="line"> /</div><div class="line">7</div></pre></td></tr></table></figure>
<ul>
<li>本题相当于考察了BST的非递归中序遍历</li>
<li>需要maintain一个stack，首先从root开始push入栈直到最左节点<br>初始stack为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10, 6, 3</div></pre></td></tr></table></figure>
<ul>
<li>在遍历过程中，如果某个节点存在右儿子，则继续从右儿子开始push入栈直到其最左节点<br>result = 3, 6<br>因为6有右儿子，所以6被pop出去之后，从6为root开始push入栈直到最左节点，然后stack为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10， 9， 8， 7</div></pre></td></tr></table></figure>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</div><div class="line">            val = x;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</div><div class="line">        TreeNode root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">		</div><div class="line">  		<span class="comment">//初始化，将root全部left入栈</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.root = root;</div><div class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> !stack.empty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            TreeNode temp = stack.pop();</div><div class="line">            <span class="keyword">int</span> val = temp.val;</div><div class="line">            temp = temp.right;</div><div class="line">			<span class="comment">//如果弹出节点有右节点，右节点视作左节点，全部左孩子入栈</span></div><div class="line">            <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(temp);</div><div class="line">                temp = temp.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> val;<span class="comment">//返回当前节点值</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Inorder-Successor-in-BST"><a href="#Inorder-Successor-in-BST" class="headerlink" title="Inorder Successor in BST"></a><a href="https://leetcode.com/problems/inorder-successor-in-bst" target="_blank" rel="external">Inorder Successor in BST</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p><strong>Note</strong>: If the given node has no in-order successor in the tree, return <code>null</code>.</p>
</blockquote>
<p>给定一个二叉搜索树和一个节点p，返回p的后继节点（中序遍历时和p相邻比p大的节点）</p>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><ol>
<li>BST的stack实现，弹栈遇到p节点时标记下，下一次弹栈的节点即是所求</li>
<li>递归实现：<ul>
<li>如果p的值小于root，则在左子树中寻找后继，若没有找到，则root就是p的后继</li>
<li>如果p的值大于root，则在右子树中寻找后继节点</li>
</ul>
</li>
</ol>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</div><div class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">  TreeNode cur = root;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;</div><div class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">      stack.push(cur);</div><div class="line">      cur = cur.left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">      cur = stack.pop();</div><div class="line">      <span class="keyword">if</span>(flag == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> cur;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(cur == p)&#123;</div><div class="line">        flag = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      cur = cur.right;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor2</span><span class="params">(TreeNode root, TreeNode p)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//后级节点在左子树或root节点中</span></div><div class="line">        <span class="keyword">if</span>(p.val &lt; root.val)&#123;</div><div class="line">            <span class="comment">//后继节点在以左孩子为root的子树中的位置</span></div><div class="line">            TreeNode left = inorderSuccessor2(root.left,p);</div><div class="line">            <span class="comment">//没有刚好比p大一个的，则root就是p的后继节点</span></div><div class="line">          	<span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span>  root;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">//在左子树中找到了p的后继</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//后继节点在右子树中</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> inorderSuccessor2(root.right,p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Search-Range-in-Binary-Search-Tree"><a href="#Search-Range-in-Binary-Search-Tree" class="headerlink" title="Search Range in Binary Search Tree"></a><a href="http://www.lintcode.com/en/problem/search-range-in-binary-search-tree/" target="_blank" rel="external">Search Range in Binary Search Tree</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree. Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&lt;=x&lt;=k2 and x is a key of given BST. Return all the keys in ascending order.</p>
<p>Have you met this question in a real interview?</p>
<p>Yes</p>
<p>Example</p>
<p>If k1 = <code>10</code> and k2 = <code>22</code>, then your function should return <code>[12, 20, 22]</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     20</div><div class="line">&gt;    /  \</div><div class="line">&gt;   8   22</div><div class="line">&gt;  / \</div><div class="line">&gt; 4   12</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个二叉搜索树和一个区间，要求升序输出二叉搜索树中在给定区间内的节点</p>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>中序遍历BST，将符合条件的结果输出即可</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">searchRange</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    TreeNode cur = root;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;</div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(cur);</div><div class="line">            cur = cur.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">            cur = stack.pop();</div><div class="line">            <span class="keyword">if</span>(cur.val &lt;= k2 &amp;&amp; cur.val &gt;= k1) &#123;</div><div class="line">                results.add(cur.val);</div><div class="line">            &#125;</div><div class="line">            cur = cur.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Insert-Node-in-Binary-Search-Tree"><a href="#Insert-Node-in-Binary-Search-Tree" class="headerlink" title="Insert Node in Binary Search Tree"></a><a href="http://www.lintcode.com/en/problem/insert-node-in-a-binary-search-tree/" target="_blank" rel="external">Insert Node in Binary Search Tree</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary search tree and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.</p>
<h5 id="Notice"><a href="#Notice" class="headerlink" title="** Notice"></a>** Notice</h5><p>You can assume there is no duplicate values in this tree + node.</p>
<p>Have you met this question in a real interview?</p>
<p>Yes</p>
<p>Example</p>
<p>Given binary search tree as follow, after Insert node 6, the tree should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   2             2</div><div class="line">&gt;  / \           / \</div><div class="line">&gt; 1   4   --&gt;   1   4</div><div class="line">&gt;    /             / \ </div><div class="line">&gt;   3             3   6</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定一个二叉搜索树和一个新节点，插入新节点，保持二叉树仍然是二叉搜索树</p>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>递归实现，判断node的值和root节点的大小关系，返回值是当前root节点：</p>
<pre><code>   1. node小于root，要插在左子树，root.left = insertNode(root.left,node);
 2. node大于root，要插在右子树，root.right= insertNode(root.right,node);
</code></pre><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertNode</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到插入位置，插入node节点</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//在左子树</span></div><div class="line">        <span class="keyword">if</span>(node.val &lt; root.val)&#123;</div><div class="line">            root.left = insertNode(root.left,node);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//在右子树</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.right = insertNode(root.right,node);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Delete-Node-in-a-BST"><a href="#Delete-Node-in-a-BST" class="headerlink" title="Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst" target="_blank" rel="external">Delete Node in a BST</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [5,3,6,2,4,null,7]</div><div class="line">&gt; key = 3</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   3   6</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 2   4   7</div><div class="line">&gt;</div><div class="line">&gt; Given key to delete is 3. So we find the node with value 3 and delete it.</div><div class="line">&gt;</div><div class="line">&gt; One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   4   6</div><div class="line">&gt;  /     \</div><div class="line">&gt; 2       7</div><div class="line">&gt;</div><div class="line">&gt; Another valid answer is [5,2,6,null,4,null,7].</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   6</div><div class="line">&gt;    \   \</div><div class="line">&gt;     4   7</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>首先要找到要删除的节点，然后用它左子树的最大值（或右子树的最小值）的值取代要删除节点的值，再将左子树的最大值（或右子树的最小值）节点删除。</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找以root为跟的树的最大节点，root非空</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findMax</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">    root= root.right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找并删除节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>  <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//在左子树</span></div><div class="line">  <span class="keyword">if</span>(root.val &gt; key)&#123;</div><div class="line">    root.left = deleteNode(root.left,key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//在右子树</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</div><div class="line">    root.right = deleteNode(root.right,key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//要删除的就是root</span></div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;<span class="comment">//如果左节点是空的</span></div><div class="line">      <span class="keyword">return</span> root.right;<span class="comment">//返回右节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>)&#123;<span class="comment">//左节点非空，右节点为空</span></div><div class="line">      <span class="keyword">return</span> root.left;<span class="comment">//返回左节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//左右节点都非空，用左子树最大节点取代当前节点</span></div><div class="line">    root.val = findMax(root.left).val;</div><div class="line">    <span class="comment">//删除左子树最大值节点</span></div><div class="line">    root.left = deleteNode(root.left,root.val);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal" target="_blank" rel="external">Binary Tree Level Order Traversal</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [3],</div><div class="line">&gt;   [9,20],</div><div class="line">&gt;   [15,7]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p><strong>广度优先搜索</strong>，利用<code>Queue</code>，先进先出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-----|--------|-------</div><div class="line">&lt;- <span class="number">3</span> | <span class="number">9</span>   <span class="number">20</span> | <span class="number">15</span>   <span class="number">7</span> </div><div class="line">-----|--------|-------</div></pre></td></tr></table></figure>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  queue.add(root);</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">      TreeNode temp = queue.poll();</div><div class="line">      res.add(temp.val);</div><div class="line">      <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.left);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.right);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    results.add(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>宽度优先搜索最常用的数据结构是队列和hash表，但是在二叉树的问题中不会用到hash表，只会用到Queue队列</p>
<h3 id="Binary-Tree-Level-Order-Traversal-II"><a href="#Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii" target="_blank" rel="external">Binary Tree Level Order Traversal II</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [15,7],</div><div class="line">&gt;   [9,20],</div><div class="line">&gt;   [3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>跟上一题的差别是层与层之间的顺序是反的，每层元素的顺序不变，所以只需要插入最终的结果集的时候反序插入，所以可以利用LinkedList，每次将每层的结果在前面插入。</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LinkedList&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div><div class="line"></div><div class="line">queue.add(root);</div><div class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">int</span> size = queue.size();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">    TreeNode temp = queue.poll();</div><div class="line">    res.add(temp.val);</div><div class="line">    <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.add(temp.left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.add(temp.right);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  results.addFirst(res);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> results;</div></pre></td></tr></table></figure>
<h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="external">Binary Tree Zigzag Level Order Traversal</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [3],</div><div class="line">&gt;   [20,9],</div><div class="line">&gt;   [15,7]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>这道题是每一层交替正反序输出，层与层之间的顺序不变，所以result可以使用ArratList，但是每一层的子res要是用LinkedList，额外立flag取定是从前插入还是从后插入。</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  queue.add(root);</div><div class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">      TreeNode temp = queue.poll();</div><div class="line">      <span class="keyword">if</span>(flag%<span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">        res.addFirst(temp.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        res.addLast(temp.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.left);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.right);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    flag++;</div><div class="line">    results.add(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p>
<p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p>
<p>如上图的例子，DFS访问数组为：ABDECFG。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p>
<p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p>
<p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>递归是深度优先搜索（DFS）的一种实现形式<ul>
<li>递归也可以用非递归方式实现</li>
</ul>
</li>
<li>二叉树上的递归<ul>
<li>遍历法</li>
<li>分治法</li>
</ul>
</li>
<li>二叉搜索树<ul>
<li>性质：中序遍历是升序序列</li>
<li>功能：O(h)的时间复杂度查找、删除、插入，h为BST高度</li>
</ul>
</li>
<li>二叉树上的宽度优先遍历<ul>
<li>利用队列实现宽度优先搜索</li>
<li>如何实现分层遍历</li>
</ul>
</li>
<li>必背程序<ul>
<li>二叉树的前序、中序遍历的非递归实现</li>
<li>二叉树的层序遍历</li>
</ul>
</li>
<li>二叉树的深度优先遍历DFS<ol>
<li>递归实现</li>
<li>非递归实现（stack）</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/59e3fde451882578c20858a5" target="_blank" rel="external"><a href="https://link.juejin.im/?target=mailto%3Amonkeysayhi7%40gmail.com" target="_blank" rel="external">猴子007的博客</a></a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bid Optimizing and Inventory Scoring in Targeted Online论文笔记]]></title>
      <url>/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online-Advertising"><a href="#Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online-Advertising" class="headerlink" title="Bid Optimizing and Inventory Scoring in Targeted Online Advertising"></a>Bid Optimizing and Inventory Scoring in Targeted Online Advertising</h2><p>这篇文章来自美国一家很优秀的DSP公司——M6D,介绍了DSP的工作流程和其中的一个核心技术：real-time bidding(实时竞价技术)</p>
<p>实时竞价：找准正确的广告信息和广告位信息，以一个能够反映真实价格的竞拍价格参与广告展示机会的竞价</p>
<a id="more"></a>
<h2 id="M6D竞价流程"><a href="#M6D竞价流程" class="headerlink" title="M6D竞价流程"></a>M6D竞价流程</h2><ol>
<li><strong>追踪用户行为</strong>：DSP公司通常会在广告主的网站上埋点（即放上一个1x1的不可见像素），这样当互联网用户第一次访问广告主的网站时，就会得到DSP公司的一个cookie，这样DSP公司就可以追踪到这个网民的在广告主网站上的行为了(这些数据也叫action data)。DSP公司还会和第三方的网站合作（例如：新浪，腾讯），在他们的网站上也埋点，或者向DMP购买网民行为数据，这样就可以追踪到网民在这些网站上的行为了(这些数据也叫mapping data)。这里值得一提的是，DSP公司对某一个用户记录的cookie和第三方网站或DMP或exchange记录的cookie是不一样的，这里需要一个叫Cookie Mapping的过程，这不是本文重点，以下假设DSP已经做好了Cookie Mapping，每个用户有一个唯一的id标识。</li>
<li>受众选择（audience selection）: m6d对每一个campaign(即每一个广告主的每个推广活动), 训练一个audience selection model, 该模型以在广告主的网站上发生转化行为（转化行为可以是注册成为用户，点击某个特定页面，购买产品。每个广告主对转化的定义不一样）的用户为正例，没有发生转化行为的用户为负例（是的，正负例很不均匀，通常要做采样和结果修正）。得到模型后，对所有的用户预估对这个campaign的转化概率p(c | u),即该用户u有多大的概率会在广告主的网站上发生转化行为（c表示conversion），去掉大多数转化概率非常小的用户，将目标用户根据转化概率高低分到不同的segments中。这样我们对每个campaign就找到了很多的目标用户，而且这些用户根据他们的质量高低，被分别放在不同的segments中。</li>
<li>通知exchange: DSP将这些目标用户的cookie告诉exchange，这样当有这些cookie的请求来的时候，exchange才会来向DSP的服务器发送请求。</li>
<li>Segment管理： 通常DSP公司会有账户管理员（运营人员），他们人工来对每个campaign的做一些设定。他们根据每个campaign所属的行业特点，经济状况，决定开启哪些segments，关掉哪些segments。例如：对没钱的小公司的campaign, 那些用户转化概率小一些的segment就不要投广告了。他们还需要对每个segment设定一个基础出价（base price）。账户管理员可以拿到每个segment的平均预估转化概率，来辅助他们设定基础出价。这一步也是人工影响投放策略最主要的地方。</li>
<li>进行实时竞价：当exchange把请求发过来的时候，DSP会拿到以下信息：当前广告位的信息，当前用户的cookie和基本信息。DSP需要在100ms内，根据对当前用户的理解，并且考虑当前广告位，根据自己的bidding算法，来要决定是否要买这次展现，投放哪个campaign的广告，出价是多少（bidding），并向exchange返回出价信息？如果超过时间DSP没有响应，则exchange默认DSP放弃这次竞价。</li>
<li>展现广告：如果赢得了展现机会，则DSP返回创意，用户就会在该广告位看到该创意。</li>
<li>追踪转化：因为DSP在广告主的网站上埋了点，就能知道用户是否在这次展现之后进行了转化行为。根据这些数据统计转化率，每个转化平均成本等指标，汇总成报告给广告主。</li>
</ol>
<h2 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h2><p>当exchange发送请求时，DSP会接受到当前用户的cookie和一些最基本的用户信息，以及当前广告位的信息。DSP则需要找到这个用户所属的所有segments，而这些segments可能会对应多个campaign。那么应该出哪个campaign的广告呢？这里有一个内部竞价的过程。</p>
<p>m6d是这么做的，首先要把一些不合适出广告的campaign根据规则过去掉。主要的规则有，如果一个用户之前已经被展现了这个campaign的广告数达到一定的个数了，那么就不要再浪费广告费了（这个次数限制通常叫frequency cap）。另外一个主要规则是，如果一个campaign已经达到了它的每日，或者每周，或者每月预算限制了，那么也不再为它投放广告了。对于剩下的campaign候选，DSP会对他们都根据算法计算出最合适的出价，然后简单地选取出价最高的那个（出价反映了当前用户对该campaign的价值）。</p>
<p>下面介绍下对于某一个campaign, 如何计算对当前展现机会的出价。</p>
<p>前面的audience selection部分，我们已经对每个用户划分了segments，然后账户管理员又对每个segment给出了基础出价（base price），当时这个出价考虑的是这个用户和这个campaign的适合程度，并没有考虑当前广告位是否适合这个campaign投广告，是否适合这个用户。因此m6d的算法，以基础出价为基准，根据当前广告位计算出一个调整因子$\phi$，最后的出价就是$baseprice * \phi$ 。因此我们全部的工作就是要计算这个$\phi$。</p>
<h4 id="计算调整因子-phi-的依据"><a href="#计算调整因子-phi-的依据" class="headerlink" title="计算调整因子$\phi$的依据"></a>计算调整因子$\phi$的依据</h4><p>在实时竞价中，一次展示机会的价值可以由其带来的真正效益来衡量，我们用转化率*转化价值来表示</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113178e5863.png" alt=""> </p>
<p>由于转化价值不好估计，我们就在转化率上面做文章。<br>对于同一个campaign来说，如果我们知道一个展现的转化率是另外一个展现的2倍，那么前面那个展现的出价应该是后面那个展现的出价的2倍。这就是M6D设计的竞价函数的依据。</p>
<h4 id="调整因子-phi-计算"><a href="#调整因子-phi-计算" class="headerlink" title="调整因子$\phi$计算"></a>调整因子$\phi$计算</h4><p>按照上面的逻辑，既然我们为segments出了一个平均价格baseprice，当一个展现机会的的转化率是这个segments中用户的平均转化率的$\phi$倍，我们应该为这个展现出$baseprice * \phi$的出价。因此有：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/591132bf75168.png" alt=""> </p>
<p>其中，u指的是用户，i是当前的广告位(inventory)，c指的是转化，a指某一具体的广告。分母计算的是在所有广告位（用j指代）上的平均转化率。这个分母要计算起来很复杂，我们要遍历所有的广告位(inventory)。但我们知道：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/591133298b64a.png" alt=""> </p>
<p>因此最终调整因子的计算化简为：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113394b3a89.png" alt=""> </p>
<p>所以m6d的bidding算法的最核心部分，就是为每个campaign都建立两个模型来分别预估p(c|u,i)和p(c|u)。考虑到每个campaign的转化数据很少，这2个模型的训练数据很少，要训练这两个模型太难了。因此m6d将同一个segment中的用户不做区分，从而可以把上式变为</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/5911344436942.png" alt=""> </p>
<p>其中，s是segment。这样就只需要训练p(c|s,i)和p(c|s)。因为s的个数远小于u的个数，这2个模型的特征空间显著变小了，模型更容易得到更好的结果。</p>
<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>以上就是m6d对bidding的建模过程了，剩下的工作就是如何训练得到这两个模型。</p>
<p><strong>p(c|s,i)模型</strong>:  要得到这个模型的训练数据，还有一个冷启动的过程。必须事先对这些segments在这些inventories上投放，然后把那些最终带来转化的展现标记为正例，没有最终带来转化的展现标记为负例。m6d认为一次转化是由之前7天内该用户见到的最后一次展现带来的。这个模型的特征只有两类，一类就是segment id, 另外一类就是inventory id。也就是说，每一个样本只有两个非0的特征，一个是segment id对应的那个特征，另外一个是inventory id对应的那个特征。m6d没有组合segment和inventory特征，这样做的结果是：不管对于哪个segment，某个特定的inventory对最后预估值的贡献都是一样的。这个假设可以认为在大多数情况下是合理的。而且如果真要把这些组合特征加入模型，特征空间一下子又大了不少，对于少得可怜的训练数据来说，很容易就过拟合了。</p>
<p><strong>p(c|s)模型</strong>：和p(c|s,i)模型基本一样，区别就是特征只有segment id。</p>
<p>这两个模型的正例比例都非常低，因此训练过程中进行了采样（sampling）和修正（recalibration）。</p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>考虑了广告位（inventory）和不考虑广告位对转化率的预估由有多大的影响呢？以下的图展示了区别：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113a88e1b2f.png" alt=""> </p>
<p>具体看个例子。对于一个hotel广告主的一个campaign，不同的广告位预估出来的$\phi$值也很不相同，旅游类的预估值最高，社会媒体的最低。说明这个模型还是有一定区分度的。</p>
<p><img src="https://ooo.0o0.ooo/2017/05/09/59113a558161d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[搜索引擎Top-k快速检索问题]]></title>
      <url>/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="Fagin’s-Algorithm-and-Threshold-Algorithm"><a href="#Fagin’s-Algorithm-and-Threshold-Algorithm" class="headerlink" title="Fagin’s Algorithm and Threshold Algorithm"></a>Fagin’s Algorithm and Threshold Algorithm</h2><p>Fagin算法和Threshold算法都是Top-K排序领域的经典算法(K代表只要对前K个值排序值)，不同于传统Top-k对一维数组前K个值排序，Fargin和Threshhold算法适用于<strong>参考多个排序指标时对前k个物品排序</strong>。</p>
<a id="more"></a>
<p>比如说我要去旅游，选酒店的时候我有两个指标：</p>
<ol>
<li>价格合适</li>
<li>好评率</li>
</ol>
<p>那么我在网站上得到了下面的酒店信息：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-38-01.png" alt=""> </p>
<p>能够想到的一种常规的做法是对两种评价指标分别赋予一个权重<script type="math/tex">w_1,w_2</script>，然后计算两种指标的加权得分:</p>
<script type="math/tex; mode=display">score = w_1*Cheapness+w_2*Rating</script><p>然后按照score排序取TOP-k个作为结果。</p>
<p>这样的做法存在一个问题，就是当候选集合比较大时（酒店数目较多），我们对所有的候选都计算出得分进行排序比较会浪费大量的计算资源，时间开销也很大，而我们真正所关注的就只有很少的K个最优的Hotel，Fagin’s Algorithm就是针对这样的问题的一种Top-k检索算法。</p>
<h3 id="Fagin’s-Algorithm"><a href="#Fagin’s-Algorithm" class="headerlink" title="Fagin’s Algorithm"></a>Fagin’s Algorithm</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-01.png" alt=""> </p>
<p>Fagin’s Algorithm的策略如下：</p>
<p>每一轮在不同的指标中依次选取排名最靠前的候选，直到从多个指标序列中选出的候选中有K个已经被送所有的指标列表中选出来了，这K个就是最终给的TOP-k结果。</p>
<p>结合上面选酒店的例子，假设我们要选top-3的酒店：</p>
<ul>
<li>第一轮，选取两个列表中最靠前的：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-20.png" alt=""> </p>
<ul>
<li>第二轮，选取两个列表中第二靠前的：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-33.png" alt=""> </p>
<ul>
<li>第三轮，选取两个列表中第三靠前的，此时，已经有一个候选Hotel——Novotel在所有的评价指标（列表）中被选中了：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-43.png" alt=""> </p>
<ul>
<li>第四轮，选取两个列表中第四靠前的：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-50-57.png" alt=""> </p>
<ul>
<li>第五轮，选取两个列表中第五靠前的，此时，有三个候选Hotel——Novotel、Hilton、Ibis在所有的评价指标（列表）中被选中了，结束：</li>
</ul>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-51-06.png" alt=""> </p>
<p>因此最终通过Fagin’s Algorithm计算出来的TOP-3的Hotel结果就是：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-56-54.png" alt=""> </p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-57-07.png" alt=""> </p>
<p>再对比一下之前的方式，可以看出对于后面的大量不可能成为结果的候选集节省了计算和时间开销。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-16-51-45.png" alt=""> </p>
<h3 id="Fagin’s-Threshold-Algorithm"><a href="#Fagin’s-Threshold-Algorithm" class="headerlink" title="Fagin’s Threshold Algorithm"></a>Fagin’s Threshold Algorithm</h3><p>在上面的算法基础之上，提出了更为严谨的Fagin’s Threshold Algorithm：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-09-34.png" alt=""> </p>
<p>还是上面的例子：</p>
<p>将初始threshold设置为无穷大</p>
<ul>
<li><p>第一轮，在Cheapness和Rating表中选取最高的，计算其在所有评价指标下的综合得分，放入Top-k列表中，并计算第一行的threshold：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-16-24.png" alt=""> </p>
<p>根据Fagin’s Threshold算法，如果当前的th值已经小于top表中的所有值，就认为后面不可能再出现比top表中更好的候选了，即可停止计算，此时还不能够停止。</p>
</li>
<li><p>第二轮，在Cheapness和Rating表中选取第二高的，计算其在所有评价指标下的综合得分，更新Top-k表，计算threshold，还不能够停止计算</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-18-09.png" alt=""> </p>
</li>
<li><p>第三轮，</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-19-01.png" alt=""> </p>
</li>
<li><p>第四轮，</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-22-17-20-03.png" alt=""> </p>
<p>此时threshold已经低于所有的top-k候选了，后面不能再有更好的候选了，因此停止计算，得到结果。</p>
</li>
</ul>
<h3 id="海量数据TOP-k查询"><a href="#海量数据TOP-k查询" class="headerlink" title="海量数据TOP-k查询"></a>海量数据TOP-k查询</h3><p>top K问题很适合采用MapReduce框架解决，用户只需编写一个Map函数和两个Reduce 函数，然后提交到Hadoop（采用Mapchain和Reducechain）上即可解决该问题。具体而言，就是首先根据数据值或者把数据hash(MD5)后的值按照范围划分到不同的机器上，最好可以让数据划分后一次读入内存，这样不同的机器负责处理不同的数值范围，实际上就是Map。得到结果后，各个机器只需拿出各自出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是Reduce过程。对于Map函数，采用Hash算法，将Hash值相同的数据交给同一个Reduce task；对于第一个Reduce函数，采用HashMap统计出每个词出现的频率，对于第二个Reduce 函数，统计所有Reduce task，输出数据中的top K即可。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【RTB论文笔记】]]></title>
      <url>/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/</url>
      <content type="html"><![CDATA[<h3 id="Bidding-Strategies"><a href="#Bidding-Strategies" class="headerlink" title="Bidding Strategies"></a>Bidding Strategies</h3><ul>
<li><p><a href="https://arxiv.org/pdf/1707.06409.pdf" target="_blank" rel="external">Attribution Modeling Increases Efficiency of Bidding in Display Advertising</a> by Eustache Diemert et al. ADKDD 2017.</p>
</li>
<li><p><a href="https://arxiv.org/pdf/1706.01614.pdf" target="_blank" rel="external">Profit Maximization for Online Advertising Demand-Side Platforms</a> by Paul Grigas et al. ArXiv 2017.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/rlb.pdf" target="_blank" rel="external">Real-Time Bidding by Reinforcement Learning in Display Advertising</a> by Han Cai et al. WSDM 2017.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/risk-bid.pdf" target="_blank" rel="external">Managing Risk of Bidding in Display Advertising</a> by Haifeng Zhang et al. WSDM 2017.</p>
</li>
<li><p><a href="https://arxiv.org/pdf/1703.02091.pdf" target="_blank" rel="external">Optimized Cost per Click in Taobao Display Advertising</a> by Han Zhu et al. ArXiv 2017.</p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/two-pred-bid.pdf" target="_blank" rel="external">Combining Powers of Two Predictors in Optimizing Real-Time Bidding Strategy under Constrained Budget</a> by Chi-Chun Lin et al. CIKM 2016.</p>
</li>
<li><p><a href="http://www.kdd.org/kdd2016/papers/files/adp0722-geyikA.pdf" target="_blank" rel="external">Joint Optimization of Multiple Performance Metrics in Online Video Advertising</a> by Sahin Cem Geyik et al. KDD 2016.</p>
<a id="more"></a>
</li>
<li><p><a href="http://discovery.ucl.ac.uk/1496878/1/weinan-zhang-phd-2016.pdf" target="_blank" rel="external">Optimal Real-Time Bidding for Display Advertising</a> by Weinan Zhang. PhD Thesis 2016.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/unbias-kdd.pdf" target="_blank" rel="external">Bid-aware Gradient Descent for Unbiased Learning with Censored Data in Display Advertising</a> by Weinan Zhang, Tianxiong Zhou, Jun Wang, Jian Xu. KDD 2016.</p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/lift-bidding.pdf" target="_blank" rel="external">Lift-Based Bidding in Ad Selection</a> by Jian Xu et al. AAAI 2016.</p>
</li>
<li><p><a href="http://wnzhang.net/papers/fc-wsdm.pdf" target="_blank" rel="external">Feedback Control of Real-Time Display Advertising</a> by Weinan Zhang et al. WSDM 2016.</p>
</li>
<li><p><a href="http://arxiv.org/abs/1511.08409" target="_blank" rel="external">Optimal Real-Time Bidding Strategies</a> by Joaquin Fernandez-Tapia, Olivier Guéant, Jean-Michel Lasry. ArXiv 2015.</p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/bid-drawbridge.pdf" target="_blank" rel="external">Programmatic Buying Bidding Strategies with Win Rate and Winning Price Estimation in Real Time Mobile Advertising</a> by Xiang Li and Devin Guan. PAKDD 2014.</p>
</li>
<li><p><a href="https://www.researchgate.net/publication/283579660_Statistical_modeling_of_Vickrey_auctions_and_applications_to_automated_bidding_strategies" target="_blank" rel="external">Statistical modeling of Vickrey auctions and applications to automated bidding strategies</a> by Joaquin Fernandez-Tapia. Working paper.</p>
</li>
<li><p><del><a href="http://wnzhang.net/share/rtb-papers/rtb-arbitrage.pdf" target="_blank" rel="external">Statistical Arbitrage Mining for Display Advertising</a> by Weinan Zhang, Jun Wang. KDD 2015.非线性出价函数，优化目标：DSP净利润</del></p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/opt-prog-buy.pdf" target="_blank" rel="external">Real-Time Bidding rules of thumb: analytically optimizing the programmatic buying of ad-inventory</a> by Joaquin Fernandez-Tapia. SSRN 2015.</p>
</li>
<li><p><del><a href="http://wnzhang.net/share/rtb-papers/optimal-rtb.pdf" target="_blank" rel="external">Optimal Real-Time Bidding for Display Advertising</a> by Weinan Zhang, Shuai Yuan, Jun Wang. KDD 2014.非线性出价函数，优化目标：点击数</del></p>
</li>
<li><p><del><a href="http://wnzhang.net/share/rtb-papers/lin-bid.pdf" target="_blank" rel="external">Bid Optimizing and Inventory Scoring in Targeted Online Advertising</a> by Claudia Perlich et al. KDD 2012.M6d线性出价函数</del></p>
</li>
<li><p><a href="http://wnzhang.net/share/rtb-papers/rtb-perf-bid.pdf" target="_blank" rel="external">Real-Time Bidding Algorithms for Performance-Based Display Ad Allocation</a> by Ye Chen et al. KDD 2011</p>
</li>
</ul>
<h3 id="CTR-CVR-Estimation"><a href="#CTR-CVR-Estimation" class="headerlink" title="CTR/CVR Estimation"></a>CTR/CVR Estimation</h3><ul>
<li><a href="https://arxiv.org/pdf/1708.05123.pdf" target="_blank" rel="external">Deep &amp; Cross Network for Ad Click Predictions</a> by Ruoxi Wang et al. AdKDD &amp; TargetAd 2017.</li>
<li><a href="https://arxiv.org/pdf/1706.06978.pdf" target="_blank" rel="external">Deep Interest Network for Click-Through Rate Prediction</a> by Guorui Zhou et al. ArXiv 2017.</li>
<li><a href="https://arxiv.org/pdf/1703.04247.pdf" target="_blank" rel="external">DeepFM: A Factorization-Machine based Neural Network for CTR Prediction</a> by Huifeng Guo et al. IJCAI 2017</li>
<li><a href="https://arxiv.org/pdf/1704.05194.pdf" target="_blank" rel="external">Learning Piece-wise Linear Models from Large Scale Data for Ad Click Prediction</a> by Kun Gai, Xiaoqiang Zhu, Han Li, et al. Arxiv 2017.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/softmax-ensemble.pdf" target="_blank" rel="external">SEM: A Softmax-based Ensemble Model for CTR Estimation in Real-Time Bidding Advertising</a> by Wen-Yuan Zhu et al. BigComp 2017.</li>
<li><a href="https://arxiv.org/pdf/1702.00855v1.pdf" target="_blank" rel="external">Neural Feature Embedding for User Response Prediction in Real-Time Bidding (RTB)</a> by Enno Shioji, Masayuki Arai. ArXiv 2017.</li>
<li><a href="https://arxiv.org/pdf/1701.04099.pdf" target="_blank" rel="external">Field-aware Factorization Machines in a Real-world Online Advertising System</a> by Yuchin Juan, Damien Lefortier, Olivier Chapelle. ArXiv 2017.</li>
<li><a href="https://arxiv.org/pdf/1611.00144.pdf" target="_blank" rel="external">Product-based Neural Networks for User Response Prediction</a> by Yanru Qu et al. ICDM 2016.</li>
<li><a href="http://staff.ustc.edu.cn/~cheneh/paper_pdf/2016/Zhen-Pan-ICDM.pdf" target="_blank" rel="external">Sparse Factorization Machines for Click-through Rate Prediction</a> by Zhen Pan et al. ICDM 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/deep-ctr-display.pdf" target="_blank" rel="external">Deep CTR Prediction in Display Advertising</a> by Junxuan Chen et al. MM 2016.</li>
<li><a href="http://wnzhang.net/papers/unbias-kdd.pdf" target="_blank" rel="external">Bid-aware Gradient Descent for Unbiased Learning with Censored Data in Display Advertising</a> by Weinan Zhang, Tianxiong Zhou, Jun Wang, Jian Xu. KDD 2016.</li>
<li><a href="http://proceedings.mlr.press/v53/yang16.pdf" target="_blank" rel="external">Large Scale CVR Prediction through Dynamic Transfer Learning of Global and Local Features</a> by Hongxia Yang et al. BIGMINE 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fctf.pdf" target="_blank" rel="external">Predicting ad click-through rates via feature-based fully coupled interaction tensor factorization</a> by Lili Shan, Lei Lin, Chengjie Sun, Xiaolong Wang. Electronic Commerce Research and Applications 2016.<ul>
<li><a href="http://wnzhang.net/share/rtb-papers/ctr-chapelle.pdf" target="_blank" rel="external">Simple and Scalable Response Prediction for Display Advertising</a> by Olivier ChapelleCriteo, Eren Manavoglu, Romer Rosales. ACM TIST 2014.</li>
</ul>
</li>
<li><a href="https://arxiv.org/pdf/1603.03713.pdf" target="_blank" rel="external">Cost-sensitive Learning for Utility Optimization in Online Advertising Auctions</a> by Flavian Vasile, Damien Lefortier, Olivier Chapelle. Extension under-review of the paper presented at the Workshop on E-Commerce, NIPS 2015.</li>
<li><a href="http://apex.sjtu.edu.cn/public/files/members/20161024/opt-ctr-bid.pdf" target="_blank" rel="external">User Response Learning for Directly Optimizing Campaign Performance in Display Advertising</a> by Kan Ren, Weinan Zhang, Yifei Rong, Haifeng Zhang, Yong Yu, Jun Wang. CIKM 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/cnn-ctr.pdf" target="_blank" rel="external">A Convolutional Click Prediction Model</a> by Qiang Liu, Feng Yu, Shu Wu, Liang Wang. CIKM 2015.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fm-ftrl.pdf" target="_blank" rel="external">Factorization Machines with Follow-The-Regularized-Leader for CTR prediction in Display Advertising</a> by Anh-Phuong Ta. BigData 2015.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/deep-ctr.pdf" target="_blank" rel="external">Deep Learning over Multi-field Categorical Data: A Case Study on User Response Prediction</a> by Weinan Zhang, Tianming Du, Jun Wang. ECIR 2016.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/ctr-bid.pdf" target="_blank" rel="external">Offline Evaluation of Response Prediction in Online Advertising Auctions</a> by Olivier Chapelle. WWW 2015.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fm-ctr.pdf" target="_blank" rel="external">Predicting Response in Mobile Advertising with Hierarchical Importance-Aware Factorization Machine</a> by Richard J. Oentaryo et al. WSDM 2014.</li>
<li><a href="https://pdfs.semanticscholar.org/fc11/8ce8cf852ccd10cae0fcf031cb5c238f69c0.pdf" target="_blank" rel="external">Scalable Hierarchical Multitask Learning Algorithms for Conversion Optimization in Display Advertising</a> by Amr Ahmed et al. WSDM 2014.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/cvr-est.pdf" target="_blank" rel="external">Estimating Conversion Rate in Display Advertising from Past Performance Data</a> by Kuang-chih Lee et al. KDD 2012.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/transfer-ctr.pdf" target="_blank" rel="external">Scalable Hands-Free Transfer Learning for Online Advertising</a> by Brian Dalessandro et al. KDD 2014.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/forget-click.pdf" target="_blank" rel="external">Evaluating and Optimizing Online Advertising: Forget the click, but there are good proxies</a> by Brian Dalessandro et al. SSRN 2012.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/delayed-feedback.pdf" target="_blank" rel="external">Modeling Delayed Feedback in Display Advertising</a> by Olivier Chapelle. KDD 2014.</li>
<li><a href="https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf" target="_blank" rel="external">Ad Click Prediction: a View from the Trenches</a> by H. Brendan McMahan. KDD 2013.</li>
<li><a href="http://wnzhang.net/share/rtb-papers/fb-ad-ctr.pdf" target="_blank" rel="external">Practical Lessons from Predicting Clicks on Ads at Facebook</a> by Xinran He et al. ADKDD 2014.</li>
</ul>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><h3 id="Attribution-Modeling-Increases-Efficiency-of-Bidding-in-Display-Advertising-by-Eustache-Diemert-et-al-ADKDD-2017"><a href="#Attribution-Modeling-Increases-Efficiency-of-Bidding-in-Display-Advertising-by-Eustache-Diemert-et-al-ADKDD-2017" class="headerlink" title="Attribution Modeling Increases Efficiency of Bidding in Display Advertising by Eustache Diemert et al. ADKDD 2017."></a><a href="https://arxiv.org/pdf/1707.06409.pdf" target="_blank" rel="external">Attribution Modeling Increases Efficiency of Bidding in Display Advertising</a> by Eustache Diemert et al. ADKDD 2017.</h3><p>归属模型提高展示广告竞价效率</p>
<p>数据集：Criteo、Facebook真实场景</p>
<p>offline数据结：<a href="http://research.criteo.com/criteo-attribution-modeling-bidding-dataset/" target="_blank" rel="external">http://research.criteo.com/criteo-attribution-modeling-bidding-dataset/</a></p>
<h4 id="Abstra"><a href="#Abstra" class="headerlink" title="Abstra"></a>Abstra</h4><p>ct以往算法将转化率预估和转化行为归因于哪次广告行为（展示或者点击）分开研究，是两个独立的问题，但是作者发现，归因模型有助于提高竞价的效果，因此将转化行为归因于哪次广告活动加入竞价策略中，提高竞价效率。</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>衡量展示广告效果基于广告展示带来的价值，目前主要的两种方式：CPC，CPA（cost per action）,工业界中归因转化的标准是：归因于转化之前30天之内最后一次点击行为。</p>
<p>对于广告引擎和平台来说，目前最先进的出价策略是：Expected Value Bidder (EVB),也就是根据展示机会的预期价值来出价。预期价值是广告主payment*预测的转化率</p>
<p>在博弈论和经济学领域，转化归因已有深入研究，已经有一些机制被提出去较好地衡量广告主的payment，尤其是在多个广告点击或者转化行为同时发生或多个渠道同时存在的情况下。</p>
<p>考虑一个广告行为序列，合理的出价方式是后面的展示行为都应该比第一次展示的价值低，因为第二次点击行为能够导致转化的可能性不高。在之前的EVB策略中，是没有这方面考虑的，因为它既不能跟踪也不能预测归因转化率，所以为了改进实时竞价策略，我们建议利用一个归因模型来修改投标策略。</p>
<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>把转化归因于最后一次点击行为适用于CPM结算方式，但不是很适合CPCorCPA方式。</p>
<p>从数据中学习归因关系，假设广告投放平台可以访问其广告主客户的转化归属标签，（该广告主通过其他广告投放平台的转化归主标签不可访问）</p>
<p>将归属关系表达成间隔时间的负指数函数，竞价策略为CPA*归属概率。</p>
<h4 id="Data-description"><a href="#Data-description" class="headerlink" title="Data description"></a>Data description</h4><p>This dataset represents a sample of 30 days of Criteo live traffic data. Each line corresponds to one impression (a banner) that was displayed to a user. For each banner we have detailed information about the context, if it was clicked, if it led to a conversion and if it led to a conversion that was attributed to Criteo or not. Data has been sub-sampled and anonymized so as not to disclose proprietary elements.</p>
<p>Here is a detailed description of the fields (they are tab-separated in the file):</p>
<ul>
<li><strong>timestamp</strong>: timestamp of the impression (starting from 0 for the first impression). The dataset is sorted according to timestamp.</li>
<li><strong>uid</strong> a unique user identifier</li>
<li><strong>campaign</strong> a unique identifier for the campaign</li>
<li><strong>conversion</strong> 1 if there was a conversion in the 30 days after the impression (independently of whether this impression was last click or not)</li>
<li><strong>conversion_timestamp</strong> the timestamp of the conversion or -1 if no conversion was observed</li>
<li><strong>conversion_id</strong> a unique identifier for each conversion (so that timelines can be reconstructed if needed). -1 if there was no conversion</li>
<li><strong>attribution</strong> 1 if the conversion was attributed to Criteo, 0 otherwise</li>
<li><strong>click</strong> 1 if the impression was clicked, 0 otherwise</li>
<li><strong>click_pos</strong> the position of the click before a conversion (0 for first-click)</li>
<li><strong>click_nb</strong> number of clicks. More than 1 if there was several clicks before a conversion</li>
<li><strong>cost</strong> the price paid by Criteo for this display (<strong>disclaimer:</strong> not the real price, only a transformed version of it)</li>
<li><strong>cpo</strong> the cost-per-order in case of attributed conversion (<strong>disclaimer:</strong> not the real price, only a transformed version of it)</li>
<li><strong>time_since_last_click</strong> the time since the last click (in s) for the given impression</li>
<li><strong>cat[1-9]</strong> contextual features associated to the display. Can be used to learn the click/conversion models. We do not disclose the meaning of these features but it is not relevant for this study. Each column is a categorical variable. In the experiments, they are mapped to a fixed dimensionality space using the Hashing Trick (see paper for reference).</li>
</ul>
<h3 id="Criteo-Data"><a href="#Criteo-Data" class="headerlink" title="Criteo Data"></a>Criteo Data</h3><ul>
<li><strong>timestamp</strong>: 时间戳</li>
<li><strong>uid</strong> 用户id</li>
<li><strong>campaign</strong> 推广计划id</li>
<li><strong>conversion</strong> 转化</li>
<li><strong>conversion_timestamp </strong>转化时间</li>
<li><strong>conversion_id</strong> 转化id</li>
<li><strong>attribution</strong> 转化归属关系</li>
<li><strong>click</strong> 点击</li>
<li><strong>click_pos</strong> 点击次序</li>
<li><strong>click_nb</strong> 点击数量</li>
<li><strong>cost</strong> 成本价格，Criteo赢得展示所支付的费用</li>
<li><strong>cpo</strong> the cost-per-order in case of attributed conversion (<strong>disclaimer:</strong> not the real price, only a transformed version of it)</li>
<li><strong>time_since_last_click</strong> 最后一次点击时间到转化的间隔时间</li>
<li><strong>cat[1-9]</strong>  上下文特征，hash过。</li>
</ul>
<h3 id="Managing-Risk-of-Bidding-in-Display-Advertising-by-Haifeng-Zhang-et-al-WSDM-2017"><a href="#Managing-Risk-of-Bidding-in-Display-Advertising-by-Haifeng-Zhang-et-al-WSDM-2017" class="headerlink" title="Managing Risk of Bidding in Display Advertising by Haifeng Zhang et al. WSDM 2017."></a><a href="http://wnzhang.net/papers/risk-bid.pdf" target="_blank" rel="external">Managing Risk of Bidding in Display Advertising</a> by Haifeng Zhang et al. WSDM 2017.</h3><p>数据集：iPinyou</p>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>广告主投放广告就像是金融投资一样，也具有风险，本文中我们明确地给出用户点击率估计的模型和竞价竞争模型来控制风险，我们从金融学引入一个idea，形成两个风险感知的竞价策略，惩罚具有风险的广告展示机会，更多地关注高收益、低风险的广告。</p>
<h4 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h4><p>提到了一些DSP平台：ipinyou,YOYI,Fikisu,广告市场的交易量已经超过了金融市场。</p>
<p>竞价策略依赖于点击率或者转化率的预估，但是点击率预估的不准确可能会导致价值估计的严重不准确，会带来巨大利润估计风险。本文中我们脱离传统的ctr预估，而是对每一个广告展示机会潜在的风险进行建模。</p>
<h3 id="Real-Time-Bidding-rules-of-thumb-analytically-optimizing-the-programmatic-buying-of-ad-inventory-by-Joaquin-Fernandez-Tapia-SSRN-2015"><a href="#Real-Time-Bidding-rules-of-thumb-analytically-optimizing-the-programmatic-buying-of-ad-inventory-by-Joaquin-Fernandez-Tapia-SSRN-2015" class="headerlink" title="Real-Time Bidding rules of thumb: analytically optimizing the programmatic buying of ad-inventory by Joaquin Fernandez-Tapia. SSRN 2015."></a><a href="http://wnzhang.net/share/rtb-papers/opt-prog-buy.pdf" target="_blank" rel="external">Real-Time Bidding rules of thumb: analytically optimizing the programmatic buying of ad-inventory</a> by Joaquin Fernandez-Tapia. SSRN 2015.</h3><p>优化目标：一定预算约束下，实现广告位采买最大化</p>
<p>比较关注的三种技术：</p>
<ol>
<li>静态宏观变量对广告活动的运作十分重要</li>
<li>针对不同广告位的竞价优化</li>
<li>预算步进优化</li>
</ol>
<h4 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h4><ol>
<li><p>工业背景：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-28-17-14-20.png" alt=""> </p>
</li>
<li><p>不同规模的模型：</p>
<p>一次广告竞价是微观的过程，但是衡量其表现却是宏观过程，比如衡量其一个月、一天的收益</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-28-17-15-00.png" alt=""> </p>
</li>
<li><p>假设</p>
<p>​</p>
</li>
<li><p>优化问题</p>
</li>
<li><p>本文提纲和贡献</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 广告 </category>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法基础班】动态规划]]></title>
      <url>/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%B8%8A)/</url>
      <content type="html"><![CDATA[<h2 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">Triangle</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;      [<span class="number">2</span>],</div><div class="line">&gt;     [<span class="number">3</span>,<span class="number">4</span>],</div><div class="line">&gt;    [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</div><div class="line">&gt;   [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
</blockquote>
<p>题目是说，从三角形的最上层走到最下层，每次只走到下一层的相邻元素，求从顶点走到最下层的最短路径长度。</p>
<h3 id="方法1：DFS遍历"><a href="#方法1：DFS遍历" class="headerlink" title="方法1：DFS遍历"></a>方法1：DFS遍历</h3><p>从上往下深度优先遍历搜索，记录所有情况之中最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> best = Integer.MAX_VALUE;;</div><div class="line"></div><div class="line"><span class="comment">//sum为走到当前节点但不包含当前节点的路径和</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//搜索结束条件：走过了最下面一层</span></div><div class="line">  <span class="keyword">int</span> height = triangle.size();</div><div class="line">  <span class="keyword">if</span>(i==height)&#123;</div><div class="line">    best = Math.min(best,sum);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  dfs(triangle,i+<span class="number">1</span>,j,sum+triangle.get(i).get(j));</div><div class="line">  dfs(triangle,i+<span class="number">1</span>,j+<span class="number">1</span>,sum+triangle.get(i).get(j));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span> </span>&#123;</div><div class="line">  dfs(triangles,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> best;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(2^n)</script></p>
<a id="more"></a>
<h3 id="方法2：分治法"><a href="#方法2：分治法" class="headerlink" title="方法2：分治法"></a>方法2：分治法</h3><p>从最底层走到某个点[i,j]的最短路径长度可以分解为两个子问题：</p>
<ol>
<li>这个点自身的路径 长度+下一层左边节点路径长度</li>
<li>这个点自身的路径 长度+下一层左右边节点路径长度</li>
</ol>
<p>最终的结果需要取这两种情况的最小值。</p>
<p><strong>边界条件</strong>：最下面一层的最小路径长度是1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="comment">//边界条件：最下面一层的路径长度是0</span></div><div class="line">  <span class="keyword">int</span> height = triangles.size();</div><div class="line">  <span class="keyword">if</span>(x==height)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="comment">//其余点的路径长度是下一层左右两个路径长度+自身长度的最小值。</span></div><div class="line">  <span class="keyword">return</span> triangles.get(x).get(y) + Math.min(</div><div class="line">    divide(triangles,x+<span class="number">1</span>,y),</div><div class="line">    divide(triangles,x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(2^n)</script></p>
<h3 id="方法3：记忆化搜索"><a href="#方法3：记忆化搜索" class="headerlink" title="方法3：记忆化搜索"></a>方法3：记忆化搜索</h3><p>显然上面的方法有很多重复计算的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">  [x,y]</div><div class="line">    ↓    ↘</div><div class="line">[x+1,y] [x+1,y+1]</div><div class="line">   ↓      ↘ ↓       ↘</div><div class="line">[x+2,y] [x+2,y+1] [x+2,y+2]</div><div class="line">**/</div></pre></td></tr></table></figure>
<p>其中[x+2,y+1]就被重复计算了两次。</p>
<p>可以将这些多次重复计算的值存下来，计算过一次之后后面再用到就可以避免重复计算了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> best = Integer.MAX_VALUE;</div><div class="line">List&lt;List&lt;Integer&gt;&gt; tri = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">int</span>[][] hash;<span class="comment">//存储已经计算过的节点值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">memorySearch</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(x == tri.size()-<span class="number">1</span>)&#123;</div><div class="line">    hash[x][y]=tri.get(x).get(y);</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(hash[x][y]!= Integer.MAX_VALUE)&#123;</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  hash[x][y] = tri.get(x).get(y)+Math.min(</div><div class="line">    memorySearch(x+<span class="number">1</span>,y),</div><div class="line">    memorySearch(x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> hash[x][y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span> </span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangles.get(i).size();j++)&#123;</div><div class="line">      hash[i][j] = Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> memorySearch(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="comment">//return best;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(n^2)</script></p>
<h3 id="方法4：多重循环"><a href="#方法4：多重循环" class="headerlink" title="方法4：多重循环"></a>方法4：多重循环</h3><h4 id="实现方式1：自底向上"><a href="#实现方式1：自底向上" class="headerlink" title="实现方式1：自底向上"></a>实现方式1：自底向上</h4><p>从终点（最下面一层）出发，逐层向上至终点。</p>
<p><strong>状态：</strong>f[i,j]表示从最下面一层到点[i,j]最短路径长度</p>
<p><strong>方程：</strong>f[i,j] = a[i,j]+min(f[i+1,j],f[i+1,j+1])</p>
<p><strong>初始化：</strong>f[i,j] = a[i,j],其中i是最下面一行</p>
<p><strong>答案：</strong>f[0,0]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpUp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span></span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; triangles.size();i++)&#123;</div><div class="line">    hash[triangles.size()-<span class="number">1</span>][i] = triangles.get(triangles.size()-<span class="number">1</span>).get(i);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =triangles.size()-<span class="number">2</span>; i &gt;= <span class="number">0</span> ;i--)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;i+<span class="number">1</span>;j++)&#123;</div><div class="line">      hash[i][j] = triangles.get(i).get(j) + Math.min(hash[i+<span class="number">1</span>][j],hash[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现方式2：自顶向下"><a href="#实现方式2：自顶向下" class="headerlink" title="实现方式2：自顶向下"></a>实现方式2：自顶向下</h4><p>从起点（顶点）出发，逐层向下至最后一层。</p>
<p><strong>状态：</strong>f[i,j]表示从最顶点到点[i,j]最短路径长度</p>
<p><strong>方程：</strong>f[i,j] = a[i,j]+min(f[i-1,j-1],f[i-1,j])</p>
<p><strong>初始化：</strong>f[0,0] = a[0,0]</p>
<p><strong>答案：</strong>min(f[i,j]),其中i是最下面一层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpDown</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span></span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  hash[<span class="number">0</span>][<span class="number">0</span>] = triangles.get(<span class="number">0</span>).get(<span class="number">0</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; triangles.size();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;i+<span class="number">1</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j) + hash[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j) + hash[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j)+Math.min(hash[i-<span class="number">1</span>][j-<span class="number">1</span>],hash[i-<span class="number">1</span>][j]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; triangles.get(triangles.size()-<span class="number">1</span>).size();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(hash[triangles.size()-<span class="number">1</span>][i] &lt; min)&#123;</div><div class="line">      min = hash[triangles.size()-<span class="number">1</span>][i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><h3 id="什么时候用DP"><a href="#什么时候用DP" class="headerlink" title="什么时候用DP"></a>什么时候用DP</h3><p>三个条件满足其一则极有可能是需要用DP求解：</p>
<ol>
<li>求最大、最小值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
</ol>
<h3 id="什么时候不用DP"><a href="#什么时候不用DP" class="headerlink" title="什么时候不用DP"></a>什么时候不用DP</h3><p>三个条件满足其一则极不可能用DP：</p>
<ol>
<li>输出所有方案</li>
<li>给得是集合，不是序列（元素顺序不可换）</li>
<li>暴力算法的时间复杂度已经是多项式复杂度了（n^2,n^3）,dp擅长将指数复杂度优化到多相似复杂度</li>
</ol>
<h2 id="动态规划四要素："><a href="#动态规划四要素：" class="headerlink" title="动态规划四要素："></a>动态规划四要素：</h2><p><strong>状态</strong>：<code>f[][]</code>的含义，<strong>最难</strong>！</p>
<p><strong>方程</strong>：状态之间的联系，怎么用小状态算大状态</p>
<p><strong>初始化</strong>：最小状态是什么，起点</p>
<p><strong>答案</strong>：最大状态是什么，终点</p>
<p><strong>两种方法：</strong></p>
<ol>
<li>自顶向下：从起点出发到终点</li>
<li>自底向上：从终点出发，反推至起点</li>
</ol>
<p><strong>VS递归三要素</strong></p>
<ul>
<li>定义（状态）<ul>
<li>接受了什么参数</li>
<li>做了什么事情</li>
<li>返回了什么值</li>
</ul>
</li>
<li>拆解（方程）<ul>
<li>符合将参数变小</li>
</ul>
</li>
<li>出口（初始化）<ul>
<li>什么时候可以直接return</li>
</ul>
</li>
</ul>
<h2 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h2><h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">Minimum Path Sum</a></h2><blockquote>
<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,3,1],</div><div class="line">&gt;  [1,5,1],</div><div class="line">&gt;  [4,2,1]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given the above grid map, return </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 7</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>. Because the path 1→3→1→1→1 minimizes the sum.</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>坐标性动态规划</p>
<p><strong>状态：</strong>f[i,j]表示从(0,0)出发走到(i,j)的路径长度</p>
<p><strong>方程：</strong>f[i,j] = a[i,j] + min(f[i-1,j],f[i,j-1]),只能从左边和上边走过来</p>
<p><strong>初始化：</strong>初始化二维数组时，初始化第0行和第0列</p>
<p><strong>答案：</strong>f[end,end]</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</div><div class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            path[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + path[<span class="number">0</span>][i-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid.length;j++)&#123;</div><div class="line">            path[j][<span class="number">0</span>] = grid[j][<span class="number">0</span>] + path[j-<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                path[i][j] = grid[i][j] + Math.min(path[i - <span class="number">1</span>][j], path[i][j - <span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> path[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">Unique Paths</a></h2><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://leetcode.com/static/images/problemset/robot_maze.png" alt="img"></p>
</blockquote>
<p>求从左上角走到右下角的方案个数，到右下角可能从上面或者左边的点过来。</p>
<p><strong>状态</strong>：f[i,j]：从(0,0)到(i,j)的方案个数</p>
<p><strong>方程：</strong>f[i,j] = f[i-1,j]+f[i,j-1]，走到[i,j]有两种方式，从[i-1,j]和从[i,j-1]，两种方式方案数加和为走到[i,j]点的总方案数</p>
<p><strong>初始化：</strong>第0行和第0列的方案数为1，f[i,0]=f[0,j]=1</p>
<p><strong>结果：</strong>f[m,n]，右下角元素的状态值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePath</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] nums= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</div><div class="line">            nums[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">            nums[<span class="number">0</span>][i] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//计算f[i][j]</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n;j++)&#123;</div><div class="line">                nums[i][j] = nums[i-<span class="number">1</span>][j] + nums[i][j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[m-<span class="number">1</span>][n-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        UniquePath test = <span class="keyword">new</span> UniquePath();</div><div class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;<span class="keyword">int</span> n = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> res = test.uniquePaths(m,n);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii" target="_blank" rel="external">Unique Paths II</a></h2><blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p>For example,</p>
<p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [0,0,0],</div><div class="line">&gt;   [0,1,0],</div><div class="line">&gt;   [0,0,0]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The total number of unique paths is <code>2</code>.</p>
</blockquote>
<p>在上一题的基础上设置了一些障碍点，所以只需要对障碍点进行判断即可。遇到障碍点时方案数设置为1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePath2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</div><div class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] nums= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            nums[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>)&#123;</div><div class="line">                    nums[i][<span class="number">0</span>] = nums[i-<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    nums[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</div><div class="line">                <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i]!=<span class="number">1</span>)&#123;</div><div class="line">                    nums[<span class="number">0</span>][i] = nums[<span class="number">0</span>][i-<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    nums[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//计算f[i][j]</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n;j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                        nums[i][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        nums[i][j] = nums[i-<span class="number">1</span>][j] + nums[i][j-<span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> nums[m-<span class="number">1</span>][n-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs" target="_blank" rel="external">Climbing Stairs</a></h2><blockquote>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 2</div><div class="line">&gt; Output:  2</div><div class="line">&gt; Explanation:  There are two ways to climb to the top.</div><div class="line">&gt;</div><div class="line">&gt; 1. 1 step + 1 step</div><div class="line">&gt; 2. 2 steps</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 3</div><div class="line">&gt; Output:  3</div><div class="line">&gt; Explanation:  There are three ways to climb to the top.</div><div class="line">&gt;</div><div class="line">&gt; 1. 1 step + 1 step + 1 step</div><div class="line">&gt; 2. 1 step + 2 steps</div><div class="line">&gt; 3. 2 steps + 1 step</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看成是一维数组，从起点走到终点，每次只能走1或2步。</p>
<p><strong>状态：</strong>f[i]走到i点的方案数</p>
<p><strong>转移方程：</strong>f[i] = f[i-1]+f[i-1]，因为只能走一步或者两步，所以只能从前一个或者两个格子过来。</p>
<p><strong>初始化：</strong>f[0] = 1;f[1] = 1;f[2] = 2</p>
<p><strong>结果：</strong>f[n]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(n==<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  res[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  res[<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</div><div class="line">    res[i] = res[i-<span class="number">1</span>] +  res[i-<span class="number">2</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res[n-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a><a href="https://leetcode.com/problems/jump-game" target="_blank" rel="external">Jump Game</a></h2><p>动态规划可以做，但是贪心法是最优方法</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = <code>[2,3,1,1,4]</code>, return <code>true</code>.</p>
<p>A = <code>[3,2,1,0,4]</code>, return <code>false</code>.</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>数组中的数字表示当前点能够跳跃的最大步长，判断是否可以跳到最后一步：是否有可行方案问题</p>
<p>坐标型动态规划，一维坐标</p>
<p><strong>状态：</strong>s[i]，是否能从起点跳到i点</p>
<p>取决于前面是否存在点j：</p>
<ol>
<li>从起点是否能跳到j点：s[j]</li>
<li>从j是否能跳到i：j+s[j]&gt;=i</li>
</ol>
<p><strong>转移方程：</strong>s[i] = s[j] &amp;&amp; j+s[j]&gt;=i（j&lt;i）</p>
<p><strong>初始化：</strong>s[0]=1</p>
<p><strong>答案：</strong>s[m]，最后一个元素的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span>[] canJump = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">  canJump[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(canJump[j] &amp;&amp; j+nums[j]&gt;=i)&#123;</div><div class="line">        canJump[i] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> canJump[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n^2)</script>，提交后超时。</p>
<p>贪心法：</p>
<p>两个指针，一个从头向尾移动，另一个计算能够到达的最远距离。</p>
<p>需要注意的是：左侧指针向右移动时不能超过记录最远到达距离的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> farthest = nums[<span class="number">0</span>];</div><div class="line">  <span class="keyword">while</span>(farthest&lt;nums.length-<span class="number">1</span> &amp;&amp; i &lt; nums.length-<span class="number">1</span> &amp;&amp; i &lt;= farthest)&#123;</div><div class="line">    farthest = Math.max(farthest,i + nums[i]);</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> farthest &gt;= nums.length-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii" target="_blank" rel="external">Jump Game II</a></h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = <code>[2,3,1,1,4]</code></p>
<p>The minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)</p>
</blockquote>
<p>数组中的数字表示当前点能够跳跃的最大步长，求从起点到终点跳跃最少的方案跳跃次数</p>
<p>求最小，坐标型动态规划</p>
<p><strong>状态：</strong>s[i]从起点出发跳到i点需要步数</p>
<p><strong>转移方程：</strong>s[i] = min(s[j]+1),j满足条件可以一步跳到i，加个判断</p>
<p><strong>初始化：</strong>s[0] = 0</p>
<p><strong>答案：</strong>s[m]，最后一个元素状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[] minStep = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  minStep[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    minStep[i] = Integer.MAX_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(j + nums[j] &gt;= i)&#123;</div><div class="line">        minStep[i] = Math.min(minStep[i],minStep[j]+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> minStep[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n^2)</script>，提交后超时。</p>
<p>贪心法：</p>
<p>两个指针，一个从头向尾移动，另一个计算能够到达的最远距离。</p>
<p>需要注意的是：左侧指针向右移动时不能超过记录最远到达距离的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> farthest = nums[<span class="number">0</span>];</div><div class="line">  <span class="keyword">while</span>(farthest&lt;nums.length-<span class="number">1</span> &amp;&amp; i &lt; nums.length-<span class="number">1</span> &amp;&amp; i &lt;= farthest)&#123;</div><div class="line">    farthest = Math.max(farthest,i + nums[i]);</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> farthest &gt;= nums.length-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="external">Longest Increasing Subsequence</a></h2><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(<em>n2</em>) complexity.</p>
</blockquote>
<p>subqequence：子序列，可以跳着取</p>
<p>substring：子串，相连的，不可以跳着取</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP和二分法</p>
<p>判断是否使用DP：</p>
<ol>
<li>求最长</li>
<li>一维序列，元素位置不可交换</li>
<li>暴力复杂度是O(2^n)</li>
</ol>
<p>看成是小人跳木桩，数组的值为木桩的高度，小人每次踩一个更高的木桩</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p><strong>状态：</strong>f[i]表示从任意一个木桩出发，从低到高，跳到i点，最多踩过多少个木桩</p>
<p><strong>转移方程：</strong>f[i] = max(f[j]+1) j满足：j&lt;i &amp;&amp; nums[j]&lt;nums[i]</p>
<p><strong>初始化：</strong>f[0] = f[1] = …= f[n-1] = 1 从前面的任何一个点出发跳到此处要经过多少根木桩，初始化时，只经过自己跳到自己踩过的木桩树为1。</p>
<p><strong>结果：</strong>max(f[1],f[2],….,f[n-1]) 因为递增子序列不一定以最后一个元素为结尾，这道题要求的是最长的子序列，所以需要在所有的点里面找到最大的值返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] length = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    length[i] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</div><div class="line">        length[i] = Math.max(length[j]+<span class="number">1</span>,length[i]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> max = length[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; length.length;i++)&#123;</div><div class="line">    max = Math.max(max,length[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度<script type="math/tex">O(n^2)</script></p>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">tail[i] -&gt; 用于记录长度为i+<span class="number">1</span>个的LIS的子序列中末尾的【最小】值</div><div class="line">size -&gt; 用于记录最大长度。</div><div class="line"></div><div class="line">对于相同长度的LIS子序列，记录末尾值的最小值是因为以该最小值为末尾的子序列更有可能在后续过程中增加长度。</div><div class="line"></div><div class="line">以nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]为例：</div><div class="line">len = <span class="number">1</span>   :      [<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">6</span>], [<span class="number">3</span>]   =&gt; tails[<span class="number">0</span>] = <span class="number">3</span></div><div class="line">								<span class="comment">//长度为1的子序列中末尾值最小的是3</span></div><div class="line">len = <span class="number">2</span>   :      [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>]       =&gt; tails[<span class="number">1</span>] = <span class="number">5</span></div><div class="line">								<span class="comment">//长度为2的子序列中末尾值最小的是5</span></div><div class="line">len = <span class="number">3</span>   :      [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]            =&gt; tails[<span class="number">2</span>] = <span class="number">6</span></div><div class="line">								<span class="comment">//长度为3的子序列中末尾值最小的是6</span></div><div class="line"></div><div class="line">此时如果后面又来了一个x</div><div class="line">(<span class="number">1</span>) 如果x大于所有tails，那么此时会有长度更长的子序列，以x结尾。那就把这个x放在这个里面，并把长度+<span class="number">1</span></div><div class="line">(<span class="number">2</span>) 如果tails[i-<span class="number">1</span>] &lt; x &lt;= tails[i], 此时不会有长度更长的子序列，但是对于长度为i的子序列，选择x和tails[i]作为结尾相比而言，选择x作为结尾在后续过程中增加长度的可能性更大，所以我们用x更新 tails[i]</div><div class="line">size -&gt; 当前最长序列长度</div><div class="line">序[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</div><div class="line">以[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>]为例：</div><div class="line">i = <span class="number">0</span> --&gt; x = <span class="number">2</span>, tail = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></div><div class="line">[<span class="number">2</span>]   --&gt; 子序列 <span class="number">2</span></div><div class="line">  </div><div class="line">i = <span class="number">1</span> --&gt; x = <span class="number">1</span>, tail = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>] --&gt; 子序列[<span class="number">1</span>]</div><div class="line">i = <span class="number">2</span>   --&gt; x = <span class="number">5</span>, tail = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">5</span>]</div><div class="line">i = <span class="number">3</span>    --&gt; x = <span class="number">3</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>]</div><div class="line">i = <span class="number">4</span>       --&gt; x = <span class="number">6</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</div><div class="line">i = <span class="number">5</span>         --&gt; x = <span class="number">4</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">i = <span class="number">6</span>           --&gt; x = <span class="number">8</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line">i = <span class="number">7</span>             --&gt; x = <span class="number">9</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">i = <span class="number">8</span>               --&gt; x = <span class="number">7</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] tail = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span> , end = size;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span> ;</div><div class="line">            <span class="keyword">if</span>(tail[mid]&lt;nums[i])&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        tail[start] = nums[i];</div><div class="line">        <span class="keyword">if</span> (start == size) &#123;</div><div class="line">            size++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h2><p>状态：f[i]表示<strong>前i个</strong>位置/数字/字符，第i个…</p>
<p>方程：f[i] = g(f[j]),j是i前面的位置</p>
<p>初始化：f[0]</p>
<p>结果：f[n]</p>
<h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a><a href="https://leetcode.com/problems/word-break" target="_blank" rel="external">Word Break</a></h3><blockquote>
<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>
<p>For example, given<br><em>s</em> = <code>&quot;leetcode&quot;</code>,<br><em>dict</em> = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.</p>
<p>Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.</p>
</blockquote>
<p>给一串字母和单词表，判断是否可以被切分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：f[i]表示前i个字母是否可以被切分。</div><div class="line"></div><div class="line">转移方程：</div><div class="line"></div><div class="line">初始化：</div><div class="line"></div><div class="line">在单词的开始加“^”标记</div><div class="line"></div><div class="line">idx: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></div><div class="line">ch:  ^ l i n t c o d e</div><div class="line">f:   T f f f T f f f T</div><div class="line"></div><div class="line">初始化：</div><div class="line">idx: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></div><div class="line">ch:  ^ l i n t c o d e</div><div class="line">f:   T f f f </div><div class="line"></div><div class="line">计算f[<span class="number">4</span>]时将f[<span class="number">0</span>~<span class="number">4</span>]的字符串^ l i n t切割成如下几种方案：</div><div class="line">^ l i n|t  -&gt;  lin和t不在单词表</div><div class="line">^ l i|n t  -&gt;  li和nt不在单词表</div><div class="line">^ l|i n t  -&gt;  l和<span class="keyword">int</span>不在单词表</div><div class="line">^|l i nt   -&gt;  ^和lint不在单词表-&gt;f[<span class="number">4</span>] = T</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span>[] f;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n;i++)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</div><div class="line">      <span class="keyword">if</span>(f[j] &amp;&amp; substring[j,i] in dict)&#123;</div><div class="line">          f[i] = <span class="keyword">true</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">时间复杂度：O(n^<span class="number">2</span>^L),n为字符串长度，L为词典里的单词个数。</div><div class="line"></div><div class="line">优化：</div><div class="line">单词的长度一般不会特别长，设单词表里单词的最大长度为MAXL所以从后往前切割，切割MAXL次即可，如果此时没有答案的话，再继续往前切割也没有必要了。</div><div class="line">优化后的时间复杂度为： O(n^L^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<h3 id="Palindrome-Partitioning-II"><a href="#Palindrome-Partitioning-II" class="headerlink" title="Palindrome Partitioning II"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii" target="_blank" rel="external">Palindrome Partitioning II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Given a string s, partition s such that every substring of the partition is a palindrome.</div><div class="line"></div><div class="line">Return the minimum cuts needed <span class="keyword">for</span> a palindrome partitioning of s.</div><div class="line"></div><div class="line">For example, given s = <span class="string">"aab"</span>,</div><div class="line">Return <span class="number">1</span> since the palindrome partitioning [<span class="string">"aa"</span>,<span class="string">"b"</span>] could be produced using <span class="number">1</span> cut.</div></pre></td></tr></table></figure>
<p>将字符串切分使得每一段都是回文串，求最少要切几刀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：f[i]，从<span class="number">0</span>到</div><div class="line">方程：</div><div class="line">初始化：</div><div class="line">结果</div><div class="line"></div><div class="line">例子：<span class="string">"aabaa"</span></div><div class="line"></div><div class="line">关于初始化：</div><div class="line">在极端情况下，长度为n的字符串切n-<span class="number">1</span>刀，每一段都可以是回文串，长度为<span class="number">1</span>的字符串切<span class="number">0</span>刀，长度为<span class="number">0</span>的字符串切-<span class="number">1</span>刀</div><div class="line">所以f[<span class="number">0</span>] = -<span class="number">1</span></div><div class="line"></div><div class="line">关于f[i]的计算：</div><div class="line">对于从<span class="number">0</span>到i的子串的划分，可以划分成如下形式：</div><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...,i-<span class="number">1</span>|i</div><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...j,j+<span class="number">1</span>,...,i</div><div class="line"></div><div class="line"></div><div class="line">用一个二维数组f[i][j]存储字符串中从i到j是否是一个回文串</div></pre></td></tr></table></figure>
<h3 id="双序列型动态规划"><a href="#双序列型动态规划" class="headerlink" title="双序列型动态规划"></a>双序列型动态规划</h3><p>给两个序列</p>
<p>状态：f[i,j]表示第一个字符串的前i个，第二个字符串的前j个</p>
<p>转移方程：</p>
<p>初始化：f[i,0],f[0,j]</p>
<p>结果：f[n,m]</p>
<p>例题1：最长公共子序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a b c d </div><div class="line">a c d e</div><div class="line"></div><div class="line">f[abcd][acde] = max(f[abc][acde],f[abcd][acd])</div><div class="line"></div><div class="line">如果最后一个字母不相等，</div><div class="line">a[i-1]!=b[i-1]:</div><div class="line">f[i][j] = max(f[i-1][j],f[i][j-1])</div><div class="line"></div><div class="line">如果最后一个字母相等，则这个字母已经是公共子序列了，只需在前面的子序列基础之上+1即可</div><div class="line">a[i-1] == b[i-1]:</div><div class="line">f[i][j] = f[i-1][j-1]+1</div></pre></td></tr></table></figure>
<h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance" target="_blank" rel="external">Edit Distance</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>
<p>给定两个字符串，最少经过多少次修改可以使第一个字符串和诶二哥字符串一样。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">s1 = mart</div><div class="line">s2 = karma</div><div class="line"></div><div class="line">f[i][j]表示使得s1的前i个字符与s2的前j个字符相等的最少改动次数 </div><div class="line">共有三种操作方式</div><div class="line"></div><div class="line">用上面的例子说明：</div><div class="line"></div><div class="line">f[<span class="number">4</span>][<span class="number">5</span>]，为了使得s1的前<span class="number">4</span>个字符与s2的前<span class="number">5</span>个字符相等有三种操作方式：</div><div class="line"><span class="number">1</span>. f[<span class="number">3</span>][<span class="number">4</span>] + <span class="number">1</span> replace，替换s1的最后一个字符串，需要s1的前<span class="number">3</span>个字符串和s2的前<span class="number">4</span>个字符串相等的修改次数，加上replace的一次操作。</div><div class="line"><span class="number">2</span>. f[<span class="number">4</span>][<span class="number">4</span>] + <span class="number">1</span> insert，在s1后面插入一个字符<span class="string">'a'</span>，此时s1和s2的最后一个字符相等乐，需要将使得s1的前四个字符和s2的前<span class="number">4</span>个字符相等的操作数，加上insert的一次操作</div><div class="line"><span class="number">3</span>. f[<span class="number">3</span>][<span class="number">5</span>]+<span class="number">1</span> delete，将s1的最后一个字符串删除，需要s1的前三个字符串和s2的前<span class="number">5</span>个字符串相等的操作数加上删除的一次操作</div><div class="line"></div><div class="line">然后需要对上面三种情况取最小值。</div><div class="line"></div><div class="line"></div><div class="line">综上，</div><div class="line">状态：f[i][j]表示使得s1的前i个字符与s2的前j个字符相等的最少改动次数 </div><div class="line">转移方程为：</div><div class="line">f[i][j] = max(f[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,f[i][j-<span class="number">1</span>]+<span class="number">1</span>,f[-<span class="number">1</span>][j]+<span class="number">1</span>)</div><div class="line">初始化：f[i][<span class="number">0</span>] = i,f[<span class="number">0</span>][j] = j</div><div class="line">答案：f[n][m]</div></pre></td></tr></table></figure>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length();i++)&#123;</div><div class="line">    dis[i][<span class="number">0</span>] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word2.length();i++)&#123;</div><div class="line">    dis[<span class="number">0</span>][i] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length();j++)&#123;</div><div class="line">      <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</div><div class="line">        dis[i][j] = dis[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        dis[i][j] = Math.min(</div><div class="line">          dis[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,<span class="comment">//替换</span></div><div class="line">          Math.min(dis[i][j-<span class="number">1</span>]+<span class="number">1</span>,<span class="comment">//插入,</span></div><div class="line">                   dis[i-<span class="number">1</span>][j]+<span class="number">1</span>)<span class="comment">//删除</span></div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dis[word1.length()][word2.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Distinct-Subsequences"><a href="#Distinct-Subsequences" class="headerlink" title="Distinct Subsequences"></a><a href="https://leetcode.com/problems/distinct-subsequences" target="_blank" rel="external">Distinct Subsequences</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>Here is an example:<br><strong>S</strong> = <code>&quot;rabbbit&quot;</code>, <strong>T</strong> = <code>&quot;rabbit&quot;</code></p>
<p>Return <code>3</code>.</p>
</blockquote>
<p>从S中挑出T有多少种方法</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：f[i][j] -&gt; 从S的前i个字母中挑出T的前j个字母的方案数</div><div class="line"></div><div class="line">比如F[<span class="number">4</span>][<span class="number">3</span>]:</div><div class="line">从S的前<span class="number">4</span>个子母中选出T的前<span class="number">3</span>个字母有多少种方案：</div><div class="line">rabb</div><div class="line">rab</div><div class="line">此时最后一个字母相等，有两种选择方案：</div><div class="line"><span class="number">1</span>. 选择最后一个字母，则还需在S的前<span class="number">3</span>个中选择T的前<span class="number">2</span>个，此时方案数=F[<span class="number">3</span>][<span class="number">2</span>]</div><div class="line"><span class="number">2</span>. 不选择最后一个字母，则需要在S的前<span class="number">3</span>个中选择<span class="number">3</span>个，此时方案数=F[<span class="number">3</span>][<span class="number">3</span>]</div><div class="line">所以这种情况最终的方案数F[<span class="number">4</span>][<span class="number">3</span>] = F[<span class="number">3</span>][<span class="number">2</span>]+F[<span class="number">3</span>][<span class="number">3</span>]</div><div class="line"></div><div class="line">比如F[<span class="number">5</span>][<span class="number">5</span>]:</div><div class="line">rabbb</div><div class="line">rabbi</div><div class="line">此时最后一个字母不相等，那么此时无法选择最后一个字母，则方案数就等于从S的前<span class="number">4</span>个子母中挑出T的前<span class="number">5</span>个，即方案数F[<span class="number">5</span>][<span class="number">5</span>]=F[<span class="number">4</span>][<span class="number">5</span>]</div><div class="line"></div><div class="line">由此转移方程为：</div><div class="line">如果最后一个不相等，那就在S的前i-<span class="number">1</span>个字母中挑出T的前j个</div><div class="line">f[i][j] = f[i-<span class="number">1</span>][j]</div><div class="line">如果最后一个相等，可以在</div><div class="line">f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>]+f[i-<span class="number">1</span>][j]</div><div class="line"></div><div class="line">初始化：f[<span class="number">0</span>][i] = <span class="number">0</span>,f[i][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">结果：f[m][n]</div></pre></td></tr></table></figure>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  nums[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length();i++)&#123;</div><div class="line">    nums[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length();i++)&#123;</div><div class="line">    nums[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.length();i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= t.length();j++)&#123;</div><div class="line">      <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</div><div class="line">        nums[i][j] = nums[i-<span class="number">1</span>][j-<span class="number">1</span>]+nums[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        nums[i][j] = nums[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> nums[s.length()][t.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interleaving-String"><a href="#Interleaving-String" class="headerlink" title="Interleaving String"></a><a href="https://leetcode.com/problems/interleaving-string" target="_blank" rel="external">Interleaving String</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p>For example,<br>Given:<br><em>s1</em> = <code>&quot;aabcc&quot;</code>,<br><em>s2</em> = <code>&quot;dbbca&quot;</code>,</p>
<p>When <em>s3</em> = <code>&quot;aadbbcbcac&quot;</code>, return true.<br>When <em>s3</em> = <code>&quot;aadbbbaccc&quot;</code>, return false.</p>
</blockquote>
<p>三个字符串s1,s2,s3，判断s3是否可以由s1,s2交替组成（顺序不变，交替着选）</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">状态：</div><div class="line">f[i][j][k]:s1的前i个和s2的前j个是否能够交替组成s3的前k个</div><div class="line">k = i + j</div><div class="line">状态可以简化为：</div><div class="line">f[i][j]:s1的前i个和s2的前j个是否能够交替组成s3的前i+j个</div><div class="line"></div><div class="line">转移方程推导：</div><div class="line">f[i][j]=<span class="keyword">true</span>有如下两种情况：</div><div class="line"><span class="number">1</span>. 最后一个字母来自s1,s1的前i-<span class="number">1</span>个字母和s2的前j个字母能够交替组成s3的前i+j-<span class="number">1</span>个，即:s1[i]==s3[i+j] &amp;&amp; f[i-<span class="number">1</span>][j]==<span class="keyword">true</span></div><div class="line"><span class="number">2</span>. 最后一个字母来自s2,s2的前j-<span class="number">1</span>个字母和s1的前i个字母能够交替组成s3的前i+j-<span class="number">1</span>个，即:s2[i]==s3[i+j] &amp;&amp; f[i][j-<span class="number">1</span>]==<span class="keyword">true</span></div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">f[i][j] = (f[i-<span class="number">1</span>][j] &amp;&amp; s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>])||</div><div class="line">			(f[i][j-<span class="number">1</span>] &amp;&amp; s2[j-<span class="number">1</span>]==s3[i+j-<span class="number">1</span>])</div><div class="line"></div><div class="line">初始化：f[i][<span class="number">0</span>] = (s1[<span class="number">0</span>...i-<span class="number">1</span>] == s3[<span class="number">0</span>...i-<span class="number">1</span>])前半段都用s1</div><div class="line">		f[<span class="number">0</span>][j] = (s2[<span class="number">0</span>...j-<span class="number">1</span>] == s3[<span class="number">0</span>...j-<span class="number">1</span>])前半段都用s2</div><div class="line"></div><div class="line">结果：f[n][m]</div></pre></td></tr></table></figure>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length()+s2.length() != s3.length())</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length()+<span class="number">1</span>][s2.length()+<span class="number">1</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt;= s1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(flag)&#123;</div><div class="line">      <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">false</span>;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      dp[i][<span class="number">0</span>] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">boolean</span> flag2 = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt;= s2.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(flag2)&#123;</div><div class="line">      <span class="keyword">if</span>(s2.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">        flag2 = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.length();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.length();j++)&#123;</div><div class="line">      dp[i][j] = (dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>) ||</div><div class="line">                  (dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[s1.length()][s2.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】堆Heap&双端队列Dequeue]]></title>
      <url>/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%A0%86Heap/</url>
      <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul>
<li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p>
</li>
<li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p>
</li>
<li><p>Heap结构：</p>
<p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p>
</li>
</ul>
<ul>
<li><p>MaxHeap vs MinHeap</p>
<ul>
<li>MaxHeap：父亲节点比左右孩子都大</li>
<li>MinHeap：父亲节点比左右孩子都小</li>
</ul>
<p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p>
</li>
<li><p>堆的存储</p>
<p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p>
<p>对于元素A[i]：</p>
<ul>
<li>父节点：A[i-2/2] (右移1)</li>
<li>左孩子：A[2i+1] (左移1，可得到2i)</li>
<li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>插入操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line">	<span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">	<span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span>		<span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">     	 <span class="number">1</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		<span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     	<span class="number">100</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>			<span class="number">2</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>		</div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">10</span>	</div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">     	 <span class="number">2</span></div><div class="line">    ↙  		↘</div><div class="line">   <span class="number">3</span>		  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  	</div><div class="line"><span class="number">4</span>      <span class="number">5</span>	 <span class="number">100</span>	</div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure>
<p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p>
<p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p>
<p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p>
<p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="构建堆，堆维护"><a href="#构建堆，堆维护" class="headerlink" title="构建堆，堆维护"></a>构建堆，堆维护</h4><p>上面提到了增加和删除节点的操作，下面通过实例说明如何从一个数组开始<strong>构建一个堆</strong>：</p>
<p>假设我们有数组<code>4,1,3,2,16,9,10,14,8,7</code></p>
<p>它的形状为：</p>
<p><a href="https://ooo.0o0.ooo/2017/11/03/59fc1f33088db.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/11/03/59fc1f33088db.png" alt="img"></a></p>
<p>当然最暴力的方式就是从最后一个元素【7】开始，向上以此对树进行维护。但事实上由于后[n/2]个元素都是根节点，不需要进行维护。因此我们只需要维护前[n/2]个节点。</p>
<p>具体步骤如下图所示：</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-13-17.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-13-17.png" alt="img"></a></p>
<p>伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BUILD-MAX-HEAP(A)</div><div class="line">	A.heap.size = A.length</div><div class="line">	for i = [A.length/2] downto 1</div><div class="line">      MAX-HEAPIFTY(A,i)</div></pre></td></tr></table></figure>
<p>根据上面的方法，我们可以将一个数组构建成一个堆，堆顶的元素是最大的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] A;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</div><div class="line"></div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    MyHeap(<span class="keyword">int</span>[] a)&#123;</div><div class="line">        <span class="keyword">this</span>.A = a;</div><div class="line">        heapSize = a.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//交换堆中元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = A[i];</div><div class="line">        A[i] = A[j];</div><div class="line">        A[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//堆维护（最大堆）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="comment">//计算左孩子和右孩子在数组中的坐标。</span></div><div class="line">        <span class="keyword">int</span> leftChild = <span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> rightChild = <span class="number">2</span>*i+<span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="comment">//找到左右孩子和该节点本身中最大的</span></div><div class="line">        <span class="keyword">int</span> largest = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(leftChild &lt; heapSize &amp;&amp; A[i] &lt; A[leftChild])&#123;<span class="comment">//如果有左孩子而且左孩子比父亲大</span></div><div class="line">            largest = leftChild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            largest = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rightChild &lt; heapSize &amp;&amp; A[largest] &lt; A[rightChild])&#123;<span class="comment">//如果有右孩子而且左孩子比当前最大的大</span></div><div class="line">            largest = rightChild;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(largest!= i)&#123;<span class="comment">//如果最大的不是该节点，是其孩子，则需要交换，维护</span></div><div class="line">            swap(i,largest);</div><div class="line">            heapify(largest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构建最大堆</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (heapSize-<span class="number">2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">            heapify(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">        MyHeap test = <span class="keyword">new</span> MyHeap(nums);</div><div class="line">        test.build();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</div><div class="line">            System.out.print(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度分析:</strong></p>
<p>在高度为h的结点上运行MAX-HEAPIFY的代价是O(h)O(h)，因此建树的总代价为：</p>
<script type="math/tex; mode=display">\sum_{h=0}^{lgn}O(h)=O(n\sum_{h=0}^{lgn}\frac{h}{2^h})=O(n)</script><p>因此堆排序的时间复杂度为<script type="math/tex">O(n)</script></p>
<h4 id="删除节点POP"><a href="#删除节点POP" class="headerlink" title="删除节点POP"></a>删除节点POP</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//删除节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Poll</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> top = A[<span class="number">0</span>];</div><div class="line">    swap(<span class="number">0</span>, heapSize-<span class="number">1</span>);<span class="comment">//交换第一个和最后一个节点</span></div><div class="line">    heapSize--;</div><div class="line">    heapify(<span class="number">0</span>);<span class="comment">//shiftdown 维护</span></div><div class="line">    <span class="keyword">return</span> top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//插入之后向上shift</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> parentID = (i-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(parentID &gt; -<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &gt; A[parentID])&#123;</div><div class="line">            swap(i,parentID);</div><div class="line">            shiftUp(parentID);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//插入节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    A[heapSize] = i;</div><div class="line">    heapSize++;</div><div class="line">    shiftUp(heapSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序就是利用堆的性质，依次将堆顶元素出堆，每次堆顶元素出堆之后堆会自动维护，所以可以保证弹出的节点是有序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//堆排序</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] HeapSort()&#123;</div><div class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heapSize];</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> size = heapSize;</div><div class="line">    <span class="keyword">while</span>(i &lt; size)&#123;</div><div class="line">        res[i] = Poll();<span class="comment">//堆顶元素出堆</span></div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(nlogn)</script></p>
<p>n次出堆，每次出堆维护时间logn</p>
<h2 id="HashHeap"><a href="#HashHeap" class="headerlink" title="HashHeap"></a>HashHeap</h2><p>哈希堆，Hashheap是用一个hashMap优化了的heap，方便快速定位某个值在heap中的位置。与heap相比，HashHeap多了一个用来指示元素位置的索引。</p>
<p>HashHeap的结构有点特殊，很神奇，需要多看几遍，其中包括两个结构heap和hashmap:</p>
<ol>
<li>heap存储元素的值</li>
<li>HashMap存储元素在heap中<strong>对应的位置和出现的次数</strong></li>
</ol>
<p>这里存储出现次数是因为，有些时候，堆中可能会有重复的元素，如果只存储其位置的话，某个值就会在多个位置上，需要用一个链表来存储所有的位置，这样不仅存储起来不方便，计算也很不方便，所以很巧妙地，我们将同一个值的元素都放到heap中的同一个位置，在hashmap中存储该位置有多少个该元素，这样堆中的每个节点元素的值也不相同了，各种计算操作起来也方便了，完美~</p>
<p>java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">//hashheap实现，以最大堆为例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashHeap</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Node&gt; map;<span class="comment">//存储元素在堆中的索引和出现的次数</span></div><div class="line">    ArrayList&lt;Integer&gt; heap;<span class="comment">//存储元素值</span></div><div class="line">    <span class="keyword">int</span> heapSize;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;<span class="comment">//节点在堆中的位置</span></div><div class="line">        <span class="keyword">int</span> count;<span class="comment">//该数值出现次数</span></div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> count)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//构造函数</span></div><div class="line">    HashHeap()&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.heap = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.heapSize = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//由数组构建最大堆</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</div><div class="line">            Add(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//交换堆中节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="comment">//获取ij在堆中指向的元素值</span></div><div class="line">        <span class="keyword">int</span> vali = heap.get(i);</div><div class="line">        <span class="keyword">int</span> valj = heap.get(j);</div><div class="line"></div><div class="line">        <span class="comment">//获取两个值在map中的个数</span></div><div class="line">        <span class="keyword">int</span> counti = map.get(vali).count;</div><div class="line">        <span class="keyword">int</span> countj = map.get(valj).count;</div><div class="line"></div><div class="line">        <span class="comment">//修改hashmap，把两个值对应的位置互换，count不变</span></div><div class="line">        map.put(vali,<span class="keyword">new</span> Node(j,counti));</div><div class="line">        map.put(valj,<span class="keyword">new</span> Node(i,countj));</div><div class="line"></div><div class="line">        <span class="comment">//交换堆中的节点值</span></div><div class="line">        heap.set(i,valj);</div><div class="line">        heap.set(j,vali);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//向上交换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> parentIdx = (idx-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(parentIdx &gt; -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(heap.get(parentIdx) &lt; heap.get(idx))&#123;</div><div class="line">                swap(idx,parentIdx);</div><div class="line">                ShiftUp(parentIdx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//向下交换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> leftChildIdx = <span class="number">2</span> * idx+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> rightChildIdx = <span class="number">2</span> * idx+<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> largestIdx = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(leftChildIdx &lt; heapSize &amp;&amp; heap.get(idx) &lt; heap.get(leftChildIdx))&#123;</div><div class="line">            largestIdx = leftChildIdx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            largestIdx = idx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rightChildIdx &lt; heapSize &amp;&amp; heap.get(largestIdx) &lt; heap.get(rightChildIdx))&#123;</div><div class="line">            largestIdx = rightChildIdx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(largestIdx != idx)&#123;</div><div class="line">            swap(idx,largestIdx);</div><div class="line">            ShiftDown(largestIdx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//插入元素，值为n</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="comment">//如果堆中已经有该元素了,放在原来的位置，heap不用动，map计数+1</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(n))&#123;</div><div class="line">            map.put(n,<span class="keyword">new</span> Node(map.get(n).idx,map.get(n).count+<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果堆中没有该元素</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(n,<span class="keyword">new</span> Node(heapSize,<span class="number">1</span>));</div><div class="line">            heap.add(n);</div><div class="line">            heapSize++;</div><div class="line">            ShiftUp(heapSize-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx = map.get(n).idx;</div><div class="line">        <span class="keyword">int</span> count = map.get(n).count;</div><div class="line">        <span class="comment">//如果该值的节点只有一个</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</div><div class="line">            swap(idx,heapSize-<span class="number">1</span>);</div><div class="line">            map.remove(n);<span class="comment">///在map中删除</span></div><div class="line">            heapSize--;</div><div class="line">            ShiftDown(idx);<span class="comment">//交换之后需要向下维护</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果该值的节点有多个，heap不用动，map里count-1</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(n, <span class="keyword">new</span> Node(idx, count - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//弹出节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> peakVal = heap.get(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> idx = map.get(peakVal).idx;</div><div class="line">        <span class="keyword">int</span> count = map.get(peakVal).count;</div><div class="line">        <span class="comment">//如果堆中只有一个该节点,需要与最后一个交换后维护，</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//与最后一个交换</span></div><div class="line">            swap(<span class="number">0</span>,heapSize-<span class="number">1</span>);</div><div class="line">            heapSize--;</div><div class="line">            ShiftDown(<span class="number">0</span>);</div><div class="line">            map.remove(peakVal);<span class="comment">//在map中删除</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果堆中有多个，heap不用变，map中对应count--；</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(peakVal,<span class="keyword">new</span> Node(idx,count-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> peakVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取堆顶元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Peek</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> heap.get(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//堆排序</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">HeapSort</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> size = heapSize;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; size)&#123;</div><div class="line">            res.add(Pop());</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        HashHeap test = <span class="keyword">new</span> HashHeap();</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</div><div class="line">        test.Build(nums);</div><div class="line">        test.Add(<span class="number">8</span>);</div><div class="line">        test.Remove(<span class="number">3</span>);</div><div class="line">        List&lt;Integer&gt; res = test.HeapSort();</div><div class="line">        System.out.print(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">Trapping Rain Water</a></h3><blockquote>
<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>
<p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt="img"></p>
</blockquote>
<p>向柱子中灌水，求能够灌水的总量。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>可以从边缘向内灌水，灌水的高度不会超过边缘柱子的高度的最小值，所以说：<strong>边缘高度奠定了灌水的基调</strong></p>
<p>从低的一边（高度为h）向内灌水，能够灌水的量为（h-h_temp），遇到更高的柱子时，更新边缘。</p>
<p>显然，这是一个<strong>双指针</strong>问题。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-31-18.png" alt=""> </p>
<p>开始时，令总水量sum=0，双指针指向边缘，左选择较小的向内移动，假如选择左边指针。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-32-16.png" alt=""> </p>
<p>sum += 1，指针继续向右移动</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-33-23.png" alt=""> </p>
<p>此时左边指针遇到了跟高的边缘，右边指针开始向内移动</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-34-14.png" alt=""> </p>
<p>右边指针也同样遇到了更高的柱子，此时再从左右两边指针中选择一个较小的向内移动，假如选的依然是左边的，向内移动，更新sum，知道遇到更高的柱子</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-35-36.png" alt=""> </p>
<p>右侧指针左移，直到两指针相遇。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</div><div class="line">            <span class="keyword">int</span> min = height[left];</div><div class="line">            left++;</div><div class="line">            <span class="keyword">while</span>(height[left]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[left];</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">int</span> min = height[right];</div><div class="line">            right--;</div><div class="line">            <span class="keyword">while</span>(height[right]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[right];</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Trapping-Rain-Water-II"><a href="#Trapping-Rain-Water-II" class="headerlink" title="Trapping Rain Water II"></a><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">Trapping Rain Water II</a></h3><blockquote>
<p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p>
<p><strong>Note:</strong><br>Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 3x6 height map:</div><div class="line">&gt; [</div><div class="line">&gt;   [1,4,3,1,3,2],</div><div class="line">&gt;   [3,2,1,3,2,4],</div><div class="line">&gt;   [2,3,3,2,3,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; Return 4.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><img src="https://leetcode.com/static/images/problemset/rainwater_empty.png" alt="img"><br>The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.</p>
<p><img src="https://leetcode.com/static/images/problemset/rainwater_fill.png" alt="img"><br>After the rain, water are trapped between the blocks. The total volume of water trapped is 4.</p>
</blockquote>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>这一题是上一题在二维空间上的扩展。</p>
<p>对比上一题的思路，上一题的围墙是左右两边的柱子，而这道题的围墙是矩阵四周一圈的墙。我们可以从最矮的墙头向内灌水，然后将被灌水的位置加入围墙。</p>
<p>有两个要解决的点：</p>
<ol>
<li>找到围墙中最矮的墙头</li>
<li>从最矮的墙头向围墙内灌水，要知道那边是围墙“内”</li>
</ol>
<p>对于第1点，要求围墙中最矮的墙头，且墙头是动态插入的，可以维护一个最小堆，每次出堆元素即为最小的。</p>
<p>对于第2点，可以额外维护一个标记数组，记录是否已经被访问过，每次入堆就将该点对应的位置标记，若某一点没有被标记则是在围墙内。</p>
<p>以上图为例：</p>
<p>首先将四周设为围墙，将围墙元素入堆[1,4,3,1,3,2,3,4,2,3,3,2,3,1]</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-30-45.png" alt=""> </p>
<p>选取围墙中最小的，向内灌水，比如：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-53-16.png" alt=""> </p>
<p>由于3&gt;1，不能灌水，将3所在位置加入围墙[<del>1</del>,4,3,1,3,2,3,4,2,3,3,2,3,1, 3]</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-55-43.png" alt=""> </p>
<p>然后依次选取高度为1的其他几个围墙作为最矮的围墙，发现都不能够往里灌水，接下来选择高度为2的围墙，发现也不能向内灌水了，选取高度为3的围墙，比如：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-56-45.png" alt=""> </p>
<p>发现可以灌水量为2，然后将此点灌水后的高度加入围墙，[<del>1</del>,4,<del>3</del>,<del>1,</del>3,<del>2</del>,3,4,<del>2</del>,3,3,<del>2</del>,3,<del>1</del>,3,  3]：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-11-03-13.png" alt=""> </p>
<p>继续重复上边的步骤，知道堆为空</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRain2</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        Node(<span class="keyword">int</span> val,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node e1,Node e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1.val-e2.val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(heightMap.length == <span class="number">0</span> || heightMap[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[heightMap.length][heightMap[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(cmp);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="comment">//初始边界入堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heightMap.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; heightMap[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == heightMap.length-<span class="number">1</span> || j == heightMap[<span class="number">0</span>].length-<span class="number">1</span>)&#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(heightMap[i][j],i,j));</div><div class="line">                    visited[i][j] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            Node top =  heap.peek();</div><div class="line">            heap.remove();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">                <span class="keyword">int</span> x_new = top.x+x_delta[i];</div><div class="line">                <span class="keyword">int</span> y_new = top.y+y_delta[i];</div><div class="line">                <span class="keyword">if</span>(x_new &gt;=<span class="number">0</span> &amp;&amp; x_new &lt; heightMap.length &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt; heightMap[<span class="number">0</span>].length &amp;&amp; !visited[x_new][y_new])&#123;</div><div class="line">                    <span class="keyword">if</span>(heightMap[x_new][y_new] &lt; top.val)&#123;</div><div class="line">                        sum += top.val-heightMap[x_new][y_new];</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(top.val,x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(heightMap[x_new][y_new],x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    visited[x_new][y_new] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TrappingRain2 test = <span class="keyword">new</span> TrappingRain2();</div><div class="line">        <span class="keyword">int</span>[][] heightMap = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> sum = test.trapRainWater(heightMap);</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Top-K-Frequent-Words"><a href="#Top-K-Frequent-Words" class="headerlink" title="Top K Frequent Words"></a><a href="https://leetcode.com/problems/top-k-frequent-words/" target="_blank" rel="external">Top K Frequent Words</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a non-empty list of words, return the <em>k</em> most frequent elements.</p>
<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</div><div class="line">&gt; Output: [&quot;i&quot;, &quot;love&quot;]</div><div class="line">&gt; Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.</div><div class="line">&gt;     Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</div><div class="line">&gt; Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</div><div class="line">&gt; Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words,</div><div class="line">&gt;     with the number of occurrence being 4, 3, 2 and 1 respectively.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Input words contain only lowercase letters.</li>
</ol>
<p><strong>Follow up:</strong></p>
<ol>
<li>Try to solve it in <em>O</em>(<em>n</em> log <em>k</em>) time and <em>O</em>(<em>n</em>) extra space.</li>
</ol>
</blockquote>
<p>给定一个字符串数组，要求返回出现次数最多的前K个字符串，如果遇到多个字符串年出现次数相同时，则优先取字典序小的字符串。</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>正常的能够想到的思路是用一个hashmap记录每个单词出现的次数，然后放入一个堆中，堆的排序依据是出现次数多的排在前面，出现次数一样多的，字典序小的排在前面，将全部字符放入堆之后弹出前K个，就得到了出现次数最多的前K个，复杂度:<script type="math/tex">O(nlogn)</script></p>
<p><strong>follow up</strong> : 要求我们用时<script type="math/tex">O(nlogn)</script> ，也就是说我们只需要维护大小为K的堆，因此，我们应该采用“最小堆”而非“最大堆”，堆顶元素是当前出现次数最小的，所以当下一次有新元素加进来的时候，如果堆的大小超过了k，就可以把堆顶这个出现次数最少的元素弹掉了，这样一来，最后堆中剩下的k个元素都是出现次数最多得了，是不是很神奇~！！！！</p>
<p>所以这道题我们的堆应该是这样的：</p>
<ol>
<li>出现次数少的优先出堆</li>
<li>出现次数一样的，字典序大的优先出队</li>
<li>堆的大小为k,当堆中元素个数超过k时，手动poll出堆</li>
</ol>
<p>这样一来，堆的大小就一直都只有K，时间复杂度就降到<script type="math/tex">O(klogn)</script> 了。这在数据量很大的情况下是十分有必要的！！比如我们要在100亿个数字中找到最大的K个，如果用之前的建堆方法就要建一个100亿大的堆。。。超恐怖，但现在，无论多少数据，我们的堆也只有k那么大了~~~~</p>
<p>ps: 这里还学到了一个<strong>比较器的神奇写法</strong>，见注释，可以在比较器中调用map中的count来进行比较诶，这样heap里面就可以只存String了。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKFrequentWords</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        String word;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        Node(String word,<span class="keyword">int</span> count)&#123;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">            <span class="keyword">this</span>.word = word;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.count!= o2.count) <span class="keyword">return</span> o1.count-o2.count;<span class="comment">//出现次数少的排在前面</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span>(o1.word.compareTo(o2.word) &lt; <span class="number">0</span>)&#123;<span class="comment">//在字母表中位置靠后的排在前面</span></div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"><span class="comment">//        Comparator&lt;String&gt; cmp2 = new Comparator&lt;String&gt;() &#123;</span></div><div class="line"><span class="comment">//            @Override</span></div><div class="line"><span class="comment">//            public int compare(String o1, String o2) &#123;</span></div><div class="line"><span class="comment">//                int o1Count = map.get(o1), o2Count = map.get(o2);</span></div><div class="line"><span class="comment">//                if(o1Count!= o2Count) return o1Count-o2Count;//出现次数少的排在前面</span></div><div class="line"><span class="comment">//                else &#123;</span></div><div class="line"><span class="comment">//                    return o2.compareTo(o1);</span></div><div class="line"><span class="comment">//                &#125;</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;;</span></div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</div><div class="line">        <span class="keyword">for</span>(String word : words)&#123;</div><div class="line">            map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(String word:map.keySet())&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(word,map.get(word)));</div><div class="line">            <span class="comment">//手动控制heap大小</span></div><div class="line">            <span class="keyword">if</span>(heap.size() &gt; k)&#123;</div><div class="line">                heap.poll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</div><div class="line">            res.add(heap.poll().word);</div><div class="line">        &#125;</div><div class="line">        Collections.reverse(res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Median-from-Data-Stream"><a href="#Find-Median-from-Data-Stream" class="headerlink" title="Find Median from Data Stream"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="external">Find Median from Data Stream</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples: </p>
<p><code>[2,3,4]</code> , the median is <code>3</code></p>
<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code></p>
<p>Design a data structure that supports the following two operations:</p>
<ul>
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; addNum(1)</div><div class="line">&gt; addNum(2)</div><div class="line">&gt; findMedian() -&gt; 1.5</div><div class="line">&gt; addNum(3) </div><div class="line">&gt; findMedian() -&gt; 2</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>数据以流的方式给出，实现加入数字和获取中位数的方法。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>baseline:每次加入数字之后排序，然后计算中位数，时间复杂度：<script type="math/tex">O(n^2logn)</script></p>
<p><strong>优化：</strong></p>
<p>中位数：将元素分成两堆，一堆比中位数小，一堆比中位数大</p>
<p>在中位数左右设置两个堆，每次进来一个元素，和中位数比较，如果大于中位数，放到右边的堆中（小顶堆），比中位数小放到左边堆中（大顶堆）。</p>
<p>入堆之后，需要比较左右两个堆的元素个数，当两边数字个之差超过2时，则需要将多的一遍的元素挪出一个去另一边，以保证两边元素个数之差&lt;=1</p>
<p>另外，每次需更新中位数，当左右两堆元素个数相等时，中位数为两个堆顶元素均值；当左右两堆元素个数相差一时，中位数为多的那个堆的堆顶元素</p>
<p>时间复杂度：<script type="math/tex">O(nlogn)</script> ,n个元素入堆，入堆操作<script type="math/tex">O(logn)</script></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</div><div class="line">    PriorityQueue&lt;Integer&gt; maxHeap;<span class="comment">//左边最大对</span></div><div class="line">    PriorityQueue&lt;Integer&gt; minHeap;<span class="comment">//右边最小堆</span></div><div class="line">    <span class="keyword">int</span> leftSum;</div><div class="line">    <span class="keyword">int</span> rightSum;</div><div class="line">    <span class="keyword">double</span> median;</div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</div><div class="line">        Comparator&lt;Integer&gt; maxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o2-o1;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(maxCmp);</div><div class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</div><div class="line">        leftSum = <span class="number">0</span>;</div><div class="line">        rightSum = <span class="number">0</span>;</div><div class="line">        median = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果两个堆都是空的,默认先放到右边堆中</span></div><div class="line">        <span class="keyword">if</span>(minHeap.isEmpty() &amp;&amp; maxHeap.isEmpty())&#123;</div><div class="line">            minHeap.add(num);</div><div class="line">            rightSum++;</div><div class="line">            median = num;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//加入的值大于中位数，放入右边的堆</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; median)&#123;</div><div class="line">            minHeap.add(num);</div><div class="line">            rightSum++;</div><div class="line">            <span class="comment">//如果右边比左边多两个了，需要挪出一个去左边</span></div><div class="line">            <span class="keyword">if</span>(rightSum-leftSum == <span class="number">2</span>)&#123;</div><div class="line">                maxHeap.add(minHeap.poll());</div><div class="line">                leftSum++;</div><div class="line">                rightSum--;</div><div class="line">            &#125;<span class="comment">//此时两边元素相等或者右边比左边多一个</span></div><div class="line">            <span class="keyword">if</span>(rightSum &gt; leftSum)&#123;</div><div class="line">                median = minHeap.peek();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                median = (minHeap.peek() + maxHeap.peek())/<span class="number">2.0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//否则，放入左边的堆</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            maxHeap.add(num);</div><div class="line">            leftSum++;</div><div class="line">            <span class="comment">//如果右边比左边多两个了，需要挪出一个去左边</span></div><div class="line">            <span class="keyword">if</span>(leftSum-rightSum == <span class="number">2</span>)&#123;</div><div class="line">                minHeap.add(maxHeap.poll());</div><div class="line">                leftSum--;</div><div class="line">                rightSum++;</div><div class="line">            &#125;<span class="comment">//此时两边元素相等或者右边比左边多一个</span></div><div class="line">            <span class="keyword">if</span>(leftSum &gt; rightSum)&#123;</div><div class="line">                median = maxHeap.peek();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                median = (minHeap.peek() + maxHeap.peek())/<span class="number">2.0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> median;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></div><div class="line"><span class="comment"> * obj.addNum(num);</span></div><div class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
<h3 id="Sliding-Window-Median"><a href="#Sliding-Window-Median" class="headerlink" title="Sliding Window Median"></a><a href="https://leetcode.com/problems/sliding-window-median" target="_blank" rel="external">Sliding Window Median</a></h3><p>上一题的follow up</p>
<h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples: </p>
<p><code>[2,3,4]</code> , the median is <code>3</code></p>
<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code></p>
<p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Window position                Median</div><div class="line">&gt; ---------------               -----</div><div class="line">&gt; [1  3  -1] -3  5  3  6  7       1</div><div class="line">&gt;  1 [3  -1  -3] 5  3  6  7       -1</div><div class="line">&gt;  1  3 [-1  -3  5] 3  6  7       -1</div><div class="line">&gt;  1  3  -1 [-3  5  3] 6  7       3</div><div class="line">&gt;  1  3  -1  -3 [5  3  6] 7       5</div><div class="line">&gt;  1  3  -1  -3  5 [3  6  7]      6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code>.</p>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><h1 id="Dqueue双端队列"><a href="#Dqueue双端队列" class="headerlink" title="Dqueue双端队列"></a>Dqueue双端队列</h1><p>可以从两段进行插入和删除</p>
<h3 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="external">Sliding Window Maximum</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Window position                Max</div><div class="line">&gt; ---------------               -----</div><div class="line">&gt; [1  3  -1] -3  5  3  6  7       3</div><div class="line">&gt;  1 [3  -1  -3] 5  3  6  7       3</div><div class="line">&gt;  1  3 [-1  -3  5] 3  6  7       5</div><div class="line">&gt;  1  3  -1 [-3  5  3] 6  7       5</div><div class="line">&gt;  1  3  -1  -3 [5  3  6] 7       6</div><div class="line">&gt;  1  3  -1  -3  5 [3  6  7]      7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
</blockquote>
<p>给定数组和窗口大小，要求返回窗口滑动过程中每一个位置的最大值。</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Heap </tag>
            
            <tag> Dequeue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2——扫描线]]></title>
      <url>/2017/11/17/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
      <content type="html"><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h2 id="lintcode391-数飞机"><a href="#lintcode391-数飞机" class="headerlink" title="lintcode391. 数飞机"></a><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给出飞机的起飞和降落时间的列表，用 interval 序列表示. 请计算出天上同时最多有多少架飞机？</p>
<p>样例</p>
<p>对于每架飞机的起降时间列表：<code>[[1,10],[2,3],[5,8],[4,7]]</code>, 返回<code>3</code>。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-17-20-40-58.png" alt=""> </p>
<p>计算空中的飞机个数，可以看成用一个线从左到右扫描的过程，计算每一时刻空中飞机的数量。</p>
<p>优化：只计算所有线段起始位置时天上的飞机即可，因为只有起始点是可能发生变化的点。遇到起点，天上的飞机数+1，遇到终点则-1。</p>
<p>因此，我们先将所有线段的起点、终点排序，并标记是起点还是终点，然后从小到大遍历这些点，遇到起点则+1，遇到终点-1，返回过程中最大的数值即为空中飞机数的最大值。</p>
<p><strong>需要注意的是</strong>：在同一点上会同时有开始点和结尾点，此时应该把结尾点放在前面，否则会出现多计算的情况。</p>
<a id="more"></a>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.operations.Bool;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">airplane_count</span> </span>&#123;</div><div class="line">    <span class="comment">//Definition of Interval:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span></span>&#123;</div><div class="line">        Integer start, end;</div><div class="line">        Interval(Integer start, Integer end) &#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Definition of node:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line">        Integer val;</div><div class="line">        <span class="keyword">boolean</span> isstart;</div><div class="line">        Node(Integer val, <span class="keyword">boolean</span> isstart) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.isstart = isstart;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//定义排序接口</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node Other)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.val == Other.val)&#123;<span class="comment">//如果连个节点位置相同，把结束点排在前面</span></div><div class="line">                <span class="keyword">return</span> Boolean.compare(<span class="keyword">this</span>.isstart,Other.isstart);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.val, Other.val);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(List&lt;Interval&gt; airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> size = airplanes.size();</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        Node[] array = <span class="keyword">new</span> Node[<span class="number">2</span> * size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.size(); i++) &#123;</div><div class="line">            array[<span class="number">2</span> * i] = (<span class="keyword">new</span> Node(airplanes.get(i).start, <span class="keyword">true</span>));</div><div class="line">            array[<span class="number">2</span> * i + <span class="number">1</span>] = (<span class="keyword">new</span> Node(airplanes.get(i).end, <span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(array);</div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i].isstart) &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252.Meeting Rooms"></a><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), determine if a person could attend all meetings.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>false</code>.</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目是说判断一个人是否可以参加给出的所有的会议，可以沿用扫描线的思路：同一时刻最多只有一个会议正在召开，就可以参加所有会议。</p>
<p>还有另外一种更快的思路：</p>
<p>如果每一个会议的开始都在上一个会议结束之后，那么就不会有时间冲突的会议，就可以都参加了，所以可以将给出的所有会议的开始时间和结束时间分别放入两个数组中，分别排序，然后判断是否所有的时间满足：starts[i]&gt;ends[i-1]。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line"></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.length; i++) &#123;</div><div class="line">            starts[i] = airplanes[i].start;</div><div class="line">            ends[i] = airplanes[i].end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(starts);</div><div class="line">        Arrays.sort(ends);</div><div class="line"></div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; starts.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (starts[i]&lt;ends[i-<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253.Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></h2><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p>
</blockquote>
<p>给定一系列会议的开始和结束时间，返回所需的最大会议室数量</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p>
<p>用扫描线模拟扫描过程，计算扫描线最多同时扫描几个区间。</p>
<p>方法二：</p>
<p>分别对会议开始和结束的时间排序，两个指针ij分别指向开始数组和结束数组，当start[i] &lt; end[j]时，i++;sum++;</p>
<p>否则j++,记录最大的sum。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> time,<span class="keyword">boolean</span> isStart)&#123;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(tmp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].start,<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].end,<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(heap.poll().isStart)&#123;</div><div class="line">                sum++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;sum--;&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            starts[i] = intervals[i].start;</div><div class="line">            ends[i] = intervals[i].end;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(starts);</div><div class="line">        Arrays.sort(ends);</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; starts.length &amp;&amp; j &lt; ends.length)&#123;</div><div class="line">            <span class="keyword">if</span>(starts[i] &lt; ends[j])&#123;</div><div class="line">                sum++;</div><div class="line">                i++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                j++;</div><div class="line">                sum--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218.The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem" target="_blank" rel="external">218.The Skyline Problem</a></h2><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<hr>
<p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p>
<p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt="Buildings"> </p>
<p><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt="Skyline Contour"></p>
<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p>
<p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>
</blockquote>
<p>题目给定每一个建筑的起始结束位置和其高度，返回建筑物构成的轮廓的拐点坐标。</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>根据观察，可以用扫描线的思路解决。</p>
<p>首先需要将建筑物的开始和结束节点及其对应的高度加入堆heap中，按照坐标从小到大进行排序，当坐标一致的时候，将结束点排在前面。</p>
<p>另外，还需要一个堆heightTemp来维护当前扫描线扫过的建筑的高度，以便迅速知道当前的最大高度。</p>
<p>接下来，将节点依次出堆模拟扫描线扫描的过程，分下面两种情况：</p>
<ol>
<li>遇到起始点:<ol>
<li>该点的高度大于当前最大高度，需要将该点坐标以及高度加入结果集，同时将高度加入heightTemp</li>
<li>该点的高度不大于当前最大高度，则只需将该点高度加入heightTemp，无需加入结果集。</li>
</ol>
</li>
<li>遇到结束点：<ol>
<li>该点高度就是当前最大高度，则需要将最大高度从heightTemp中pop出去，然后将该点坐标和pop之后的当前最大高度加入结果集。</li>
<li>该点高度小于当前最大高度，只需将该点高度从heightTemp中pop出去。</li>
</ol>
</li>
</ol>
<p>实现上面的算法之后，还不够，因为忽略了在同一个位置有多个点出现的情况，比如某个位置即是A建筑的结束也是B建筑的开始位置，将它们都加入的结果集，显然是重复的，需要筛选掉只剩一个，分如下两种情况：</p>
<ol>
<li>在某个点有多个建筑结束  —&gt; 取最后一个结束的，也就是高度最低的</li>
<li>在某个点有多个建筑开始  —&gt;  取高度最高的</li>
<li>在某个点既有建筑开始也有建筑结束，但前后高度不一样  —&gt; 取开始高度最高的</li>
<li>在某个点既有建筑开始也有建筑结束，但前后高度一样  —&gt; 不加入最终结果集</li>
</ol>
<p>基于上面的思路，可以开始写代码了</p>
<p>据说这道题还可以用线段树做，待学习。。。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheSkylineProblem</span> </span>&#123;</div><div class="line">  <span class="comment">//节点，包含坐标，高度，开始点or结束点</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> loc;</div><div class="line">        <span class="keyword">int</span> height;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> loc,<span class="keyword">int</span> height,<span class="keyword">boolean</span> isStart) &#123;</div><div class="line">            <span class="keyword">this</span>.loc = loc;</div><div class="line">            <span class="keyword">this</span>.height = height;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">      <span class="comment">//Node堆，排序依据：坐标小的优先，坐标相同的结束点优先，起始和结束相同的高度高的优先。</span></div><div class="line">       Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.loc != o2.loc)<span class="keyword">return</span> o1.loc - o2.loc;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == o2.isStart)&#123;</div><div class="line">                        <span class="keyword">return</span> o1.height - o2.height;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span>(o1.isStart==<span class="keyword">true</span>)&#123;</div><div class="line">                         <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">	<span class="comment">//最大堆，用于存放扫描线扫过的建筑的高度</span></div><div class="line">        Comparator&lt;Integer&gt; MaxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o2-o1;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">      <span class="comment">//堆声明</span></div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</div><div class="line">        PriorityQueue&lt;Integer&gt; heightTemp = <span class="keyword">new</span> PriorityQueue&lt;&gt;(MaxCmp);</div><div class="line">      <span class="comment">//将给定数据点入堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; buildings.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(buildings[i][<span class="number">0</span>],buildings[i][<span class="number">2</span>],<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(buildings[i][<span class="number">1</span>],buildings[i][<span class="number">2</span>],<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//数据点出堆，模拟扫描过程</span></div><div class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</div><div class="line">            Node node = heap.poll();<span class="comment">//出堆</span></div><div class="line">            <span class="comment">//是开始节点</span></div><div class="line">            <span class="keyword">if</span>(node.isStart)&#123;</div><div class="line">                <span class="comment">//如果高于当前最大高度，将坐标和对应高度加入结果集，同时标记为开始节点</span></div><div class="line">                <span class="keyword">if</span>(heightTemp.isEmpty() || node.height &gt; heightTemp.peek())&#123;</div><div class="line">                    result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;node.loc,node.height,<span class="number">1</span>&#125;);</div><div class="line">                    heightTemp.add(node.height);</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果没有高于当前最大高度，仅加入当前高度对，不加入结果集</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heightTemp.add(node.height);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//是结束节点</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果该节点对应的高度就是当前最大高度</span></div><div class="line">                <span class="keyword">if</span>(!heightTemp.isEmpty() &amp;&amp; node.height == heightTemp.peek())&#123;</div><div class="line">                    <span class="comment">//将最大高度从当前高度堆中弹出</span></div><div class="line">                    heightTemp.poll();</div><div class="line">                    <span class="keyword">if</span>(heightTemp.isEmpty())&#123;</div><div class="line">                        <span class="comment">//结果集中加入当前剩余的最大高度</span></div><div class="line">                        result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;node.loc,<span class="number">0</span>,<span class="number">0</span>&#125;);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//结果集中加入当前剩余的最大高度</span></div><div class="line">                        result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;node.loc,heightTemp.peek(),<span class="number">0</span>&#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果该节点对应的高度小于当前最大高度，则将该高度从当前高度对中移除</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heightTemp.remove(node.height);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//对结果集中节点进行处理，主要处理两种情况:</span></div><div class="line">      <span class="comment">//1.同一位置有多个点，包括开始点和结束点</span></div><div class="line">      <span class="comment">//2.在某一位置，有结束点和开始点，但前后高度一样</span></div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; result2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; result.size() &amp;&amp; j &lt; result.size())&#123;</div><div class="line">            <span class="keyword">int</span> maxTemp = result.get(i)[<span class="number">1</span>];</div><div class="line">          <span class="comment">//相同位置有多个节点情况</span></div><div class="line">            <span class="keyword">while</span> (j &lt; result.size() &amp;&amp; result.get(i)[<span class="number">0</span>] == result.get(j)[<span class="number">0</span>])&#123;</div><div class="line">                <span class="comment">//在结束节点中选最低的</span></div><div class="line">                <span class="keyword">if</span>(result.get(j)[<span class="number">2</span>] == <span class="number">0</span>)&#123;</div><div class="line">                    maxTemp = Math.min(maxTemp,result.get(j)[<span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//在开始节点中选最高的</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    maxTemp = Math.max(maxTemp,result.get(j)[<span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//如果跟前一个高度不一致，才加入最终结果集</span></div><div class="line">            <span class="keyword">if</span>(result2.isEmpty() || result2.get(result2.size()-<span class="number">1</span>)[<span class="number">1</span>] != maxTemp)&#123;</div><div class="line">                result2.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;result.get(i)[<span class="number">0</span>],maxTemp&#125;);</div><div class="line">            &#125;</div><div class="line">            i = j;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//返回最终结果集</span></div><div class="line">        <span class="keyword">return</span> result2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> sweep_line </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/11/16/%E3%80%90leetcode%E3%80%91%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81/</url>
      <content type="html"><![CDATA[<p>leetcode刷题总结</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">208.Implement Trie (Prefix Tree)</a></td>
<td>实现一个Trie树模板，支持插入、搜索、前缀搜索操作</td>
<td>Trie</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">211.Add and Search Word - Data structure design</a></td>
<td>实现Trie树的插入、搜索，支持搜索”a.b”格式，”.”表示通配符</td>
<td>Trie+DFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">677.Map Sum Pairs</a></td>
<td>单词有权重，输入前缀词，给出所有以此为前缀的词的权重之和</td>
<td>Trie+DFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">200.Number of Islands</a></td>
<td>统计中有0,1，相邻1为island，统计island个数(连通子图)</td>
<td>并查集、DFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-islands-ii/" target="_blank" rel="external">305.Number of Islands II</a></td>
<td>初始矩阵为0，每次随机将某一位改变成1，统计每一时刻island个数</td>
<td>并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="external">130.Surrounded Regions</a></td>
<td>“XXOO”将被X包围的O改成X，处于边界的O不算被包围</td>
<td>DFS、并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="external">261.Graph Valid Tree</a></td>
<td>给定点集和边集，判断此图是否为树</td>
<td>并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="external">323.Number of Connected Components in an Undirected Graph</a></td>
<td>给定点集和边集，返回连通子图个数</td>
<td>并查集</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/word-search" target="_blank" rel="external">79.Word Search</a></td>
<td>给一个字母矩阵和一个单词，查找字母矩阵中是否有该单词</td>
<td>回溯+BFS</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">212.Word Search II</a></td>
<td>给一个字母矩阵和一个单词数组，返回数组，里面包含出现在矩阵中的所有单词</td>
<td>Trie+DFS</td>
<td></td>
</tr>
<tr>
<td><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></td>
<td>给定一些区间，求同一时刻空中最多有多少飞机</td>
<td>扫描线</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></td>
<td>给定一些区间，判断是否可以参加所有会议（所有会议没有冲突）</td>
<td>排序扫描/扫描线</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></td>
<td>给定一些区间，求最多需要多少间会议室（最多有多少会议同时开）</td>
<td>扫描线</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">42.Trapping Rain Water</a></td>
<td>一维接雨水</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">407.Trapping Rain Water II</a></td>
<td>二维接雨水</td>
<td>堆</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">62.Unique Paths</a></td>
<td>从网格左上角走到右下角有多少种方案</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/unique-paths-ii" target="_blank" rel="external">63.Unique Paths II</a></td>
<td>从网格左上角走到右下角有多少种方案，有一些障碍点</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">120.Triangle</a></td>
<td>给定一个三角形，求从顶端走到最下面的最短路径</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/climbing-stairs" target="_blank" rel="external">70.Climbing Stairs</a></td>
<td>爬楼梯，每次只可以爬一步或者两步，求爬到顶有多少种方案</td>
<td>DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/jump-game" target="_blank" rel="external">55.Jump Game</a></td>
<td></td>
<td>贪心法</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/jump-game-ii" target="_blank" rel="external">45.Jump Game II</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">145.Binary Tree Postorder Traversal</a></td>
<td>二叉树的后续遍历</td>
<td>DFS、递归、回溯</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">94.Binary Tree Inorder Traversal</a></td>
<td>二叉树的中续遍历</td>
<td>DFS、递归、回溯</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">144.Binary Tree Preorder Traversal</a></td>
<td>二叉树的前续遍历</td>
<td>DFS、递归、回溯</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">226.Invert Binary Tree</a></td>
<td>二叉树对称翻转</td>
<td>分治法、递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="external">100.Same Tree</a></td>
<td>判断两个二叉树是否相同</td>
<td>递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="external">236.Lowest Common Ancestor of a Binary Tree</a></td>
<td>求二叉树中两个节点的最近公共祖先</td>
<td>分治法、递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="external">110.Balanced Binary Tree</a></td>
<td>给定一个二叉树，判断是否是平衡二叉树</td>
<td>递归</td>
<td>额外resultTypt判断是否平衡以及最大深度差</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">104.Maximum Depth of Binary Tree</a></td>
<td>给定二叉树，求其最大深度</td>
<td>分治法、递归</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="external">97.Interleaving String</a></td>
<td>给定三个字符串s1,s2,s3,返回s3是否能够由s1和s2组成，s1,s2中字母顺序不变</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="external">115.Distinct Subsequences</a></td>
<td>给定字符串S和T，从S中选取字母构成T共有多少种方案</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="external">72.Edit Distance</a></td>
<td>给定两字符串s1,s2和三种操作：插入、删除、替换，最少经过多少步操作可以使得s1和s2一样</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/palindromic-substrings/" target="_blank" rel="external">647.Palindromic Substrings</a></td>
<td>给定一个字符串，返回其中回文串个数</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="external">132.Palindrome Partitioning II</a></td>
<td>给定一个字符串，最少切几刀可以使每一段都是回文串</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="external">139.Word Break</a></td>
<td>给定一个字符串和一个单词表，返回字符串是否可以切割成全部由单词表中的单词组成</td>
<td>序列型DP</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="external">334.Increasing Triplet Subsequence</a></td>
<td>给定一个数组，返回是否有递增的三元组</td>
<td>两指针</td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="external">300.Longest Increasing Subsequence</a></td>
<td>给定一个序列，求其最长递增子序列的长度</td>
<td>坐标型DP</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/powx-n" target="_blank" rel="external">50.Pow(x, n)</a></td>
<td>求x的n次方</td>
<td>二分法+递归</td>
<td>int -&gt;long</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="external">29.Divide Two Integers</a></td>
<td>求两个数相除a/b</td>
<td>二分搜索。找到最大的x：x*b &lt;= a</td>
<td>边界条件-2147483648/-1</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">287.Find the Duplicate Number</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
<th>难易</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="external">328.Odd Even Linked List</a></td>
<td>给定链表，将偶数位放置在链表后，奇数位偶数位数字相对位置保持不变</td>
<td>链表</td>
<td></td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">234Palindrome Linked List</a></td>
<td>判断链表是否是回文串</td>
<td>回文，链表</td>
<td>1.找到链表中位数，将后半段反转，对比前后元素是否一致<br>2.利用stack，将前一半存起来，继续 向后扫描与stack中元素对比</td>
<td>难</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">160.Intersection of Two Linked Lists</a></td>
<td>找到两链表AA和B相交的位置</td>
<td>链表</td>
<td>两个指针分别遍历，一个先A后B，一个先B后A，两指针指向节点相等即为相交处</td>
<td>技巧题</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="external">147.Insertion Sort List</a></td>
<td>链表的插入排序</td>
<td>链表、插入排序</td>
<td>建dummy节点，原链表元素按序插入dummy节点开头的链表</td>
<td>技巧+中等</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="external">24.Swap Nodes in Pairs</a></td>
<td>从前向后，两两交换链表节点</td>
<td>链表、交换</td>
<td>从前向后遍历，两两交换</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="external">203.Remove Linked List Elements</a></td>
<td>给定链表和val，删除链表中所有值为val的元素</td>
<td>链表、删除节点</td>
<td>遍历，删除</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">2.Add Two Numbers</a></td>
<td>给定两个链表表示两个数字，位数由低到高，返回链表表示两个链表的和</td>
<td>链表</td>
<td>遍历相加，记录进位</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="external">445.Add Two Numbers II</a></td>
<td>给定两个链表表示两个数字，位数由高到低，返回链表表示两个链表的和</td>
<td>链表、反转</td>
<td>反转-&gt;相加-&gt;反转</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">109.Convert Sorted List to Binary Search Tree</a></td>
<td></td>
<td></td>
<td></td>
<td>难</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/plus-one-linked-list/" target="_blank" rel="external">369.Plus One Linked List</a></td>
<td>给定链表代表一个数字，由高位到低位，返回该数字+1链表</td>
<td>链表、反转</td>
<td>1.反转-&gt;相加-&gt;反转<br>2.递归<br>3.技巧：找从后向前第一个不为9的元素+1，后面9置0</td>
<td>简单+技巧</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/split-linked-list-in-parts/" target="_blank" rel="external">725.Split Linked List in Parts</a></td>
<td>给定一个链表和数字k，将链表分为k段，每段长度差不大于1，长的放前面</td>
<td>链表</td>
<td>1.求链表长度len<br>2.m = len/k,n = len%k<br>3.前n个链表长度为m+1，其余长度为m</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">25.Reverse Nodes in k-Group</a></td>
<td>给定链表和数字k，将链表分组，每组k个元素，按组反转</td>
<td>链表、反转</td>
<td>两指针指向分组头和尾，将头和尾之间的链表反转</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">109.Convert Sorted List to Binary Search Tree</a></td>
<td>链表转为高度平衡搜索二叉树</td>
<td>链表、二叉搜索树</td>
<td>递归，中点做为root，对左链表和右链表递归调用构建BST</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
<th>难易</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">88.Merge Sorted Array</a></td>
<td>合并两个有序数组到第一个数组</td>
<td>数组</td>
<td>从后向前遍历，比较大小依次从后向前插入nums1</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="external">349.Intersection of Two Arrays</a></td>
<td>找两个数组交集，去重</td>
<td>排序、hashmap</td>
<td>1.排序<br>2.两指针遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="external">350.Intersection of Two Arrays II</a></td>
<td>找两个数组交集</td>
<td>排序、hashmap</td>
<td>1.排序<br>2.两指针遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/sparse-matrix-multiplication" target="_blank" rel="external">311.Sparse Matrix Multiplication</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h1><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>题意</th>
<th>知识点</th>
<th>思路</th>
<th>难易</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/sort-transformed-array/" target="_blank" rel="external">360.Sort Transformed Array</a></td>
<td>给定有序数组，计算ax^2+bx+c，返回结果依然有序</td>
<td>two pointers</td>
<td>根据二次函数性质，a&gt;0先减后增，比较两指针，从后向前插入，a&lt;0反之</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/max-consecutive-ones" target="_blank" rel="external">485.Max Consecutive Ones</a></td>
<td>给定数组有0有1，返回连续1的最大长度</td>
<td>two pointers</td>
<td>两指针滑窗，记录当前最大长度，遇到0跳过重新开始</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/max-consecutive-ones-ii" target="_blank" rel="external">487.Max Consecutive Ones II</a></td>
<td>给定数组有0有1，最多可以把一个0变成1，返回连续1的最大长度</td>
<td>two pointers</td>
<td>两指针滑窗，记录窗口内0的个数，超过1缩小窗口大小，记录滑窗最大长度</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2——Trie树]]></title>
      <url>/2017/11/14/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91Trie%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="leetcode相关题目"><a href="#leetcode相关题目" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><ul>
<li><del><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></del></li>
<li><del><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></del></li>
<li><del><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></del></li>
<li>​</li>
</ul>
<h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p>
<p>Trie树，即字典树/前缀树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p>
<p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p>
<p>将单词插入Trie树，只在跟之前的字符串出现分歧时分裂，对最后一个字母做标记，这样查找的时候，根据最后一个字母的标记，即可判断出该单词是否出现过。</p>
<p>这里有一个巧妙的操作，可以让插入和查询操作同时完成，所以查询的时间复杂度简化为所要查询的单词的长度，即<script type="math/tex">O(1)</script>。</p>
<a id="more"></a>
<p>它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash_table</th>
<th>TIRE树</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找时间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td></td>
<td>优于hash_table</td>
</tr>
</tbody>
</table>
</div>
<p>对于a,aa,aaa,aaaa的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash</th>
<th>trie</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>10个a</td>
<td>5个a节点</td>
</tr>
<tr>
<td>可用操作</td>
<td>有/无/查询</td>
<td>有/无/前缀查询</td>
</tr>
<tr>
<td></td>
<td>1行</td>
<td>75~100行</td>
</tr>
</tbody>
</table>
</div>
<p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p>
<h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p>
<p>需要节约空间</p>
<p>查找前缀</p>
<h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>有两种方式来实现Trie树，对于存储char类型的Trie树，因为只有26个字母，故可采用映射的方式将字母映射到长度为26的数组上，而下标就是字母。</p>
<p>而对于其他类型，比如int数目未知，可以考虑用hashmap的方式来实现。</p>
<h3 id="1-hashmap实现Trie树"><a href="#1-hashmap实现Trie树" class="headerlink" title="1. hashmap实现Trie树"></a>1. hashmap实现Trie树</h3><p>c++版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">char</span> ch;</div><div class="line">	<span class="keyword">bool</span> istail;</div><div class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childern;</div><div class="line"></div><div class="line">	TrieNode() &#123;</div><div class="line">		childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line">		<span class="comment">//childern = NULL;</span></div><div class="line">		istail = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	TrieNode(<span class="keyword">char</span> c) &#123;</div><div class="line">		ch = c;</div><div class="line">		childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line">		<span class="comment">//childern = NULL;</span></div><div class="line">		istail = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	TrieNode* root;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="comment">/** Initialize your data structure here. */</span></div><div class="line">	Trie() &#123;</div><div class="line">		root = <span class="keyword">new</span> TrieNode();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** Inserts a word into the trie. */</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">		TrieNode* node = <span class="keyword">this</span>-&gt;root;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> chtemp = word[i];</div><div class="line">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">				iter = (*childrenmap).find(chtemp);</div><div class="line">				<span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">					node = iter-&gt;second;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					TrieNode* newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">					(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">					node = newnode;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; newmap;</div><div class="line">				TrieNode *newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">				(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">				node = newnode;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		node-&gt;istail = <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns if the word is in the trie. */</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (word.size() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		TrieNode* node = root;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> chtemp = word[i];</div><div class="line">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">				iter = (*childrenmap).find(chtemp);</div><div class="line">				<span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">					node = iter-&gt;second;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;<span class="comment">//children为空</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (node-&gt;ch == word[word.size() - <span class="number">1</span>] &amp;&amp; node-&gt;istail) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line">		TrieNode* node = root;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.size(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> chtemp = prefix[i];</div><div class="line">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line">				<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">				iter = (*childrenmap).find(chtemp);</div><div class="line">				<span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">					node = iter-&gt;second;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;<span class="comment">//children空</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>java版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        HashMap&lt;Character,TrieNode&gt; children;</div><div class="line">        <span class="keyword">boolean</span> istail;</div><div class="line">        TrieNode()&#123;</div><div class="line">            children = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">        TrieNode root;</div><div class="line">        Trie()&#123;</div><div class="line">            root = <span class="keyword">new</span> TrieNode();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;word.length();i++) &#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span> (node.children.containsKey(chtemp)) &#123;<span class="comment">//已经包含此字母</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">                    node.children.put(chtemp, <span class="keyword">new</span> TrieNode());</div><div class="line">                &#125;</div><div class="line">                node = node.children.get(chtemp);</div><div class="line">            &#125;</div><div class="line">            node.istail=<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(word.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length();i++)&#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(chtemp)) &#123;<span class="comment">//包含此字母</span></div><div class="line">                    node = node.children.get(chtemp);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(node.istail)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span> (prefix.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(prefix.charAt(i)))&#123;</div><div class="line">                    node = node.children.get(prefix.charAt(i));</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<h3 id="2-数组实现Trie树"><a href="#2-数组实现Trie树" class="headerlink" title="2. 数组实现Trie树"></a>2. 数组实现Trie树</h3><p>对于char类型的数据，只有26个字母，所以，可以用一个长度为26的数组存储后续的节点，数组index对应的就是字母的顺序：a~z</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[prefix.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="leetcode相关题目-1"><a href="#leetcode相关题目-1" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><h3 id="Add-and-Search-Word-Data-structure-design"><a href="#Add-and-Search-Word-Data-structure-design" class="headerlink" title="Add and Search Word - Data structure design"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Design a data structure that supports the following two operations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; void addWord(word)</div><div class="line">&gt; bool search(word)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; addWord(&quot;bad&quot;)</div><div class="line">&gt; addWord(&quot;dad&quot;)</div><div class="line">&gt; addWord(&quot;mad&quot;)</div><div class="line">&gt; search(&quot;pad&quot;) -&gt; false</div><div class="line">&gt; search(&quot;bad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;.ad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;b..&quot;) -&gt; true</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用Tire树，搜索时遇到”.”对所有节点进行DFS</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Adds a word into the data structure. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchHelper</span><span class="params">(String word,<span class="keyword">int</span> startIdx,TrieNode node)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIdx ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word.charAt(i) == <span class="string">'.'</span>)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>;j++) &#123;</div><div class="line">                    <span class="keyword">if</span> (node.children[j] != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//TrieNode nodetemp = node.children[j];</span></div><div class="line">                        <span class="keyword">boolean</span> has = searchHelper(word, i + <span class="number">1</span>, node.children[j]);</div><div class="line">                        <span class="keyword">if</span> (has) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> searchHelper(word,<span class="number">0</span>,<span class="keyword">this</span>.root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></div><div class="line"><span class="comment"> * obj.addWord(word);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
<h3 id="Map-Sum-Pairs"><a href="#Map-Sum-Pairs" class="headerlink" title="Map Sum Pairs"></a><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement a MapSum class with <code>insert</code>, and <code>sum</code> methods.</p>
<p>For the method <code>insert</code>, you’ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.</p>
<p>For the method <code>sum</code>, you’ll be given a string representing the prefix, and you need to return the sum of all the pairs’ value whose key starts with the prefix.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: insert(&quot;apple&quot;, 3), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 3</div><div class="line">&gt; Input: insert(&quot;app&quot;, 2), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 5</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>建立Trie树，将原来的标记是否为单词结尾的bool型属性改为int型权重属性，单词结尾的字母值为该单词的权重值，其余字母权重设为0，找到前缀所在分支之后，DFS该前缀词下面的所有节点，累加权重值。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">int</span> weight;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.weight = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; key.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[key.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[key.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[key.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.weight=val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode node)</span></span>&#123;</div><div class="line">        res = res+node.weight;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[i]!=<span class="keyword">null</span>)&#123;</div><div class="line">                dfs(node.children[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (node.children[prefix.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i) - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        res=<span class="number">0</span>;</div><div class="line">        dfs(node);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * MapSum obj = new MapSum();</span></div><div class="line"><span class="comment"> * obj.insert(key,val);</span></div><div class="line"><span class="comment"> * int param_2 = obj.sum(prefix);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
<h3 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,<br>Given <strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</div><div class="line">&gt;   [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Return </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [&quot;eat&quot;,&quot;oath&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>Word Search 1要求我们返回某一个单词是否在矩阵中，Word Search 2作为升级版。给出了一串单词，搜索是否在矩阵中，如果一个一个搜索效率会很低，尤其是在要搜索的单词序列中有大量相同的前缀时，所以，考虑<strong>将搜索的单词序列构建Trie树，然后再在字母矩阵中用DFS的方式搜索</strong>。</p>
<p>然而想到了思路，要想完整地写出这道题，也十分艰难。</p>
<p>这里有几个需要注意的点：</p>
<ol>
<li><p>要将能够搜索到的单词加入最终的结果表中，可以适当修改Trie的结构，在叶子节点存储该条路径对应的word，方便后续找到路径之后将该单词加入结果表</p>
</li>
<li><p>已经用过的字母不能用第二次，所以要对字母矩阵中遍历过的字母做标记，DFS搜索结束后要恢复标记，后面还可以继续使用。这里我一开始用的方法是额外建立一个boolean型矩阵进行存储，看了大神的代码发现可以直接在原字母矩阵中进行标记即可。</p>
</li>
<li><p>在矩阵中某点周围寻找下一个字母是否存在时，我一开始采用的方式是：</p>
<p>在Trie树中遍历下一层node中的字母然后再去字母矩阵中某点周围四个点搜索，这样遍历下一层node判断是否还有字母，每次需要遍历26个字母，看了大神的代码有更好的方式：</p>
<p>从矩阵当前点周围的四个点入手，获取周围四个点的字母（实际上最多是三个，因为至少已经有一个被访问了），然后再去node中直接获取下层节是否存在该字母即可。</p>
</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="comment">//boolean istail;//记录是否是某个单词的末尾</span></div><div class="line">        String word;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="comment">//this.istail=false;</span></div><div class="line">            <span class="keyword">this</span>.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.word = word;</div><div class="line">        <span class="comment">//node.istail=true;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchBoard</span><span class="params">(<span class="keyword">char</span>[][] board, TrieNode node,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,List&lt;String&gt; result)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> ch = board[x_idx][y_idx];</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'#'</span> || node.children[ch-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        node = node.children[ch-<span class="string">'a'</span>];</div><div class="line">        <span class="keyword">if</span>(node.word != <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(node.word);</div><div class="line">            node.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = <span class="string">'#'</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">            <span class="keyword">int</span> x = x_idx+x_delta[i];</div><div class="line">            <span class="keyword">int</span> y = y_idx+y_delta[i];</div><div class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length)&#123;</div><div class="line">                searchBoard(board,node,x,y,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = ch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length;i++)&#123;</div><div class="line">            insert(words[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board.length;j++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; board[<span class="number">0</span>].length;k++)&#123;</div><div class="line">                searchBoard(board,root,j,k,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Trie </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Logistic Regression相关]]></title>
      <url>/2017/11/06/Logistic-Regression%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>LR真的很基础而且也非常非常重要，算法面试必考，啃了好多遍，总结一下，希望能够经常复习。</p>
<p>暑假去头条面试，一面的面试官问到：</p>
<ol>
<li>推导一下LR吧</li>
<li>为什么要用sigmod函数</li>
<li>如何优化求解（梯度下降）</li>
<li>代码实现一下</li>
</ol>
<a id="more"></a>
<h2 id="LR模型推导"><a href="#LR模型推导" class="headerlink" title="LR模型推导"></a>LR模型推导</h2><h2 id="梯度下降求解LR"><a href="#梯度下降求解LR" class="headerlink" title="梯度下降求解LR"></a>梯度下降求解LR</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【神经网络和深度学习】课程笔记1]]></title>
      <url>/2017/11/06/%E3%80%90%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2——并查集]]></title>
      <url>/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="Union-Find并查集"><a href="#Union-Find并查集" class="headerlink" title="Union Find并查集"></a>Union Find并查集</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>一种用来解决集合查询合并的数据结构</strong></p>
<p>假如A、B、C三人在Microsoft工作，D、E、F、G四人在Linkedin工作，给七个人都分发一个工牌，上面写着自己的公司名字，告诉他们自己的老大是哪家公司，则可以表示成如下形式。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-10-31.png" alt=""></p>
<p>如果A遇到F，看一眼对方的工牌，跟自己是不是一个boss，就知道对方是不是跟自己是同一家公司的人了。</p>
<p>如果有一天M公司把L公司收购了，那么此时，需要对两个公司的员工进行合并操作，给员工分发新的工牌，为了减少重新分配的麻烦，就把L的boss指向M，此时L下面的员工最大的boss是M了，那么A和E就在一个阵营了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-15-16.png" alt=""></p>
<p>如果在M公司三个员工和L公司四个员工中分别选出一个作为该公司的boss，可以表示成如下形式：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-34.png" alt=""></p>
<p>那么合并之后，J的boss设置为B，此时大家都是一个阵营的了。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-45.png" alt=""></p>
 <a id="more"></a>
<h2 id="并查集的精髓"><a href="#并查集的精髓" class="headerlink" title="并查集的精髓"></a><strong>并查集的精髓</strong></h2><p>一共包含三个操作</p>
<ol>
<li><p>初始化</p>
<p>初始化操作中，每个元素的boss指向自己.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">HashMap&lt;Integer,Integer&gt; father = <span class="keyword">new</span> HashMap&lt;integer,integer&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    father.put(nums[i],nums[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>查找</p>
<p>查找元素所在的集合，也就是最大的boss。</p>
<p>如果要判断两个点是否属于同一个集合，就看这两个点的boss是否是同一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> parent = x;</div><div class="line">  <span class="keyword">while</span>(parent!=father.get(parent))&#123;</div><div class="line">    parent = fater.get(parent);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n)</script></p>
</li>
<li><p>合并</p>
<p>两个不想交的集合，其中一个的大boss认另一个为boss。</p>
<p>找到两个元素的boss，如果不是同一个，就把一个的boss指向另一个的boss。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> fa_x = find(x);</div><div class="line">  <span class="keyword">int</span> fa_y = find(y);</div><div class="line">  <span class="keyword">if</span>(fa_x != f_y)&#123;</div><div class="line">    father.put(fa_X,fa_y);<span class="comment">//合并两个boss</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<script type="math/tex">O(n)</script></p>
</li>
</ol>
<h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a><strong>并查集的优化</strong></h2><p>baseline的find流程：</p>
<p>如果有这样一条路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F</div></pre></td></tr></table></figure>
<p>查找A的boss时，需要遍历整个路径，寻找B、C、D时还需要再遍历一次，这显然是大量重复的工作，所以我们可以把一次遍历途中经过的节点都直接指向boss，下次再查询的时候，时间复杂的就是<script type="math/tex">O(1)</script>了，这就是<strong>带路径压缩的并查集</strong>的查找：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-41-32.png" alt=""></p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-42-34.png" alt=""></p>
<p>平均时间复杂度降至<script type="math/tex">O(1)</script></p>
<h2 id="并查集模板-c-版"><a href="#并查集模板-c-版" class="headerlink" title="并查集模板(c++版)"></a>并查集模板(c++版)</h2><ol>
<li><p>hash_map实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; father;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">//初始化并查集</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements)</span></span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; elements.size();i++)&#123;</div><div class="line">                father.insert(make_pair(elements[i],elements[i]));</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//并查集中插入操作，不支持删除</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> x_fa)</span></span>&#123;</div><div class="line">            father.insert(make_pair(x,x_fa));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在并查集中查找元素的boss</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> parent = x;</div><div class="line">            <span class="keyword">while</span>(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//带路径压缩的并查集</span></div><div class="line">            <span class="keyword">while</span>(father.find(x)-&gt;second != x)&#123;</div><div class="line">                x = father[x];</div><div class="line">                father[x] = parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//合并两个元素</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> x_father = findfather(x);</div><div class="line">            <span class="keyword">int</span> y_father = findfather(y);</div><div class="line">            <span class="keyword">if</span>(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//计算并查集中有多少个不想交的子集合</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">countsets</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; father_set;</div><div class="line">            <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter = father.begin();iter != father.end();iter++)&#123;</div><div class="line">                <span class="keyword">int</span> parent = findfather(iter-&gt;first);</div><div class="line">                iter-&gt;second = parent;</div><div class="line">                father_set.insert(parent);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>vector实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>用vector会比hashmap快，但如果数据很稀疏，空间复杂度会比较高。</p>
</li>
</ol>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul>
<li><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external"><del>leetcode200. Number of Islands</del></a></li>
<li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/" target="_blank" rel="external"><del>leetcode323. Number of Connected Components in an Undirected Graph</del></a></li>
<li><a href="https://leetcode.com/problems/number-of-islands-ii/description/" target="_blank" rel="external"><del>leetcode305. Number of Islands II</del></a></li>
<li><a href="https://leetcode.com/problems/graph-valid-tree/description/" target="_blank" rel="external"><del>leetcode261. Graph Valid Tree</del></a></li>
<li><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="external"><del>leetcode130. Surrounded Regions</del></a></li>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="external">leetcode128. Longest Consecutive Sequence</a></li>
<li><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="external">leetcode547. Friend Circles</a></li>
</ul>
<h3 id="leetcode200-Number-of-Islands"><a href="#leetcode200-Number-of-Islands" class="headerlink" title="leetcode200. Number of Islands"></a>leetcode200. Number of Islands</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11110</div><div class="line">&gt; 11010</div><div class="line">&gt; 11000</div><div class="line">&gt; 00000</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Answer: 1</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11000</div><div class="line">&gt; 11000</div><div class="line">&gt; 00100</div><div class="line">&gt; 00011</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Answer: 3</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目的意思是说矩阵中的1代表陆地，0代表海洋，如果某个1的上或下或左或右也是1的话，就是属于同一片陆地，要求矩阵中陆地的个数。也就是找出矩阵中连接子图的个数。</p>
<p>有两种思路：</p>
<ol>
<li><p>并查集</p>
<p>找出矩阵中子图的个数，可以利用并查集，在每个点附近做查找和合并操作，如果其周围有1，就讲其归为一类，最后返回并查集的集合个数就是所求的。</p>
<p>并查集处理二维矩阵时索引比较麻烦，所以这里需要先将二维坐标转化为一维并查集坐标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">矩阵维度：m*n</div><div class="line">二维坐标：(i,j) --&gt; 一维坐标：x*n+j</div><div class="line">一维坐标：idx     --&gt; 二维坐标：(idx/m,idx%m)</div></pre></td></tr></table></figure>
<p>经过坐标转化，可以使用并查集进行计算了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = grid.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    UnionFind unionfindset;<span class="comment">//声明并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; island;<span class="comment">//存储是1的元素</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isseen(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//记录是否遍历过</span></div><div class="line">    <span class="comment">//初始化,插入元素</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</div><div class="line">                <span class="comment">//father.insert(make_pair(i*cols+j,i*cols+j));</span></div><div class="line">                unionfindset.add(i*cols+j,i*cols+j);</div><div class="line">                island.push_back(&#123;i,j&#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; island.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> x_idx = island[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> y_idx = island[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> idx = x_idx*cols+y_idx;</div><div class="line">        <span class="keyword">if</span>(isseen[x_idx][y_idx]==<span class="number">0</span>)&#123;</div><div class="line">            isseen[x_idx][y_idx] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(x_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx<span class="number">-1</span>][y_idx]==<span class="string">'1'</span>)&#123;<span class="comment">//上</span></div><div class="line">                isseen[x_idx<span class="number">-1</span>][y_idx] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx-cols,idx);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(y_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx][y_idx<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;<span class="comment">//左</span></div><div class="line">                isseen[x_idx][y_idx<span class="number">-1</span>] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx<span class="number">-1</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> unionfindset.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>BFS/DFS</p>
<p>从矩阵中的一个1开始做深度或广度优先遍历，其周围能够遍历到的1都是跟其属于同片陆地的，把遍历过的陆地标记为0，并把count++；然后继续从下一个出现1的地方开始遍历，跟前面的操作一样，最后就可以得到count就是矩阵中陆地的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,<span class="keyword">int</span>&amp; rows,<span class="keyword">int</span>&amp; cols)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x_idx&lt;<span class="number">0</span> || x_idx &gt;=rows || y_idx&lt;<span class="number">0</span> || y_idx &gt;= cols || grid[x_idx][y_idx]==<span class="string">'0'</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    grid[x_idx][y_idx]=<span class="string">'0'</span>;</div><div class="line">    bfs(grid,x_idx,y_idx<span class="number">-1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx<span class="number">-1</span>,y_idx,rows,cols);</div><div class="line">    bfs(grid,x_idx,y_idx+<span class="number">1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx+<span class="number">1</span>,y_idx,rows,cols);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int numIslands(vector<vector<char>&gt;&amp; grid) {</vector<char></p>
<pre><code>int rows = grid.size();
if(rows==0){
    return 0;
}
int cols = grid[0].size();
if(cols==0){
    return 0;
}
//unordered_map&lt;int,int&gt; father;//并查集
//vector&lt;vector&lt;int&gt;&gt; island;//存储是1的元素
int count = 0;
for(int i = 0; i &lt; rows;i++){
    for(int j = 0 ; j &lt; cols;j++){
        if(grid[i][j]==&#39;1&#39;){
            count++;
            bfs(grid,i,j,rows,cols);
        }
    }
}
return count;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### leetcode305.Number of Islands II </div><div class="line"></div><div class="line">#### 题目</div><div class="line">&gt; A 2d grid map of `m` rows and `n` columns is initially filled with water. We may perform an *addLand* operation which turns the water at position (row, col) into a land. Given a list of positions to operate, **count the number of islands after each addLand operation**. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</div><div class="line">&gt;</div><div class="line">&gt; **Example:**</div><div class="line">&gt;</div><div class="line">&gt; Given `m = 3, n = 3`, `positions = [[0,0], [0,1], [1,2], [2,1]]`.</div><div class="line">&gt; Initially, the 2d grid `grid` is filled with water. (Assume 0 represents water and 1 represents land).</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>0 0 0<br>0 0 0<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 0 0<br>0 0 0   Number of islands = 1<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 1 0<br>0 0 0   Number of islands = 1<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 1 0<br>0 0 1   Number of islands = 2<br>0 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>1 1 0<br>0 0 1   Number of islands = 3<br>0 1 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; We return the result as an array: `[1, 1, 2, 3]`</div><div class="line"></div><div class="line">一个矩阵，元素都是0，代表海洋，每次选择一个元素标记为1，代表陆地，输出每轮矩阵中的island个数。</div><div class="line"></div><div class="line">#### 思路</div><div class="line"></div><div class="line">这道题目跟上面题目不同的地方在于这次是每次选择一个点进行更新，所以如果每次用DFS/BFS遍历的话，会有大量重复的运算，如果用并查集，则只需要每次对于新加入的island对其周围进行检查然后对并查集进行更新即可。</div><div class="line"></div><div class="line">#### 代码</div><div class="line"></div><div class="line">​```c++</div><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">public:</div><div class="line">vector&lt;int&gt; numIslands2(int m, int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; positions) &#123;</div><div class="line">    int count = 0;</div><div class="line">    vector&lt;int&gt; results;</div><div class="line">    UnionFind UnionFindset;</div><div class="line">    vector&lt;int&gt; x_add = &#123;0,0,1,-1&#125;;</div><div class="line">    vector&lt;int&gt; y_add = &#123;1,-1,0,0&#125;;</div><div class="line">    //初始化地图</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; mapmatrix(m,vector&lt;int&gt;(n,0));</div><div class="line">    for(int i = 0; i &lt; positions.size();i++)&#123;</div><div class="line">        int x = positions[i].first;</div><div class="line">        int y = positions[i].second;</div><div class="line">        mapmatrix[x][y] = 1;</div><div class="line">        int idx_demension_one = x*n+y;</div><div class="line">        UnionFindset.add(idx_demension_one,idx_demension_one);//加入并查集</div><div class="line">        count++;</div><div class="line">        for(int j = 0 ; j &lt; 4;j++)&#123;</div><div class="line">            //相邻元素的坐标</div><div class="line">            int x_neighbor = x+x_add[j];</div><div class="line">            int y_neighbor = y+y_add[j];</div><div class="line">            int idx_demension_one_neighbor = x_neighbor*n+y_neighbor;</div><div class="line">            //如果相邻元素还在地图中，而且是陆地（val=1）</div><div class="line">            if(x_neighbor&gt;=0 &amp;&amp; x_neighbor&lt;m &amp;&amp; y_neighbor&gt;=0 &amp;&amp; y_neighbor&lt;n &amp;&amp; mapmatrix[x_neighbor][y_neighbor]==1 &amp;&amp; UnionFindset.findfather(idx_demension_one) != UnionFindset.findfather(idx_demension_one_neighbor))&#123;</div><div class="line">                UnionFindset.unionset(idx_demension_one,idx_demension_one_neighbor);</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        results.push_back(count);</div><div class="line">    &#125;</div><div class="line">    return results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="leetcode261-Graph-Valid-Tree"><a href="#leetcode261-Graph-Valid-Tree" class="headerlink" title="leetcode261. Graph Valid Tree"></a>leetcode261. Graph Valid Tree</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.</p>
<p><strong>Note</strong>: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code>and thus will not appear together in <code>edges</code>.</p>
</blockquote>
<p>给定n个节点和节点之间的边集，判断由这些节点和边集是否能够构成树。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>给定n个几点和边集构成树的条件有两个：</p>
<ol>
<li>所有的点都在一个并查集中，也就是都属于一个root节点</li>
<li>不能有环</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        <span class="keyword">int</span> start_fa = UnionFindgraph.findfather(start);</div><div class="line">        <span class="keyword">int</span> end_fa = UnionFindgraph.findfather(end);</div><div class="line">        <span class="keyword">if</span>(start_fa == end_fa)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            UnionFindgraph.unionset(start_fa,end_fa);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(UnionFindgraph.countsets()==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph"><a href="#leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph" class="headerlink" title="leetcode323. Number of Connected Components in an Undirected Graph"></a>leetcode323. Number of Connected Components in an Undirected Graph</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0          3</div><div class="line">&gt;      |          |</div><div class="line">&gt;      1 --- 2    4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, return <code>2</code>.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0           4</div><div class="line">&gt;      |           |</div><div class="line">&gt;      1 --- 2 --- 3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</code>, return <code>1</code>.</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>判断矩阵中联通子图图的个数，遍历边集，将边首尾节点合并，最终的并查集boss数就是联通子图的个数。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        UnionFindgraph.unionset(start,end);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> UnionFindgraph.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="leetcode130-Surrounded-Regions"><a href="#leetcode130-Surrounded-Regions" class="headerlink" title="leetcode130. Surrounded Regions"></a>leetcode130. Surrounded Regions</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the <strong>letter</strong> O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X O O X</div><div class="line">&gt; X X O X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>将被X围住的O标记为X。</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>通过分析可知，就是要将所有以O组成、但没有连通到网格边缘的区域变为X。</p>
<ol>
<li>BFS/DFS：沿着四个边向内找O，找到每一个O就把相连的都变成N，因为 他们都是要保留的，最后遍历二维数组，遇到O变成X，遇到N变回O</li>
<li>并查集：将区域内的O合并，组成集合，如果有元素在边界，就将该集合的father设为N，最后遍历所有的0，如果其father为N，就标记为O，否则标记为X。</li>
</ol>
<p>显然，1会比较快，下面使用BFS实现的.</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>&#123;</div><div class="line">    <span class="comment">// if(x&lt;0 || x &gt;= rows || y&lt;0 || y &gt;= cols || board[x][y]=='X')&#123;</span></div><div class="line">    <span class="comment">//     return;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; board[x][y]==<span class="string">'O'</span>)&#123;</div><div class="line">        board[x][y]=<span class="string">'N'</span>;</div><div class="line">        dfs(board,x<span class="number">-1</span>,y,rows,cols);</div><div class="line">        dfs(board,x+<span class="number">1</span>,y,rows,cols);</div><div class="line">        dfs(board,x,y<span class="number">-1</span>,rows,cols);</div><div class="line">        dfs(board,x,y+<span class="number">1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> rows = board.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//上下边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">        dfs(board,<span class="number">0</span>,i,rows,cols);</div><div class="line">        dfs(board,rows<span class="number">-1</span>,i,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//左右边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        dfs(board,i,<span class="number">0</span>,rows,cols);</div><div class="line">        dfs(board,i,cols<span class="number">-1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'N'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'O'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'X'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么时候用并查集？</p>
<ul>
<li>集合合并</li>
<li>判断两个点是否在同一个集合内</li>
</ul>
<h1 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h1><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p>
<p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p>
<h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash_table</th>
<th>TIRE树</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找时间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td></td>
<td>优于hash_table</td>
</tr>
</tbody>
</table>
</div>
<p>对于a,aa,aaa,aaaa的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>hash</th>
<th>trie</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储</td>
<td>10个a</td>
<td>5个a节点</td>
</tr>
<tr>
<td>可用操作</td>
<td>有/无/查询</td>
<td>有/无/前缀查询</td>
</tr>
<tr>
<td></td>
<td>1行</td>
<td>75~100行</td>
</tr>
</tbody>
</table>
</div>
<p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p>
<h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p>
<p>需要节约空间</p>
<p>查找前缀</p>
<h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>例题：</p>
<p>Word search II</p>
<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://stomachache007.wordpress.com/2017/10/23/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E9%AB%98%E7%BA%A7%E7%8F%AD%E7%AC%94%E8%AE%B02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/" target="_blank" rel="external">stomachache007的blog</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> UnionFind </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班习题集】]]></title>
      <url>/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E4%B9%A0%E9%A2%98%E9%9B%86%E3%80%91/</url>
      <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 请输入文章密码！ "/> <label for="pass"> 请输入文章密码！ </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19rQuo3K8D/bwPe1ASA8cwiiSpnMQ7kJv+5oEf6FU+iVVzrI5JFFuTMugq4Utgj2ByHQtJWBLrB8BQKfzfbrthQlDH2Hikb3K6xkPNsdE4evkk75pVl8fc7MK67/QBj6CDt5vkNU5UkizWP8vf/pBk563bU/8b9HH0EpOqNugKCC4riyKGPZXXIY45CB97f4xYmn9fYHB9zOIf9tlsHeFlsXvsMNY8FsFkpunrR/HDAdy+DAAA8RGrQpWOBLLbCUowFfQL33Q1nS238iWGO0ge2NxP4rZH98rS3+jQR61jegE8ycO8jrOaPbu7Qljql4yEY+UIggfdDbogHA6oBDBkYkihDgXKFEylSpzhOi+V43N1S+XiuEFmkc+mGAh0Bis65Oi6OANxchPomw64Y8xQ6I8OGk6FnnqIIe3q6gWs9IieEHu73KKB3YFobB6wvANMKst/HSwoMHDEt4VGSWjiw3tvKS6HnYF1b5fGoDbS7Jc2GwV7HFnRQ0VXhRYTrmmcLC4/zoravG69PcDG6kVPH++AJTLTu5tjn8PF4DFeztkRZXW3Vur90oDd3sRsdAkPZDjgOR28cM/Su7s9Hn0JM7UbzYxQN1bWYgNlSlUOfIVPugAHsi91WR2+W1V+lQAFij7jztOvEP+MCD896EMIl1PFDQ8gnR/q4/HPsuW4DSXyfrQ9NJrEXZ3SxekK1nCGiqmiZC4UWldk7n39jqnakskl0GAeUtnp6VOYwQNvMZ9tFKNuEhtzhRhVtL9FKIcLjQcteBXLimMJlYWWQ7Vnf6Ia32v6YaiX7sE2IIFYYQ9NZfCJng2TOm0phQX7IpX8SXBsK0y3q0/QpVrjOjdx2fbJHPfjpCoy1QRmbnA9mrXA8sK2/25QA+aLFMy168NPFF6dzuWgwabjlxl/HaihpbDZiWKKiohoLsw7NOmlvXTxN6FxQwR7z+T2jGN73YNmNZJ2fKWOKvQWMXSPUYNASp2zO43hj5F3MamYOLX47urqjhYhiVSqJeYsp7cW5scBPhGLErZjrBVTpEPguHgga8xzgmLsJLAG0nBWZ9cVr93atLQ+bGSsmE+PHr0YRaow0XrTyIP26qWDGtcEt9QX0rblPry+xvTlxKtsOsSPEOR+cnwOixWwcnxGdD9907EZFs58/Y8sbXd0oFk+5agENySXV30qOxMRMVl7EpNXlorXW6QzXQz3mTSoy+qZXOj6oaFJr+J1UCvJ3W13xYUS0uxSVqsqHu6dclBs5VPO6+brjN5/GV0+u1xzclOU+KNySlCLZ6MD4tGtDE+/bpMZKbHkiEy+JUFnnU1tQeP9hQH6vS6ASe+Lju6/Ns/FolH7fvHV/m44E2fRCgmIoxm/c6BSV+qYTD1H8RQF5J2lbquVQA7vuOxfobBNuWFuPwqEZXX5biZwGCIjIGYmbTHM2wymbWEnlqCZTwFdaUH+r39zepGaNxLYBCoEHvyg1L262M6XCQfvlQcmNmb+RHKoSkcnmcWJXdtWxcWjxiQNYy1ZHf15sDYWzuWqYPis8Q8g4CR0Z0mFbzweqdOEXMSdebshbgdSM9V81UkhFOgqinW7uVGG6ii7gp949hkVGch5cgoDoaXPm0uM/owK8jzevfP2jXWbN3SPV7AtYbN8QxjJuz0zjiwnPSnBlvBhhTsx7JB8GykMA0a0GL31ljPGCnaLp03EcMyifXe2JoLNIoVCn1OJCX4pMQJZYWOsiouaeMXwfi8pv65uY79L4Mf5VUpy5iibMESU498UUHlmPPVZL1KN7S6LpPwGG8+Ugu8IdqjAgp7oYsVtFjyC41Zwh57bzF2cPcKuQZ23+Roz6B/MgaMkZ0wOFrD6WaFLV8ImL4mPxKQx1mdjQNIZeqe4mULE6wb3q0DrnerKVGxsAirwbrIJpY02bNU3l1/G/XcWQtV1IYiyIGYRtSd3Bu2WRKviuNdadnZ+XM5yClz+S+O/MfQqLAf8XHmFbtx2WJ5NOYAO4fRLm5ksnwAPDfn+xD8HW6ExiqSpdKiO3d8VY2kg75IQZi0sxyt2OkxcWR4BuEsa0SN0Hve4Y4ZLuM0NA9Nmy5B7foORLXBl4lmIva7lGh/flSXI+xbUtzxiWLPs7eTefgI9PmxWibj8lsOijSft0UY4vO+Rycz2GOB3EJZPZJ3FrieAGCJ2xIA1Q5NUekt6IafnFLgyd1IRBxjNmSF4j4DcCuz/ddXJFSaWzcG0n9IbARdhaYvMlB9U3t9SN/ara3S/Xrmp9q8Uo3kU1RvoJVrSOO9tCSJOUbxtHXZMzxaVVPjNin02XSApUiJU5fQ4qz3m8VD+P+zLq7fZMVlQ3QgvNAA3x2Pmx/pcL+jhSXrkW3OhTvltgBJqGfuU24TVJkdZzR4C+umzgTzrB0sOfnmHPDFFo2eLYlOBjQj6w0w0vqAp5i76Uh18XPgRAcg0SiK+/1mys1lYg/T41EY59KBvMcbsnJ9Jj40VmywW7gY3h/iH20SMnjGdhZAivyP7cp7LhuUPqj/96wi11dUNZsVwIm5L1SadIttid7oRn9Pkwgo25ImBBiw0f//TALP1SlEDgneup3Be1IhxgjYezY2fMwVCccJpk+8nLZUxpYzAGSMsiRhwFrZ9MlpFAlp4cFKzei0DZZGmcubgbwildwa/yj6Cs0UpRYCw9gQjWm07gSK73QlTfe+C+IjQgPDI/UNes4V+my42P385RWStC03pkzp6HGtV4WmHSibkZAsaR7OzjGD4YyGZLePKchWC65UcORoJb3SZ9PX6iE9A2RtITMQtoUHVWTKoWOdjIrBww45vTyBi8dZyQi0h31dw+siQG4NazIX5Bczt9fOCxaOxu/kMs/vIi5N/NqSBdGuuqT9lFNUa/uv+1ptDqXZy9c0XK4BK/iXdHrmwq2PTzDSGM8GLlpajTzALFOaMv4QB35j0bUfsP3RrexYa9eOfSvjSxhNBSR9BU0R2YycgAuks3MfQbeyYJT27Bbu3NUhQFFcWfXB50PIi54T11O924tKkelBSpVGZB5XG3+OpYnsmlcr8/UjAqLTVA2UmCxVOPQefLWl8b+nYTGcRVqYi9BXXSxYxZLWnbSUXtS4l3rB9hwryGpRJ1jgSvCAN5uBas0BDmWszR7bu4t9j4zB/OXMyAvm1nL9vF7pgO+YEmeUIhXMRULIc9wMJIrwPi1UiTog2SsyFkh43VcG03cnOKb2eB8zIM5oFf49ZUR/ae7tNLCz8w+86NTt9SZu9H9C1NBj0nZ00QVwNQafFT2WA+oLqFt211ZSAct7YYX+ejoIot12lAy8i8hV8Kc6Aiw0Ttb/WqbDLwFxA7R7EfnHy9zo46/8cv7el+QVeob06oExiKc6ccb+o42PVP4PwB1o4M20JpMolPefRw755xLKQESpDnM8NQmXxtqrGV/oReiQ0rXcAs/61S8fGKKfp1xkVzAi5/1xVwfMndE15UtdnPYsssmpio69tFGP6ryIhF4ytfCPHuYXQ0IB/vcB0KclidluHFzvzD/Bk8j5sp7yfBSCSjfCEJhYS+Eodx0PO22SA9Nq/sVzE2ikMykm00AmXwjp9OUw7B2F846O2Hr3CRY/LU5V9oC9QXbf8+piIYYz7k7uJreM3hLRn78Shq2XyC5RM85eTgP6kor2Kx2B867+8mXzUEFqCjMVPgQHHQh5Ewi7rILbr4MFLvReKeCZmh3wnX2ETZopGEkKr9OaKerAebm1+jhzXwRJuctWD+xxGF1x4uTryX90sAlFHNyDixCGEdK/ymsKxJBJHhRfjdCSp5ToLd3Og7Hc/yTFRKr7foVuKRy8anVFWK1FRmtGVb/6p66efKY+53VUuU3GMxsd34mAt/QdygCidI/tSpaLmAx5ej84OV+AOmZm5p8VafeLJzkhu2PiVEDdzFM6s+DaMnX2T77FwlCt05eXhygH8CXyIN/DFEu5hWQdgfv2oEsNb/TAZbOGl9y7Y7wOYX++SNDZgWSSUAMKnbBZ8mA1irI4Rr2DUGqj0H2Nrnf0pfHPtgcnOqBxDRlTL0CjRUGaEBFBjw5eCtW9WOORzqvRa+Or3u/uLMhIfko7frbgIahDm3xGOA1xK4FA9nk53KoKio3dBrf9MqjdRIe1PLGnbOx+D4azYY+JoLpHRsTxP8XsSwQCOQsPl2Yx8HdUaFJvw8NjWWy+M2XcN63DXw5NhlVjeoF4nPTSmkzUJReFyaSN8OLE5KkKm0fCDdlYrDKwcS/fE7BsgP8dY7HrRIfmaa9x+5JsGRi+7sdoS6L5H6K6J2s9ms7PsHk3/9mKDa9XQABdMFocxLhJ7ShQdVN8xQOrScL/MqnAkoQuvbCu5WLKAs+yN3TNijCmx8hNx/DTWs73hZb6PadXckr1kO3DbhPxOOR0nanVcppPgrrZ+KqxP+J2xdQUVUHdB4KFWlNna5CLV7l2glAqzIP3mf1QxT0lv+MijaIAFUOADa70LMkSwIf7cefVcF4WYbyVMrkfw5tVykknLZX2PyXteLBTTpGnHMKwEcDUuP7XGu3Vmt8G2r1t6NXEixLrYD3gJdJ4LiZygrpN4y/Ud0B8L7GlLD63fmUpBPVhzlMcbdOXY3PH17UbRP7qR2KhzBvhs95rgAAFsH1wWpNiZcUt20Pcf9+3kiy9I32kHnOvJNPnFd6KOtdAIdPjscCLzGELuZA+xDBVSCWW9syYYo2sX1E35Sh5H14/kGqcYklM7n4MuKBoXnzWOI/Rj3xy/QaLz0BW8TGoOOp8S6ScDTlstuzCmehSmTcXrMf/KkDD7/gnYQoQGMiVw3prvx1AGDYfq70CXjh+NN6pze+AnkWl6leoUGQK1XzaBvqK8jz2fCagml6oVt6W6/sa1akXo0lG+UHCYZnA32zGIgdhAWoxsNydy0PEY2ZDzSNoW1ZswFGo2uJ0eqHHOK8i3THfaGkd5hMHdhblw2CJHL9sivPX3kDIms1niAErzaMm3kGxQm7W4I/ADIyacowO99CX9MDtksFvO2yra89Utm3DaLp76b5cCKDuNS51C7A9HB/T10pHoPwmjWb7IDJfTDTZwp8WfF95t51PwaiLEzv3wllhlqiwsi89zr+fE8BBDoLPBF+jIoX0+i8cM2TeP+kBphk9pJN7RcGYenZrr8MoB7vzJYOAQ0T0br7ahD4FBUCCoSVIRbk40n0fVytBDe57PTip1/hA7hsnfMh0QwCYUfAQVw2SSr7y8svn3DLiRDM2t+HGrI/gaZO/VX1/WNVEcm0CYepSTNkk0gK1Ep1g87QMIG9UijTtrZDZafEtJbgkpWu3cdLoQhZ7bK/ebPqWXA/JvtrtVilyCZ8QUr8IAsV5roR1JZ+fslvktszrEsPd8Dt01IxDRy3fKwYIoHYcxnAqECsK5X0JpbjGO+TP0dTaqCe5wVvevd2axxN/Dh+iuSvPiUaqUMljnkET8wfSxWpy/LtjcPKtBK0dX4LaPsaBYk1ts/kAAWywYgSO2Y+E/7k4zq/BwMQsU/Cs+Z0a1l1pA0ndcMsxPz+LG2MDAo+4Qi5OBX12VxCBCEDxi05R5cvcDuPxSV6kobNu3SFJdEGuacCMJ5ICOEPpFaRmcyDSItRmP2ougc7N6pGfZbEPGKjo+mwijhG1W7vh5NPSv08nPcxc78UB5I//oXXDQTEpHKH2bBZOC3FwiQFC5K0sg+Ohd1FXTV7RVcYGtZW7FBrBeC9fnouAaMJcsjs5msZ0Vco2CUMSkIPinH/Qq18+glxmmKhJd+IPdlSsO6b8RgOfB5k2sYI/UY1mlmhH9bhPqFemojGG/wNoDsr/2h9EtJmEm13QHV3D4ri+cZLSmwHKE8TYaKc2NPcNYTLkIs0bivTYtQk//l1kK+zGPuVt63BUJOVvMTWvOFdqXGGuRyea5jjsDWeU/BFmnwDbeuW9THBZK+EyBAHvyNJcWc6/UlcPzMsuttPGaGBxd5oEtqcnOPnqF990gYOvlidNtG09a61Qn/U7NBl6gEfLjWM1WmwVhayVi0pNrhcLHaCT3W7MP5vkvPq6QrbZ+gW5FkAl0ETENTH4uMgztj5Ju+IrrIBuC4+naXkBjkGX7KRZeNG9K90Ai6IZ/4XBNm/64U6o00LJ93kOOqoC/fIi5NQlUS/ZHDM0uLMkKkXc2XnR1r3DgF2xN+gpEJRrhgIQLG42zmopeorDjO7pR90BYwT8IHtMt5SeioHr+oD+G+yqgXHpPOa0zKo2SpKqT1celVkDcBRCilLdSRwRL8e8Lcx5aPm0aX+8Lk6nus1DoKz0jusN4kdqqge/ZIiR/xx6hszq9xjB2HqUEN4AmMuzRDd6Kr/9lxYHd4udg/dt0gDmMadEEzoHiF1e7FSJ2mGYDZtDBOTe3bTa+btDHb0mYyXOCOMLyghROdqXFR3TAS/euQrp64Jp4k9kOW78hqvPxOMFxQlyT1DNKVAWrqdwX9WKkxjSRilnZrCsjyOcV7dF835JgokhTt6f2ygpNKahOKoNFWHDRn1rDNATY34/CFrPApVZKv6JCOzZOh91G6PST/zCI13pudiztbRTh8PZkFvMqEqvisSgTpMFjBT/gO7jsVbsRGZJz1NDS/jsvQVDvVU0WGJWbIUkvo7rWIamdIl2AQurXto9AF/URl2wmYfeZzvAvwxxydCWt7MWHFfo3DDfH7f70Fs2jHNVUaup643eITKGxv6Q6zX8jQisf51Ysl3mJGQO20XAZPjUUrvwLnKj/6ElZUBBXGVDP0cQDYdJonmRnOqEn/oxplHAMHxbKojwwPKDHdgy8v7szS5Jha4usQM4rVx7YBgcyal22a4UI86rbWZmYOhzKTW+c/drraPdW728ZNux/D1nGVrRLYLAcLS/3E85pOJX5gCMbI+kFPESJx4B58tnAPBvPCXR6w6BKF/UefTKJXYR7r7sQQFbOk9eLMXRXBF/8xI12G4tHrxRzbj/VMUWfkEmTHVWEMDQtLWdUBORHat7hmlXxwE/91HSxxzWkJIAiIBTimCWI7FmDneUW0Qh1K4YPt3465PAiYCk1InVhAWZKVNmhyM9+oIgUidsyvG3vntx7BrqfU9ahczC5fwsa+cvO6TtAZHAxyzQ4/lFg0mcJcRJm48751zgoG+uJBHzVt9akq/lMQ57jQG8QzUDSoRfZ6MqUX+7OT9rs7nNJHCy0dtaKcdtRfx8GyIhlZPdEHmlgs+Om87PCLcbQeA+qi9RTlx6rCFNANyzIcytgcVRP/W3x2mNum2xcIP6uugIrmEMndeNiVi2FOi3Q9P3tokACooo32TkLa5Zw9jEdsrPLj4IFSNHYZFiLp9XScK+AIFxEwOaqjWZ9A3nE2grU+sS84EmtABF1emQk3qxaOWIyR0lU+pmr7vhKSW3Q0J8nwqt3GUKrUN8Ve23AFuBw1mK9zFWy1LJTx7ikrGH8MFVamudBdk8AkUN9+fXALJeyLp0GMTcW/Mz0iYMI7gUuy4cjgybp3xcCvfaWzQDwyybNsxaI/z3fHyOHhD2fQi9D+MRvNfalrSeS9CBIM+pHPWaRx1ZjV+riFfLD7EO4xWDsVxHUXd8MeBsFtFRC05RXrwSytSbvNcSr3oUJ6yOzTOwLmzKh5yVuAn7iKUiJ0W+SAZ0ynSO4B5Rmv7ifUjb/WVEXMMWNz5ms6nWvqc2RgLXveuTq652lTHpakA8ODXZ0ATuMu957uJCdOLJaBMHywOybdVzyFBF8zPpe4nyqtIik4ch6PvQyfesPi0HlR1/TE0Ong17JBj1niG7Hp8DaeC3Cj4BN7m9IXEkjoLP0Lq4h3t1qB+l34RdFsm6+qbFpKPKa24yM5IsLJ8pTUDcZED3f6NnjsSCFYPnO4+9wdHi1E7RgRcKDAD/xT/mWqDpAWUcx0P/r/oTcjc/OP1vdauDHmgNy8MiYwNz6UyxVlPJcPeLamLWRMChmJM/K5AmfBa9KlNwYdjdrF/oJY8d0moEeIusUD0NLGY19EBk4gTqicYDtVVwgP1MN6ovtGwZDFBWLvRRrtVUJO4MD/d/d1DwheF7LpDzpwwH517ftYV6qBi+C8KsYaHjXBUXqo/RQ+fdiLmC3n6y809EVUjyB8gT7kXnKHaqsUYkrw4LqVy8SLmoeh0nm4OJ6rIDx60p2IyTWRfZwEaLmMjn0H1NLNfPxSNTuTEagu7utVFZdcdwtoaSuyY9t4YKAh1gaHrKy7J2wYPfXJHKT2UtkQlTIP5DM9h2b+F+GACcJh3y/Aeu7C8wRn+OnfFP52DC9GvCgEJkWioX1gtFvIMxzRaGvl3Tt7+Td5F4B/FkZkRKO8CAo605JsAoydLwUn/jrD3OY7e9GTt74QkpvU8VpaiF+B7bzCMhCqkvnXqXVHKZU+BxTTOhnwKEfsyFzoSCMAusL/8tL4OMt8v7Pu444A42sfHxHmqRReEVs1cuYtrqs87snyNqyqAIYxlvWcaheTIbJsxsrXLu2/ljQuSPxPx0jn7hFk8LYFpPR12Sb1UooBdnet+zO3IpeR3RMY70lulr+OWDV8F4jNV+MBMFtidQF6cbmolxHXYUiXwyATEYDoZWfwxJ/CJPl32QskQhRFXGgulT6bCw8/5EpRtFjXptDtJe9RVGyJt9nmx01LFvqPbzmiE+jjBWBxai96lds9Uwd9j/2hHxnPOv5o5ALY63EGlKBtFrMXN/YBKKGhL9qzTuvn5XPZQ6UraDbGQ8zZSfyZDRWD37P9gL3aSs3ka4f1T+TahyHfVu5l6COCS2Cbie7MFsTPxuaVWzbnh+IoKryjXK8Ifjf43b82JeM0Raej9L0VgXuIl31kQSN5jkkaCnHXwymOpytQlOScLzfhfwQBKrSUo3EvHw0soA1hVnffyAJqmOSyu+VlCmJU+p4EsebzgS7JPhWFb/FbSHTwPtQkOpiNMgW0AlVEyqJXIzXHihmcW7vuUb/L4jTrwbchezr5Tw1HEq5K8jPV8/4wHQlwxWj9TX6OgDdmnkaLikpKDRltrcgoXjEwRjj+eMdzoqf9wK2qmd57gLaiT+ZoY/hp6s3x32xdWxeDasmpCowRp5j350TgADCGfm6YNLAwcGPOl6d+tBqhtduO0LWxOJvIiqH9x5lzENpsk6lNGBsrLhMumjN84thaYhLUBhofQsgvfIPqTXnC/pU5LfYd2QKC7EGOET9nB0oc5ku8gtPMBEyRSRonwGQ3NC2NpM45qRTYjYgukfU4puMxcryBf07EkAke2uRydJPMsPvSrs4QAbkEYaQz0Ep716YBSVMPa5OOVXngCPKxiPdC8ldYjvQy2phShUdwNJ4cqeoQF3nz4eK8bIcdnYuh4d/xgMhWMLaAP+TyAWV5IwyHcY8BUAMcIA3lY4eiS5j2oK46wXRFRxn2XHeB9NevEHIawfMRoxGsSJhSbCkhGre/3EZKoO5LFNQRM8y9Iq6+0Cp9OPmCQ9AzYmoJeKefe8FUcz58g0YBGO4zXhaEx2Wowqbj62Zsy+GaYwRCW/c2scEWP06SIQPtOb3gcbg3pZw5Q9Wdb2FT8pXgwybhxM6crbSpUTX1d6UwVTUjbV+/vqlchWQ68uQf+EC69M0zaIvv91CkWNsDeVnoZ9jWYWh7/6zIZ/L+unRWFNuW47jKDAHAdoSj8dAnkPssLAIWSwYqJlnb4N6b9vzOYsOC83je1P2a4ZPxxO+MdjJEzxQcDh8Ww7lTLQ8UlENj5kcJAsoHbucwPIDfh7aWeL1732C+7B/bcZdcTH98gjf9Cv2OcypJ0eacI1aNY51fRVToAGcUTEE14GNmJcOpyxL4uPTr7zvz7upGFl2bCW3KJOyBH0h8tIAKtbj4OuoygX93be81fFaxp4qfF5cghiSDjD+Z7qurV6Y0aOkTSjsQpTu1AUundF2j5SAe9fbhH/rkSy5xJdyKn/WU60P/cKuqd37FwZp2RaAveNZwdHNCer/deHPAlfK8iNrw6WksvuuZUyApcfBom50hRtzS4L13E0YREIllOrTs90G4zopNKybWodIUEt5YhVwppRj1igqoXUZWRP3WVqK+1aJYUbE6cYwypKMCq4fePrO5adbli2z1xMMGn1DAOHPtbxojVrHqALcg2/vUb9E3Q75xrAjd9blY4cwOIQTB+2ySpN4yp5OOFvGh4YD+0Vx2anryX9vP/pKZOSTRP2ji2rCDbzB3YnsE3d/ItqmGTvEiz1EuwzYb23TMCTX8iPyKt/SnU9eP7wO5zC5Cept1GjBSJvnJ3mHTrYDqg5XCQ2KitJ50TI0+O17HN9O0rW9lYHV9K3X2p65bUk+Gh5r2HATqBwBuQySD/ActkhPyBsvMkxqZBwb0WUPl7BJrDmKkw04aC8v7uDrwWwTUiPadqg03mSsscCQ/pOKLDHg636ICFhJwozC9G7ksfLr8tmSxd8ekkAfEdgQbBNtWiphZd/HkUCXudU/Av/HJlgrqTzc/CLMnaOUKoQNS1wizIx+uM/UX14y3mbiGfvamFvV02EsHOWKwjxktdNz8vPUJJ+p0rTJ7e8oxxIabES/5v7kTHfwlGUdn9WAi+PvfONieSV0VfOv7OxlIuITtStRBtAGYYQiFahv0JcQtKIje9wXvXxatY/YEOCULxpc4YEcOLoV/IxeZidNe2mmLonLn1c38zPRbkimNN5LukkUi2u+lTmNCiuWogDd2ZL0qgO0MtSA5n2ztmLjS62ekyBCkSdW90ZaTfR5xiCsL59NbIZhrCxLstcsaPEj4Gq11Hln3HeTr69qE4UI6R+TDkOrsSAx+xGhnlt5G/z4Cn7NXk9z/zqqK+QqZ5VVELj+URP4zo9zIItywa5Vuk7MS9Dateg9yuOZJrSJJmT0zQrfhlbS7nMJN0eTQWe8EgrGHhBOoh9ZtEgmjJB6XBEcrR1cpcY/iUoJfPDwNlMqADydYNCY6Swc8PtEZ9X8C/Vv1Rbd68D3DLZhC2CpkW1f57J2wuVab8lIingRHQh8l8EkZLNoZRKtdh6kduYvdCNd5l4uU1vMHjCF9W4ParUzLqK13lncWHm+7rx9vk/ST7Nm48rRkegh//EM6zX0DVydij/SQByeiFCSmUuAHRejaeszZH0+Bi7LgYFFSOEPbKuZkhYIvOUQU4puE+/PP5rrM5YuBTPypwHWbMB7wlB25r4z/VGNCfgE3gVlV2H9ELdLwCwfErVDGgD3ZgCkmU6Oq44v34Agg4itq3vAK1LZx6+wna+8sHN4LxihM+ZkWD5MQoaiPhk9uEEviVmIKL3oxW8c1lnhYODVxylk0RjEVjuugjSf03GJPMfXm6l432EGzQ44k7fNUmKH1htGy5m0gIsWhQqGXFKmgL1dEZ8LUZjhFRpt5IdxEFpLkiKQHkUd6PWjonq9ZVD/FP+dS4/DXhanYenoSIQPYD4LB/g/lwSmPz2SiVQv51+6XnRRIAc2DmAYfg+WWf4TnjbylsijDQYZAoCR9tzCJvMXiP4XQSsi9RI8jboq9L8K6EssNFL/d+LgHALJbNrh1K90Hcl7EA0Qxp+Efk/eqTW9JOE40uAEwrzpUfFSKVrrXSKDtyx8/6GWfjDjGL15RU6C2QiMl+tOx+Rr7xxa8dChmjUYQCPSbQVg4mynHL3C2b0nqR6iN7GUHXhyOlJ+lLhrm5keIpKmAfjGFXGCL4yIQJXXZCsTJzItvBlYgmpUaObktqtYw8Wd+ua99KxIp8Z7gzLRSFdqTfnKW64HBEu/fafOBdaewS9MRincHUXD3fZXHH7ocUG3G/w9kFPHUuRfgdGY65VCIZY2l+3A9e0+uoeK74U1Q0oc/eQ9GUVt3BKuny1R6IS1Rt7toSaxNFdyJBnZW0l3ExbaaiWCaZubXVc2VK+C5cCqfE4cyjWbSki1LutJ45WlBNKFoMi1HWaFavaR3KWcrIXAbIt7XABRjrjw4PJhf0k9s3cFj7xNtDoXxwlB5HtOHaQ0uwqqBZdv4jZer/qSxcWCMNuAReB4zqJt5Sc9pPIG2EOTB1WltwSkcKxeMxNE4OcTQBFxQafj4srd7ZCJNhWRJ5dkDFbB7s0nsEfW3HoPorU49Y8Wgm4NRO0lpeAAEu+bektas6/60p/RS/xaSWIeL7yxD7F9njvjUkJXVq7dJf0RorDWgwLgPUlX/Wm+2efANWhhpkLpt3WLY9o1JQRKtXX5Eft5XEO2QGpeSbW/2wYddCFJz4nUJIMS3KGyyk29AHqH+jvir9A3lhzm6liew2OCuWGw0ZowMkkNYthVInS1bIqDWYxrZAwYpO7a5qi06nPcpVMP1QpGHOwkA0j8qE/xh72i4M4G+rpTGzzZMZ6j9SotB2YlLwHue0BvHW22VkEfpmmYfp2TPSuwbznHPw3/1tfCN6iFQPu6gYM3li1zpD4/aYaODjiB/2nwJquLzUoZMp3EtY/+RFdg43lpDpSUkU21YDEl9a8TyM87I1RIq/A1B7TNYDuuOfw2qJtI3KW1A2HjjAxpZWREc0O2fEtvBMSzbCouP8pgCc6fhD4vmK1VwFQK0/PGRPsUVdr4gNfFb+Uv+TU1ZcGG9oZP59MG15ch/qn+uqpzVViwcpiSlVIpW6pm5ISiQK7oY9YFYj4/17LflyoB3tlvnepzaQtkHI6lVdGoPWJn9+LYtJTntkfUX+Ok+YbVwwnYCj55MwuQ78ecx1epBwNQ46T2+5W0qAjQ6WSH4iFL99lEGLZojCYtPzOB0rwLt2IoZjyrACuw77G3c1cGP7pO+Nov4F1jTsukUzpSOawnHj5xqCoxnQVDJfNbaN3HOQs6k5TlTA0PmzcJcYyy7FeL2/Opfq9vn30NfiE7YC/Sr7yV3E3hYbK0ivHjjqVANjRhdD3Wt0J76Tekd5Cx2R8HQ6ogm66A2WzGxmNm+03hOe1aWcSJOnkrKCNpx49b7Qlb/BTNd2o6j+HJJ1C1om3pDI2pTqbDh/3vEiH1/vfYMpx7Dc0CN5eWJ9FSjLOGz7gYSzXBsK3dAP2plDqUZk4eBvT4YyiYDCEoqHyVCZBpEgUgEqKG6UQrl4JwX13hYFnIY5ur7Y5O7YaGrn09DEDB+DQBpiAuEEp8NPp1yC1iMlu+SHjQxak+4Q7WUTp6+zZK6wJHCxlKN6R81MuHGJKcWi3UUD1eJyKU3Y6Uw4kujjEE9cnSPevYz3T27Qeiy0vrQCCRcCmrAkf8n2RAVZTkDX4VrEPFDktnFA32aX5f7m+82AqIooUhW/5eEhJQMq23yAXsxNsVImBynSZO8cgbvII9ZXBiaMv2b+qf5fNnjxoJ1qeDz8/FE4tMzFtzspD7HAuoQmdfZLzKliKJBl6qIIyBbXRVgbSdjl5pHqd4ZSJeOyLikTe1VyEe2SfVmB7BB+hYJ0SdE9GsuwbDb9ks3X9dQJMO48BFdmY+f+9akuz8IOpL8Rems5c9ZKb42vInOZVyn3+PzvDnevQ0FC2QEgY0IZIj0dF59CwNavAuAdOakINuNukw6mW7VYqY076+fjNqK5Q7boJJf8aZZ3KREJr/joKouY9XDc6qqJRIMpU4RKf1WRumTDJ9JcaFNW95RbbFSB4C1G+TiyDqmYjx963exBfd3tb440ST8cTyz8/UKLVQFDk1kg3dfWbE7FyxIO6lCtkO/ZvfZsoov3KVMmyQ0yTR/Qy/Fco5YkIc00BLr6o7P51JmtA0M8a0d1ZV+ylFpsl9MKQ7coSuJMQiXO2O10AST13ePRWCSnX+kN9zrQ1FnW6vdoUBOUtauQPFcDU8k1ZOe1sgRLP6bPJ5bn6Pvw4AXhP5VNIiS10iRfm+vUjS14U7cMMnWhL8NTMl6Fuc5YQQRsQm9NHST5awy+JpAmMg/iSGbwlgRIkSivlhgF8asaKXmVTyLD4vrIjn7DQMrSWkwpu1uaW1dEnKDuS6tG1qukOrq90Ieqlc+UNSIyFupSls2vufXMBEB4pCnDA1FRq5THceLgL9eogMHfZrwUZ6PrziImzeNwjImFA44YVpkjaC+OQpkKULhgPBaBXqXDqGbsZ2i7s9/T8ySxWvnd/P6ANjCdDM+uvLVYLfBdz9YoINvelazpe25F3dpKrmpPC1aQwhAarA8OYUZ6FBYtUX9UjXj1Y4PzxgcqB2SNGU/R0zFUMwWFs+nw1nt6X5PADQp2JxCDcll5XsFZrjPiS3J124oHGYNwS2fLX0Ozta/4+IK96OiunByie0oBJRaWDpgx3I9B2J8JSOcINU0ZkCST16fJJCUAUESkEGz/PoLrsQjQ91Gt/QBTxbTr1tWv7m49Z+UMBIC3RiDPa4Q1ZKMMoxvDGQVNkXBUfMEnJDvmZCkEP7aqLrf9qk4tt/m+uj3NRf9JoXOCNrNdvFZ5zu5M3m9eU2TJC6ZhhQVF1WH5t9vCz3HFXIdUnfY6Bt1TDppOUyNkI12zGRB+Zf4F+Fa8CSfopUxWi/Rd/HFzrk8H5mSzy/owePzpRfN9ZkQH7JEqIlZvGwrkASKmqeXnlWF1QuC </div>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 九章算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++中struct的一些操作]]></title>
      <url>/2017/11/04/c-%E4%B8%ADstruct%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>c++中class和struct的构造函数方式相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  Node()：x(<span class="number">0</span>),y(<span class="number">0</span>),z(<span class="number">0</span>)&#123;&#125;;<span class="comment">//无参构造函数</span></div><div class="line">  Node(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k):x(i),y(j),val(k)&#123;&#125;<span class="comment">//有参构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++STL中vector的一些操作]]></title>
      <url>/2017/11/04/c-STL%E4%B8%ADvector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>记录c++STL中vector的一些操作</p>
<h2 id="指定长度vector声明"><a href="#指定长度vector声明" class="headerlink" title="指定长度vector声明"></a>指定长度vector声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);<span class="comment">//长度为n</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n,t);<span class="comment">//长度为n,值为t</span></div></pre></td></tr></table></figure>
<h2 id="指定长度二维vector声明"><a href="#指定长度二维vector声明" class="headerlink" title="指定长度二维vector声明"></a>指定长度二维vector声明</h2><p>声明一个<script type="math/tex">m*n</script>维的矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//所有元素都是0</span></div></pre></td></tr></table></figure>
<h2 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line">sort(vec.begin(),vec.end());</div></pre></td></tr></table></figure>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>resize()可以用来重新定义vector的大小，也可以用在声明数组时指定数组的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;<span class="comment">//重定义vector的长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, value_type val)</span></span>;<span class="comment">//重定义vector的长度和数值</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> vetcor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[回溯法、【leetcode】51.52 N-Queens]]></title>
      <url>/2017/11/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E3%80%90leetcode%E3%80%9151-52-N-Queens/</url>
      <content type="html"><![CDATA[<h2 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h2><p>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。<br>如果用爬山来比喻：<br>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。<br>第二点脑子是回溯知道剪枝；如果有一条岔路走不通，那这条路我们不走，就可以少走很多不必要走的路。</p>
<h2 id="识别回溯问题"><a href="#识别回溯问题" class="headerlink" title="识别回溯问题"></a>识别回溯问题</h2><p>判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。<br>一般回溯的问题有三种：</p>
<ol>
<li>Find a path to success 有没有解</li>
<li>Find all paths to success 求所有解<ol>
<li>求所有解的个数</li>
<li>求所有解的具体信息</li>
</ol>
</li>
</ol>
<ol>
<li>Find the best path to success 求最优解</li>
</ol>
<p>还有一些爱混淆的概念：递归，回溯，DFS。<br>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。<br>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。在树和图上回溯时人们叫它DFS。<br>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</p>
<p>关于回溯的三种问题，模板略有不同，<br>第一种，返回值是true/false。<br>第二种，求个数，设全局counter，返回值是void；求所有解信息，设result，返回值void。<br>第三种，设个全局变量best，返回值是void。</p>
<h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>第一种，有没有解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">boolean solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, return true</div><div class="line">        else return false</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            if solve(c) succeeds, return true</div><div class="line">        &#125;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种，求所有的解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, count++, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三种，求最优解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, update best result, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>八皇后问题是大数学家高斯于1850年提出来的。该问题是在8×8的国际象棋棋盘上放置8个皇后，使得没有一个皇后能“吃掉”任何其他一个皇后，即没有任何两个皇后被放置在棋盘的同一行、同一列或同一斜线上。</p>
<p>扩展到一般情况就是：在n*n的棋盘上放置n和棋子，使得没有任何两个棋子在同一行、同一列或同一对角线上</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了更好的理解回溯法，把这个问题分解成三个子问题：</p>
<ol>
<li>是否有这样的安放方法，满足游戏规则</li>
<li>如果有，有多少个安放方式[leetcode 52]</li>
<li>输出所有的安放方式[leetcode 51]</li>
</ol>
<p>因为任何两个皇后不可能在同一行，所以我们可以采用如下的策略：<br><strong>一行一行地安放皇后，每次放置皇后时需要确保此次放置的皇后跟之前已经放置的皇后没有处于同行、同列、同对角线上</strong></p>
<p>需要下面两个函数：</p>
<ol>
<li>递归调用安放皇后（回溯法）<br>逐个遍历可以安放皇后的位置，并递归调用取定下一层可以安放皇后的位置。直到最后一行的元素存在合法的放置位置，说明这是一种合理的安放情况。</li>
</ol>
<ol>
<li>判断在某一点放queen是否合法</li>
</ol>
<p>因为是一行一行放，所以可以保证不在一行上，需要判断同一列是否已经有皇后，以及左上方和右上方对角线方向是否已经有皇后。</p>
<p>另外还需要一个额外的空间标记当前皇后们安放的位置</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>三个子问题的函数2，判断某一点是否可以放置皇后的函数一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断是否可以放置</div><div class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">    //判断左上方对角线是否有皇后</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==1)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断右上方对角线是否有皇后</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==1)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==1)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code>是用来存放当前棋盘上放置的皇后位置。</p>
<p>差别在于回溯函数：</p>
<h4 id="1-是否存在"><a href="#1-是否存在" class="headerlink" title="1. 是否存在"></a>1. 是否存在</h4><p>只需要找到一个满足条件的放置方案即可，逐行放置皇后，遇到不满足条件的情况就回退到上一层，继续寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//递归调用，判断皇后放置字当前点之后是否存在合法路径</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一行，安放最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//如果存在合法安放情况，返回true</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//该点合理，将皇后放到该点，递归调用，判断下一层是否存在合法方案</div><div class="line">                vec[k][i]=1;//房子皇后，标记皇后位置</div><div class="line">                if (solve(vec,n,k+1,i))//下一层存在合法方案。返回true 否则回退，将皇后从该点移除</div><div class="line">                    return true;</div><div class="line">                vec[k][i]=0;//取消皇后位置标记</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool ifNQueens(int n) &#123;</div><div class="line">    if(n==1)</div><div class="line">        return true;</div><div class="line">    if(n&lt;4)</div><div class="line">        return false</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));//存储当前棋盘皇后位置</div><div class="line">    //遍历首行放置皇后</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        if(solve(vec,n,1,i))//找到一条合法放置方式，返回true</div><div class="line">            return true</div><div class="line">        vec[0][i]=0;//否则恢复该点未被选中的棋盘，继续遍历下一个点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-存在多少种安放方式-leetcode-51"><a href="#2-存在多少种安放方式-leetcode-51" class="headerlink" title="2. 存在多少种安放方式 [leetcode] 51"></a>2. 存在多少种安放方式 [leetcode] 51</h4><p>在上面存在的基础之上，引入一个count计数变量，记录合法方案的数量，也就是没找到一个合法的安放方式就+1，知道遍历完所有的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> resultNum = <span class="number">0</span>;</div><div class="line"><span class="keyword">char</span>[][] map;</div><div class="line"><span class="comment">//判断当前点是否合理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line"><span class="comment">//上方是否有点</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> line = <span class="number">0</span>;line &lt; i;line++)&#123;</div><div class="line"><span class="keyword">if</span>(map[line][j] == <span class="string">'Q'</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//左上对角线是否有Q</span></div><div class="line"><span class="keyword">int</span> line = i-<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> col = j-<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (line &gt;= <span class="number">0</span> &amp;&amp; col &gt;=<span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">if</span>(map[line][col] == <span class="string">'Q'</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">line--;</div><div class="line">col--;</div><div class="line">&#125;</div><div class="line"><span class="comment">//右上方是否有Q</span></div><div class="line">line = i-<span class="number">1</span>;</div><div class="line">col = j+<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (line &gt;= <span class="number">0</span> &amp;&amp; col &lt;map.length)&#123;</div><div class="line"><span class="keyword">if</span>(map[line][col] == <span class="string">'Q'</span>)&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">line--;</div><div class="line">col++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(row == map.length)&#123;</div><div class="line">resultNum += <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map.length;j++)&#123;</div><div class="line"><span class="keyword">if</span>(isValid(row,j))&#123;</div><div class="line">map[row][j] = <span class="string">'Q'</span>;</div><div class="line">solve(row+<span class="number">1</span>);</div><div class="line">map[row][j] = <span class="string">'.'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="comment">//初始化map</span></div><div class="line"><span class="keyword">this</span>.map = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ;j ++)&#123;</div><div class="line">map[i][j] = <span class="string">'.'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">solve(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> resultNum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-输出所有的安放方式-leetcode-51"><a href="#3-输出所有的安放方式-leetcode-51" class="headerlink" title="3.输出所有的安放方式 [leetcode] 51"></a>3.输出所有的安放方式 [leetcode] 51</h4><p>这次需要我们将所有合法的安放方式都输出，也就当找到一条合法安放方式时，就把当前的皇后放置情况输出到结果集。</p>
<p>另外根据题目输出结果格式要求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line"> [&quot;.Q..&quot;,  // Solution 1</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;..Q.&quot;],</div><div class="line"></div><div class="line"> [&quot;..Q.&quot;,  // Solution 2</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;.Q..&quot;]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>对保存安放情况的变量类型作出修改：由原来的<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code> 变为<code>vector&lt;string&gt;&amp; vec</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class NQueen &#123;</div><div class="line">    char[][] map;</div><div class="line">    //判断当前点是否合理</div><div class="line">    public boolean isValid(int i,int j)&#123;</div><div class="line">        //上方是否有点</div><div class="line">        for(int line = 0;line &lt; i;line++)&#123;</div><div class="line">            if(map[line][j] == &apos;Q&apos;)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //左上对角线是否有Q</div><div class="line">        int line = i-1;</div><div class="line">        int col = j-1;</div><div class="line">        while (line &gt;= 0 &amp;&amp; col &gt;=0)&#123;</div><div class="line">            if(map[line][col] == &apos;Q&apos;)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            line--;</div><div class="line">            col--;</div><div class="line">        &#125;</div><div class="line">        //右上方是否有Q</div><div class="line">        line = i-1;</div><div class="line">        col = j+1;</div><div class="line">        while (line &gt;= 0 &amp;&amp; col &lt;map.length)&#123;</div><div class="line">            if(map[line][col] == &apos;Q&apos;)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            line--;</div><div class="line">            col++;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void solve(List&lt;List&lt;String&gt;&gt; results,int row)&#123;</div><div class="line">        if(row == map.length)&#123;</div><div class="line">            //map转化为结果存入result</div><div class="line">            List&lt;String&gt; res = new ArrayList&lt;&gt;();</div><div class="line">            for(int i = 0 ;i &lt; map.length;i++)&#123;</div><div class="line">                String s = new String();</div><div class="line">                for(int j = 0 ; j &lt; map.length;j++)&#123;</div><div class="line">                    s += map[i][j];</div><div class="line">                &#125;</div><div class="line">                res.add(s);</div><div class="line">            &#125;</div><div class="line">            results.add(res);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            for(int j = 0; j &lt; map.length;j++)&#123;</div><div class="line">                if(isValid(row,j))&#123;</div><div class="line">                    map[row][j] = &apos;Q&apos;;</div><div class="line">                    solve(results,row+1);</div><div class="line">                    map[row][j] = &apos;.&apos;;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();</div><div class="line">        //初始化map</div><div class="line">        this.map = new char[n][n];</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            for(int j = 0; j &lt; n ;j ++)&#123;</div><div class="line">                map[i][j] = &apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        solve(results,0);</div><div class="line">        return results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="leetcode相关问题"><a href="#leetcode相关问题" class="headerlink" title="leetcode相关问题"></a>leetcode相关问题</h1><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="external">Permutations</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of <strong>distinct</strong> numbers, return all possible permutations.</p>
<p>For example,<br><code>[1,2,3]</code> have the following permutations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,2,3],</div><div class="line">&gt;   [1,3,2],</div><div class="line">&gt;   [2,1,3],</div><div class="line">&gt;   [2,3,1],</div><div class="line">&gt;   [3,1,2],</div><div class="line">&gt;   [3,2,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>求给定数组中元素的排列组合，元素无重复</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>分析元素排列的全部可能，典型的回溯，按照上面的模板做就好</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] hasVisit;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == nums.length)&#123;</div><div class="line">            <span class="comment">//结果放入results</span></div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">                <span class="comment">//该元素没有中出现过,放入result</span></div><div class="line">                <span class="keyword">if</span>(!hasVisit[i])&#123;</div><div class="line">                    hasVisit[i] = <span class="keyword">true</span>;</div><div class="line">                    result.add(nums[i]);</div><div class="line">                    solve(n+<span class="number">1</span>,nums);</div><div class="line">                    hasVisit[i] = <span class="keyword">false</span>;</div><div class="line">                    result.remove(result.size()-<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">this</span>.results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.hasVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line"></div><div class="line">        solve(<span class="number">0</span>,nums);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<p><strong>固定-交换法</strong></p>
<p>还有一种思路，这个更好理解一丢丢：</p>
<p>n个数的全排列，一共有n!n!种情况. （n个位置，第一个位置有n种，当第一个位置固定下来之后，第二个位置有n-1种情况…）</p>
<p>全排列的过程：</p>
<ul>
<li>选择第一个字符</li>
<li>获得第一个字符固定下来之后的所有的全排列<ul>
<li>选择第二个字符</li>
<li>获得第一+ 二个字符固定下来之后的所有的全排列</li>
</ul>
</li>
</ul>
<p>从这个过程可见，这是一个递归的过程。</p>
<p>所以这种方式也是通过固定一个元素，进行剩余元素的交换。缺点是，每次交换过后需要再次交换以回到上一层数组。</p>
<p><a href="http://om1bxijvl.bkt.clouddn.com/2017-12-23-21-01-06.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-23-21-01-06.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">permutationsSwitch</span> </span>&#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> fixed)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(fixed == nums.length)&#123;</div><div class="line">            List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</div><div class="line">                result.add(e);</div><div class="line">            &#125;</div><div class="line">            results.add(result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = fixed;i &lt; nums.length;i++) &#123;</div><div class="line">                swap(nums,fixed,i);</div><div class="line">                helper(nums,fixed +<span class="number">1</span>);</div><div class="line">                swap(nums,fixed,i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        helper(nums,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="external">Permutations II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br><code>[1,1,2]</code> have the following unique permutations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,1,2],</div><div class="line">&gt;   [1,2,1],</div><div class="line">&gt;   [2,1,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>相比上一题，有重复元素</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>遇到重复元素先排序，排序之后按照上题的思路，</p>
<p>注意：选取同一位置上的元素时，需要跳过重复元素</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationsII</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] hasVisit;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == nums.length)&#123;</div><div class="line">            <span class="comment">//结果放入results</span></div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> last = Integer.MIN_VALUE;<span class="comment">//用以就该位置当前元素，下一轮遇到重复时需要跳过</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(hasVisit[i] || (i != <span class="number">0</span> &amp;&amp; nums[i] == last))&#123;<span class="comment">//这里不可以用nums[i] == nums[i-1]</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    hasVisit[i] = <span class="keyword">true</span>;</div><div class="line">                    result.add(nums[i]);</div><div class="line">                    solve(n+<span class="number">1</span>,nums);</div><div class="line">                    hasVisit[i] = <span class="keyword">false</span>;</div><div class="line">                    result.remove(result.size()-<span class="number">1</span>);</div><div class="line">                    last = nums[i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">this</span>.results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.hasVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.sort(nums);</div><div class="line">        solve(<span class="number">0</span>,nums);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="external">Permutation Sequence</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>The set <code>[1,2,3,…,*n*]</code> contains a total of <em>n</em>! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for <em>n</em> = 3):</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given <em>n</em> and <em>k</em>, return the <em>k</em>th permutation sequence.</p>
<p><strong>Note:</strong> Given <em>n</em> will be between 1 and 9 inclusive.</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对于<code>n</code>个字符组成的字符串<code>{1,2,3,...,n}</code>，取第<code>k</code>个数时，首先可以求出第一个数，即<code>(k-1)/(n-1)!</code>。</p>
<p>按照这样的方法依次求出每一位的数字。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] hasVisit;</div><div class="line">String result = <span class="keyword">new</span> String();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calProduct</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</div><div class="line">    result *= n;</div><div class="line">    n--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == nums.length)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//要找到第nn个数字放到这里</span></div><div class="line">  <span class="keyword">int</span> nn = (k-<span class="number">1</span>)/calProduct(nums.length-n-<span class="number">1</span>);</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; num &lt; nn)&#123;</div><div class="line">    <span class="comment">//如果nums[j]已经被用过了</span></div><div class="line">    <span class="keyword">while</span>(hasVisit[j])&#123;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    num++;</div><div class="line">    j++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(hasVisit[j])&#123;</div><div class="line">    j++;</div><div class="line">  &#125;</div><div class="line">  result += nums[j];</div><div class="line">  hasVisit[j] = <span class="keyword">true</span>;</div><div class="line">  solve(n+<span class="number">1</span>,nums,k - (nn)*calProduct(nums.length-n-<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</div><div class="line">    nums[i-<span class="number">1</span>] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.hasVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">  solve(<span class="number">0</span>,nums,k);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Binary-Watch"><a href="#Binary-Watch" class="headerlink" title="Binary Watch"></a><a href="https://leetcode.com/problems/binary-watch/" target="_blank" rel="external">Binary Watch</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>A binary watch has 4 LEDs on the top which represent the <strong>hours</strong> (<strong>0-11</strong>), and the 6 LEDs on the bottom represent the <strong>minutes</strong> (<strong>0-59</strong>).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.</p>
<p>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: n = 1</div><div class="line">&gt; Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
</blockquote>
<p>一个二进制手表，第一行有4个灯代表小时，第二行有6个灯代表分钟，给定一个num表示总共可以亮的灯的数量，返回所有可能的时间</p>
<p>注意：时间表示范围为0-11:59</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>方法一：</p>
<p>分别对小时和分钟进行回溯，把num分配到两行上，计算小时和分钟的可能值，再进行组合输出</p>
<p>方法二：</p>
<p>利用<code>Integer.bitCount()</code> 函数计算二进制表示的1的个数，遍历00:00-11:59所有的时间，当小时和分钟的二进制表示中1的个数和为0时输出到结果集合。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryWatch</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; HorM;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; HHs;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; MMs;</div><div class="line"></div><div class="line">    <span class="comment">//计算时间,转化为字符串</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">calTime</span><span class="params">(List&lt;Integer&gt; hour,List&lt;Integer&gt; minute)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] hh = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] mm = &#123;<span class="number">32</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</div><div class="line">        String res = <span class="keyword">new</span> String();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">            h += hour.get(i) * hh[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>;i++)&#123;</div><div class="line">            m += minute.get(i) * mm[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(h &lt;<span class="number">12</span> &amp;&amp; m &lt; <span class="number">60</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(m&lt;<span class="number">10</span>)&#123;</div><div class="line">                res = Integer.toString(h) + <span class="string">":0"</span> + Integer.toString(m);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                res = Integer.toString(h) + <span class="string">":"</span> + Integer.toString(m);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算小时或者分钟</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> oneSum,List&lt;Integer&gt; HorM,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(HorM.size() == n &amp;&amp; oneSum == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(HorM);</div><div class="line">            <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</div><div class="line">                HHs.add(temp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                MMs.add(temp);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HorM.size() == n &amp;&amp; oneSum != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            HorM.add(<span class="number">0</span>);</div><div class="line">            solve(oneSum,HorM,n);</div><div class="line">            HorM.remove(HorM.size()-<span class="number">1</span>);</div><div class="line">            HorM.add(<span class="number">1</span>);</div><div class="line">            solve(oneSum - <span class="number">1</span>,HorM,n);</div><div class="line">            HorM.remove(HorM.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//计算第一行最少和最多放置几个元素</span></div><div class="line">        <span class="keyword">int</span> min = Math.min(<span class="number">0</span>,Math.max(<span class="number">0</span>,num-<span class="number">8</span>));</div><div class="line">        <span class="keyword">int</span> max = Math.min(<span class="number">4</span>,num);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min ; i &lt;= max;i++)&#123;</div><div class="line">            HHs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            MMs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            HorM = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="comment">//i为第一行放置个数</span></div><div class="line">            <span class="comment">//计算小时数组</span></div><div class="line">            solve(i,HorM,<span class="number">4</span>);</div><div class="line">            <span class="comment">//计算分钟数组</span></div><div class="line">            HorM = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            solve(num - i,HorM,<span class="number">6</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; HHs.size();ii++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt; MMs.size();jj++)&#123;</div><div class="line">                    String res = calTime(HHs.get(ii),MMs.get(jj));</div><div class="line">                    <span class="keyword">if</span>(!res.isEmpty())&#123;</div><div class="line">                        result.add(res);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        BinaryWatch test = <span class="keyword">new</span> BinaryWatch();</div><div class="line">        List&lt;String&gt; result = test.readBinaryWatch(<span class="number">2</span>);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h ++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m ++) &#123;</div><div class="line">                <span class="keyword">if</span> (Integer.bitCount(h) + Integer.bitCount(m) == num) &#123;</div><div class="line">                    <span class="keyword">if</span> (m &lt; <span class="number">10</span>) &#123;</div><div class="line">                        res.add(h + <span class="string">":"</span> + <span class="string">"0"</span> + m);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        res.add(h + <span class="string">":"</span> + m);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a><a href="https://leetcode.com/problems/next-permutation" target="_blank" rel="external">Next Permutation</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>如果数组是降序的，则这几个数组的组合中，后面没有了：</p>
<p>比如[9,7,6,5,4]，这几个数字是降序的，由这几个数字组成的排列中没有序号大于这个组合方式的了。</p>
<p>当数组中出现升序位置时，说明后面有编号大于此排列的排列情况</p>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="Next Permutation"></p>
<p>步骤：</p>
<ol>
<li>找到第一处升序数组[4,7]</li>
<li>将升序位置与后面数组中最后一个大于该元素的位置交换[4,5]</li>
<li>此时原来5位置的后面都比4小，前面都比4大，而且是降序，所以将后半段数组倒置即可。</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//交换两个位置</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> temp = nums[i];</div><div class="line">  nums[i] = nums[j];</div><div class="line">  nums[j] = temp;</div><div class="line">&#125;</div><div class="line"><span class="comment">//数组反转</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">int</span> temp = nums[i];</div><div class="line">    nums[i] = nums[j];</div><div class="line">    nums[j] = temp;</div><div class="line">    i++;</div><div class="line">    j--;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="comment">//找第一次出现升序的地方</span></div><div class="line">  <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    i--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</div><div class="line">    reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//找到第一个比nums[i-1]小的数字</span></div><div class="line">    <span class="keyword">int</span> j = i+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> target = nums[i-<span class="number">1</span>];</div><div class="line">    <span class="keyword">while</span>(j &lt; nums.length)&#123;</div><div class="line">      <span class="keyword">if</span>(nums[j] &lt;= target)&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    swap(nums,i-<span class="number">1</span>,j-<span class="number">1</span>);</div><div class="line">    reverse(nums,i,nums.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="external">Combinations</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>For example,<br>If <em>n</em> = 4 and <em>k</em> = 2, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [2,4],</div><div class="line">&gt;   [3,4],</div><div class="line">&gt;   [2,3],</div><div class="line">&gt;   [1,2],</div><div class="line">&gt;   [1,3],</div><div class="line">&gt;   [1,4],</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给定n和k，给出<script type="math/tex">C(n,k)</script> 的全部组合方式</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>非常典型的回溯问题</p>
<p>思路就是从n个里面选择1个，然后再剩余的n-1个里面选择k-1个</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">//一共1-n和数字，从start开始，选择k个</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> start,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="comment">//k个都选完了，加入结果</span></div><div class="line">  <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</div><div class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    temp.addAll(result);</div><div class="line">    results.add(temp);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//遍历到最后了，但是没选够k个，返回</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(start == n+<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//遍历从start右边的元素，选取一个，在剩下的元素中选取k-1个</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= n;i++)&#123;</div><div class="line">      result.add(i);</div><div class="line">      solve(n,i+<span class="number">1</span>,k-<span class="number">1</span>);</div><div class="line">      result.remove(result.size()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">  solve(n,<span class="number">1</span>,k);</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="external">Combination Sum</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [7],</div><div class="line">&gt;   [2, 2, 3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给一个数组和一个target.求数组中的元素和等于target的所有可能。元素可以多次取。</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>回溯</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start == candidates.length)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; candidates.length;i++)&#123;</div><div class="line">                result.add(candidates[i]);</div><div class="line">                solve(candidates,target-candidates[i],i);</div><div class="line">                result.remove(result.size()-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        solve(candidates,target,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="external">Combination Sum II</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p>
<p>Each number in <strong>C</strong> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1, 7],</div><div class="line">&gt;   [1, 2, 5],</div><div class="line">&gt;   [2, 6],</div><div class="line">&gt;   [1, 1, 6]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>给一个有重数组和一个target.求数组中的元素和等于target的所有可能。元素不可以多次取。</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>这道题与上一题的最大区别就是不能多次取！需要注意的地方就是递归进入时的i需要加一（跳过本元素）</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start == candidates.length)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; candidates.length;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(i &gt; start  &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])<span class="keyword">continue</span>; <span class="comment">// 去重</span></div><div class="line">                result.add(candidates[i]);</div><div class="line">                solve(candidates,target-candidates[i],i+<span class="number">1</span>);</div><div class="line">                result.remove(result.size()-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        Arrays.sort(candidates);</div><div class="line">        solve(candidates,target,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        CombinationSum test = <span class="keyword">new</span> CombinationSum();</div><div class="line">        <span class="keyword">int</span>[] candidates = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</div><div class="line">        <span class="keyword">int</span> target = <span class="number">7</span>;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; resuts = test.combinationSum(candidates,target);</div><div class="line">        System.out.print(resuts);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="external">Combination Sum III</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Find all possible combinations of <strong>*k*</strong> numbers that add up to a number <strong>*n*</strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>*Example 1:*</strong></p>
<p>Input: <strong>*k*</strong> = 3, <strong>*n*</strong> = 7</p>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,2,4]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>*Example 2:*</strong></p>
<p>Input: <strong>*k*</strong> = 3, <strong>*n*</strong> = 9</p>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,2,6], [1,3,5], [2,3,4]]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>求k个数（0-9的数）的和为n的所有组合。</p>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>还是回溯问题。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)&#123;</div><div class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    temp.addAll(result);</div><div class="line">    results.add(temp);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= <span class="number">9</span>; i++)&#123;</div><div class="line">      result.add(i);</div><div class="line">      solve(k-<span class="number">1</span>,n-i,i+<span class="number">1</span>);</div><div class="line">      result.remove(result.size()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Count-Numbers-with-Unique-Digits"><a href="#Count-Numbers-with-Unique-Digits" class="headerlink" title="Count Numbers with Unique Digits"></a><a href="https://leetcode.com/problems/count-numbers-with-unique-digits/" target="_blank" rel="external">Count Numbers with Unique Digits</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a <strong>non-negative</strong> integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.</p>
<p><strong>Example:</strong><br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding <code>[11,22,33,44,55,66,77,88,99]</code>)</p>
<p><strong>Credits:</strong><br>Special thanks to <a href="https://discuss.leetcode.com/user/memoryless" target="_blank" rel="external">@memoryless</a> for adding this problem and creating all test cases.</p>
</blockquote>
<p>给一个n。求x的个数，其中0&lt;=x&lt;=10n0&lt;=x&lt;=10n ，且x的每一位的数字都不相同。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">n位数的可能有如下：</div><div class="line"></div><div class="line"><span class="number">0</span>      （就是<span class="number">0</span>）</div><div class="line"><span class="number">1</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>)  (从<span class="number">1</span>-<span class="number">9</span>里随机挑选一个)</div><div class="line"><span class="number">2</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">9</span>,<span class="number">1</span>)  (第一位从<span class="number">1</span>-<span class="number">9</span>挑，第二位与第一位不同即可，所以也是<span class="number">9</span>种)</div><div class="line"><span class="number">3</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">8</span>,<span class="number">1</span>) (第一位从<span class="number">1</span>-<span class="number">9</span>挑，第二位与第一位不同，第三位与前两位不同)</div><div class="line">...</div><div class="line">n 位数</div><div class="line"></div><div class="line">代码：</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span>[] c = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">            <span class="keyword">int</span> product = <span class="number">9</span>;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i &lt; n-<span class="number">1</span>)&#123;</div><div class="line">                product *= c[i];</div><div class="line">                num += product;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Beautiful-Arrangement"><a href="#Beautiful-Arrangement" class="headerlink" title="Beautiful Arrangement"></a><a href="https://leetcode.com/problems/beautiful-arrangement/" target="_blank" rel="external">Beautiful Arrangement</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Suppose you have <strong>N</strong> integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these <strong>N</strong> numbers successfully if one of the following is true for the ith position (1 &lt;= i &lt;= N) in this array:</p>
<ol>
<li>The number at the ith position is divisible by <strong>i</strong>.</li>
<li><strong>i</strong> is divisible by the number at the ith position.</li>
</ol>
<p>Now given N, how many beautiful arrangements can you construct?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 2</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: </div><div class="line">&gt;</div><div class="line">&gt; The first beautiful arrangement is [1, 2]:</div><div class="line">&gt;</div><div class="line">&gt; Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).</div><div class="line">&gt;</div><div class="line">&gt; Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).</div><div class="line">&gt;</div><div class="line">&gt; The second beautiful arrangement is [2, 1]:</div><div class="line">&gt;</div><div class="line">&gt; Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).</div><div class="line">&gt;</div><div class="line">&gt; Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>回溯，遇到满足条件的sum++;</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautifulArrangement</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] map;</div><div class="line">    <span class="keyword">int</span>[] result;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx % val == <span class="number">0</span> || (idx !=<span class="number">0</span> &amp;&amp; val % idx == <span class="number">0</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> N)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx == N)&#123;</div><div class="line">            sum++;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(!map[i-<span class="number">1</span>] &amp;&amp; isValid(idx+<span class="number">1</span>,i))&#123;</div><div class="line">                    result[idx] = i;</div><div class="line">                    map[i-<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">                    solve(idx+<span class="number">1</span>,N);</div><div class="line">                    map[i-<span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</div><div class="line">        <span class="keyword">this</span>.result = <span class="keyword">new</span> <span class="keyword">int</span>[N];</div><div class="line">        solve(<span class="number">0</span>,N);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="external">Letter Combinations of a Phone Number</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:Digit string &quot;23&quot;</div><div class="line">&gt; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>组合问题，回溯即可</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsofaPhoneNumber</span> </span>&#123;</div><div class="line">    HashMap&lt;Character, <span class="keyword">char</span>[]&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    String result = <span class="keyword">new</span> String();</div><div class="line">    List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTable</span><span class="params">()</span></span>&#123;</div><div class="line">        table.put(<span class="string">'1'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]);</div><div class="line">        table.put(<span class="string">'2'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</div><div class="line">        table.put(<span class="string">'3'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;);</div><div class="line">        table.put(<span class="string">'4'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>&#125;);</div><div class="line">        table.put(<span class="string">'5'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;);</div><div class="line">        table.put(<span class="string">'6'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>&#125;);</div><div class="line">        table.put(<span class="string">'7'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>&#125;);</div><div class="line">        table.put(<span class="string">'8'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>&#125;);</div><div class="line">        table.put(<span class="string">'9'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>&#125;);</div><div class="line">        table.put(<span class="string">'0'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>&#125;);</div><div class="line">        table.put(<span class="string">'#'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'#'</span>&#125;);</div><div class="line">        table.put(<span class="string">'*'</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'*'</span>&#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(String digits,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx == digits.length())&#123;</div><div class="line">            String temp = <span class="keyword">new</span> String();</div><div class="line">            temp += result;</div><div class="line">            <span class="keyword">if</span>(!temp.isEmpty())&#123;</div><div class="line">                results.add(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(table.get(digits.charAt(idx)).length == <span class="number">0</span>)&#123;</div><div class="line">                solve(digits,idx+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(table.get(digits.charAt(idx)).length == <span class="number">1</span>)&#123;</div><div class="line">                result += table.get(digits.charAt(idx))[<span class="number">0</span>];</div><div class="line">                solve(digits,idx+<span class="number">1</span>);</div><div class="line">                result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; table.get(digits.charAt(idx)).length;i++)&#123;</div><div class="line">                    result += table.get(digits.charAt(idx))[i];</div><div class="line">                    solve(digits,idx+<span class="number">1</span>);</div><div class="line">                    result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</div><div class="line">        buildTable();</div><div class="line">        solve(digits,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">        LetterCombinationsofaPhoneNumber test = <span class="keyword">new</span> LetterCombinationsofaPhoneNumber();</div><div class="line">        String digits = <span class="string">"22"</span>;</div><div class="line">        test.buildTable();</div><div class="line">        List&lt;String&gt; results = test.letterCombinations(digits);</div><div class="line">        System.out.print(results);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="external">Generate Parentheses</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   &quot;((()))&quot;,</div><div class="line">&gt;   &quot;(()())&quot;,</div><div class="line">&gt;   &quot;(())()&quot;,</div><div class="line">&gt;   &quot;()(())&quot;,</div><div class="line">&gt;   &quot;()()()&quot;</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>回溯，向2n个位置放<code>‘(’</code>  或<code>‘)’</code> 用变量<code>rightNeed</code> 表示右边还需要的<code>‘)’</code>数量，也就是当前<code>‘(’</code>  与<code>‘)’</code> 的数量差：</p>
<ol>
<li>如果放置过程中出现右括号必做括号多的情况，返回上一层，因为这种情况不可能是结果了，无需向下计算</li>
<li>当2n个括号放置完毕，且左右括号相等时</li>
<li>加入括号有两重方式，加入左括号或者右括号</li>
</ol>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    String result = <span class="keyword">new</span> String();</div><div class="line">    <span class="keyword">char</span>[] parentheses;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> rightNeed,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(rightNeed &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(idx == <span class="number">2</span>*n)&#123;</div><div class="line">            <span class="keyword">if</span>(rightNeed == <span class="number">0</span>)&#123;</div><div class="line">                String temp = <span class="keyword">new</span> String();</div><div class="line">                temp += result;</div><div class="line">                results.add(temp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//加入括号分两种情况讨论：left和right</span></div><div class="line">            result += <span class="string">'('</span>;</div><div class="line">            solve(idx+<span class="number">1</span>,rightNeed+<span class="number">1</span>,n);</div><div class="line">            result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line"></div><div class="line">            result += <span class="string">')'</span>;</div><div class="line">            solve(idx+<span class="number">1</span>,rightNeed-<span class="number">1</span>,n);</div><div class="line">            result = result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        solve(<span class="number">0</span>,<span class="number">0</span>,n);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="external">Sudoku Solver</a></h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<p>A sudoku puzzle…</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p>
<p>9×99×9 的数独，填入数字1-9，要求行列不重复，且每个宫内不重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[][] usedinLine = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//第i行中是否用过数字k</span></div><div class="line"><span class="keyword">boolean</span>[][] usedinCol = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//第i列中是否用过数字k</span></div><div class="line"><span class="keyword">boolean</span>[][][] usedinBlock = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];<span class="comment">//第ij个格子中是否用过数字k</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span>;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">9</span>; val++) &#123;</div><div class="line">          <span class="keyword">if</span> (!usedinLine[i][val - <span class="number">1</span>] &amp;&amp; !usedinCol[j][val - <span class="number">1</span>] &amp;&amp; !usedinBlock[i / <span class="number">3</span>][j / <span class="number">3</span>][val - <span class="number">1</span>]) &#123;</div><div class="line">            usedinLine[i][val - <span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            usedinCol[j][val - <span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            usedinBlock[i / <span class="number">3</span>][j / <span class="number">3</span>][val - <span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            board[i][j] = (<span class="keyword">char</span>) (val + <span class="number">48</span>);</div><div class="line">            <span class="keyword">if</span> (solve(board)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            usedinLine[i][val - <span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">            usedinCol[j][val - <span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">            usedinBlock[i / <span class="number">3</span>][j / <span class="number">3</span>][val - <span class="number">1</span>] = <span class="keyword">false</span>;</div><div class="line">            board[i][j] = <span class="string">'.'</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span>;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</div><div class="line">        usedinLine[i][board[i][j]-<span class="string">'1'</span>] = <span class="keyword">true</span>;</div><div class="line">        usedinCol[j][board[i][j]-<span class="string">'1'</span>] = <span class="keyword">true</span>;</div><div class="line">        usedinBlock[i/<span class="number">3</span>][j/<span class="number">3</span>][board[i][j]-<span class="string">'1'</span>] = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  solve(board);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a><a href="https://leetcode.com/problems/wildcard-matching" target="_blank" rel="external">Wildcard Matching</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &apos;?&apos; Matches any single character.</div><div class="line">&gt; &apos;*&apos; Matches any sequence of characters (including the empty sequence).</div><div class="line">&gt;</div><div class="line">&gt; The matching should cover the entire input string (not partial).</div><div class="line">&gt;</div><div class="line">&gt; The function prototype should be:</div><div class="line">&gt; bool isMatch(const char *s, const char *p)</div><div class="line">&gt;</div><div class="line">&gt; Some examples:</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;a&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</div><div class="line">&gt; isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</div><div class="line">&gt; isMatch(&quot;ab&quot;, &quot;?*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>被伤透了的一道题。。。凉凉</p>
<p>思路就是：两指针i,j + 回溯</p>
<ol>
<li>两指针所指元素相等或者j指向‘?’，两指针后移递归调用</li>
<li>两指针指的元素不相等，j也没指向‘?’和‘*’，这种情况凑不成一样的了，回溯</li>
<li>如果j指向‘*’i可以选择跳过0\1\2.…一直到可以跳到最后一个元素，然后j也向后跳一个，看后面的是否相等，也就是递归调用了</li>
</ol>
<p>边界条件：</p>
<ol>
<li>两指针都指向末尾了，返回true</li>
<li>j到末尾了，i没有，返回false</li>
<li>i到末尾了，j没有，如果j后面都是*则返回true,否则不可能相等，返回true</li>
</ol>
<p>写完了超时了，因为ij组合会重复计算，所以需要用dp,把算过的存下来</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardMatching</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(String s, String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="comment">//边界条件</span></div><div class="line">    <span class="comment">//两指针都遍历到末尾</span></div><div class="line">    <span class="keyword">if</span>(i == s.length() &amp;&amp; j == p.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//j遍历到末尾，i没有</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//i指针遍历到末尾，j没有</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">      <span class="comment">//如果j后面都是*了，则可以相等</span></div><div class="line">      <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">        j++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//如果j后面不是全是*则一定不可以</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遇到*，i可以继续向后遍历，判断是否相等，回溯</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">      <span class="keyword">while</span>(i &lt;= s.length())&#123;</div><div class="line">        <span class="keyword">if</span>(solve(s,p,i,j+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        i++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遇到？或者两个字符相等，继续匹配下一个</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'?'</span> || s.charAt(i) == p.charAt(j))&#123;</div><div class="line">      <span class="keyword">return</span> solve(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//两字符单纯地不相等</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> solve(s,p,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    WildcardMatching test = <span class="keyword">new</span> WildcardMatching();</div><div class="line">    String s = <span class="string">"a"</span>;</div><div class="line">    String p = <span class="string">"aa"</span>;</div><div class="line">    <span class="keyword">boolean</span> a = test.solve(s,p,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    System.out.print(a);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改进DP：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] dp;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String s, String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="comment">//计算过了 直接返回</span></div><div class="line">  <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//边界条件</span></div><div class="line">  <span class="comment">//两指针都遍历到末尾</span></div><div class="line">  <span class="keyword">if</span>(i == s.length() &amp;&amp; j == p.length())&#123;</div><div class="line">    dp[i][j] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//j遍历到末尾，i没有</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">    dp[i][j] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//i指针遍历到末尾，j没有</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">    <span class="comment">//如果j后面都是*了，则可以相等</span></div><div class="line">    <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(j == p.length())&#123;</div><div class="line">      dp[i][j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果j后面不是全是*则一定不可以</span></div><div class="line">    <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//遇到*，i可以继续向后遍历，判断是否相等，回溯</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">    dp[i][j] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt;= s.length())&#123;</div><div class="line">      <span class="keyword">if</span>(solve(s,p,i,j+<span class="number">1</span>) == <span class="number">1</span>)&#123;</div><div class="line">        dp[i][j] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">      &#125;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[i-<span class="number">1</span>][j];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//遇到？或者两个字符相等，继续匹配下一个</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'?'</span> || s.charAt(i) == p.charAt(j))&#123;</div><div class="line">    dp[i][j] = solve(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//两字符单纯地不相等</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    dp[i][j] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">  dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</div><div class="line">  solve(s,p,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> dp[s.length()][p.length()]==<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="external">Regular Expression Matching</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &apos;.&apos; Matches any single character.</div><div class="line">&gt; &apos;*&apos; Matches zero or more of the preceding element.</div><div class="line">&gt;</div><div class="line">&gt; The matching should cover the entire input string (not partial).</div><div class="line">&gt;</div><div class="line">&gt; The function prototype should be:</div><div class="line">&gt; bool isMatch(const char *s, const char *p)</div><div class="line">&gt;</div><div class="line">&gt; Some examples:</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;a&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</div><div class="line">&gt; isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aa&quot;, &quot;.*&quot;) → true</div><div class="line">&gt; isMatch(&quot;ab&quot;, &quot;.*&quot;) → true</div><div class="line">&gt; isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p><code>.</code>可代表任意一个字母</p>
<p><code>*</code> 和它前面的字母组合m在一起，可以用于表示0或任意多个m</p>
<p>思路就是两指针，从后向前匹配，当遇到*时，有两种选择：</p>
<ol>
<li>匹配s中的0个（j-2,i不变），继续向后递归</li>
<li>匹配s中的1个（j不变,i-1），继续向后递归</li>
<li>多个的情况包含在2中</li>
</ol>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(String s, String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; <span class="number">0</span>)&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">                <span class="keyword">return</span> solve(s,p,i,j-<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</div><div class="line">            <span class="comment">//如果*前面一个是.或者是跟i指向的字母一样，可以选择匹配1个或者不匹配</span></div><div class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span> || p.charAt(j-<span class="number">1</span>) == s.charAt(i))&#123;</div><div class="line">                <span class="keyword">return</span> solve(s, p,i-<span class="number">1</span>,j) || <span class="comment">//匹配了s中的1个字符，j向前移两位，继续，这里匹配了多个字符的情况包含在后续的计算中了</span></div><div class="line">                        solve(s,p,i,j-<span class="number">2</span>);<span class="comment">//匹配了s中的0个字符，j向前移两位，继续</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果*前面不是.也不和i指向的数字一样，只能让他复制0个，继续往后判断</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span>  solve(s, p,i,j-<span class="number">2</span>);<span class="comment">//匹配了s中的0个字符，j向前移两位，继续</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> solve(s,p,i-<span class="number">1</span>,j-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//指向字母不一样</span></div><div class="line">        <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> solve(s,p,s.length()-<span class="number">1</span>,p.length()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        RegularExpressionMatching test = <span class="keyword">new</span> RegularExpressionMatching();</div><div class="line">        String s = <span class="string">"aab"</span>;</div><div class="line">        String p = <span class="string">"c*a*b"</span>;</div><div class="line">        <span class="keyword">boolean</span> a = test.isMatch(s,p);</div><div class="line">        System.out.print(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II    "></a><a href="https://leetcode.com/problems/subsets" target="_blank" rel="external"><a href="https://leetcode.com/problems/subsets-ii" target="_blank" rel="external">Subsets II</a>    </a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If <strong>nums</strong> = <code>[1,2,2]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [2],</div><div class="line">&gt;   [1],</div><div class="line">&gt;   [1,2,2],</div><div class="line">&gt;   [2,2],</div><div class="line">&gt;   [1,2],</div><div class="line">&gt;   []</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>遇到重复元素先排序，然后回溯。需要注意的是遇到重复的元素需要跳过，但是只有在本位置用过的才不可以用相同元素，所以需要加一个flag来验证一下</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">if</span>(idx == nums.length)&#123;<span class="keyword">return</span>;&#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; nums.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; flag)&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      result.add(nums[i]);</div><div class="line">      List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">      temp.addAll(result);</div><div class="line">      results.add(temp);</div><div class="line">      solve(nums,i+<span class="number">1</span>);</div><div class="line">      result.remove(result.size()-<span class="number">1</span>);</div><div class="line">      flag = <span class="keyword">true</span>;<span class="comment">//记录在本位置是否用过</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  results.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">  solve(nums,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Increasing-Subsequences"><a href="#Increasing-Subsequences" class="headerlink" title="Increasing Subsequences"></a><a href="https://leetcode.com/problems/increasing-subsequences" target="_blank" rel="external">Increasing Subsequences</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote>
<hr>
<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [4, 6, 7, 7]</div><div class="line">&gt; Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will not exceed 15.</li>
<li>The range of integer in the given array is [-100,100].</li>
<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>
</ol>
</blockquote>
<p>给定数组，列举所有递增子序列</p>
<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>回溯</p>
<p>如果加入的元素比result中最后一个元素的，就加入结果集合，否则不加入，继续向后。对于重复元素，需要跳过，这里元素无法排序，所以需要一个额外的数组维护元素是否出现过。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreasingSubsequences</span> </span>&#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] flag= <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">201</span>];</div><div class="line">    <span class="keyword">if</span>(idx == nums.length)&#123;<span class="keyword">return</span>;&#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(flag[nums[i]+<span class="number">100</span>])&#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果当前result里没有元素或者当前元素比result里面的最后一个元素大，加入元素</span></div><div class="line">        <span class="keyword">if</span>(result.size() == <span class="number">0</span> || nums[i] &gt;= result.get(result.size()-<span class="number">1</span>))&#123;</div><div class="line">          result.add(nums[i]);</div><div class="line">          flag[nums[i]+<span class="number">100</span>] = <span class="keyword">true</span>;<span class="comment">//标志本轮这个元素用过了</span></div><div class="line">          <span class="keyword">if</span>(result.size() &gt; <span class="number">1</span>)&#123;<span class="comment">//如果当前子序列长度大于1,加入结果集</span></div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">          &#125;</div><div class="line">          solve(nums,i+<span class="number">1</span>);<span class="comment">//不管是不是加入结果集了，都要继续下一层</span></div><div class="line">          result.remove(result.size()-<span class="number">1</span>);<span class="comment">//有nums[i]的计算完毕，将其移除</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    solve(nums,<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    IncreasingSubsequences test = <span class="keyword">new</span> IncreasingSubsequences();</div><div class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; res = test.findSubsequences(nums);</div><div class="line">    System.out.print(res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Gray-Code"><a href="#Gray-Code" class="headerlink" title="Gray Code"></a><a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="external">Gray Code</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer <em>n</em> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given <em>n</em> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 00 - 0</div><div class="line">&gt; 01 - 1</div><div class="line">&gt; 11 - 3</div><div class="line">&gt; 10 - 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong><br>For a given <em>n</em>, a gray code sequence is not uniquely defined.</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
</blockquote>
<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p> <img src="http://omaby2s5z.bkt.clouddn.com/2018-01-16-18-15-09.png" alt=""></p>
<p>格雷码是很经典的问题，规则其实很简单，在二进制形式下，任何相邻的两个值的二进制表示形式只有一位是不同的，我们可以找找规律。</p>
<p>一位就是简单的：0,1</p>
<p>两位是：00,01,11,10</p>
<p>三位是：000,001,011,010,110,111,101,100</p>
<p>发现什么规律没有？我们把一位的两个数，前面加上0，就是二位的头两个数，前面加上1再反序，就是二位的后两个数。把二位的前面加上0，就是三位的头四个数，把二位的前面加上1再反过来，就是三位的后四个数。</p>
<p>也就是说，对于每多一位的格雷码，前面一半的第一位都是0，后面一半的第一位都是1，其余的位，前后两半正好是中间对称的，前面一半就是少一位的格雷码序列，后面一半时把其反序。</p>
<p>知道这个规律就好做了，我们可以递归来做，每次取n-1位的格雷码来做上述操作，对于一位的格雷码，直接赋值是0,1就可以了。</p>
<p>不过题目要求返回的是十进制数，而不是字符串，所以我们最好直接操作十进制数，这里前面加0其实就不用做什么，前面加1的话可以将1左移n-1位然后与各个数字相加即可。</p>
<p>注意题目说的n是非负数，所以要考虑n=0的情况，测试用例的n=0时返回的是0。</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    results.add(<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  results.add(<span class="number">0</span>);</div><div class="line">  results.add(<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)&#123; <span class="keyword">return</span> results;&#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</div><div class="line">    <span class="keyword">int</span> len = results.size();</div><div class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> delta = <span class="number">1</span>&lt;&lt;i;</div><div class="line">      results.add(results.get(len-<span class="number">1</span>) + delta);</div><div class="line">      len--;</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006121957" target="_blank" rel="external">liuqi627的博客</a><br><a href="http://www.jianshu.com/p/8f3b8df612ae" target="_blank" rel="external">Jason_Yuan的博客</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++STL中堆的使用]]></title>
      <url>/2017/11/04/c-STL%E4%B8%AD%E5%A0%86%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="方法一：priority-queue"><a href="#方法一：priority-queue" class="headerlink" title="方法一：priority_queue"></a>方法一：priority_queue</h2><p>这种方法需要<code>#include&lt;queue&gt;</code></p>
<p>最基本的使用方法，对于一串数字建堆：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">riority_queue&lt;<span class="keyword">int</span>&gt; heap;</div></pre></td></tr></table></figure>
<p>这种情况下默认为最大堆，也就是堆顶元素值最大。</p>
<p>如果需要建立最小堆，可以采用如下方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最小堆</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最大堆</span></div></pre></td></tr></table></figure>
<p>然而在多数情况下，我们还需要记录一些排序元素的额外信息，比如索引之类的，则需要以下三个步骤：</p>
<ol>
<li><p>定义堆中需要存储的结构体：</p>
<p>​</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line">Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>确定堆中元素的存储顺序，也就是最大堆还是最小堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置比较函数，确定堆中元素的顺序，是最大堆还是最小堆，</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</div><div class="line">       	<span class="keyword">return</span> a.val&gt;b.val;<span class="comment">//最小堆</span></div><div class="line">      	<span class="comment">//return a.val&lt;b.val;//最大堆</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>建堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; heap;<span class="comment">//建堆</span></div><div class="line">heap.pop();<span class="comment">//出堆</span></div><div class="line">heap.push();<span class="comment">//入堆</span></div><div class="line">heap.top();<span class="comment">//获取堆顶元素</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="方法二：利用vector"><a href="#方法二：利用vector" class="headerlink" title="方法二：利用vector"></a>方法二：利用vector</h2><p>这种法法需要<code>#include&lt;algorithm&gt;</code> <code>#include &lt;functional&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</div><div class="line"><span class="comment">//建堆</span></div><div class="line">make_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大堆</span></div><div class="line">make_heap(a.begin(),a.end(), greater&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小堆</span></div><div class="line"><span class="comment">//pop</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大值出堆</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小值出堆</span></div><div class="line"><span class="comment">//插入元素</span></div><div class="line">push_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">//堆排序</span></div><div class="line">sort_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">// push_heap ( begin , end )   将最后一个元素插入堆中（堆自动调整）</span></div><div class="line"><span class="comment">// pop_heap ( begin , end )   将第一个元素从堆中删去（堆自动调整），并放到最后</span></div><div class="line"><span class="comment">// find ( begin , end , value ) 从begin到end查找value，若找不到，返回end</span></div></pre></td></tr></table></figure>
<p>​     </p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记1]]></title>
      <url>/2017/11/04/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/</url>
      <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p>
<ol>
<li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li>
<li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li>
<li>Kth Largest in N Arrays</li>
</ol>
<h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
</blockquote>
<p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p>
<p><strong>example</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p>
<p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p>
<p>看了leetcode题解，有二分查找的方式更快。</p>
<p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p>
<ul>
<li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li>
<li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li>
<li>直到min和max回合，此时就找到了第k个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p>
<p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p>
</blockquote>
<p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>7</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>2+1=3</td>
<td>2+7=9</td>
<td>2+11=13</td>
</tr>
<tr>
<td>4</td>
<td>4+1=5</td>
<td>4+7=11</td>
<td>4+11=15</td>
</tr>
<tr>
<td>6</td>
<td>6+1=7</td>
<td>6+7=13</td>
<td>6+11=17</td>
</tr>
</tbody>
</table>
</div>
<p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定N个无序数组，从中找出第k大的元素</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p>
<ol>
<li>将N个数组中的最大值入堆</li>
<li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li>
<li>循环k次，找到第k大的元素</li>
</ol>
<p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  	<span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      	<span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       	<span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li>
<li>见到第k小，想到用堆维护候选集合，出堆k次</li>
<li>见到数组要往排序上面想，先排序，然后再其他操作</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 九章算法 </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【九章算法强化班】课程笔记2]]></title>
      <url>/2017/11/04/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E7%AC%ACk%E5%A4%A7/</url>
      <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p>
<ol>
<li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li>
<li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li>
<li>Kth Largest in N Arrays</li>
</ol>
<h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
</blockquote>
<p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p>
<p><strong>example</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p>
<p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p>
<p>看了leetcode题解，有二分查找的方式更快。</p>
<p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p>
<ul>
<li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li>
<li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li>
<li>直到min和max回合，此时就找到了第k个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p>
<p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p>
</blockquote>
<p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>7</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>2+1=3</td>
<td>2+7=9</td>
<td>2+11=13</td>
</tr>
<tr>
<td>4</td>
<td>4+1=5</td>
<td>4+7=11</td>
<td>4+11=15</td>
</tr>
<tr>
<td>6</td>
<td>6+1=7</td>
<td>6+7=13</td>
<td>6+11=17</td>
</tr>
</tbody>
</table>
</div>
<p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定N个无序数组，从中找出第k大的元素</p>
</blockquote>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p>
<ol>
<li>将N个数组中的最大值入堆</li>
<li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li>
<li>循环k次，找到第k大的元素</li>
</ol>
<p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  	<span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      	<span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       	<span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li>
<li>见到第k小，想到用堆维护候选集合，出堆k次</li>
<li>见到数组要往排序上面想，先排序，然后再其他操作</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 九章算法 </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DSP国内硕士论文总结]]></title>
      <url>/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>准备开题，先看一下国内的相关硕士学位论文，知网上down的。</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><ul>
<li><p><strong>大数据平台下的互联网广告点击率预估模型</strong></p>
<p>基于腾讯社交广告数据集，hive+hadoop环境下实现GBDT+FM分布式点击率预估，用到贝叶斯平滑等，竞赛在分布式环境下的扩展。</p>
</li>
</ul>
<ul>
<li>​</li>
</ul>
<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><ul>
<li><p><strong>针对在线广告实时竞价系统的相关算法研究、电子科大、郭威</strong></p>
<p>将竞价策略总结为预算控制和估价算法两个步骤，提出一种<strong>预算步进（buget pacing）算法和一个出价模型</strong></p>
<p>数据集：iPinyou</p>
<p>2.2介绍计算广告核心问题和<strong>结算方式</strong></p>
<p>核心问题：广告主、用户、媒体三方博弈，涉及信息检索、机器学习、最优化三个领域。</p>
<p><strong>结算方式以及适用场景：CPT-&gt;CPM-&gt;CPC-&gt;eCPM</strong> 这里总结的很好</p>
<p>第3章点击率预估：LR\GBDT \FM\在线算法online SGD，FTRL数据集Criteo</p>
<p>第4章设计了一个 <strong>buget pacing(预算步进)</strong> 策略</p>
<p>第5章竞价算法设计：DSP策略中的关键技术图</p>
<p>这个问题通常是一个约束最优化问题，约束是广告主一天的广告预算，最优某个性能指标，如点击数或转化数。</p>
</li>
</ul>
<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><ul>
<li><p><strong>在线广告 DSP 平台实时竞价算法的研究与实现 、上海交通、韩静</strong></p>
<p>主要研究实时竞价算法，点击率预估和竞价策略。</p>
<p>ctr预估：LR和GBDT。</p>
<p>竞价策略：提出固定竞价、分组竞价（M6D）、综合竞价（非线性竞价）三种策略，进行数学推导</p>
<p>数据集：iPinyou，评价指标KPI</p>
<p><strong>利用这份数据集做实验的流程</strong> （第四章）：</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-02-19-39-45.png" alt=""> </p>
</li>
</ul>
<ul>
<li><p><strong>广告点击率预估的深层神经网络模型研究</strong> 北邮 王孝舒</p>
<p>Criteo竞赛数据</p>
<p>baseline：LR</p>
<p>优化：DNN，分别选取sigmod和Relu作为激活函数进行实验</p>
</li>
<li><p><strong>互联网广告精准投放平台设计与实现 成都理工 葛泽泽</strong></p>
<p>基于hadoop、hive实现DSP平台</p>
<p><strong>国内外发展情况可参考</strong></p>
</li>
<li><p>基于流式计算的广告特征提取系统的设计与实现 钟晓诚 南京大学</p>
<p>做的是搜索广告的</p>
<p>流式广告特征提取系统，实时处理广告数据，不断训练、更新ctr预估模型，基于百度开发的流式计算框架Task Manager，集合HDFS\MapReduce</p>
<p>可以将广告特征数据反映到线上模型的时间缩短至分钟级</p>
<p>​</p>
</li>
<li><p>基于逻辑回归的在线广告ctr优化和预测 浙江大学 代成雷</p>
<p>用了LR和FTRL进行ctr预估</p>
</li>
<li><p>基于深度学习的搜索广告点击率预测方法研究 哈工大 李思琴</p>
<p>GPU、深度学习CTR预估与贝叶斯分类、LR、svm对比</p>
<p><strong>卷积神经网络</strong></p>
<p>KDD2012数据集</p>
<p>特征用到w2v</p>
<p>评估：AUC</p>
<p>​</p>
</li>
<li><p><strong>在线广告中实时竞价机制研究与算法实现 华中师范 朱丽辉</strong></p>
<p>当竞价较低时，提升竞价能大幅增加赢得竞价的概率；当竞价较高时，降低竞价对赢得竞价的概率影响不大。提出了预算再分配模型，将竞价空间分成不同的区间，将预算消耗在最优价格区间。结合上述两点给出了一个基于动态点击率预估的分段竞价算法，很好地解决了小广告主的利益问题。</p>
<p>本文提出了一个＂预算再分配＂的竞价策略：将广告主的整个竞价空间按照价格的高低划分为三个区间Ｐｉ，Ｐ２，Ｐ３，当估价在ＰＩ，Ｐ３的时候，对其进行相应的降价措施，当估价在Ｐ２的时候对其进行提价操作。</p>
<p>核心思想：当广告主的预算在非常有限的情况下，应该放弃那些过高的竞价以及没意义的竞价（估价过低），将预算尽量分配在适当的竞价范围。</p>
<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-16-22-39-56.png" alt=""> </p>
<p>数据集：ipinyou</p>
</li>
<li><p>​</p>
</li>
</ul>
<h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><ul>
<li><p><strong>互联网广告精准投放平台研究 华中师范 李志</strong></p>
<p>实现了一个DSP平台</p>
<p>用贝叶斯分类，对用户特征进行分类</p>
<p><strong>背景写的很好，有国内外DSP产品比较</strong></p>
<p><strong>平台设计和流程需要参考</strong></p>
<p>​</p>
</li>
<li><p>​</p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
        <categories>
            
            <category> DSP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2017/11/02/test-1/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive中静态分区和动态分区]]></title>
      <url>/2017/11/02/Hive%E4%B8%AD%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/</url>
      <content type="html"><![CDATA[<h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对应列的值自动分区写入，如果该列值对应的分区目录还没有创建， 会自动创建并写入数据。</p>
<h2 id="静态分区"><a href="#静态分区" class="headerlink" title="静态分区"></a>静态分区</h2><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>create table zhangsiyao.dt_0802_0815 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>load data local inpath ‘/home/warehouse/user.txt’ overwrite into table teacher partition(work_date=”2016-07-12”);</p>
<p>需要按照分区一个分区一个分区导入数据</p>
<h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><h3 id="创建分区表（和静态分区一样）"><a href="#创建分区表（和静态分区一样）" class="headerlink" title="创建分区表（和静态分区一样）"></a>创建分区表（和静态分区一样）</h3><p>create table zhangsiyao.dt_0811_0820 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p>
<h3 id="创建数据表（中间数据）"><a href="#创建数据表（中间数据）" class="headerlink" title="创建数据表（中间数据）"></a>创建数据表（中间数据）</h3><p>create table zhangsiyao.data_analy_11_20 as select a.itime,a.uid,a.gid,a.app_ver,a.unet ,a.device_type,a.device_os,a.client_type,a.crtv_id,a.country,a.province,a.city,a.isp,a.ad_location,a.ad_status,a.dt,b.age_gt,b.sex_gt,b.income_gt,b.marital_status_gt,c.sponsor_id,c.creative_name,c.creative_title,c.creative_abstract,c.category_id,c.create_time,c.update_time from (select <em> from ad.wireless_ad_org_final where dt&gt;’2017-08-10’ and crtv_id &lt;&gt;-1) a left join (select </em> from user_portraint.focus_user_portraint_profile where dt&gt;’2017-08-10’) b on (a.dt=b.dt and a.client_type=b.client_type and a.uid=b.uid) left join (select * from ad.ad_creative_ods where dt&gt;’2017-08-10’) c on (a.dt=b.dt and a.crtv_id=c.creative_id);</p>
<h3 id="设置动态分区"><a href="#设置动态分区" class="headerlink" title="设置动态分区"></a>设置动态分区</h3><p>set hive.exec.dynamic.partition=true;(可通过这个语句查看：set hive.exec.dynamic.partition;)<br>set hive.exec.dynamic.partition.mode=nonstrict; （strict要求至少有一个静态分区， nonstrict可以都是动态分区）<br>set hive.exec.max.dynamic.partitions=100000;(如果自动分区数大于这个参数，将会报错)<br>set hive.exec.max.dynamic.partitions.pernode=100000;</p>
<h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><p>insert overwrite table zhangsiyao.dt_0811_0820 partition(dt) select itime,uid,gid,app_ver,unet,device_type,device_os,client_type,crtv_id,country,province,city,isp,ad_location,ad_status,age_gt,sex_gt,income_gt,marital_status_gt,sponsor_id,creative_name,creative_title,creative_abstract,category_id,create_time,update_time,dt from zhangsiyao.data_analy_11_20 where dt&lt;’2017-08-21’;</p>
<p><strong>这里需要注意的是，用select选择数据导入动态分区时，要把关键字放在最后面，因为动态分区默认以最后一个关键字作为分区关键字</strong></p>
]]></content>
      
        <categories>
            
            <category> hive </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Hive中percentile_approx计算等频划分分位点]]></title>
      <url>/2017/11/02/%E5%88%A9%E7%94%A8Hive%E4%B8%ADpercentile-approx%E8%AE%A1%E7%AE%97%E7%AD%89%E9%A2%91%E5%88%92%E5%88%86%E5%88%86%E4%BD%8D%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="等频划分"><a href="#等频划分" class="headerlink" title="等频划分"></a>等频划分</h2><p>等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间</p>
<p>等比划分：按照数据的全部取值情况，平均划分成k个区间</p>
<h2 id="Hive-中计算分位数的函数：percentile-approx"><a href="#Hive-中计算分位数的函数：percentile-approx" class="headerlink" title="Hive 中计算分位数的函数：percentile_approx"></a>Hive 中计算分位数的函数：<code>percentile_approx</code></h2><p>hive 中的<code>percentile_approx</code>函数可以确定等频划分的分位点<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">percentile_approx(col,array(0.2,0.4,0.6,0.8))</div><div class="line">[0.0,4001.0,4061.0]</div></pre></td></tr></table></figure></p>
<p>其中col为要划分的列，array中的数字代表划分的位置，比如(0.2,0.4,0.6,0.8)就是钱20%数量的样本被分到一个区间，然后20%-40%的样本被分到一个区间….</p>
<p>返回值是一个array</p>
<p>如果希望变成一列，可以用<code>explode</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explode(percentile_approx(cast(col as double),array(0.05,0.5,0.95),9999))as percentile</div><div class="line"></div><div class="line">percentile</div><div class="line">0.0</div><div class="line">4001.1</div><div class="line">4061.0</div></pre></td></tr></table></figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table zhangsiyao.percentile_of_dt_fea_0818_0820_2 as select explode(percentile_approx(adloc_age_sex_ctr,array(0.25,0.5,0.75))) as adloc_age_sex_ctr_percentile,explode(percentile_approx(adloc_income_ctr,array(0.25,0.5,0.75))) as adloc_income_ctr_percentile,explode(percentile_approx(adloc_marry_ctr,array(0.25,0.5,0.75))) as adloc_marry_ctr_percentile,explode(percentile_approx(adloc_province_ctr,array(0.25,0.5,0.75))) as adloc_province_ctr_percentile,explode(percentile_approx(adloc_clinttype_ctr,array(0.25,0.5,0.75))) as adloc_clinttype_ctr_percentile,explode(percentile_approx(adloc_sponsorid_ctr,array(0.25,0.5,0.75))) as adloc_sponsorid_ctr_percentile,explode(percentile_approx(adloc_categoryid_ctr,array(0.25,0.5,0.75))) as adloc_categoryid_ctr_percentile,explode(percentile_approx(adloc_crtvid_ctr,array(0.25,0.5,0.75))) as adloc_crtvid_ctr_percentile,explode(percentile_approx(adloc_unet_ctr,array(0.25,0.5,0.75))) as adloc_unet_ctr_percentile,explode(percentile_approx(adloc_isp_ctr,array(0.25,0.5,0.75))) as adloc_isp_ctr_percentile,explode(percentile_approx(adloc_appver_ctr,array(0.25,0.5,0.75))) as adloc_appver_ctr_percentile,explode(percentile_approx(adloc_devicetype_ctr ,adloc_deviceos_ctr,array(0.25,0.5,0.75))) as adloc_devicetype_ctr ,adloc_deviceos_ctr_percentile,explode(percentile_approx(age_province_ctr,array(0.25,0.5,0.75))) as age_province_ctr_percentile,explode(percentile_approx(age_marry_ctr,array(0.25,0.5,0.75))) as age_marry_ctr_percentile,explode(percentile_approx(age_categoryid_ctr,array(0.25,0.5,0.75))) as age_categoryid_ctr_percentile,explode(percentile_approx(age_crtvid_ctr,array(0.25,0.5,0.75))) as age_crtvid_ctr_percentile,explode(percentile_approx(sex_marry_ctr,array(0.25,0.5,0.75))) as sex_marry_ctr_percentile,explode(percentile_approx(sex_categoryid_ctr,array(0.25,0.5,0.75))) as sex_categoryid_ctr_percentile,explode(percentile_approx(income_categoryid_ctr,array(0.25,0.5,0.75))) as income_categoryid_ctr_percentile,explode(percentile_approx(income_crtvid_ctr,array(0.25,0.5,0.75))) as income_crtvid_ctr_percentile,explode(percentile_approx(marry_categoryid_ctr,array(0.25,0.5,0.75))) as marry_categoryid_ctr_percentile,explode(percentile_approx(marry_crtvid_ctr,sponsorid_unet_ctr,array(0.25,0.5,0.75))) as marry_crtvid_ctr,sponsorid_unet_ctr_percentile from zhangsiyao.dt_fea_0818_0820;</div></pre></td></tr></table></figure>
<p>由此就找到了将特征等频划分的分位点，可以按照得到的分位点队连续型特征进行分桶操作</p>
]]></content>
      
        <categories>
            
            <category> hive </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TPC_DS工具生成数据导入Hive]]></title>
      <url>/2017/11/02/TPC-DS%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Hive/</url>
      <content type="html"><![CDATA[<p>生成步骤</p>
<p>1.在官网上(<a href="http://www.tpc.org/tpcds/" target="_blank" rel="external">http://www.tpc.org/tpcds/</a> )去下载最新的：TPC-DS. </p>
<p>2.解压: 下载的 zip 文件放在 Linux 上解压,并进入他的 tools 目录.</p>
<p>3.编译：make (忽略编译警告，只保证生成过程成功完成). 这里需要Linux安装上了 gcc , gcc c++, expect 等.</p>
<p>4.生成数据：在tools目录下执行：./dsdgen -scale 100 -force (-force:会覆盖原来生成的data,否则不覆盖);生成的25个.dat 的数据文件.</p>
<p>默认只能生成 100GB, 300GB, 1TB, 3TB, 10TB, 30TB and 100TB大小的数据，如果想要生成一个比较小的数据集，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">100M:</div><div class="line">./dsdgen -scale 1000 -dir tmp/ -parallel 1000 -child 1</div></pre></td></tr></table></figure></p>
<ol>
<li>hive中创建相应的数据表，导入之前生成的数据<br>运行脚本<code>hive_create_table.sql</code></li>
</ol>
<p>“hive -f hive_create_table.sql”<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">use tpc_ds;</div><div class="line"></div><div class="line">create table if not exists dbgen_version</div><div class="line">(</div><div class="line">    dv_version varchar(16),</div><div class="line">    dv_create_date date,</div><div class="line">    dv_create_time string,</div><div class="line">    dv_cmdline_args varchar(200) </div><div class="line">)</div><div class="line">row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/dbgen_version_1_10000.dat&quot; overwrite into table tpc_ds.dbgen_version;</div><div class="line"></div><div class="line">create table if not exists customer_address</div><div class="line">(</div><div class="line">    ca_address_sk int,</div><div class="line">    ca_address_id char(16),</div><div class="line">    ca_street_number char(10),</div><div class="line">    ca_street_name varchar(60),</div><div class="line">    ca_street_type char(15),</div><div class="line">    ca_suite_number char(10),</div><div class="line">    ca_city varchar(60),</div><div class="line">    ca_county varchar(30),</div><div class="line">    ca_state char(2),</div><div class="line">    ca_zip char(10),</div><div class="line">    ca_country varchar(20),</div><div class="line">    ca_gmt_offset decimal(5,2),</div><div class="line">    ca_location_type char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_address_1_10000.dat&quot; overwrite into table tpc_ds.customer_address;</div><div class="line"></div><div class="line">create table if not exists customer_demographics</div><div class="line">(</div><div class="line">    cd_demo_sk int,</div><div class="line">    cd_gender char(1),</div><div class="line">    cd_marital_status char(1),</div><div class="line">    cd_education_status char(20),</div><div class="line">    cd_purchase_estimate int,</div><div class="line">    cd_credit_rating char(10),</div><div class="line">    cd_dep_count int,</div><div class="line">    cd_dep_employed_count int,</div><div class="line">    cd_dep_college_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_demographics_1_10000.dat&quot; overwrite into table tpc_ds.customer_demographics;</div><div class="line"></div><div class="line">create table if not exists date_dim</div><div class="line">(</div><div class="line">    d_date_sk int,</div><div class="line">    d_date_id char(16) ,</div><div class="line">    d_date date ,</div><div class="line">    d_month_seq int,</div><div class="line">    d_week_seq int,</div><div class="line">    d_quarter_seq int,</div><div class="line">    d_year int,</div><div class="line">    d_dow int,</div><div class="line">    d_moy int,</div><div class="line">    d_dom int,</div><div class="line">    d_qoy int,</div><div class="line">    d_fy_year int,</div><div class="line">    d_fy_quarter_seq int,</div><div class="line">    d_fy_week_seq int,</div><div class="line">    d_day_name char(9),</div><div class="line">    d_quarter_name char(6),</div><div class="line">    d_holiday char(1),</div><div class="line">    d_weekend char(1),</div><div class="line">    d_following_holiday char(1),</div><div class="line">    d_first_dom int,</div><div class="line">    d_last_dom int,</div><div class="line">    d_same_day_ly int,</div><div class="line">    d_same_day_lq int,</div><div class="line">    d_current_day char(1),</div><div class="line">    d_current_week char(1),</div><div class="line">    d_current_month char(1),</div><div class="line">    d_current_quarter char(1),</div><div class="line">    d_current_year char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/date_dim_1_10000.dat&quot; overwrite into table tpc_ds.date_dim;</div><div class="line"></div><div class="line">create table if not exists warehouse</div><div class="line">(</div><div class="line">    w_warehouse_sk int,</div><div class="line">    w_warehouse_id char(16),</div><div class="line">    w_warehouse_name varchar(20),</div><div class="line">    w_warehouse_sq_ft int,</div><div class="line">    w_street_number char(10),</div><div class="line">    w_street_name varchar(60),</div><div class="line">    w_street_type char(15),</div><div class="line">    w_suite_number char(10),</div><div class="line">    w_city varchar(60),</div><div class="line">    w_county varchar(30),</div><div class="line">    w_state char(2),</div><div class="line">    w_zip char(10),</div><div class="line">    w_country varchar(20),</div><div class="line">    w_gmt_offset decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/warehouse_1_10000.dat&quot; overwrite into table tpc_ds.warehouse;</div><div class="line"></div><div class="line">create table if not exists ship_mode</div><div class="line">(</div><div class="line">    sm_ship_mode_sk int,</div><div class="line">    sm_ship_mode_id char(16),</div><div class="line">    sm_type char(30),</div><div class="line">    sm_code char(10),</div><div class="line">    sm_carrier char(20),</div><div class="line">    sm_contract char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/ship_mode_1_10000.dat&quot; overwrite into table tpc_ds.ship_mode;</div><div class="line"></div><div class="line">create table if not exists time_dim</div><div class="line">(</div><div class="line">    t_time_sk int,</div><div class="line">    t_time_id char(16),</div><div class="line">    t_time int,</div><div class="line">    t_hour int,</div><div class="line">    t_minute int,</div><div class="line">    t_second int,</div><div class="line">    t_am_pm char(2),</div><div class="line">    t_shift char(20),</div><div class="line">    t_sub_shift char(20),</div><div class="line">    t_meal_time char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/time_dim_1_10000.dat&quot; overwrite into table tpc_ds.time_dim;</div><div class="line"></div><div class="line">create table if not exists reason</div><div class="line">(</div><div class="line">    r_reason_sk int,</div><div class="line">    r_reason_id char(16),</div><div class="line">    r_reason_desc char(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/reason_1_10000.dat&quot; overwrite into table tpc_ds.reason;</div><div class="line"></div><div class="line">create table if not exists income_band</div><div class="line">(</div><div class="line">    ib_income_band_sk int,</div><div class="line">    ib_lower_bound int,</div><div class="line">    ib_upper_bound int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/income_band_1_10000.dat&quot; overwrite into table tpc_ds.income_band;</div><div class="line"></div><div class="line">create table if not exists item</div><div class="line">(</div><div class="line">    i_item_sk int,</div><div class="line">    i_item_id char(16),</div><div class="line">    i_rec_start_date date ,</div><div class="line">    i_rec_end_date date ,</div><div class="line">    i_item_desc varchar(200),</div><div class="line">    i_current_price decimal(7,2),</div><div class="line">    i_wholesale_cost decimal(7,2),</div><div class="line">    i_brand_id int,</div><div class="line">    i_brand char(50),</div><div class="line">    i_class_id int,</div><div class="line">    i_class char(50),</div><div class="line">    i_category_id int,</div><div class="line">    i_category char(50),</div><div class="line">    i_manufact_id int,</div><div class="line">    i_manufact char(50),</div><div class="line">    i_size char(20),</div><div class="line">    i_formulation char(20),</div><div class="line">    i_color char(20),</div><div class="line">    i_units char(10),</div><div class="line">    i_container char(10),</div><div class="line">    i_manager_id int,</div><div class="line">    i_product_name char(50)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/item_1_10000.dat&quot; overwrite into table tpc_ds.item;</div><div class="line"></div><div class="line">create table if not exists store</div><div class="line">(</div><div class="line">    s_store_sk int,</div><div class="line">    s_store_id char(16),</div><div class="line">    s_rec_start_date date ,</div><div class="line">    s_rec_end_date date ,</div><div class="line">    s_closed_date_sk int,</div><div class="line">    s_store_name varchar(50),</div><div class="line">    s_number_employees int,</div><div class="line">    s_floor_space int,</div><div class="line">    s_hours char(20),</div><div class="line">    s_manager varchar(40),</div><div class="line">    s_market_id int,</div><div class="line">    s_geography_class varchar(100),</div><div class="line">    s_market_desc varchar(100),</div><div class="line">    s_market_manager varchar(40),</div><div class="line">    s_division_id int,</div><div class="line">    s_division_name varchar(50),</div><div class="line">    s_company_id int,</div><div class="line">    s_company_name varchar(50),</div><div class="line">    s_street_number varchar(10),</div><div class="line">    s_street_name varchar(60),</div><div class="line">    s_street_type char(15),</div><div class="line">    s_suite_number char(10),</div><div class="line">    s_city varchar(60),</div><div class="line">    s_county varchar(30),</div><div class="line">    s_state char(2),</div><div class="line">    s_zip char(10),</div><div class="line">    s_country varchar(20),</div><div class="line">    s_gmt_offset decimal(5,2),</div><div class="line">    s_tax_precentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_1_10000.dat&quot; overwrite into table tpc_ds.store;</div><div class="line"></div><div class="line">create table if not exists call_center</div><div class="line">(</div><div class="line">    cc_call_center_sk int,</div><div class="line">    cc_call_center_id char(16),</div><div class="line">    cc_rec_start_date date ,</div><div class="line">    cc_rec_end_date date ,</div><div class="line">    cc_closed_date_sk int,</div><div class="line">    cc_open_date_sk int,</div><div class="line">    cc_name varchar(50),</div><div class="line">    cc_class varchar(50),</div><div class="line">    cc_employees int,</div><div class="line">    cc_sq_ft int,</div><div class="line">    cc_hours char(20),</div><div class="line">    cc_manager varchar(40),</div><div class="line">    cc_mkt_id int,</div><div class="line">    cc_mkt_class char(50),</div><div class="line">    cc_mkt_desc varchar(100),</div><div class="line">    cc_market_manager varchar(40),</div><div class="line">    cc_division int,</div><div class="line">    cc_division_name varchar(50),</div><div class="line">    cc_company int,</div><div class="line">    cc_company_name char(50),</div><div class="line">    cc_street_number char(10),</div><div class="line">    cc_street_name varchar(60),</div><div class="line">    cc_street_type char(15),</div><div class="line">    cc_suite_number char(10),</div><div class="line">    cc_city varchar(60),</div><div class="line">    cc_county varchar(30),</div><div class="line">    cc_state char(2),</div><div class="line">    cc_zip char(10),</div><div class="line">    cc_country varchar(20),</div><div class="line">    cc_gmt_offset decimal(5,2),</div><div class="line">    cc_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/call_center_1_10000.dat&quot; overwrite into table tpc_ds.call_center;</div><div class="line"></div><div class="line">create table if not exists customer</div><div class="line">(</div><div class="line">    c_customer_sk int,</div><div class="line">    c_customer_id char(16),</div><div class="line">    c_current_cdemo_sk int,</div><div class="line">    c_current_hdemo_sk int,</div><div class="line">    c_current_addr_sk int,</div><div class="line">    c_first_shipto_date_sk int,</div><div class="line">    c_first_sales_date_sk int,</div><div class="line">    c_salutation char(10),</div><div class="line">    c_first_name char(20),</div><div class="line">    c_last_name char(30),</div><div class="line">    c_preferred_cust_flag char(1),</div><div class="line">    c_birth_day int,</div><div class="line">    c_birth_month int,</div><div class="line">    c_birth_year int,</div><div class="line">    c_birth_country varchar(20),</div><div class="line">    c_login char(13),</div><div class="line">    c_email_address char(50),</div><div class="line">    c_last_review_date char(10)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_1_10000.dat&quot; overwrite into table tpc_ds.customer;</div><div class="line"></div><div class="line">create table if not exists web_site</div><div class="line">(</div><div class="line">    web_site_sk int,</div><div class="line">    web_site_id char(16),</div><div class="line">    web_rec_start_date date ,</div><div class="line">    web_rec_end_date date ,</div><div class="line">    web_name varchar(50),</div><div class="line">    web_open_date_sk int,</div><div class="line">    web_close_date_sk int,</div><div class="line">    web_class varchar(50),</div><div class="line">    web_manager varchar(40),</div><div class="line">    web_mkt_id int,</div><div class="line">    web_mkt_class varchar(50),</div><div class="line">    web_mkt_desc varchar(100),</div><div class="line">    web_market_manager varchar(40),</div><div class="line">    web_company_id int,</div><div class="line">    web_company_name char(50),</div><div class="line">    web_street_number char(10),</div><div class="line">    web_street_name varchar(60),</div><div class="line">    web_street_type char(15),</div><div class="line">    web_suite_number char(10),</div><div class="line">    web_city varchar(60),</div><div class="line">    web_county varchar(30),</div><div class="line">    web_state char(2),</div><div class="line">    web_zip char(10),</div><div class="line">    web_country varchar(20),</div><div class="line">    web_gmt_offset decimal(5,2),</div><div class="line">    web_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_site_1_10000.dat&quot; overwrite into table tpc_ds.web_site;</div><div class="line"></div><div class="line">create table if not exists store_returns</div><div class="line">(</div><div class="line">    sr_returned_date_sk int,</div><div class="line">    sr_return_time_sk int,</div><div class="line">    sr_item_sk int,</div><div class="line">    sr_customer_sk int,</div><div class="line">    sr_cdemo_sk int,</div><div class="line">    sr_hdemo_sk int,</div><div class="line">    sr_addr_sk int,</div><div class="line">    sr_store_sk int,</div><div class="line">    sr_reason_sk int,</div><div class="line">    sr_ticket_number int,</div><div class="line">    sr_return_quantity int,</div><div class="line">    sr_return_amt decimal(7,2),</div><div class="line">    sr_return_tax decimal(7,2),</div><div class="line">    sr_return_amt_inc_tax decimal(7,2),</div><div class="line">    sr_fee decimal(7,2),</div><div class="line">    sr_return_ship_cost decimal(7,2),</div><div class="line">    sr_refunded_cash decimal(7,2),</div><div class="line">    sr_reversed_charge decimal(7,2),</div><div class="line">    sr_store_credit decimal(7,2),</div><div class="line">    sr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_returns_1_10000.dat&quot; overwrite into table tpc_ds.store_returns;</div><div class="line"></div><div class="line">create table if not exists household_demographics</div><div class="line">(</div><div class="line">    hd_demo_sk int,</div><div class="line">    hd_income_band_sk int,</div><div class="line">    hd_buy_potential char(15),</div><div class="line">    hd_dep_count int,</div><div class="line">    hd_vehicle_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/household_demographics_1_10000.dat&quot; overwrite into table tpc_ds.household_demographics;</div><div class="line"></div><div class="line">create table if not exists web_page</div><div class="line">(</div><div class="line">    wp_web_page_sk int,</div><div class="line">    wp_web_page_id char(16),</div><div class="line">    wp_rec_start_date date ,</div><div class="line">    wp_rec_end_date date ,</div><div class="line">    wp_creation_date_sk int,</div><div class="line">    wp_access_date_sk int,</div><div class="line">    wp_autogen_flag char(1),</div><div class="line">    wp_customer_sk int,</div><div class="line">    wp_url varchar(100),</div><div class="line">    wp_type char(50),</div><div class="line">    wp_char_count int,</div><div class="line">    wp_link_count int,</div><div class="line">    wp_image_count int,</div><div class="line">    wp_max_ad_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_page_1_10000.dat&quot; overwrite into table tpc_ds.web_page;</div><div class="line"></div><div class="line">create table if not exists promotion</div><div class="line">(</div><div class="line">    p_promo_sk int,</div><div class="line">    p_promo_id char(16),</div><div class="line">    p_start_date_sk int,</div><div class="line">    p_end_date_sk int,</div><div class="line">    p_item_sk int,</div><div class="line">    p_cost decimal(15,2),</div><div class="line">    p_response_target int,</div><div class="line">    p_promo_name char(50),</div><div class="line">    p_channel_dmail char(1),</div><div class="line">    p_channel_email char(1),</div><div class="line">    p_channel_catalog char(1),</div><div class="line">    p_channel_tv char(1),</div><div class="line">    p_channel_radio char(1),</div><div class="line">    p_channel_press char(1),</div><div class="line">    p_channel_event char(1),</div><div class="line">    p_channel_demo char(1),</div><div class="line">    p_channel_details varchar(100),</div><div class="line">    p_purpose char(15),</div><div class="line">    p_discount_active char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/promotion_1_10000.dat&quot; overwrite into table tpc_ds.promotion;</div><div class="line"></div><div class="line">create table if not exists catalog_page</div><div class="line">(</div><div class="line">    cp_catalog_page_sk int,</div><div class="line">    cp_catalog_page_id char(16),</div><div class="line">    cp_start_date_sk int,</div><div class="line">    cp_end_date_sk int,</div><div class="line">    cp_department varchar(50),</div><div class="line">    cp_catalog_number int,</div><div class="line">    cp_catalog_page_number int,</div><div class="line">    cp_description varchar(100),</div><div class="line">    cp_type varchar(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_page_1_10000.dat&quot; overwrite into table tpc_ds.catalog_page;</div><div class="line"></div><div class="line">create table if not exists inventory</div><div class="line">(</div><div class="line">    inv_date_sk int,</div><div class="line">    inv_item_sk int,</div><div class="line">    inv_warehouse_sk int,</div><div class="line">    inv_quantity_on_hand int)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/inventory_1_10000.dat&quot; overwrite into table tpc_ds.inventory;</div><div class="line"></div><div class="line">create table if not exists catalog_returns</div><div class="line">(</div><div class="line">    cr_returned_date_sk int,</div><div class="line">    cr_returned_time_sk int,</div><div class="line">    cr_item_sk int,</div><div class="line">    cr_refunded_customer_sk int,</div><div class="line">    cr_refunded_cdemo_sk int,</div><div class="line">    cr_refunded_hdemo_sk int,</div><div class="line">    cr_refunded_addr_sk int,</div><div class="line">    cr_returning_customer_sk int,</div><div class="line">    cr_returning_cdemo_sk int,</div><div class="line">    cr_returning_hdemo_sk int,</div><div class="line">    cr_returning_addr_sk int,</div><div class="line">    cr_call_center_sk int,</div><div class="line">    cr_catalog_page_sk int,</div><div class="line">    cr_ship_mode_sk int,</div><div class="line">    cr_warehouse_sk int,</div><div class="line">    cr_reason_sk int,</div><div class="line">    cr_order_number int,</div><div class="line">    cr_return_quantity int,</div><div class="line">    cr_return_amount decimal(7,2),</div><div class="line">    cr_return_tax decimal(7,2),</div><div class="line">    cr_return_amt_inc_tax decimal(7,2),</div><div class="line">    cr_fee decimal(7,2),</div><div class="line">    cr_return_ship_cost decimal(7,2),</div><div class="line">    cr_refunded_cash decimal(7,2),</div><div class="line">    cr_reversed_charge decimal(7,2),</div><div class="line">    cr_store_credit decimal(7,2),</div><div class="line">    cr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_returns_1_10000.dat&quot; overwrite into table tpc_ds.catalog_returns;</div><div class="line"></div><div class="line">create table if not exists web_returns</div><div class="line">(</div><div class="line">    wr_returned_date_sk int,</div><div class="line">    wr_returned_time_sk int,</div><div class="line">    wr_item_sk int,</div><div class="line">    wr_refunded_customer_sk int,</div><div class="line">    wr_refunded_cdemo_sk int,</div><div class="line">    wr_refunded_hdemo_sk int,</div><div class="line">    wr_refunded_addr_sk int,</div><div class="line">    wr_returning_customer_sk int,</div><div class="line">    wr_returning_cdemo_sk int,</div><div class="line">    wr_returning_hdemo_sk int,</div><div class="line">    wr_returning_addr_sk int,</div><div class="line">    wr_web_page_sk int,</div><div class="line">    wr_reason_sk int,</div><div class="line">    wr_order_number int,</div><div class="line">    wr_return_quantity int,</div><div class="line">    wr_return_amt decimal(7,2),</div><div class="line">    wr_return_tax decimal(7,2),</div><div class="line">    wr_return_amt_inc_tax decimal(7,2),</div><div class="line">    wr_fee decimal(7,2),</div><div class="line">    wr_return_ship_cost decimal(7,2),</div><div class="line">    wr_refunded_cash decimal(7,2),</div><div class="line">    wr_reversed_charge decimal(7,2),</div><div class="line">    wr_account_credit decimal(7,2),</div><div class="line">    wr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_returns_1_10000.dat&quot; overwrite into table tpc_ds.web_returns;</div><div class="line"></div><div class="line">create table if not exists web_sales</div><div class="line">(</div><div class="line">    ws_sold_date_sk int,</div><div class="line">    ws_sold_time_sk int,</div><div class="line">    ws_ship_date_sk int,</div><div class="line">    ws_item_sk int,</div><div class="line">    ws_bill_customer_sk int,</div><div class="line">    ws_bill_cdemo_sk int,</div><div class="line">    ws_bill_hdemo_sk int,</div><div class="line">    ws_bill_addr_sk int,</div><div class="line">    ws_ship_customer_sk int,</div><div class="line">    ws_ship_cdemo_sk int,</div><div class="line">    ws_ship_hdemo_sk int,</div><div class="line">    ws_ship_addr_sk int,</div><div class="line">    ws_web_page_sk int,</div><div class="line">    ws_web_site_sk int,</div><div class="line">    ws_ship_mode_sk int,</div><div class="line">    ws_warehouse_sk int,</div><div class="line">    ws_promo_sk int,</div><div class="line">    ws_order_number int,</div><div class="line">    ws_quantity int,</div><div class="line">    ws_wholesale_cost decimal(7,2),</div><div class="line">    ws_list_price decimal(7,2),</div><div class="line">    ws_sales_price decimal(7,2),</div><div class="line">    ws_ext_discount_amt decimal(7,2),</div><div class="line">    ws_ext_sales_price decimal(7,2),</div><div class="line">    ws_ext_wholesale_cost decimal(7,2),</div><div class="line">    ws_ext_list_price decimal(7,2),</div><div class="line">    ws_ext_tax decimal(7,2),</div><div class="line">    ws_coupon_amt decimal(7,2),</div><div class="line">    ws_ext_ship_cost decimal(7,2),</div><div class="line">    ws_net_paid decimal(7,2),</div><div class="line">    ws_net_paid_inc_tax decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    ws_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_sales_1_10000.dat&quot; overwrite into table tpc_ds.web_sales;</div><div class="line"></div><div class="line">create table if not exists catalog_sales</div><div class="line">(</div><div class="line">    cs_sold_date_sk int,</div><div class="line">    cs_sold_time_sk int,</div><div class="line">    cs_ship_date_sk int,</div><div class="line">    cs_bill_customer_sk int,</div><div class="line">    cs_bill_cdemo_sk int,</div><div class="line">    cs_bill_hdemo_sk int,</div><div class="line">    cs_bill_addr_sk int,</div><div class="line">    cs_ship_customer_sk int,</div><div class="line">    cs_ship_cdemo_sk int,</div><div class="line">    cs_ship_hdemo_sk int,</div><div class="line">    cs_ship_addr_sk int,</div><div class="line">    cs_call_center_sk int,</div><div class="line">    cs_catalog_page_sk int,</div><div class="line">    cs_ship_mode_sk int,</div><div class="line">    cs_warehouse_sk int,</div><div class="line">    cs_item_sk int,</div><div class="line">    cs_promo_sk int,</div><div class="line">    cs_order_number int,</div><div class="line">    cs_quantity int,</div><div class="line">    cs_wholesale_cost decimal(7,2),</div><div class="line">    cs_list_price decimal(7,2),</div><div class="line">    cs_sales_price decimal(7,2),</div><div class="line">    cs_ext_discount_amt decimal(7,2),</div><div class="line">    cs_ext_sales_price decimal(7,2),</div><div class="line">    cs_ext_wholesale_cost decimal(7,2),</div><div class="line">    cs_ext_list_price decimal(7,2),</div><div class="line">    cs_ext_tax decimal(7,2),</div><div class="line">    cs_coupon_amt decimal(7,2),</div><div class="line">    cs_ext_ship_cost decimal(7,2),</div><div class="line">    cs_net_paid decimal(7,2),</div><div class="line">    cs_net_paid_inc_tax decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    cs_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_sales_1_10000.dat&quot; overwrite into table tpc_ds.catalog_sales;</div><div class="line"></div><div class="line">create table if not exists store_sales</div><div class="line">(</div><div class="line">    ss_sold_date_sk int,</div><div class="line">    ss_sold_time_sk int,</div><div class="line">    ss_item_sk int,</div><div class="line">    ss_customer_sk int,</div><div class="line">    ss_cdemo_sk int,</div><div class="line">    ss_hdemo_sk int,</div><div class="line">    ss_addr_sk int,</div><div class="line">    ss_store_sk int,</div><div class="line">    ss_promo_sk int,</div><div class="line">    ss_ticket_number int,</div><div class="line">    ss_quantity int,</div><div class="line">    ss_wholesale_cost decimal(7,2),</div><div class="line">    ss_list_price decimal(7,2),</div><div class="line">    ss_sales_price decimal(7,2),</div><div class="line">    ss_ext_discount_amt decimal(7,2),</div><div class="line">    ss_ext_sales_price decimal(7,2),</div><div class="line">    ss_ext_wholesale_cost decimal(7,2),</div><div class="line">    ss_ext_list_price decimal(7,2),</div><div class="line">    ss_ext_tax decimal(7,2),</div><div class="line">    ss_coupon_amt decimal(7,2),</div><div class="line">    ss_net_paid decimal(7,2),</div><div class="line">    ss_net_paid_inc_tax decimal(7,2),</div><div class="line">    ss_net_profit decimal(7,2))row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_sales_1_10000.dat&quot; overwrite into table tpc_ds.store_sales;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【算法导论】动态规划（二）矩阵链乘法]]></title>
      <url>/2017/11/01/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="矩阵链乘法问题"><a href="#矩阵链乘法问题" class="headerlink" title="矩阵链乘法问题"></a>矩阵链乘法问题</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>两个矩阵A和B相乘，维度分别为$ p×q$和$ q×r$，则$A*B$的时间复杂度为$pqr$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MATRIX_MULTIPLY(A,B)&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;A.rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; B.cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A.cols;k++)&#123;</div><div class="line">        C[i,j] = A[i,k]*B[k,j];</div><div class="line">&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h3><p>​    首先，给定一个矩阵链 <script type="math/tex"><A_1,A_2,A_3></script>  ，三个矩阵的规模分别为：10×100 ， 100×5 ，5×50 ，计算他们的乘积有两种方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$((A_1A_2)A_3)$</th>
<th style="text-align:left"><script type="math/tex">10*100*5+10*5*50=7500</script></th>
</tr>
</thead>
<tbody>
<tr>
<td>$(A_1(A_2A_3))$</td>
<td style="text-align:left"><script type="math/tex">100*5*50+10*100*50=75000</script></td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，对一串矩阵做乘法操作，乘法的顺序影响到算法的时间复杂度。由此，引出矩阵链乘法问题：</p>
<p><strong>给定n个矩阵的链<script type="math/tex"><A_1,A_2,...,A_n></script>，矩阵<script type="math/tex">A_i</script> 的规模为<script type="math/tex">p_{i-1} \times p_i</script>，确定代价最低的计算顺序，使得计算乘积$A_1A_2A_n$所需标量乘法次数最小。</strong></p>
<a id="more"></a>
<h3 id="用DP解决此问题"><a href="#用DP解决此问题" class="headerlink" title="用DP解决此问题"></a>用DP解决此问题</h3><p>DP四步骤：</p>
<ol>
<li>可以将求解<script type="math/tex">A_1,*A_2*...*A_n</script>所需要的乘法次数问题划分成两个子问题：求解<script type="math/tex">A_1,*A_2*...*A_k</script>所需要的乘法次数+求解<script type="math/tex">A_{k+1},*A_{k+2}*...*A_n</script>所需要的乘法次数+<script type="math/tex">p_0*p_k*p_n</script></li>
<li>​</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【算法导论】动态规划（一）钢条切割]]></title>
      <url>/2017/10/31/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/</url>
      <content type="html"><![CDATA[<h2 id="1-动态规划（Dynamic-programming）"><a href="#1-动态规划（Dynamic-programming）" class="headerlink" title="1. 动态规划（Dynamic programming）"></a>1. 动态规划（Dynamic programming）</h2><p>这里programming指的是<strong>表格</strong>，而非编程。动态规划通常用来<strong>求解最优化问题</strong></p>
<p>与分治法对比：</p>
<ol>
<li>相同点：都是通过子问题组合求解原问题</li>
<li>不同点：分治法将问题划分为<strong>不相交</strong>的子问题，求解再合并，动态规划应用于<strong>子问题重叠</strong>的情况，即不同的子问题具有公共的子子问题，此时如果用分治法就会出现重复计算求解。为了避免重复动态规划对子问题只求解一次，将其保存在表格中，从而无需每求解一个子子问题时重复计算。</li>
</ol>
<h2 id="2-求解步骤"><a href="#2-求解步骤" class="headerlink" title="2. 求解步骤"></a>2. 求解步骤</h2><ol>
<li>刻画最优解的结构特征</li>
<li>递归定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造最优解</li>
</ol>
<p>其中不是所有的题目都会要求4，仅仅要求3，要求4的时候，我们需要在得到3的同事维护一些额外的信息来求出4。</p>
<p>看到这四个步骤的时候，还是挺懵逼的，继续往下看=.=</p>
<a id="more"></a>
<h2 id="3-钢条切割问题"><a href="#3-钢条切割问题" class="headerlink" title="3. 钢条切割问题"></a>3. 钢条切割问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Serling公司购买一根长钢管，将其切割成短钢管出售，给定钢管长度和对应的价钱如下表：</p>
<p><img src="https://i.loli.net/2017/10/31/59f7536b8fc8f.png" alt=""> </p>
<p>问题要求根据上面的价格，给出最佳的切割方案，使得收益最大。</p>
<p>以n=4为例，可以将钢条切割成如下图所示的8种情况，其中收益岁大的是(c)：</p>
<p><img src="https://ooo.0o0.ooo/2017/10/30/59f73938d2f50.png" alt=""> </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>钢条长度为n时，共有$2^{n-1}$种分割方式。</p>
<ol>
<li><p>递归</p>
<p>把长度为n的钢条切割问题转化为：将钢条从左边切下长度为i的一段，对右边剩下的长度为n-i的钢条进行进一步的切割。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if n==0:</div><div class="line">2 	return 0</div><div class="line">3 q=MIN</div><div class="line">4 for i = 1 to n:</div><div class="line">5 	q=max(q,p[i],CUT-ROD(p,n-i))</div><div class="line">6 return q</div></pre></td></tr></table></figure>
<p>当n=4时，上面递推方式的工作量如图所示，复杂度为$T(n)=2^n$</p>
<p><img src="https://i.loli.net/2017/10/31/59f759167976c.png" alt=""> </p>
</li>
<li><p>动态规划（DP）</p>
<p>可以看出来用上面递归的方式计算，中间会重复求解相同子问题。使用动态规划，<strong>仔细安排求解顺序，对每个子问题只求解一次所以，并把结果保存下来</strong>，供后续使用避免重复计算。</p>
<p>​    对于钢条切割的问题，我们可以将长度为n的钢条切割问题转化为规模更小的子问题：当完成首次切割后，将两段钢条看成<strong>两个独立的钢条切割</strong>问题，通过<strong>组合</strong>两个相关子问题的最优解，选取组合收益最大者，构成原问题的最优解。</p>
<p>因此，将长度为n的钢条切割成两段，共有下面n种切割方式，求解下面n个子问题的最优解，再选取其中最大的作为原问题的最优解。</p>
<script type="math/tex; mode=display">
r_n=max(p_n,r_{1}+r_{n-1},r_{2}+r_{n-2},...,r_{n-1}+r_1)</script><p>​以n=4为例：</p>
<p>$r_1=1$</p>
<p>$r_2=max(p_2,max(r_1)+max(r_1))=max(5,1+1)=5$</p>
<p>$r_3=max(p_3,max(r_1)+max(r_2))=max(8,5+1)=8$</p>
<p>$r_4=max(p_4,max(r_1)+max(r_3),max(r_2)+max(r_2))=max(9,8+1,5+5)=10$</p>
<p>…</p>
<p>​    动态规划两种实现方法：</p>
</li>
</ol>
<ul>
<li><p>自顶向下：</p>
<p>仍按照递归的方式实现，过程中保存每个子问题的解，后续过程中先检查是否已经保存过此解，如果是，直接返回保存的值。就好像带了一个“备忘录”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">memorized-CUT-ROD[] = MIN//用于记录子问题结果</div><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if memorized-CUT-ROD[n] &gt; 0:</div><div class="line">2 	return memorized-CUT-ROD[n]</div><div class="line">3 else</div><div class="line">4 	for i = 1 to n:</div><div class="line">5 	q=max(q,p[i],memorized-CUT-ROD(p,n-i))</div><div class="line">6 memorized-CUT-ROD[n] = q</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p>自底向上</p>
<p>需要恰当定义子问题的“规模”，使得任何子问题的求解都只依赖于“更小的”子问题，进而将子问题按规律排序，按由小到大的顺序进行求解，当求解某个自问题时，它所以来的子问题都已经求解完毕。</p>
<p>伪代码略，直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            maxvalue[i] = max(maxvalue[i],maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 至此，可以求出该问题的最优解了~</p>
</li>
</ul>
<h3 id="重构解"><a href="#重构解" class="headerlink" title="重构解"></a>重构解</h3><p>​    上面的求解过程可以求出最优解的值，但并没有返回解本身（具体的切割方案），为了得到最优解，需要在求解最优解的同时，保存切割信息。扩展上面的算法，使之对子问题不仅保存最优收益值$r_j$，还保存该最优方案对应的第一段钢条的切割长度，也就是第一段钢条的切割位置距离钢条左端的长度$s_j$，最后输出最优方案时，根据$s_j$即可复原出最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);<span class="comment">//记录最优方案值</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftlen(len,<span class="number">0</span>);<span class="comment">//记录第一段钢条距左端距离</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        leftlen[i] = i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]&gt;maxvalue[i])&#123;</div><div class="line">                maxvalue[i] = maxvalue[j<span class="number">-1</span>]+maxvalue[i-j];</div><div class="line">                leftlen[i] = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//输出最优解方案</span></div><div class="line">    <span class="keyword">int</span> m = n<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;leftlen[m]&lt;&lt;<span class="string">"\t"</span>;</div><div class="line">        m -= leftlen[m];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如图：</p>
<p>​                <img src="http://omaby2s5z.bkt.clouddn.com/2017-10-31-22-25-25.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】713.Subarray-Product-Less-Than-K.md]]></title>
      <url>/2017/10/26/%E3%80%90leetcode%E3%80%91713-Subarray-Product-Less-Than-K-md/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Your are given an array of positive integers nums.</p>
<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">Output: 8</div><div class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个正整数组，和一个整数k，求成绩小于k的连续子数组个数</p>
<p>这道题真的是做了很久，想到了用滑窗，用一个数字记录窗口内数字成绩，但是算不明白个数</p>
<p>问题的关键在于:</p>
<p><strong>每次滑窗的末尾向后移动一位之后，满足条件的窗口内新增的连续子数组数目为：end-start+1</strong></p>
<p>因为每次滑窗末尾向后移动一位，新增的子数组必然包含最后一个数字，又必须是连续子数组，所以新增的个数是end-start+1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后附上很简单的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class="line">    int product = 1;</div><div class="line">    int count = 0;</div><div class="line">    int start = 0;</div><div class="line">    int end = 0;</div><div class="line">    while(end &lt; nums.size()&amp;&amp;start&lt;=end)&#123;</div><div class="line">        product = product*nums[end];</div><div class="line">        while(product&gt;=k&amp;&amp;start&lt;=end)&#123;</div><div class="line">            product = product/nums[start];</div><div class="line">            start++;</div><div class="line">        &#125;</div><div class="line">        count+=end-start+1;</div><div class="line">        end++;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="http://omaby2s5z.bkt.clouddn.com/blog/171026/1g02kLeb0H.png?imageslim" alt=""><br><img src="http://omaby2s5z.bkt.clouddn.com/201710261713_719.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】 628. Maximum Product of Three Numbers]]></title>
      <url>/2017/08/01/%E3%80%90leetcode%E3%80%91-628-Maximum-Product-of-Three-Numbers/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3]</div><div class="line">Output: 6</div></pre></td></tr></table></figure></p>
<p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3,4]</div><div class="line">Output: 24</div></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>The length of the given array will be in range [3,$10^4$] and all elements are in the range [-1000, 1000].<br>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果数组里面没有负整数，那最大的乘积就是三个最大的数字乘积，题目说明数组中的数字范围是<strong>[-1000, 1000]</strong>，所以会有两种情况：</p>
<ol>
<li>两个最小的负数<script type="math/tex">*</script>一个最大的正数</li>
<li>三个最大的正数相乘</li>
</ol>
<p>所以只需要定义5个变量用来存储两个最小的和三个最大的数字，遍历一遍数组获取5个变量的值，然后返回两种情况中值较大的那种。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    //声明变量用来存储两个最小的数字和三个最大的数字</div><div class="line">    int min1 = 1001, min2 = 1001, max1 = -1001, max2 = -1001, max3 = -1001;</div><div class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</div><div class="line">        //遇到比min1还小的</div><div class="line">        if (nums[i] &lt; min1) &#123;</div><div class="line">            min2 = min1;</div><div class="line">            min1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &lt; min2) &#123;</div><div class="line">            min2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        if (nums[i] &gt; max1) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = max1;</div><div class="line">            max1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max2) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max3) &#123;</div><div class="line">            max3 = nums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = min1*min2*max1;</div><div class="line">    int y = max1*max2*max3;</div><div class="line">    if (x &gt; y)</div><div class="line">        return x;</div><div class="line">    else</div><div class="line">        return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597ffda9bb7c7.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】1. Two Sum]]></title>
      <url>/2017/08/01/%E3%80%90leetcode%E3%80%911-Two-Sum/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line"></div><div class="line">return [0, 1].</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给一个数组和一个整数，返回数组中和恰好等于这个整数的两个数组的位置</p>
<p>自己就只想出来了从前向后遍历的方法，时间复杂度$O(n^2)$</p>
<p>代码如下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        hash_map&lt;int,int&gt; map;</div><div class="line">        for(int i = 0;i &lt; nums.size();i++)&#123;</div><div class="line">            int res = target-nums[i];</div><div class="line">            if (map.)</div><div class="line">            for(int j = i+1;j &lt; nums.size();j++)&#123;</div><div class="line">                if (res == nums[j])&#123;</div><div class="line">                    result.push_back(i);</div><div class="line">                    result.push_back(j);</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>看了solution才知道这道题正确的打开方式是用hash_map，可以先把数组中的元素存入hash_map中，这样就可以实现O(1)复杂度的按值查找了。</p>
<p>不过还有更好的方式，就是采用边查找边插入的方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt; a,int b) &#123;</div><div class="line">    vector&lt;int&gt; res;</div><div class="line">    unordered_map&lt;int, int&gt; map;</div><div class="line">    for (int i = 0; i &lt; a.size(); i++) &#123;</div><div class="line">        int temp = b - a[i];</div><div class="line">        //查看map里是否已经有要找的元素</div><div class="line">        unordered_map&lt;int, int&gt;::iterator it = map.find(temp);</div><div class="line">        //如果没有，把当前元素的值和idx插入map</div><div class="line">        if (it == map.end()) &#123;</div><div class="line">            map.insert(make_pair(a[i], i));</div><div class="line">        &#125;</div><div class="line">        //找到了符合要求的，返回idx</div><div class="line">        else&#123;</div><div class="line">            res.push_back(it-&gt;second);</div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在查找指定值元素的时候就可以有$O(1)$的复杂度了，遍历的复杂度是$O(n)$,总的复杂度是$O(n)$</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597f5b7c55158.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> hash_table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>/2017/07/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>分治法</strong><br>将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p>
<p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//将两个有序数组合并成一个有序数组</div><div class="line">void merge(int a[], int begin,int mid,int end,int b[]) &#123;</div><div class="line">    int i = begin;</div><div class="line">    int j = mid + 1;</div><div class="line">    int k = 0;</div><div class="line">    while ((i &lt;= mid) &amp;&amp; (j &lt;= end)) &#123;</div><div class="line">        if (a[i] &lt; a[j]) &#123;</div><div class="line">            b[k] = a[i];</div><div class="line">            k++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            b[k] = a[j];</div><div class="line">            k++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (i&lt;=mid)&#123;</div><div class="line">        b[k] = a[i];</div><div class="line">        k++;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= end)&#123;</div><div class="line">        b[k] = a[j];</div><div class="line">        k++;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; k; i++)&#123;</div><div class="line">        a[begin + i] = b[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//归并排序</div><div class="line">void MergeSort(int a[], int begin,int end,int b[]) &#123;</div><div class="line">    if (begin &lt; end) &#123;</div><div class="line">        int mid = (begin + end) / 2;</div><div class="line">        MergeSort(a, begin, mid, b);</div><div class="line">        MergeSort(a, mid + 1, end, b);</div><div class="line">        merge(a, begin, mid, end, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况$O(n\log(n))$<br>平均情况$O(n\log(n))$</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[不使用中间变量交换两个数字]]></title>
      <url>/2017/07/22/%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>给定两个数字a和b，要求不使用中间变量交换二者</p>
<h3 id="一般做法"><a href="#一般做法" class="headerlink" title="一般做法"></a>一般做法</h3><p>一般的做法很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    int temp = a;</div><div class="line">    a = b;</div><div class="line">    b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不使用中间变量的做法"><a href="#不使用中间变量的做法" class="headerlink" title="不使用中间变量的做法"></a>不使用中间变量的做法</h3><p>采用位操作符中的异或操作<code>^</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取反</td>
<td>0变1,1变0</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td>后面补0</td>
</tr>
<tr>
<td style="text-align:center">>&gt;</td>
<td style="text-align:center">右移</td>
<td>前面补0，后面吞位</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
<td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
<td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>位或</td>
<td>有一个或2个1，则为1。<strong>用于做and运算</strong></td>
</tr>
</tbody>
</table>
</div>
<p>容易发现<code>^</code>的性质：</p>
<ol>
<li>两个相同的数字做<code>^</code>操作得0</li>
<li>任何数字跟0做<code>^</code>操作还是它本身</li>
</ol>
<p>所以可以通过下面的方式交换两个数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    a = a^b;</div><div class="line">    b = b^a;</div><div class="line">    a = a^b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序大部分时间正确，但是有个致命缺陷，当a和b指向同一个位置时，计算a^b得0，也就是说a和b所指向的地址是同一个，所以此时a=b=0。所以上面这样写的前提是假设两个指针不会指向同一个位置。这也是编译器优化时经常考虑的一点，这种两个指针指向同一个存储器的情况叫做存储器别名使用（memory aliasing）。</p>
<p>因此正确的程序应该如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    if (a!=b)&#123;</div><div class="line">        a = a^b;</div><div class="line">        b = b^a;</div><div class="line">        a = a^b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[选择排序]]></title>
      <url>/2017/07/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次从无序区选择一个最小的放大有序区的最后</p>
<p>设数组为a[0…n-1]。</p>
<ol>
<li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p>
</li>
<li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p>
</li>
<li><p>i++并重复第二步直到i==n-1。排序完成。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//选择排序</div><div class="line">void SekectSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        int min = a[i];</div><div class="line">        int loc = i;</div><div class="line">        //寻找最小的元素</div><div class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</div><div class="line">            if (a[j] &lt; min) &#123;</div><div class="line">                min = a[j];</div><div class="line">                loc = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //把最小的元素放在有序区后面</div><div class="line">        int temp = a[loc];</div><div class="line">        a[loc] = a[i];</div><div class="line">        a[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/07/22/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>希尔排序的实质是分组插入排序，又称缩小增量排序。</p>
<p>该方法的基本思想是：</p>
<ol>
<li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的），对这些子序列分别进行直接插入排序</li>
<li>依次缩减增量再进行排序</li>
<li>待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li>
</ol>
<p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在我们要将这样一个数组排序，一共有10个元素</p>
<p><img src="https://i.loli.net/2017/07/20/59701858e5e96.png" alt=""> </p>
<ul>
<li><strong>第一次 增量 gap = 10/2 = 5</strong></li>
</ul>
<p><img src="https://i.loli.net/2017/07/20/59701a2be3ef5.png" alt=""> </p>
<p>整个数组被分成了5个子数组，分别是[49,13]，[38,27]，[65,49]，[97,55]，[26,4]<br>然后对这五个子数组进行插入排序，得到下面结果</p>
<p><img src="https://i.loli.net/2017/07/20/59701b9f8c66f.png" alt=""> </p>
<ul>
<li><strong>第二次 增量 gap = 5/2 = 2</strong></li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/07/20/59701bfe5a204.png" alt=""> </p>
<p>这次我们把整个数组分成了两个子数组，分别是[13,49,4,38,97],[27,55,49,65,26]<br>对这个两个子数组排序，结果如下：<br><img src="https://i.loli.net/2017/07/20/59701d3805da5.png" alt=""> </p>
<ul>
<li><strong>第三次 增量 gap = 2/2 = 1</strong><br>此时整个数组已经接近有序，对整个数组进行全排列</li>
</ul>
<p><img src="https://i.loli.net/2017/07/20/59701e32a8bb1.png" alt=""> </p>
<p>最终得到数组有序</p>
<p><img src="https://ooo.0o0.ooo/2017/07/20/59701fd2c547a.png" alt=""> </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; delta; i++) &#123;//分成了delta个子序列</div><div class="line">            //对每个子序列进行插入排序</div><div class="line">            for (int j = i + delta; j &lt; len; j = j + delta) &#123;</div><div class="line">                int jj = j - delta;</div><div class="line">                int temp = a[j];</div><div class="line">                while ((a[jj] &gt; temp)&amp;&amp;(jj&gt;=0)) &#123;</div><div class="line">                    a[jj + delta] = a[jj];</div><div class="line">                    jj -= delta;</div><div class="line">                &#125;</div><div class="line">                //插入</div><div class="line">                a[jj + delta] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">白话经典算法系列</a>原文是这么说的</p>
<blockquote>
<p>很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较…….。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。</p>
</blockquote>
<p>我理解了一下，思路就是把在序列中提取子序列的过程简化了，我们可以从第gap个元素开始，向后遍历到序列末尾，可以个元素都跟其所在的子序列中位于它前面的数字做插入排序，最终就会得到一个有序数列了~</p>
<p>画个图表示一下吧，还是刚才那个序列，比如说此时进行到第二次排序了，gap=2的情况：</p>
<p>从a[2]开始遍历，此时a[2]所在的子序列为[a[0],a[2],a[4],a[6],a[8]]，需要将a[2]和位于它前面的a[0]比较，插入到合适的位置：</p>
<p><img src="https://i.loli.net/2017/07/22/59731239a3cd2.png" alt=""> </p>
<p>指针后移一位， 同上此时a[3]所在的子序列为[a[1],a[3],a[5],a[7],a[9]]，需要将a[3]和位于它前面的a[1]比较，插入合适的位置：</p>
<p><img src="https://i.loli.net/2017/07/22/59731264440fc.png" alt=""> </p>
<p>接下来指针指向a[4],此时需要将a[4]和位于它前面的a[2]、a[0]比较，插入合适的位置：</p>
<p><img src="https://i.loli.net/2017/07/22/59731282140fd.png" alt=""> </p>
<p>下面重复上面的步骤：</p>
<p><img src="https://i.loli.net/2017/07/22/597312a912c5c.png" alt=""> </p>
<p><img src="https://i.loli.net/2017/07/22/597312ca290dc.png" alt=""> </p>
<p>此处省略剩余步骤…..最终可以将数组排列至有序状态</p>
<p>现在可以上代码了~<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = delta; i &lt; len; i++) &#123;//遍历</div><div class="line">            //对该元素子前面的子数组进行插入排序</div><div class="line">            int temp = a[i];</div><div class="line">            int jj = i - delta;</div><div class="line">            while ((jj &gt;=0)&amp;&amp;(a[jj]&gt;temp))&#123;</div><div class="line">                swap(a[jj], a[jj+delta]);</div><div class="line">                jj -= delta;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[插入排序]]></title>
      <url>/2017/07/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p>
<p>设数组为a[0…n-1]。</p>
<ol>
<li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p>
</li>
<li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p>
</li>
<li><p>i++并重复第二步直到i==n-1。排序完成。</p>
</li>
</ol>
<p>在查找某元素应该插入到前面有序序列的位置时，我们可以采用边交换边插入的方式，直到无需交换</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                int temp = a[j];</div><div class="line">                a[j] = a[j - 1];</div><div class="line">                a[j - 1] = temp;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中交换元素部分可以调用STL中的swap函数实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//插入排序</div><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                swap(a[j], a[j - 1]);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>/2017/07/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol>
<li>依次比较相邻的两个数据，如果前面的比后面的大，就将其交换</li>
<li>这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置</li>
<li>重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        for (int j = 0; j &lt; len -1-i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来可以优化一下，上面的程序中一共进行了N轮比较，其实如果有一趟没有发生交换就说明这时候每两个相邻数据都已经呈现前边比后边小的状态了，此时已经达到有序状态了，所以后面就无需再继续比较了</p>
<h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int flag = 1;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        int flag = 0;//用来记录本轮是否发生交换</div><div class="line">        for (int j = 0; j &lt; len - 1 - i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = 1;//本轮发生交换了</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 0) &#123;//如果本轮未发生交换，跳出</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以进一步优化，假设有100个数的数组，只有前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。</p>
<p>一般地，冒泡排序在进行过程中，也会出现后面已经排好了的情况，所以如果记录一下有序的位置，下一次就可以不用向后遍历了。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int k ;//用于记录从那个数据开始之后的数据为</div><div class="line">    int flag = len-1;//用于几率从哪个数据开始之后的数据有序</div><div class="line">    while (flag &gt; 0) &#123;</div><div class="line">        k = flag;//计算到k之前</div><div class="line">        flag = 0;//用于记录本轮是否有交换</div><div class="line">        for (int j = 0; j &lt; k; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = j;//本轮交换了，更新交换位置</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下冒泡排序的关键点就是相邻元素两两比较交换，执行N轮，如果有某一轮没有发生交换说明已经有序，停止；记录下每一轮交换停止的位置，这之后的数据时有序的，下一轮无需考察。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>/2017/07/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>感谢@MoreWindows的白话经典算法系列，浅显易懂，让我终于看懂了快速排序，总结一下</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>从数列中选择一个作为<strong>基准数</strong></li>
<li><strong>分区</strong>操作：把比基准数小的都排在基准数的左边，比基准数大的都排在基准数的右边</li>
<li>对基准数的左边和右边<strong>分治</strong>排序</li>
</ol>
<h3 id="具体实现：挖坑填数-分治法"><a href="#具体实现：挖坑填数-分治法" class="headerlink" title="具体实现：挖坑填数+分治法"></a>具体实现：挖坑填数+分治法</h3><p>这里结合个实际例子说明</p>
<p><img src="https://i.loli.net/2017/07/18/596da83e7801a.png" alt=""> </p>
<p>根据上面的步骤，选取第一个作为<strong>基准数</strong>，接下来我们需要把比它小的数字放到它的左边，比它大的数字放到它的右边，这里就需要重点注意<strong>挖坑填数</strong>的方法了，划重点！！！</p>
<p><img src="https://i.loli.net/2017/07/18/596da86bf0f53.png" alt="">  temp=72</p>
<p>我们先把基准数72保存到变量temp中，这时候就相当于在数组的第一个位置上挖了一个“坑”，如果我们在后边发现有比temp小的数字，就可以把那个比较小的数字填到这个空缺的“坑”里了。</p>
<p><img src="https://i.loli.net/2017/07/18/596dada8c0f65.png" alt=""> </p>
<p>我们定义一个从后向前遍历的指针j，发现a[8]位置上的48比72小，所以我们要把48放到前面去，填补之前72留下的空缺.</p>
<p><img src="https://i.loli.net/2017/07/18/596da9ed5c6da.png" alt=""> </p>
<p>这时候原来存放48的这个位置就空了出来，有了一个新的“坑”，此时指针i向后遍历，如果找到比temp大的数字，便可以填补之前的48留下的坑了。恩，我们找到了a[3]位置上的88，将他填补到之前48留下来的“坑”里。</p>
<p><img src="https://i.loli.net/2017/07/18/596dabf678c11.png" alt=""> </p>
<p>接下来继续重复上面的过程，先从后向前找到比基准值小的，填补在前面的“坑”里，然后再从前向后找比基准值大的，填补刚才空出来的“坑”。直到最终两个指着相遇。</p>
<p><img src="https://i.loli.net/2017/07/18/596dacb08d160.png" alt=""> </p>
<p>而此时空缺的位置，恰好就是基准值temp的位置。将基准值填入空缺位置，至此就完成了一次分区的操作，此时基准数前面的数字都比基准数小，后面的都比基准数大。</p>
<p>接下来就是对基准数前后两段数组分而治之，采用递归调用的思想，将整个数组调整至有序状态。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void quiksort(vector&lt;int&gt; &amp;vec, int i, int j) &#123;</div><div class="line">    if (i &lt; j) &#123;</div><div class="line">        int temp = vec[i];//存储基准值</div><div class="line">        int left = i;</div><div class="line">        int right = j;</div><div class="line">        while (left &lt; right) &#123;</div><div class="line">            //后指针向前遍历，寻找比基准值小的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[right] &gt;= temp) &#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[left] = vec[right];</div><div class="line">            //前指针向后遍历，寻找比基准值大的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[left] &lt;= temp) &#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[right] = vec[left];</div><div class="line">        &#125;</div><div class="line">        vec[right] = temp;</div><div class="line">        //递归调用</div><div class="line">        quiksort(vec, i, right - 1);</div><div class="line">        quiksort(vec, right + 1, j);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec = &#123;&#125;;</div><div class="line">    scanf_s(&quot;%d&quot;, &amp;n);</div><div class="line">    while (n &gt; 0) &#123;</div><div class="line">        scanf_s(&quot;%d&quot;, &amp;temp);</div><div class="line">        vec.push_back(temp);</div><div class="line">        n--;</div><div class="line">    &#125;</div><div class="line">    quiksort(vec, 0, vec.size() - 1);</div><div class="line">    for (int i = 0; i &lt; vec.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; vec[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>期望时间复杂度：$O(n\log(n))$</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 排序算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[今日头条-算法岗]]></title>
      <url>/2017/07/17/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E7%AE%97%E6%B3%95%E5%B2%97/</url>
      <content type="html"><![CDATA[<p>昨天去头条面试了，意料之中的挂了23333</p>
<p>没怎么考察算法，就做了个自我介绍，简单介绍了一下项目，问了问ffm的原理，跟fm比起来有哪些优势</p>
<p>紧接着上了两道算法题，两道题都很基础，但自己真心不扎实，难怪人家看不上==</p>
<h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><p>给一个句子，把句子翻转但单词不翻转<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:&quot;I am a coder&quot;</div><div class="line">output:&quot;coder a am I&quot;</div></pre></td></tr></table></figure></p>
<p>对字符串、字符数组这里一直都很懵逼，看到题就知道自己写不出来了，挣扎了一会投降了==<br>而且我的重点都放在了要怎么读进来啊！不会读进来啊！怎么读啊！要好好看c++了啊喂！</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>先翻转整个句子，再把每一个单词翻转过来。翻转字符串的时候前后对换，能减少一半的时间复杂度</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//反转字符串</div><div class="line">void ReverseString(char *begin, char *end) &#123;</div><div class="line">    while (begin &lt; end) &#123;</div><div class="line">        char temp = *begin;</div><div class="line">        *begin = *end;</div><div class="line">        *end = temp;</div><div class="line">        begin++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//反转句子</div><div class="line">char* ReverseSentance(char *ch) &#123;</div><div class="line">    char *begin = ch;</div><div class="line">    char *end = ch;</div><div class="line"></div><div class="line">    while (*end != &apos;\0&apos;)</div><div class="line">        end++;</div><div class="line">    end--;</div><div class="line">    //反转整个句子</div><div class="line">    ReverseString(begin, end);</div><div class="line"></div><div class="line">    //逐个反转单词</div><div class="line">    begin = ch;</div><div class="line">    end = ch;</div><div class="line">    while ((*begin != &apos;\0&apos;)) &#123;</div><div class="line">        while ((*end != &apos; &apos;) &amp;&amp; (*end != &apos;\0&apos;)) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        ReverseString(begin, end - 1);</div><div class="line">        if (*end != &apos;\0&apos;) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        begin = end;</div><div class="line">    &#125;</div><div class="line">    return ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    /*fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    char str[1024];</div><div class="line">    int i = 0;</div><div class="line">    while ((str[i] = getchar()) != &apos;\n&apos;) &#123;</div><div class="line">        i++;</div><div class="line">    &#125; </div><div class="line">    int length = sizeof(str)/sizeof(str[0]);</div><div class="line">    char *array = str;*/</div><div class="line">    char a[] = &quot;I am a coder&quot;;</div><div class="line">    char *array = a;</div><div class="line">    int length = sizeof(a) / sizeof(a[0]);</div><div class="line">    cout &lt;&lt; length;</div><div class="line">    array = ReverseSentance(array);</div><div class="line">    for (int i = 0; i &lt; length-1; i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *array;</div><div class="line">        array++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个有序数组和一个数字，统计该数字在数组中出现的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:3</div><div class="line">1 2 3 3 4 5 6</div><div class="line">output:2</div></pre></td></tr></table></figure>
<p>我想到了用二分查找来解决，然后我竟然找到了这个数字时候左右分别递归再找==</p>
<p>其实找到了之后就向左向右遍历就可以了，因为数组本身已经是有序的了嘛。。。。</p>
<h3 id="关键思路"><a href="#关键思路" class="headerlink" title="关键思路"></a>关键思路</h3><p><strong>二分查找该数字是否在数组中出现，如果找到了就分别向左侧和右侧探测连续出现了几次</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//二分查找</div><div class="line">int midfind(vector&lt;int&gt; &amp;vec,int head,int tail,int n) &#123;</div><div class="line">    if (head &gt; tail)</div><div class="line">        return -1;</div><div class="line">    else &#123;</div><div class="line">        int mid = (head + tail) / 2;</div><div class="line">        if (vec[mid] == n)</div><div class="line">            return mid;</div><div class="line">        else if (vec[mid] &lt; n) &#123;</div><div class="line">            return midfind(vec, mid + 1, tail, n);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return midfind(vec, head, mid - 1, n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec;</div><div class="line">    fscanf(fin,&quot;%d&quot;,&amp;n);</div><div class="line">    while (fscanf(fin, &quot;%d&quot;,&amp;temp)!=EOF) &#123;</div><div class="line">        vec.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    int len = vec.size();</div><div class="line">    int pos = midfind(vec, 0, len - 1, n);</div><div class="line">    if (pos == -1)</div><div class="line">        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</div><div class="line">    else &#123;</div><div class="line">        int pos1 = pos - 1;</div><div class="line">        int pos2 = pos + 1;</div><div class="line">        int sum = 1;</div><div class="line">        while ((pos1&gt;=0) &amp;&amp; (vec[pos1]==n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos1--;</div><div class="line">        &#125;</div><div class="line">        while ((pos2&lt;len) &amp;&amp; (vec[pos2] == n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos2++;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>立flag 好好刷算法了要！！！！！基础很重要！</p>
]]></content>
      
        <categories>
            
            <category> 面经 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Optimal Real-Time Bidding for Display Advertising论文笔记]]></title>
      <url>/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014"><a href="#Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014" class="headerlink" title="Optimal Real-Time Bidding for Display Advertising——KDD2014"></a>Optimal Real-Time Bidding for Display Advertising——KDD2014</h2><p>参考着师兄的博客<a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a>，仔细读完了这篇paper，总结一下，方便日后回顾</p>
<p>ps:十分感谢师兄@<a href="http://blog.csdn.net/breada" target="_blank" rel="external">面包包包包包包</a>，看了师兄的三篇博客可算是入了门，不然真是一头雾水hold不住啊</p>
<p>这篇文章的核心就是提出了一个<strong>非线性的竞价函数</strong>，相比于KDD2012的<a href="http://cwds.uw.edu/sites/default/files/p804.pdf" target="_blank" rel="external">《Bid Optimizing and Inventory Scoring in Targeted Online Advertising》</a>中提出的线性竞价函数，本文认为出价应该与点击率、转化率等指标具有<strong>非线性关系</strong></p>
<p>首先，文章将现实问题用数学方法建模为限制条件下的优化问题，并通过拉格朗日乘子法，求得出价策略的数学表达式（非线性竞价函数）；然后利用iPinYou数据拟合出价策略中的参数；最后，做实验验证结果，发现了一个有意思的结论：相比少量高品质的展示机会，那些大量低品质的展示机会同样可以具有较好的广告效果，值得出价。这个发现对于那些预算不够，同时又想做广告的小广告主来说，简直就是福音。</p>
<a id="more"></a>
<h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><h3 id="选择合适的出价策略，在预算的限制下实现广告效果最大化"><a href="#选择合适的出价策略，在预算的限制下实现广告效果最大化" class="headerlink" title="选择合适的出价策略，在预算的限制下实现广告效果最大化"></a>选择合适的出价策略，在预算的限制下实现广告效果最大化</h3><p>把这句话用数学的形式表达出来就是下面的样子：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p>
<p>看起来来有点复杂，其实很简单，两个式子，第一行是优化目标：寻找似的收益最大化的出价函数b()</p>
<p>第二行就是预算约束，就是花的钱不能超过预算约束B</p>
<p>模型中涉及的具体符号定义如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59141e0b0486d.png" alt=""> </p>
<h3 id="结合着具体的符号定义，可以解释一下之前建立的数学模型了"><a href="#结合着具体的符号定义，可以解释一下之前建立的数学模型了" class="headerlink" title="结合着具体的符号定义，可以解释一下之前建立的数学模型了"></a>结合着具体的符号定义，可以解释一下之前建立的数学模型了</h3><p>$dx$：x代表一次bid request，也就是一次竞价请求的特征向量，是ADX发给DSP的竞价请求“标识XXX,男性，20-25岁，跑鞋爱好者，广告位为首页”，即一次广告展示机会。之所以是dx而不是x，是因为我们关注的是整个广告推广计划中所有的竞价过程，而非某一次竞价。</p>
<p>$p_x(x)$：广告展示机会的概率密度分布，我的理解是在全网所有的竞价中，满足我DSP要求的、或者是我能收到的bid request所占的比例。因此，$p_x(x)*dx$的物理意义是我能收到的展示机会。</p>
<p>$\theta(x)$：θ是赢得此次竞价所能带来的收益(KPI)，本文用CTR来衡量，CTR越高，收益就越高。</p>
<p>$b(\theta(x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我所出的价格bid。</p>
<p>$\omega(b(\theta(x),x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我的出价bid能获胜的概率是多少。因此，$\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$表示对于本次我所收到的这个展示机会来说，在该机会能带来收益（如CTR,CVR等）为θ(x)，我出价为bid的情况下，我能打败对手获得此次展示机会的概率。</p>
<p>以$\theta(x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会后，所能获得的收益。</p>
<p>以$b(\theta(x),x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会所花费的钱。</p>
<p>$N_T$：生存时间T内广告推广活动中所有的bid request数量</p>
<p>总之还是那句话：<strong>选择合适的出价策略，在预算的限制下实现广告效果最大化</strong></p>
<h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p>
<p>经过一系列的化简，我们可以把模型的函数表达式简化成下面的样子，具体过程参考原文</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/591426f75561b.png" alt=""> </p>
<p>现在参数就只有$\theta$了，也就是CTR，接下来要怎么求解最大值呢？这是要一个带约束条件的最优化问题，作者是用了拉格朗日乘子法来解决的</p>
<p>通过拉格朗日乘子法，我们可以将不等式乘一个参数$\lambda$后和等式写进一个公式里(化简过程已省略)，得到如下结果:</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/591427c023edb.png" alt=""> </p>
<p>然后对其求导，令导数为0得到：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142a08a7855.png" alt=""> </p>
<p>进而求得出价函数$b(\theta)$与赢得竞价概率之间的函数关系为：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142a857ef5e.png" alt=""> </p>
<p>也就是说，我们想要的出价函数b()与胜率函数w()有关，那我们就来看看他们之间到底有什么关系。作者利用数据集绘制出二者之间的关系如图：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142bedeeacb.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/05/11/59142c7551aaa.png" alt=""> </p>
<p>我们发现这个函数走势很像$y=\frac{x}{c+x}$啊！！！对，作者也发现了，于是乎就有了下面的非线性竞价函数：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142c9e5260d.png" alt=""> </p>
<p>然后把（9）带回到（8）中就求得了我们梦寐以求的非线性出价函数：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142ce77aa66.png" alt=""> </p>
<p>画个图看看上面的两个函数走势吧：</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59142d47bf56d.png" alt=""> </p>
<p>还是很符合实际情况的，点击率越高，出价也就越高，出价越高，赢得竞价的可能行也就越高</p>
<p>到此，我们就已经把问题的数学转化和模型求解弄完了，那剩下的关键问题就是要<strong>求解两个参数：$\lambda$和$c$了</strong></p>
<p>可以看出来$c$是可以直接根据历史数据拟合出来的，利用最小二乘法使得均方误差最小即可</p>
<p>难点在于$\lambda$的求解，文章采用的方法是：<strong>通过不断调整以获得在测试数据中得到最大收益（点击量）来获得</strong></p>
<h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><ol>
<li>利用iPinYou实时竞价数据，每一条数据是一个竞价请求，包含其特征、赢得竞价的价格、用户反馈（点击or转化）</li>
<li>将数据集按2:1分割分别作为训练和测试集</li>
<li>流程：用训练数据训练出点击率预估模型和出价函数，根据测试数据特征，计算出一个出价，如果超过数据集中的真实出价，则认为竞价成功</li>
<li>根据真是数据集中的情况进行模型评估</li>
<li>为了对比，将预算分别设置为原始预算的1/64,1/32,1/16,1/8,1/4,1/2进行实验</li>
<li>对比策略：按固定值出价，随机出价，按最大eCPC出价，线性出价</li>
</ol>
<p>经过一系列的实验，文章得出了下面的结论：</p>
<ol>
<li><strong>非线性出价策略赢得的总点击量大，而且单次点击所产生的费用低</strong></li>
<li><strong>预算约束越严格的情况下，相比于线性出价策略，非线性出价策略对于点击量的提升越大</strong></li>
<li>预算越低，$\lambda$的最优解的值越大，出价相对也越低，但是对于低价值的展示机会，非线性出价策略的出价比线性出价策略的出价略高。如下图所示</li>
</ol>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59145d12c4aea.png" alt=""> </p>
<p>我们可以很直观的看出，我们所得到的出价策略是一个非线性的。横坐标θ代表了广告展示计划的品质，ORTB会对低价值的展示机会出高价，这样的结果能为我们带来什么，谁会去要那些低价值的展示机会呢？我们来看下面这张图</p>
<p><img src="https://ooo.0o0.ooo/2017/05/11/59145cfc4d8d4.png" alt=""> </p>
<p>在此图中，我们盯着一条曲线看，比如蓝色的(1/32)。随着λ增加，收获的点击量是增加的，意味着λ越高，我们的收益越高。对于我们获得的出价策略而言，λ越高，我们的出价是越低的，也就意味着这次展示机会的价值是很低的。这样的结果值得我们深思，我们以为低价值的展示机会是不值钱的，但数据说明，这些看似不值钱的展示所能带来的回报还算不错。特别地，在λ=1e-05时三条曲线的几乎重合，而红色代表有钱的广告主，蓝色代表穷广告主，虽然预算差了16倍，但是获得的收益是相同的，这个结论对于预算有限的小广告主而言，是个天大的好消息：虽然我们钱不多，但只要我们出价合适，依然可以收获很好的广告效果，四两拨千斤，极大的调动了小广告主参加程序化交易的积极性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a></p>
]]></content>
      
        <categories>
            
            <category> RTB </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】169. Majority Element]]></title>
      <url>/2017/04/10/%E3%80%90leetcode%E3%80%91169-Majority-Element/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code>times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个数组长度为n，其中有一个元素出现的次数大于<code>⌊ n/2 ⌋</code>，现在我们要找出这个元素</p>
<h2 id="moore-voting算法"><a href="#moore-voting算法" class="headerlink" title="moore-voting算法"></a>moore-voting算法</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>找出一对不同的元素就去掉它们，最后剩下的一定是所找的元素。</p>
<p>需要<strong>两个指针</strong>和<strong>一个计数器</strong>，其中一个指针指向当前出现次数最大的元素，另一个向后遍历，count存储当前出现次数最大的元素出现的次数</p>
<ol>
<li>当用于遍历的指针2指向元素和指针1指向的元素相等时，count加1，否则减1</li>
<li>当count减至0的时候，指针1需要向后移动到指针2的位置，指针2继续向后遍历</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    int len = nums.size();</div><div class="line">    int result = 0;</div><div class="line">    int count = 1;</div><div class="line">    int temp = 0;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        if (count != 0) &#123;</div><div class="line">            if (nums[i] == nums[temp])</div><div class="line">                count++;</div><div class="line">            else</div><div class="line">                count--;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            temp = i;</div><div class="line">            count = 1;</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">    return nums[temp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb46e839db1.png" alt=""> </p>
<h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h3><p>把数字都转化为二进制处理。如果majority element第i位上的数字是1，那么所有数字第i位上为1的总个数一定会大于<code>⌊ n/2 ⌋</code>,反之，如果majority element第i位上的数字是0，那么所有数字第i位上为0的总个数一定会大于<code>⌊ n/2 ⌋</code></p>
<p>所以，如果我们统计所有的n个数字的第i位上1(或者0)的个数，看是否大于<code>⌊ n/2 ⌋</code>，就可以确定majority element第i位到底是0还是1了</p>
<p>int型数据一共有32bit，所有需要计算32个二进制位。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i,j,count,major=0;</div><div class="line">        for(i=0;i&lt;32;i++)</div><div class="line">        &#123;</div><div class="line">            for(j=0,count=0;j&lt;nums.size();j++)</div><div class="line">            &#123;</div><div class="line">                if((nums[j]&gt;&gt;i&amp;1)==1)</div><div class="line">                    count++;</div><div class="line">            &#125;</div><div class="line">            if(count&gt;nums.size()/2)</div><div class="line">                major+=(1&lt;&lt;i);</div><div class="line">        &#125;</div><div class="line">        return major;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb4bc45530f.png" alt=""> </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在用bit manipulation方法时，在已经确定了定majority element第i位到底是0还是1之后恢复majority element的时候，遇到了一个问题，查了很久，在这里总结一下</p>
<p>一开始我用了下面这样的方法恢复majority element</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (int i = 0; i &lt; 32; i++) &#123;</div><div class="line">    if (countones[i] &gt; len / 2)</div><div class="line">        result += pow(2, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是我们平时手算二进制转化成10进制的方法，但是发现遇到负数的时候就不能正确恢复了==</p>
<p>然后就查啊查，发现：</p>
<p><strong>int类型默认是signed的</strong>，也就是说带符号的，32bit中<strong>最高的那一位是用来表示符号的，最高位是0表示非负数，最高位是1表示负数</strong>，所以能够表示的整数的范围是$-2^{31}-1$~$2^{31}-1$。关于负数的二进制表示，之前写过一篇博客 <a href="https://siyaozhang.github.io/2017/04/04/c-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9C-%E2%80%9D/" target="_blank" rel="external">负数的二进制表示</a>，可以看出来确实负数的二进制表示最高位是1</p>
<p>所以用上面的方法<strong>不断叠加</strong>$2^i$（<strong>正数</strong>）是<strong>永远都不会恢复到原来的负数</strong>的，因为最高位永远都不会由0变为1，而且$2^{31}$已经超过int型的表示范围了。</p>
<p>因此，还是要<strong>用bit运算根据各个位是0还是1来恢复出原来的majority element</strong>，这样无论是正是负就都不会出错了。</p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017练习赛B. 斐波那契数列 矩阵快速幂]]></title>
      <url>/2017/04/08/%E5%8C%97%E9%82%AEACM2017%E7%BB%83%E4%B9%A0%E8%B5%9BB-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/08/58e8ff74c74b3.png" alt=""> </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>矩阵快速幂<br>快速幂</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int mod = 10000;</div><div class="line">const int N = 2;//矩阵的维数,角标从0开始</div><div class="line">struct Matrix</div><div class="line">&#123;</div><div class="line">    long long v[N][N];</div><div class="line">    Matrix()</div><div class="line">    &#123;</div><div class="line">        memset(v,0,sizeof(v));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//矩阵的乘法p1*p2</div><div class="line">Matrix multi(Matrix p1,Matrix p2)</div><div class="line">&#123;</div><div class="line">    Matrix res;</div><div class="line">    for(int i=0;i&lt;N;i++)</div><div class="line">        for(int j=0;j&lt;N;j++)</div><div class="line">            if(p1.v[i][j])//代码优化，是0的话就不用计算</div><div class="line">                for(int k=0;k&lt;N;k++)</div><div class="line">                    res.v[i][k]=(res.v[i][k]+(p1.v[i][j]*p2.v[j][k]))%mod;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">//矩阵的快速幂p^k</div><div class="line">Matrix pow(Matrix p,long long k)</div><div class="line">&#123;</div><div class="line">    Matrix t;</div><div class="line">    for(int i=0;i&lt;N;i++)//初始化为单位矩阵</div><div class="line">        t.v[i][i]=1;</div><div class="line">    while(k)</div><div class="line">    &#123;</div><div class="line">        if(k&amp;1)</div><div class="line">            t=multi(t,p);</div><div class="line">        p=multi(p,p);</div><div class="line">        k=k&gt;&gt;1;</div><div class="line">    &#125;</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    long long n;</div><div class="line">    Matrix e,ans;</div><div class="line">    e.v[0][0]=e.v[0][1]=e.v[1][0]=1;</div><div class="line">    e.v[1][1]=0;</div><div class="line">    while(scanf(&quot;%I64dd&quot;,&amp;n)!=EOF&amp;&amp;n!=-1)</div><div class="line">    &#123;</div><div class="line">        ans = pow(e,n);</div><div class="line">        printf(&quot;%I64d\n&quot;,ans.v[0][1]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017练习赛A. Email Adress]]></title>
      <url>/2017/04/08/%E5%8C%97%E9%82%AEACM2017%E7%BB%83%E4%B9%A0%E8%B5%9BA-Email-Adress/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>大概就是给一串字符，表示email地址，其中<code>@</code>用at表示，<code>.</code>用dot表示，当然了字母串里可能本来就有at和dot。<br>所以要想将给定的字符串恢复成尽可能短的email地址需要注意下面几条：</p>
<ol>
<li>只能含有一个<code>@</code>，且不能在开头处，即除开头外遇到的第一个at转化成<code>@</code>，其余还是at</li>
<li>除开头和结尾的dot不能转化成<code>.</code>以外其余的全部转化成<code>.</code></li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">char arrin[10000];</div><div class="line">FILE *fin;</div><div class="line">int main()&#123;</div><div class="line">    fin=fopen(&quot;in.txt&quot;,&quot;r&quot;);</div><div class="line">    char ch;</div><div class="line">    while(~fscanf(fin,&quot;%c&quot;,&amp;ch))&#123;</div><div class="line">        int i =1;</div><div class="line">        bool atflag = false;</div><div class="line">        memset(arrin,0,10000);</div><div class="line">        //存入字符串 </div><div class="line">        arrin[0]=ch;</div><div class="line">        while(fscanf(fin,&quot;%c&quot;,&amp;ch) &amp;&amp; ch!=&apos;\n&apos;)&#123;</div><div class="line">            arrin[i]=ch;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        //arrin[i]=-1;</div><div class="line">        //计算输出</div><div class="line">        printf(&quot;%c&quot;,arrin[0]);</div><div class="line">        for(int j =1;j &lt; i;j++)&#123;</div><div class="line">            if(arrin[j] == &apos;a&apos; &amp;&amp; arrin[j+1] == &apos;t&apos; &amp;&amp; atflag == false)&#123;//第一次遇到at </div><div class="line">                printf(&quot;%c&quot;,&apos;@&apos;);</div><div class="line">                atflag = true;</div><div class="line">                j+=1;</div><div class="line">            &#125;</div><div class="line">            else if(arrin[j] == &apos;d&apos; &amp;&amp; arrin[j+1] == &apos;o&apos; &amp;&amp; arrin[j+2] == &apos;t&apos; &amp;&amp; arrin[j+3] != &apos;\0&apos;)&#123;//dot不在结尾的情况 </div><div class="line">                printf(&quot;%c&quot;,&apos;.&apos;);</div><div class="line">                j+=2;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                printf(&quot;%c&quot;,arrin[j]);</div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">        printf(&quot;\n&quot;);   </div><div class="line">    &#125; </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017网预 Square Coins-动态规划]]></title>
      <url>/2017/04/05/%E5%8C%97%E9%82%AEACM2017%E7%BD%91%E9%A2%84-Square-Coins-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Artoria, also known as Saber-chan, was born into a time of chaos and war that began with the demise of the Roman empire. Somewhere in the far east, people in Utopia know nothing about war or conflicts. They live in peace for quite a long time and developed a strange currency system. In particular, they use square coins. Not only have they square shapes but also their values are square integers. Coins with values of all square numbers up to 289 (=172), i.e., 1-credit coins, 4-credit coins, 9-credit coins, …, and 289-credit coins, are available in Utopia.</p>
<p>According to the Utopia currency system, there are four combinations of coins to pay ten credits:</p>
<p>ten 1-credit coins,<br>one 4-credit coin and six 1-credit coins,<br>two 4-credit coins and two 1-credit coins, and<br>one 9-credit coin and one 1-credit coin.</p>
<p>Your mission is to count the number of ways to pay a given amount using coins of Utopia. The answer may be very big, please output the answer module 1000000009.</p>
<p><strong>input</strong></p>
<p>The input begins with a line containing a single integer T(1≤T≤2000), indicating the number of test cases. Each of the next T lines each containing an integer meaning an amount to be paid. You may assume that all the amounts are positive and less than 2000. </p>
<p><strong>output</strong></p>
<p>For each of the given amount, output one line containing a single integer representing the number of combinations of coins module 1000000009. No other characters should appear in the output.</p>
<p><strong>sample</strong><br>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2</div><div class="line">10</div><div class="line">30</div></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4</div><div class="line">27</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一共有17种面值的硬币，个数不限，给定一个数值n，给出有多少种组合方式</p>
<p>利用<strong>动态规划</strong>的思想，可以预先计算好组成n的组合方式</p>
<p><strong>dp[i+coin[j]] = dp[i+coin[j]]+dp[i]</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">int dp[2005];</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; result;</div><div class="line">    memset(dp, 0, 2005);</div><div class="line">    dp[0] = 1;</div><div class="line">    for (int i = 1; i &lt;= 17; i++) &#123;</div><div class="line">        for (int j = 0; j &lt; 2005; j++) &#123;</div><div class="line">            dp[j + i*i] = (dp[j + i*i] + dp[j])% 1000000009;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int N;</div><div class="line">    scanf(&quot;%d&quot;, &amp;N);</div><div class="line">    while (N) &#123;</div><div class="line">        int n;</div><div class="line">        scanf(&quot;%d&quot;, &amp;n);</div><div class="line">        printf(&quot;%d\n&quot;,dp[n]);</div><div class="line">        N--;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[增强学习]]></title>
      <url>/2017/04/04/%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>增强学习</p>
<p>机器学习中的一个领域，关注智能体如何基于环境而采取一系列的行动，以取得最大化的预期利益或回报</p>
<p>特点</p>
<p>试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。</p>
<p>延迟回报，增强学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</p>
<p>例子</p>
<p>比如下象棋，每一步都是一个决策过程，但决策的结果事后才知道<br>再比如机器人的行走，移动过程中不知道如何挪动<br>一种可行的思路是设计一个回报函数，每执行一步决策后，向agent进行汇报，比如四足机器人，如果他向前走了一步（接近目标），那么回报函数为正，后退为负。这样，我们对每一步进行评价，得到相应的回报函数，我们只需要找到一条回报值最大的路径（每步的回报之和最大），就认为是最佳的路径。</p>
]]></content>
      
        <categories>
            
            <category> deep learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[word2vec（文本深度表示模型）]]></title>
      <url>/2017/04/04/word2vec%EF%BC%88%E6%96%87%E6%9C%AC%E6%B7%B1%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>简介</p>
<p>Word2vec 是 Google 在 2013 年年中开源的一款将词表征为实数值向量的高效工具, 其利用深度学习的思想，可以通过训练，把对文本内容的处理简化为 K 维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。Word2vec输出的词向量可以被用来做很多 NLP 相关的工作，比如聚类、找同义词、词性分析等等。如果换个思路， 把词当做特征，那么Word2vec就可以把特征映射到 K 维向量空间，可以为文本数据寻求更加深层次的特征表示 。</p>
<p>Word2vec 使用的是 Distributed representation 的词向量表示方式。Distributed representation 最早由 Hinton在 1986 年提出[4]。其基本思想是 通过训练将每个词映射成 K 维实数向量（K 一般为模型中的超参数），通过词之间的距离（比如 cosine 相似度、欧氏距离等）来判断它们之间的语义相似度.其采用一个 三层的神经网络 ，输入层-隐层-输出层。有个核心的技术是 根据词频用Huffman编码 ，使得所有词频相似的词隐藏层激活的内容基本一致，出现频率越高的词语，他们激活的隐藏层数目越少，这样有效的降低了计算的复杂度。而Word2vec大受欢迎的一个原因正是其高效性，Mikolov 在论文[2]中指出，一个优化的单机版本一天可训练上千亿词。</p>
<p>这个三层神经网络本身是 对语言模型进行建模 ，但也同时 获得一种单词在向量空间上的表示 ，而这个副作用才是Word2vec的真正目标。</p>
<p>与潜在语义分析（Latent Semantic Index, LSI）、潜在狄立克雷分配（Latent Dirichlet Allocation，LDA）的经典过程相比，Word2vec利用了词的上下文，语义信息更加地丰富。</p>
<p>参考文献</p>
<p>有道技术沙龙-Deep Learning实战之word2vec</p>
<p>卷积和pooling</p>
<p>Deep Learning in NLP （一）词向量和语言模型</p>
]]></content>
      
        <categories>
            
            <category> deep learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017热身赛-A题]]></title>
      <url>/2017/04/04/%E5%8C%97%E9%82%AEACM2017-A%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/04/58e34e2ccb0cc.png" alt=""> </p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个列数字，求这列数字中的三元组$(a_i,a_j,a_k)$满足下面两个条件</p>
<ol>
<li>$a_i\leq a_j\leq a_k$</li>
<li>$a_i+a_j+a_k=0$<br>注意：<strong>重复的只算一次</strong></li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先排序</p>
<p>三个元素和为0，那么一定有两个元素大于等于0，一个小于0；或者两个小于等于0，一个大于0。总之<strong>不能三个元素都同号</strong></p>
<p>设三个指针，low从前往后扫描，high从后往前扫描，mid在这两个指针中间从前往后扫描：<br>先固定low指针，从前往后扫描，知道元素值&gt;=0时停止</p>
<ul>
<li>当三个指针指向的元素和为0时，记录下来。</li>
<li>当三个指针指向的元素和&gt;0时，high向前移动。</li>
<li>当三个指针指向的元素和&lt;0时，mid向后移动。</li>
</ul>
<p>需要注意的地方：</p>
<ol>
<li>同一个指针扫过的<strong>相等的元素只计算第一次</strong>，后面的要略过</li>
<li>元素值的平方已经超过int的最大位数，要用<strong>long long</strong>型</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line"> </div><div class="line">int main() &#123;</div><div class="line">    int arr[2005] = &#123; 0 &#125;;</div><div class="line">    char c;</div><div class="line">    vector&lt;int&gt; output;</div><div class="line">    int samplenum;</div><div class="line">    cin &gt;&gt; samplenum;</div><div class="line">    while (samplenum)</div><div class="line">    &#123;</div><div class="line">        long long result = 0;</div><div class="line">        int len;</div><div class="line">        cin &gt;&gt; len;</div><div class="line">        getchar();</div><div class="line">        int ii = 0;</div><div class="line">        //读入数据</div><div class="line">        while ((c = getchar()) != &apos;\n&apos;)</div><div class="line">        &#123;</div><div class="line">            if (c != &apos; &apos;)//把这句判断条件改动  </div><div class="line">            &#123;</div><div class="line">                ungetc(c, stdin);</div><div class="line">                cin &gt;&gt; arr[ii++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //排序</div><div class="line">        sort(arr, arr + len);</div><div class="line">        //low指针从前向后遍历</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (i &gt; 0 &amp;&amp; arr[i] == arr[i - 1]) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            int lo = i + 1;</div><div class="line">            int hi = len - 1;</div><div class="line">            while (lo &lt; hi) &#123;</div><div class="line">                if ((arr[i] + arr[lo] + arr[hi]) == 0) &#123;</div><div class="line">                    long long aa = (long long)arr[i] * arr[i];</div><div class="line">                    long long bb = (long long)arr[lo] * arr[lo];</div><div class="line">                    long long cc = (long long)arr[hi] * arr[hi];</div><div class="line">                    long long aaa = aa + bb + cc;</div><div class="line">                    result += aaa;</div><div class="line">                    //略过相同元素</div><div class="line">                    while (lo + 1 &lt;= hi &amp;&amp; arr[lo + 1] == arr[lo]) &#123;</div><div class="line">                        lo++;</div><div class="line">                    &#125;</div><div class="line">                    while (hi - 1 &gt;= lo &amp;&amp; arr[hi - 1] == arr[hi]) &#123;</div><div class="line">                        hi--;</div><div class="line">                    &#125;</div><div class="line">                    lo++;</div><div class="line">                    hi--;</div><div class="line">                &#125;</div><div class="line">                else if ((arr[i] + arr[lo] + arr[hi]) &gt; 0) &#123;</div><div class="line">                    hi--;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    lo++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        output.push_back(result % 1000000007);</div><div class="line">        samplenum--;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; output.size(); i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; output[i] &lt;&lt; endl;</div><div class="line">    &#125;   </div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮ACM2017热身赛-D题]]></title>
      <url>/2017/04/04/%E5%8C%97%E9%82%AEACM2017-D%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/04/58e35af64bb4e.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/04/58e35b082f8e5.png" alt=""> </p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个整数，将它分解成连续素数的和，求这样的分解方法数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先利用素数筛打出素数表</p>
<p>然后</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">vector&lt;int&gt; primes;</div><div class="line">bool is_prime[1000006];</div><div class="line"></div><div class="line">//建立素数表和存储素数的vector</div><div class="line">void init_primes()</div><div class="line">&#123;</div><div class="line">    memset(is_prime,true, 1000005);</div><div class="line">    is_prime[0] = is_prime[1] = false;</div><div class="line">    for (int i = 2; i &lt;= 1000005; ++i)&#123;</div><div class="line">        if (is_prime[i])&#123;</div><div class="line">            primes.push_back(i);</div><div class="line">            for (int j = 2; j*i &lt;= 1000005; j++)&#123;</div><div class="line">                is_prime[i*j] = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()&#123;</div><div class="line">    vector&lt;int&gt; output;</div><div class="line">    init_primes();</div><div class="line">    int primesnum = primes.size();</div><div class="line">    int n;</div><div class="line">    while (cin &gt;&gt; n)&#123;</div><div class="line">        //i是分解形式的首个素数，j是最后一个素数</div><div class="line">        int i = 0, j = 0, sum = 0, result = 0;</div><div class="line">        while(true)&#123;</div><div class="line">            while (sum &lt; n &amp;&amp; j &lt; primesnum)&#123;</div><div class="line">                sum += primes[j++];</div><div class="line">            &#125;</div><div class="line">            //加到最后一个素数了，和还是小于n，说明后面没有满足条件的分解方式了，跳出循环结束运算</div><div class="line">            if (sum &lt; n)&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if (sum == n)&#123;</div><div class="line">                ++result;</div><div class="line">            &#125;</div><div class="line">            //i向后移</div><div class="line">            sum -= primes[i++];</div><div class="line">        &#125;</div><div class="line">        output.push_back(result);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; output.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; output[i] &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[准确率、召回率、F1、ROC、AUC]]></title>
      <url>/2017/04/04/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81F1%E3%80%81ROC%E3%80%81AUC/</url>
      <content type="html"><![CDATA[<h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>对学习器的<strong>泛化性能</strong>进行评估<br>在预测任务中，给定样例集$D=\lbrace (x_1,y_1),(x_2,y_),…,(x_n,y_n)\rbrace$，其中$y_i$是$x_n$的真实标记,估计学习器的性能就是<strong>把预测的结果$f(x)$与实际值进行比较</strong></p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p><strong>回归</strong>任务中常用的是“<strong>均方误差</strong>”：</p>
<script type="math/tex; mode=display">E(f,D) = \frac{m}{1}\sum_{i=1}^{m}(f(x_i)-y_i)^2</script><p>下面介绍<strong>分类任务中常用的度量指标</strong></p>
<h3 id="1-错误率与精度"><a href="#1-错误率与精度" class="headerlink" title="1. 错误率与精度"></a>1. 错误率与精度</h3><p><strong>错误率</strong>就是分类错误的样本数占样本总数的比例</p>
<script type="math/tex; mode=display">E(f,D)=\frac{m}{1}\sum_{i=1}^{m}(f(x_i) \neq y_i)^2</script><p><strong>精度</strong>就是$1-E$</p>
<h3 id="2-准确率、召回率和F1"><a href="#2-准确率、召回率和F1" class="headerlink" title="2. 准确率、召回率和F1"></a>2. 准确率、召回率和F1</h3><p>错误率和精度不能满足所有任务的需求<br>比如在web搜索中，我们经常会关心，<strong>检索出来的信息有多少是用户关心</strong>的，或者用户<strong>真正关心的数据中有多少被检索出来</strong>了，所以引入<strong>“准确率”和“召回率”</strong></p>
<p>分类据结果的混淆矩阵为<br><img src="https://ooo.0o0.ooo/2017/04/01/58dfad37d9823.png" alt=""> </p>
<p><strong>准确率</strong>和<strong>召回率</strong>定义为：</p>
<script type="math/tex; mode=display">P=\frac{TP}{TP+FP}</script><script type="math/tex; mode=display">r=\frac{TP}{TP+FN}</script><p><strong>准确率和召回率是一组矛盾的度量</strong>，一般准确率高时，召回率往往偏低；召回率高时，准确率往往偏低<br>如何理解二者之间的矛盾呢，我们依然沿用上面的例子，如果我们想尽可能多地返回<strong>用户关心的信息</strong>，就可以返回大量的信息，此时用户关心的结果可能都被选上了，但是也返回了大量用户不关心的信息，准确率较低；反之，如果我们希望返回的信息中心用户关心的比例比较高，就可以只返回那些有把握的信息，但这样就会漏掉不少可能也是用户关心的信息，也就是召回率比较低。</p>
<p>下图为P-R曲线，可以直观的反映准确率和召回率之间的矛盾，评估模型时，可以根据曲线下方面积进行模型比较，面积大者效果比较好<br><img src="https://ooo.0o0.ooo/2017/04/01/58dfaf3b77185.png" alt=""> </p>
<p>在实际应用时中，我们可以<strong>结合实际情况，权衡两个指标的重要程度</strong>，因此引入$F_{\beta}$指标：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfad605dae8.png" alt=""> </p>
<p>$\beta&gt;1$时准去率相对更重要，$\beta&lt;1$召回率相对更重要。当$\beta=1$时，就是我们常用的F1度量形式</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfaeb332ca9.png" alt=""> </p>
<h3 id="3-ROC、AUC"><a href="#3-ROC、AUC" class="headerlink" title="3. ROC、AUC"></a>3. ROC、AUC</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p><strong>体现了“一般情况下”泛化性能的好坏</strong></p>
<p>很多机器学习器是为测试样本产生一个<strong>实值或概率预测</strong>，然后再设定一个<strong>阈值t</strong>，<strong>高于这个阈值就预测为正类</strong>，反之预测为负类。针对不同的任务，选取的阈值t也不一样，<strong>ROC体现了综合考虑学习器在不同任务下的“期望泛化能力”的好坏</strong></p>
<h4 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h4><p>先看看ROC曲线长什么样</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfb6ba0e55d.png" alt=""> </p>
<p>横轴：“<strong>假正例率（false positive rate）</strong>”——负样本预测成正类的比例</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfb64788070.png" alt=""> </p>
<p>纵轴：“<strong>真正例率（true positive rate）</strong>”——正样本预测成正类的比例</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfb6335754e.png" alt=""> </p>
<p>为了方便理解公式，再贴一下混淆矩阵</p>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfad37d9823.png" alt=""> </p>
<p>现在来解释一下ROC曲线：曲线上的每一点都是一个<strong>（TPR,FPR）点对</strong>，表示的是对于<strong>一个模型</strong>，<strong>选择一个阈值t作为分类的依据</strong>，得到的假正例率和真正例率构成的点对。</p>
<ul>
<li><p>(0,0)表示所有样本都预测成负类的情况</p>
</li>
<li><p>(1,1)表示所有样本都预测成正类的情况</p>
</li>
<li><p>(0,1)表示所有样本都预测正确的情况</p>
</li>
<li><p>虚线表示随机预测的情况</p>
</li>
</ul>
<h4 id="绘制ROC曲线"><a href="#绘制ROC曲线" class="headerlink" title="绘制ROC曲线"></a>绘制ROC曲线</h4><ul>
<li>给出20个测试样本</li>
<li>“class”为样本的真实属性</li>
<li>“score”是预测值，表示样本属于正样本的概率</li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfba441c81f.png" alt=""> </p>
<p><strong>步骤</strong>：</p>
<ul>
<li>从高到低依次选取“score”作为阈值，概率大于该阈值的预测成正类，反之预测成反类</li>
<li>每次选取一个不同的阈值会都会得到一个(FPR,TPR)点对，即ROC曲线上的一点。这样一来，我们一共得到了20组(FPR,TPR)点对，将它们画在ROC曲线的结果如下图：</li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/04/01/58dfbb4601c4f.png" alt=""> </p>
<ul>
<li>当我们将阈值设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。<strong>将这些(FPR,TPR)对连接起来，就得到了ROC曲线</strong>。</li>
<li>当<strong>阈值的取值越多，ROC曲线越平滑</strong>。</li>
</ul>
<h4 id="AUC（area-under-ROC-curve）"><a href="#AUC（area-under-ROC-curve）" class="headerlink" title="AUC（area under ROC curve）"></a>AUC（area under ROC curve）</h4><ul>
<li>AUC的值就是处<strong>于ROC曲线下方部分面积的大小</strong></li>
<li>通常，AUC的值介于0.5到1.0之间，<strong>越接近1表示模型的泛化能力越好</strong></li>
<li><strong>较大的AUC代表了较好的performance</strong></li>
</ul>
<h4 id="AUC的计算方法"><a href="#AUC的计算方法" class="headerlink" title="AUC的计算方法"></a>AUC的计算方法</h4><p>形式化地看，AUC考虑的是<strong>样本预测的排序质量</strong>，也就是在M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score（正样本排在负样本前面）</p>
<ol>
<li>从误差方面入手，即由模型计算出来的分数，负样本比正样本高的概率。如果给定$m_+$个正例和$m_-$个负例，令$D_+$和$D_-$分别表是正、负例集合，则排序“损失”定义为</li>
</ol>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e349099c736.png" alt=""><br>即考虑每一对正、反例对，如果正例的预测值小于反例，则记一个罚分，如果相等，记0.5个罚分。对应于RUC曲线上半部分的面积，那么RUC曲线下半部分的面积：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e3497b012a6.png" alt=""> </p>
<ol>
<li>第二种方法实际上和上述方法是一样的，但是复杂度减小了。</li>
</ol>
<ul>
<li>首先对score从大到小排序</li>
<li>然后令最大score对应的sample 的rank为n，第二大score对应sample的rank为n-1，以此类推</li>
<li>然后把所有的正类样本的rank相加，再减去正类样本的score为最小的那M个值的情况。</li>
<li>得到的就是所有的样本中有多少对正类样本的score大于负类样本的score。</li>
<li>然后再除以M×N。即</li>
</ul>
<script type="math/tex; mode=display">AUC=\frac{(所有的正例位置相加)-M*(M+1)}{M*N}</script><p>另外，特别需要注意的是，再存在score相等的情况时，对相等score的样本，需要 赋予相同的rank(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。具体操作就是再把所有这些score相等的样本 的rank取平均。然后再使用上述公式。</p>
<h3 id="为什么使用ROC"><a href="#为什么使用ROC" class="headerlink" title="为什么使用ROC"></a>为什么使用ROC</h3><p>既然已经这么多评价标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：<strong>当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变</strong>。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是ROC曲线和Precision-Recall曲线的对比： </p>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e342f8b9196.png" alt=""> </p>
<p>在上图中，(a)和(c)为ROC曲线，(b)和(d)为Precision-Recall曲线。(a)和(b)展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c)和(d)是将测试集中负样本的数量增加到原来的10倍后，分类器的结果。可以明显的看出，<strong>ROC曲线基本保持原貌</strong>，而Precision-Recall曲线则变化较大。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zybuluo.com/frank-shaw/note/152851" target="_blank" rel="external">评价分类器性能指标之AUC、ROC</a></p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯2017笔试——16进制]]></title>
      <url>/2017/04/04/%E8%85%BE%E8%AE%AF2017%E7%AC%94%E8%AF%95%E2%80%94%E2%80%9416%E8%BF%9B%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/03/58e262eeb3a6e.png" alt=""> </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>关键点：</p>
<p><strong>运算时都用10进制运算</strong></p>
<ol>
<li><p><strong>16进制的输出</strong>，用cout&lt;&lt;hex&lt;&lt;“十进制表达”<br>c++可以表达十进制、八进制、十六进制，不能直接表达2进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;iostream&gt;  </div><div class="line">using namespace std;  </div><div class="line">void main()  </div><div class="line">&#123;  </div><div class="line">    int a,b,c;  </div><div class="line">    a=10; //十进制  </div><div class="line">    b=010;//八进制  </div><div class="line">    c=0x10; //十六进制  </div><div class="line">    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;c=&quot;&lt;&lt;c&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;a(八进制)=&quot;&lt;&lt;oct&lt;&lt;a&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;a(十六进制)=&quot;&lt;&lt;hex&lt;&lt;a&lt;&lt;endl;  </div><div class="line">    cout&lt;&lt;&quot;a(重新变回十进制)=&quot;&lt;&lt;dec&lt;&lt;a&lt;&lt;endl;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>前导0的补齐</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cout.fill(&apos;0&apos;);//设置填充字符</div><div class="line">cout.width(8);//设置宽度为8</div><div class="line">cout&lt;&lt;hex&lt;&lt;num;//输出16进制表示</div></pre></td></tr></table></figure>
</li>
<li><p><strong>空格、回车的输出条件</strong></p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&quot;stdafx.h&quot;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int atr[26];//26个字母对应的10进制数字</div><div class="line">char charr[16];//存储16个字母</div><div class="line">FILE *fin;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //26个字母的对应的10进制数字，97开始</div><div class="line">    for (int i = 0; i &lt; 26; i++) &#123;</div><div class="line">        atr[i] = 97 + i;</div><div class="line">    &#125;</div><div class="line">    fin = fopen(&quot;in.txt&quot;, &quot;r&quot;);</div><div class="line">    int i = 1;//记录偏移的次数</div><div class="line">    char ch;</div><div class="line">    int nums = 0;//记录读入的字母个数</div><div class="line">    while (fscanf(fin,&quot;%c&quot;, &amp;ch)!= EOF)</div><div class="line">    &#123;</div><div class="line">        charr[nums % 16] = ch;</div><div class="line">        if (nums % 16 == 0) &#123;//每格16个字母输出一次偏移量</div><div class="line">            cout.fill(&apos;0&apos;);//前面补0</div><div class="line">            cout.width(8);//补齐之后宽度为8</div><div class="line">            cout &lt;&lt;  hex&lt;&lt; 16 * i ;//hex为输出16进制表示</div><div class="line">            printf(&quot;  &quot;);//偏移量</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        //输出字母对应的十六进制数字表示</div><div class="line">        cout &lt;&lt;  hex &lt;&lt;atr[ch - &apos;a&apos;] &lt;&lt; &quot; &quot;;</div><div class="line">        if ((nums+1) % 8 == 0) &#123;</div><div class="line">            cout &lt;&lt; &quot; &quot;;//每隔8个多输出一个空格</div><div class="line">        &#125;</div><div class="line">        //输出16个字母构成的字母串</div><div class="line">        if ((nums + 1) % 16 == 0) &#123;</div><div class="line">            for (int j = 0; j &lt; 16; j++) &#123;</div><div class="line">                cout &lt;&lt; charr[j];</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt;endl;//输出回车</div><div class="line">        &#125;</div><div class="line">        nums++;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯2017笔试——二叉排序树]]></title>
      <url>/2017/04/04/%E8%85%BE%E8%AE%AF2017%E7%AC%94%E8%AF%95%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/03/58e250806556e.png" alt=""> </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>对于二叉排序树的任何一个节点，其<strong>左子树的元素都小于右子树的元素</strong></li>
<li><strong>满二叉排序树树</strong>，树的结构可以确定</li>
</ul>
<p>如果树的深度是$k$，满二叉树有$2^k-1$个元素，按从小到大的顺序排列为：$[a_1,a_2,…,a_{2^k-1}]$，则该满二叉树的结构如下：</p>
<ol>
<li>根节点的元素为$a_{\frac{2^k}{2}}$，$[a_1,a_2,…,a_{\frac{2^k}{2}-1}]$中的元素在根节点的左子树中，$[a_{\frac{2^k}{2}+1},…,a_{2^k-1}]$中的元素在根节点的右子树中</li>
<li>对左子树、右子树两个区间再分别做1中的操作，得到最终的二叉排序树</li>
</ol>
<p>给定三个节点，根据二叉排序树的性质，可以知道<strong>包含这三个节点的最小子树的根节点的值，一定在这三个节点值构成的区间$[min,max]$内</strong></p>
<p><img src="https://ooo.0o0.ooo/2017/04/03/58e260ca6dcb7.png" alt=""> </p>
<p>所以我们可以从上至下遍历二叉排序树</p>
<ol>
<li>如果根节点root值包含在三个节点值构成的最大区间内，则根节root点就是所求</li>
<li>如果根节点值小于min，则令右子树的根节点为root</li>
<li>如果根节点值大于min，则对左子树的根节点为root</li>
</ol>
<p>重复上述操作，直到找到一个节点值为$t$，$t\in[min,max]$，该节点即为所求</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&quot;stdafx.h&quot;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">FILE *fin;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    fin = fopen(&quot;in.txt&quot;, &quot;r&quot;);</div><div class="line">    int k ,a,b,c;</div><div class="line">    int max, min;</div><div class="line">    fscanf(fin,&quot;%d&quot;, &amp;k);</div><div class="line">    fscanf(fin, &quot;%d&quot;, &amp;a);</div><div class="line">    fscanf(fin, &quot;%d&quot;, &amp;b);</div><div class="line">    fscanf(fin, &quot;%d&quot;, &amp;c);</div><div class="line">    //求三个节点值最大的max和最小的min</div><div class="line">    if (a &gt; b&amp;&amp;a &gt; c) &#123;</div><div class="line">        max = a;</div><div class="line">        if (b &gt; c) &#123;</div><div class="line">            min = c;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            min = b;</div><div class="line">    &#125;</div><div class="line">    if (b &gt; c&amp;&amp;b &gt; a) &#123;</div><div class="line">        max = b;</div><div class="line">        if (a &gt; c) &#123;</div><div class="line">            min = c;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            min = a;</div><div class="line">    &#125;</div><div class="line">    if (c &gt; b&amp;&amp;c &gt; a) &#123;</div><div class="line">        max = c;</div><div class="line">        if (b &gt; a) &#123;</div><div class="line">            min = a;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            min = b;</div><div class="line">    &#125;</div><div class="line">    //搜索</div><div class="line">    int low = 0;</div><div class="line">    int high = pow(2, k);</div><div class="line">    while (true) &#123;</div><div class="line">        int root = (low+high) / 2;</div><div class="line">        if ((max - root)*(min - root) &lt; 0)&#123;</div><div class="line">            cout &lt;&lt; root;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            if (max &lt; root) &#123;</div><div class="line">                high = root;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                low = root;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> binary tree </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++ 取反运算符“~”]]></title>
      <url>/2017/04/04/c-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9C-%E2%80%9D/</url>
      <content type="html"><![CDATA[<h2 id="取反符"><a href="#取反符" class="headerlink" title="取反符"></a>取反符</h2><p>将<strong>二进制表示</strong>的数字中的<strong>0变为1, 1变为0</strong></p>
<p>但是需要注意的是c++中对int型进行取反操作时，将前面的<strong>前导0也进行了取反</strong>(int型变量为32bit)。</p>
<p>比如1的二进制表示是</p>
<p><strong>00000000 00000000 00000000 00000001</strong></p>
<p><strong>~(00000000 00000000 00000000 00000001) = 11111111 11111111 11111111 11111110</strong></p>
<h2 id="负数的二进制表示"><a href="#负数的二进制表示" class="headerlink" title="负数的二进制表示"></a>负数的二进制表示</h2><p><strong>负数的二进制表示 = 其绝对值的补码</strong></p>
<p><strong>原码</strong>：一个整数，按照绝对值大小转换成的<strong>二进制数</strong>，称为原码。</p>
<p>比如<strong>-3</strong>的原码是：</p>
<p><strong>00000000 00000000 00000000 00000011</strong></p>
<p><strong>反码</strong>：将二进制数<strong>按位取反</strong>，所得的新二进制数称为原二进制数的反码。</p>
<p><strong>-3</strong>的反码是：</p>
<p><strong>11111111 11111111 11111111 11111100</strong></p>
<p><strong>补码</strong>：<strong>反码加1</strong>称为补码。也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。</p>
<p>那么<strong>-3的补码</strong>，也就是<strong>-3的二进制表示</strong>为：</p>
<p><strong>11111111 11111111 11111111 11111100 + 1<br>= 11111111 11111111 11111111 11111101</strong></p>
<p>同理，整数-1在计算机中的二进制表示为：</p>
<p>1、先取1的原码：00000000 00000000 00000000 00000001</p>
<p>2、得反码：     11111111 11111111 11111111 11111110</p>
<p>3、得补码：     11111111 11111111 11111111 11111111</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>只有<strong>~(-1) = 0</strong></p>
<p><strong>其他整型数取反都是非0的</strong></p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++ 中scanf（）函数返回值问题]]></title>
      <url>/2017/04/03/c-%E4%B8%ADscanf()%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>用c++做ACM的时候发现读入数据是一个很头疼的事情，用了各种cin、getline()，发现scanf()最方便，能够<strong>默认分割所有的空白字符</strong>(空格，回车和指标符都行)，然后只需要用外层的for循环来控制读入的个数和存储位置了<br>对于异常情况的处理，比如数据结束，数据格式错误等，就需要我们了解scanf()函数的返回值了</p>
<ol>
<li>首先scanf()函数有返回值且<strong>返回值是int型</strong></li>
<li><p>当scanf()函数按照指定格式正确接收变量时，返回<strong>正确接收变量的个数</strong></p>
</li>
<li><p>当scanf()函数<strong>没有接收到指定格式的变量时，返回值为0</strong></p>
</li>
<li>遇到错误或遇到<strong>end of file</strong>，返回值为<strong>EOF（-1）</strong></li>
</ol>
<p>比如：<br><strong>scanf(“%d%d”, &amp;x, &amp;y);</strong></p>
<ul>
<li>如果x和y都被成功读入，那么scanf的返回值就是2;</li>
<li>如果只有x被成功读入，返回值为1;</li>
<li>如果x和y都未被成功读入，返回值为0;</li>
<li>如果遇到错误或遇到end of file，返回值为EOF（-1）</li>
</ul>
<p>接下来看看结合实际的数据输入格式，到底怎么用</p>
<p><img src="https://ooo.0o0.ooo/2017/04/03/58e20d09f1252.png" alt=""> </p>
<p>现在要将形如上面的数据读入</p>
<ul>
<li>每组数据有两行</li>
<li>第一行的第一个数字告诉我们第二行会有多少个元素</li>
<li>读到输入结束为止</li>
</ul>
<p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#define MAX 1000</div><div class="line">FILE *fin;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int arr[MAX];</div><div class="line">    fin = fopen(&quot;in.txt&quot;, &quot;r&quot;);</div><div class="line">    int n,T;</div><div class="line">    while (fscanf(fin,&quot;%d%d&quot;, &amp;n,&amp;T)!= EOF)</div><div class="line">    &#123;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            fscanf(fin,&quot;%d&quot;, &amp;arr[i]);</div><div class="line">        &#125;</div><div class="line">        //打印输出读入的数据</div><div class="line">        printf(&quot;%d %d\n&quot;, n, T);</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            printf(&quot;%d &quot;, arr[i]);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://ooo.0o0.ooo/2017/04/03/58e210cf2ef50.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[微软2017笔试2]]></title>
      <url>/2017/04/01/%E5%BE%AE%E8%BD%AF2017%E7%AC%94%E8%AF%952/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/01/58df730ed6544.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/01/58df731d63cde.png" alt=""> </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int N = 105;</div><div class="line">int n, m, k;</div><div class="line">int w[N][N];//距离矩阵</div><div class="line">int deep[N];//每层节点数</div><div class="line">int L[N];//叶子节点序号，从小到大，也是距离矩阵的表头</div><div class="line">int vis[N];</div><div class="line">int locfa[N];</div><div class="line">int mp[N][N];//节点标号矩阵</div><div class="line">int fa[N];//父亲节点</div><div class="line">int fur[N], dfur[N];</div><div class="line">bool Check(int x, int y)</div><div class="line">&#123;</div><div class="line">    if (x == y)return true;</div><div class="line">    return w[fur[x]][fur[y]] == 2 + dfur[x] + dfur[y];</div><div class="line">&#125;</div><div class="line">void Solve()</div><div class="line">&#123;</div><div class="line">    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))</div><div class="line">    &#123;</div><div class="line">        memset(w, -1, sizeof(w));</div><div class="line">        memset(vis, 0, sizeof(vis));</div><div class="line">        //存入每层节点数</div><div class="line">        for (int i = 1; i &lt;= m; i++)</div><div class="line">            scanf(&quot;%d&quot;, deep + i);</div><div class="line">        //读入每层节点标号</div><div class="line">        for (int i = 1; i &lt;= m; i++)</div><div class="line">            for (int j = 1; j &lt;= deep[i]; j++)</div><div class="line">                scanf(&quot;%d&quot;, &amp;mp[i][j]);</div><div class="line">        for (int i = 1; i &lt;= k; i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%d&quot;, L + i);</div><div class="line">            fur[L[i]] = L[i];</div><div class="line">            dfur[L[i]] = 0;</div><div class="line">            vis[L[i]] = 1;</div><div class="line">        &#125;</div><div class="line">        //存入距离矩阵</div><div class="line">        for (int i = 1; i &lt;= k; i++)</div><div class="line">            for (int j = 1; j &lt;= k; j++)</div><div class="line">                scanf(&quot;%d&quot;, &amp;w[L[i]][L[j]]);</div><div class="line">        //每个节点的父亲设置为自己</div><div class="line">        for (int i = 1; i&lt;m; i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 1; j &lt;= deep[i]; j++)</div><div class="line">                if (!vis[mp[i][j]])</div><div class="line">                &#123;</div><div class="line">                    locfa[i] = j;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        for (int i = m; i&gt;1; i--)//i is now deep</div><div class="line">        &#123;</div><div class="line">            int st = 1, j = 1;</div><div class="line">            while (st &lt;= deep[i])</div><div class="line">            &#123;</div><div class="line">                while (j &lt;= deep[i])</div><div class="line">                &#123;</div><div class="line">                    if (Check(mp[i][st], mp[i][j]))</div><div class="line">                    &#123;</div><div class="line">                        fa[mp[i][j]] = mp[i - 1][locfa[i - 1]];</div><div class="line">                        j++;</div><div class="line">                    &#125;</div><div class="line">                    else break;</div><div class="line">                &#125;</div><div class="line">                fur[mp[i - 1][locfa[i - 1]]] = fur[mp[i][st]];</div><div class="line">                dfur[mp[i - 1][locfa[i - 1]]] = dfur[mp[i][st]] + 1;</div><div class="line">                st = j, locfa[i - 1]++;</div><div class="line">                while (vis[mp[i - 1][locfa[i - 1]]] == 1)locfa[i - 1]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for (int i = 1; i &lt;= n; i++)</div><div class="line">            printf(&quot;%d%c&quot;, fa[i], i == n ? &apos;\n&apos; : &apos; &apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</div><div class="line">    Solve();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先记下来吧，大神的代码，没看太懂==</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】344. Reverse String]]></title>
      <url>/2017/03/30/%E3%80%90leetcode%E3%80%91344-Reverse-String/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given s = &quot;hello&quot;, return &quot;olleh&quot;.</div></pre></td></tr></table></figure>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>字符串翻转</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>反向遍历，输入到另一个string中，复杂度$O(n)$</li>
<li>看了tag中有two pointers,一个从前往后一个从后往前，交换数值，复杂度减少一半$O(n/2)$</li>
</ol>
<p><strong>算法复杂度：O(n)</strong></p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//反向遍历输入另一个string</div><div class="line">public:</div><div class="line">    string reverseString(string s) &#123;</div><div class="line">        string result = &quot;&quot;;</div><div class="line">        int len = s.size();</div><div class="line">        for (int i = len - 1; i &gt;= 0; i--) &#123;</div><div class="line">            result += s[i];</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//two pointer</div><div class="line">public:</div><div class="line">    string reverseString(string s) &#123;</div><div class="line">         for(auto iter = 0; iter &lt; s.size() / 2; ++iter)</div><div class="line">            swap(s[iter], s[s.size() - 1 - iter]);</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/14/58c7f3bcc560d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[北邮acm2017热身赛 Saber's Conjecture 素数筛]]></title>
      <url>/2017/03/29/ACM-Saber-s-Conjecture-%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>In a parallel universe, young Saber-chan does not have a humongous appetite, instead, she likes studying math in her spare time. This afternoon when Saber-chan is plunged in her study, she came across an interesting conjecture: for any even number n greater than or equal to 4, there exists at least one pair of prime numbers p1 and p2 such that n=p1+p2.</p>
<p>This conjecture is actually known as the Goldbach’s conjecture. It is has not been proved nor refused yet. However in this universe, there are more programmers than mathematicians, people tend to prove math findings by programs. As the King of Knights and King of Britain, Saber-chan orders you to write a program that reports the number of all the pairs of prime numbers satisfying the condition in the conjecture for a given even number.</p>
<p>A sequence of even numbers is given as input. Corresponding to each number, the program should output the number of pairs mentioned above. Notice that Saber-chan is interested in the number of essentially different pairs and therefore you should not count (p1,p2) and (p2,p1) separately as two different pairs.</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>An integer is given in each input line. You may assume that each integer is even, and is greater than or equal to 4 and less than 215. The end of the input is indicated by a number 0.</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>Each output line should contain an integer number. No other characters should appear in the output.</p>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p><strong>input:</strong></p>
<p>6</p>
<p>10</p>
<p>12</p>
<p>0</p>
<p><strong>output:</strong></p>
<p>1</p>
<p>2</p>
<p>1</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个数$p$，$p=q_1+q_2$其中$q_1$和$q_2$都是素数，输出这样的$(q_1,q_2)$对数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>step1：<br>利用素数筛，先枚举出一定范围内的素数</p>
<p>step2：<br>给定一个数p，遍历(2，p/2)中的素数t，如果p-t也是素数，则结果+1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">//bool f[1024*32];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //素数表</div><div class="line">    bool sushu[1024 * 32 + 1];</div><div class="line">    int n = 1024 * 32;</div><div class="line">    for (int i = 0; i &lt;= n; i++)</div><div class="line">        sushu[i] = true;</div><div class="line">    sushu[1] = false;</div><div class="line">    for (int i = 2; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        if (sushu[i] == true)</div><div class="line">        &#123;</div><div class="line">            for (int j = 2; j*i &lt;= n; j++)</div><div class="line">                sushu[i*j] = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;int&gt; result;</div><div class="line">    while(cin)&#123;</div><div class="line">        int aaa;</div><div class="line">        cin &gt;&gt; aaa;</div><div class="line">        if (aaa ==0)</div><div class="line">        &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        int sum = 0;</div><div class="line">        for (int i = 2; i &lt;= aaa / 2; i++) &#123;</div><div class="line">            if (sushu[i] == 1) &#123;</div><div class="line">                if (sushu[aaa - i] == 1) &#123;</div><div class="line">                    sum++;</div><div class="line">                &#125;</div><div class="line">            &#125;   </div><div class="line">        &#125;</div><div class="line">        result.push_back(sum);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; result.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; result[i] &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><p>关于一定范围内素数的枚举，有下面两种素数筛的方法</p>
<h3 id="1-普通筛选法—埃拉托斯特尼筛法"><a href="#1-普通筛选法—埃拉托斯特尼筛法" class="headerlink" title="1. 普通筛选法—埃拉托斯特尼筛法"></a>1. 普通筛选法—埃拉托斯特尼筛法</h3><p><strong>基本思想</strong>：素数的倍数一定不是素数</p>
<p><strong>步骤</strong>:</p>
<p>用一个长度为N+1的数组保存信息（0表示素数，1表示非素数），初始值都置为0（都默认为素数）</p>
<ol>
<li>从第一个素数2开始遍历，把2的倍数都标记为非素数（置为1）</li>
<li>然后向后遍历，找到2后面的下一个素数3，把3的倍数都标记为非素数（置为1）</li>
<li>继续向后遍历，找到素数k，对k进行同样的处理</li>
<li>直到最后，数组中依然为0的数即为素数。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bool sushu[1024 * 32 + 1];</div><div class="line">    int n = 1024 * 32;</div><div class="line">    for (int i = 0; i &lt;= n; i++)</div><div class="line">        sushu[i] = true;</div><div class="line">    sushu[1] = false;</div><div class="line">    for (int i = 2; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        if (sushu[i] == true)</div><div class="line">        &#123;</div><div class="line">            for (int j = 2; j*i &lt;= n; j++)</div><div class="line">                sushu[i*j] = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(nlogn)$</p>
<h3 id="2-线性筛法—欧拉筛法"><a href="#2-线性筛法—欧拉筛法" class="headerlink" title="2. 线性筛法—欧拉筛法"></a>2. 线性筛法—欧拉筛法</h3><p><strong>基本思想</strong>：保证每个合数只会被它的<strong>最小质因数</strong>筛去，因此每个数只会被标记一次</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#define MAXN 100005</div><div class="line">#define MAXL 1299710</div><div class="line">int prime[MAXN];//最小质因数</div><div class="line">int check[MAXL];//是否为素数</div><div class="line"></div><div class="line">int tot = 0;</div><div class="line">memset(check, 0, sizeof(check));</div><div class="line">for (int i = 2; i &lt; MAXL; ++i)</div><div class="line">&#123;</div><div class="line">  if (!check[i])</div><div class="line">  &#123;</div><div class="line">    prime[tot++] = i;</div><div class="line">  &#125;</div><div class="line">  for (int j = 0; j &lt; tot; ++j)</div><div class="line">  &#123;</div><div class="line">    if (i * prime[j] &gt; MAXL)</div><div class="line">    &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">    check[i*prime[j]] = 1;</div><div class="line">    if (i % prime[j] == 0)</div><div class="line">    &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/grubbyskyer/p/3852421.html" target="_blank" rel="external">Grubbyskyer的博客——线性筛法求素数</a></p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[组合数求解]]></title>
      <url>/2017/03/29/%E7%BB%84%E5%90%88%E6%95%B0%E6%B1%82%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>转自<a href="https://www.oschina.net/code/snippet_203297_11313" target="_blank" rel="external">baoer1024的分享</a></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>暴力求解，C(n,m)=n<em>(n-1)</em>…*(n-m+1)/m!，n&lt;=15 </li>
<li>打表，C(n,m)=C(n-1,m-1)+C(n-1,m)，n&lt;=10,000 </li>
<li>质因数分解，C(n,m)=n!/(m!*(n-m)!)，C(n,m)=p1a1-b1-c1p2a2-b2-c2…pkak-bk-ck,n&lt;=10,000,000 </li>
<li>Lucas定理，将m,n化为p进制,有:C(n,m)=C(n0,m0)*C(n1,m1)…(mod p)，算一个不是很大的C(n,m)%p,p为素数，化为线性同余方程,用扩展的欧几里德定理求解，n在int范围内，修改一下可以满足long long范围内。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方案一：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=(n-m+<span class="number">1</span>); --i)</div><div class="line">        ans *= i;</div><div class="line">    <span class="keyword">while</span>(m)</div><div class="line">        ans /= m--;</div><div class="line">    <span class="keyword">return</span> ans % M;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>方案二：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</div><div class="line"><span class="keyword">int</span> C[MAXN+<span class="number">1</span>][MAXN+<span class="number">1</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=MAXN; ++i)</div><div class="line">    &#123;</div><div class="line">        C[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=MAXN; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=MAXN; ++j)</div><div class="line">        C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % M;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> C[n][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方案三：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//用筛法生成素数</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span>;</div><div class="line"><span class="keyword">bool</span> arr[MAXN+<span class="number">1</span>] = &#123;<span class="literal">false</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; produce_prim_number()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prim;</div><div class="line">    prim.push_back(<span class="number">2</span>);</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>; i*i&lt;=MAXN; i+=<span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!arr[i])</div><div class="line">        &#123;</div><div class="line">            prim.push_back(i);</div><div class="line">            <span class="keyword">for</span>(j=i*i; j&lt;=MAXN; j+=i)</div><div class="line">            arr[j] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;=MAXN)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!arr[i])</div><div class="line">        prim.push_back(i);</div><div class="line">        i+=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prim;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算n!中素因子p的指数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rec = p;</div><div class="line">    <span class="keyword">while</span>(x&gt;=rec)</div><div class="line">    &#123;</div><div class="line">        ans += x/rec;</div><div class="line">        rec *= p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算n的k次方对M取模，二分法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> M)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(k)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            ans = (ans * n) % M;</div><div class="line">        &#125;</div><div class="line">        n = (n * n) % M;</div><div class="line">        k &gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算C(n,m)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prim = produce_prim_number();</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prim.size() &amp;&amp; prim[i]&lt;=n; ++i)</div><div class="line">    &#123;</div><div class="line">        num = Cal(n, prim[i]) - Cal(m, prim[i]) - Cal(n-m, prim[i]);</div><div class="line">        ans = (ans * Pow(prim[i], num, M)) % M;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>方案四：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10007</span>;</div><div class="line"><span class="keyword">int</span> ff[M+<span class="number">5</span>];  <span class="comment">//打表，记录n!，避免重复计算</span></div><div class="line"> </div><div class="line"><span class="comment">//求最大公因数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//解线性同余方程，扩展欧几里德定理</span></div><div class="line"><span class="keyword">int</span> x,y;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Extended_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">       x=<span class="number">1</span>;</div><div class="line">       y=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">       Extended_gcd(b,a%b);</div><div class="line">       <span class="keyword">long</span> t=x;</div><div class="line">       x=y;</div><div class="line">       y=t-(a/b)*y;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//计算不大的C(n,m)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(b&gt;a)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    b=(ff[a-b]*ff[b])%M;</div><div class="line">    a=ff[a];</div><div class="line">    <span class="keyword">int</span> c=gcd(a,b);</div><div class="line">    a/=c;</div><div class="line">    b/=c;</div><div class="line">    Extended_gcd(b,M);</div><div class="line">    x=(x+M)%M;</div><div class="line">    x=(x*a)%M;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//Lucas定理</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="keyword">while</span>(m||n)</div><div class="line">    &#123;</div><div class="line">             a=n%M;</div><div class="line">        b=m%M;</div><div class="line">        n/=M;</div><div class="line">        m/=M;</div><div class="line">        ans=(ans*C(a,b))%M;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,m,n;</div><div class="line">    ff[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)  <span class="comment">//预计算n!</span></div><div class="line">    ff[i]=(ff[i<span class="number">-1</span>]*i)%M;</div><div class="line">     </div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,func(n,m));</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ1850 Code-动态规划]]></title>
      <url>/2017/03/29/POJ1850-Code-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Transmitting and memorizing information is a task that requires different coding systems for the best use of the available space. A well known system is that one where a number is associated to a character sequence. It is considered that the words are made only of small characters of the English alphabet a,b,c, …, z (26 characters). From all these words we consider only those whose letters are in lexigraphical order (each character is smaller than the next character). </p>
<p>The coding system works like this: </p>
<ul>
<li>The words are arranged in the increasing order of their length. </li>
<li>The words with the same length are arranged in lexicographical order (the order from the dictionary). </li>
<li>We codify these words by their numbering, starting with a, as follows: </li>
</ul>
<p>a - 1 </p>
<p>b - 2 </p>
<p>… </p>
<p>z - 26 </p>
<p>ab - 27 </p>
<p>… </p>
<p>az - 51 </p>
<p>bc - 52 </p>
<p>… </p>
<p>vwxyz - 83681 </p>
<p>… </p>
<p>Specify for a given word if it can be codified according to this coding system. For the affirmative case specify its code. </p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>The only line contains a word. There are some constraints: </p>
<ul>
<li>The word is maximum 10 letters length </li>
<li>The English alphabet has 26 characters. </li>
</ul>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>The output will contain the code of the given word, or 0 if the word can not be codified.</p>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p><strong>input</strong>: bf</p>
<p><strong>output</strong>: 55</p>
<h2 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h2><p>按照题目给出的例子，给出字母串表标号。</p>
<p>题目中给出的字母串中字母是“<strong>单调递增</strong>”的，也就是没有重复，后一个要大于前一个</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>所谓“标号”，就是某一个字母串<strong>前面的字母串个数+1</strong></p>
<p>问题转化为求字母串<strong>前面的字母串个数</strong></p>
<p>某一个字母串<strong>前面的字母串</strong>有三种情况:</p>
<ol>
<li><strong>长度小于</strong>该字母串</li>
<li>长度等于该字母串，<strong>首字母小于</strong>该字母串首字母</li>
<li>长度和首字母都与该字母串相等，但<strong>位置更靠前</strong></li>
</ol>
<p>因为后面的字母串对前面的字母串有<strong>包含</strong>的关系，所以考虑用<strong>动态规划</strong>来求解，那接下来的重点就是寻找状态转移方程了</p>
<p>用$dp[i][j]$表示长度为$i$首字母为$j$的字母串个数，那么$dp[i+1][j]=dp[i][j+1]+dp[i][j+2]+···+dp[i][‘z’-i]$</p>
<p>光看公式可能理解得不是很好，举个例子吧：<br>比如我们现在想求<strong>长度是5位</strong>，<strong>b打头</strong>的字母串的个数:</p>
<p>b _ _ _ _      ······$dp[5][b]$</p>
<p>那么考虑后面的四位，有下面的22种情况：</p>
<p>b ++c++ _ _ _  ······$dp[4][c]$</p>
<p>b ++d++ _ _ _  ······$dp[4][d]$</p>
<p>b ++e++ _ _ _  ······$dp[4][e]$</p>
<p>···</p>
<p>b ++w++ ++x++ ++y++ ++z++  ······$dp[4][w]$</p>
<p>把上面的22种情况相加，就可以得到长度为5，b打头的所有字母串个数$p[5][b]$</p>
<p>对于其中的$dp[4][j]$也应用上述的方法可以求解</p>
<p>有了上面的思路，就可以由最初的$dp[1][j]=1$逐步求出完整的$dp[i][j]$表了！</p>
<p>好开心是不是，下面算个题试试好不好用吧：</p>
<p>假如我们现在要求字母串“<strong>cefkq</strong>”的序号，也就是这个字母串前面有多少个。回头看那三种情况：</p>
<ol>
<li><strong>长度小于</strong>该字母串 —— 把所有的$dp[4][j]$，$dp[3][j]$，$dp[2][j]$，$dp[1][j]$加起来</li>
<li>长度等于该字母串，<strong>首字母小于</strong>该字母串首字母 —— $dp[5][a]$,$dp[5][b]$加起来</li>
<li>长度和首字母都与该字母串相等，但<strong>位置更靠前</strong> </li>
</ol>
<p>嗯，问题解决了一大部分了，现在就剩第三种情况了！！！！<br>再看一眼字母串“<strong>cefkq</strong>”</p>
<p>长度和首字母都相等，位置比它在前面，那就一位一位考虑呗</p>
<p>第二位是e，<br>c ++d++ _ _ _在它前面！所以又有$dp[4][d]$个在它前面的，加上！</p>
<p>第三位是f，ef中间没有其他字母了，继续往后看</p>
<p>第四位是k，fk中间还有g、h、i、j</p>
<p>c e ++g++ _ _  ······$dp[3][g]$</p>
<p>c e ++h++ _ _  ······$dp[3][h]$</p>
<p>c e ++i++ _ _  ······$dp[3][i]$</p>
<p>c e ++j++ _ _  ······$dp[3][j]$</p>
<p>统统加上！</p>
<p>······</p>
<p>再往后就跟前面一样了，不再赘述了</p>
<p>到这，问题解决了，上代码</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; str;</div><div class="line">    <span class="keyword">int</span> len = str.length();</div><div class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (len&gt;<span class="number">10</span>)&#123;</div><div class="line">        result= <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((str[<span class="number">0</span>]-<span class="string">'a'</span>)&lt;<span class="number">0</span> || (str[<span class="number">0</span>] - <span class="string">'a'</span>)&gt;<span class="number">25</span>)&#123;</div><div class="line">        result= <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化dp表</span></div><div class="line">    <span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>-i; j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; <span class="number">27</span>-i; k++) &#123;</div><div class="line">                dp[i][j] += dp[i<span class="number">-1</span>][k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//dp表每一行总数，也就是长度为k的字母串总数</span></div><div class="line">    <span class="keyword">int</span> sum[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span> - i; j++) &#123;</div><div class="line">            sum[i] += dp[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> temp = len<span class="number">-2</span>;</div><div class="line">    <span class="comment">//位数小于n的数的个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;</div><div class="line">        result += sum[i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//位数=n但首字母比n首字母小的个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str[<span class="number">0</span>]-<span class="string">'a'</span>; i++) &#123;</div><div class="line">        result += dp[len<span class="number">-1</span>][i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//位数=n但中间字母比n小的个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">int</span> left = str[i<span class="number">-1</span>] - <span class="string">'a'</span>;</div><div class="line">        <span class="keyword">int</span> now = str[i] - <span class="string">'a'</span>;</div><div class="line">        <span class="keyword">if</span> (now&lt;<span class="number">0</span>|| now&gt;<span class="number">25</span>)&#123;</div><div class="line">            result =  <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (now &lt;= left)&#123;</div><div class="line">            result = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left+<span class="number">1</span>; j &lt; now; j++)&#123;</div><div class="line">            result += dp[temp][j];</div><div class="line">        &#125;</div><div class="line">        temp--;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; result;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2017/03/22/test/</url>
      <content type="html"><![CDATA[<p><code>count.py</code></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = a &amp; b;<span class="comment">//进位位置</span></div><div class="line">    <span class="keyword">int</span> result = a^b;</div><div class="line">    <span class="keyword">while</span> (c)</div><div class="line">    &#123;</div><div class="line">        c = c &lt;&lt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> t = c;</div><div class="line">        c = result &amp; c;</div><div class="line">        result = result ^ t;</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">   public:</div><div class="line">       int getSum(int a, int b) &#123;</div><div class="line">       int c = a &amp; b;//进位位置</div><div class="line">       int result = a^b;</div><div class="line">       while (c)</div><div class="line">       &#123;</div><div class="line">           c = c &lt;&lt; 1;</div><div class="line">           int t = c;</div><div class="line">           c = result &amp; c;</div><div class="line">           result = result ^ t;</div><div class="line">       &#125;</div><div class="line">           return result;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo下Markdown与MathJax冲突问题]]></title>
      <url>/2017/03/22/Hexo%E4%B8%8BMarkdown%E4%B8%8EMathJax%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>用markdown写博客，mathjax解析数学公式，二者对于一些符号会发生冲突，到时公式无法正确解析：</p>
<ul>
<li><code>_</code>的转义，在markdown中，<code>_</code>是斜体，但是在latex中，是下标测意思，会出现冲突</li>
<li><code>\\</code>的换行，在markdown中，<code>\\</code>会被转义为<code>\</code>,这样也会影响影响mathjax对公式中的<code>\\</code>进行渲染</li>
<li><code>*</code>的转义，在markdown中，<code>*</code> 是加粗</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>hexo默认使用<code>marked.js</code>去解析我们写的markdown，比如一些符号，<code>_</code>代表斜体，会被处理为<code>&lt;em&gt;</code>标签，<br>比如<code>x_i</code>在开始被渲染的时候，处理为<code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候mathjax就无法渲染成下标了。<br>很多符号都有这个问题，比如粗体<code>*</code>,也是无法在mathjax渲染出来的，好在有替代的乘法等,包括<code>\</code>同理。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>更换Hexo的markdown渲染引擎</p>
<p><a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="external">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="external">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm uninstall hexo-renderer-marked --save</div><div class="line">npm install hexo-renderer-kramed --save</div></pre></td></tr></table></figure>
</li>
<li><p>修改Hexo渲染源码</p>
</li>
</ol>
<p>找到<code>blog/node_modules\kramed\lib\rules\inline.js</code>文件</p>
<ol>
<li>修改<code>\</code>转义</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</div><div class="line">改为：</div><div class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</div></pre></td></tr></table></figure>
<ol>
<li><p>修改<code>_</code>转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</div><div class="line">改为：</div><div class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</div></pre></td></tr></table></figure>
</li>
<li><p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="external">Hexo下mathjax的转义问题</a></p>
<p><a href="http://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="external">使Marked.js与MathJax共存</a></p>
]]></content>
      
        <categories>
            
            <category> blog config </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[FFM（field-aware Factorization Machine）——升级版FM]]></title>
      <url>/2017/03/22/FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>FFM（Field-aware Factorization Machine）最初的概念来自Yu-Chin Juan（阮毓钦，毕业于中国台湾大学，现在美国Criteo工作）与其比赛队员，是他们借鉴了来自<a href="https://kaggle2.blob.core.windows.net/competitions/kddcup2012/2748/media/Opera.pdf" target="_blank" rel="external">Michael Jahrer的论文</a>中的field概念提出了<strong>FM的升级版</strong>模型</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h4><p>对于给定的数据我们进行训练，进而对测试集进行预测，首先我们想到利用<strong>线性模型</strong>进行拟合（也就是一维特征）：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e965ec210.png" alt=""> </p>
<p>进一步，我们考虑加入<strong>二维组合特征</strong>进行拟合：</p>
<h4 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h4><p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e99b2f719.png" alt=""> </p>
<p>也就是<strong>FM</strong>中的交叉特征（二次项），采用<strong>矩阵分解</strong>得到如下形式：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e9cb62988.png" alt=""> </p>
<p>其中$w_{j_1}$和$w_{j_2}$分别为特征$j_1$和$j_1$对应的<strong>隐向量</strong>，对应下图中左边两个矩阵的一行或一列即是一个隐向量。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" alt=""> </p>
<h4 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h4><p>现在在FM的基础之上，我们<strong>引入field-aware的概念</strong>，可以推得<strong>FFM的二次项形式</strong>如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d0e9fe74136.png" alt=""> </p>
<p>其中$w_{j_1,f_{j_2}}$为<strong>特征$j_1$针对$j_2$所在的类别$f_{j_2}$的隐向量</strong></p>
<p>$w_{j_2,f_{j_1}}$为<strong>特征$j_2$针对$j_1$所在的类别$f_{j_1}$的隐向量</strong></p>
<p>FFM完整的模型方程为</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d1361058228.png" alt=""> </p>
<p>为了便于理解，先看下面的例子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country</th>
<th style="text-align:center">Day</th>
<th style="text-align:center">Ad_type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">USA</td>
<td style="text-align:center">26/11/15</td>
<td style="text-align:center">Movie</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">China</td>
<td style="text-align:center">1/7/14</td>
<td style="text-align:center">Game</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country=USA</th>
<th style="text-align:center">Country=China</th>
<th style="text-align:center">Day=26/11/15</th>
<th style="text-align:center">Day=1/7/14</th>
<th style="text-align:center">Day=19/2/15</th>
<th style="text-align:center">Ad_type=Movie</th>
<th style="text-align:center">Ad_type=Game</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们对原始数据进行One-Hot编码生成数值特征，这时引入field的概念，把同一个categorical特征经过One-Hot编码生成的数值特征都放到同一个field中。比如：“Day=26/11/15”、“Day=1/7/14”、“Day=19/2/15”这三个特征是由“日期”这一categorical特征生成的，可以放到同一个field中。这时我们再计算隐向量的时候，<strong>隐向量不仅与特征相关，还与field相关</strong>。每一维特征$x_i$针对其它特征的每一种field<br>$f_j$，都会学习一个隐向量 $w_{i,f_j}$。</p>
<p>假设样本的n个特征属于 f 个field，那么FFM的二次项有  nf 个隐向量，如果隐向量的长度为 k ，那么FFM的二次参数有 nfk 个。而在FM模型中，每一维特征的隐向量只有一个<strong>，FM可以看作FFM的特例，是把所有特征都归属到一个field时的FFM模型</strong>。此外，由于隐向量与field相关，FFM二次项并不能够化简，其预测<strong>复杂度是 $O(kn^2)$。</strong></p>
<h3 id="FFM实现"><a href="#FFM实现" class="headerlink" title="FFM实现"></a>FFM实现</h3><p>Yu-Chin Juan实现了一个C++版的FFM模型，源码可从Github下载<a href="https://github.com/guestwalk/libffm" target="_blank" rel="external">https://github.com/guestwalk/libffm</a></p>
<p>该<strong>FFM模型采用logistic loss作为损失函数，和L2惩罚项</strong>，因此只能用于<strong>二元分类</strong>问题。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d13b9c6f3d1.png" alt=""> </p>
<p>模型<strong>采用SGD进行优化</strong>。</p>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://ooo.0o0.ooo/2017/03/21/58d13cd0e100e.png" alt=""> </p>
<p>这条记录可以编码成5个特征，其中“Genre=Comedy”和“Genre=Drama”属于同一个field，“Price”是数值型，不用One-Hot编码转换。<br>利用线性模型进行拟合：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d13d13d9ec3.png" alt=""> </p>
<p>二维组合特征拟合：<br><img src="https://ooo.0o0.ooo/2017/03/21/58d13d21ddd24.png" alt=""> </p>
<p>FM（隐向量）拟合：<br><img src="https://ooo.0o0.ooo/2017/03/21/58d13d2db61d3.png" alt=""> </p>
<p>FFM拟合：</p>
<p>为了方便说明FFM的样本格式，我们将所有的特征和对应的field映射成整数编号。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/21/58d13cf17aac5.png" alt="">  </p>
<p>FFM的组合特征有10项，如下图所示<br><img src="https://ooo.0o0.ooo/2017/03/21/58d1401cb9e37.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> FFM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】371. Sum of Two Integers]]></title>
      <url>/2017/03/18/%E3%80%90leetcode%E3%80%91371-Sum-of-Two-Integers/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求两个整数和，不能用加法</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>想到了转化成2进制再求和</p>
<ol>
<li>异或（^）操作：<br>1^0 = 0^1 = 1，0^0 = 1^1 = 0，先求出<strong>不考虑进位</strong>情况下的各位数字相加的运算结果d</li>
<li>和（&amp;）操作：<br>1^1 = 1，1^0 = 0^1 = 0^0 = 0，然后求出两个数字对应位置都是1的位，也就是需要进位的位置c。</li>
<li>左移操作（&lt;&lt;）：c&lt;&lt;1，前两步操由于没有进位而漏加的部分</li>
<li>对c和d重复进行上述操作，直到c为0，即没有由于需要进位而漏加的部分。</li>
</ol>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int getSum(int a, int b) &#123;</div><div class="line">    int c = a &amp; b;//进位位置</div><div class="line">    int result = a^b;</div><div class="line">    while (c)</div><div class="line">    &#123;</div><div class="line">        c = c &lt;&lt; 1;</div><div class="line">        int t = c;</div><div class="line">        c = result &amp; c;</div><div class="line">        result = result ^ t;</div><div class="line">    &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/18/58cccdf37f8b3.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【LeetCode】283. Move Zeros]]></title>
      <url>/2017/03/18/%E3%80%90LeetCode%E3%80%91283-Move-Zeros/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>把给定数组中的0全部挪到后边，保持其余数字顺序不变</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>遍历，把非零元素从前向后赋值给原数组，剩余空位补0。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int len = nums.size();</div><div class="line">        int j = 0;//赋值指针</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (nums[i] != 0) &#123;</div><div class="line">                nums[j] = nums[i];</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            else continue;</div><div class="line">        &#125;</div><div class="line">        for (; j &lt; len; j++) &#123;//将后面剩余的空位用0补齐</div><div class="line">            nums[j] = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/18/58ccc96ac194d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【LeetCode】104. Maximum Depth of Binary Tree]]></title>
      <url>/2017/03/17/%E3%80%90LeetCode%E3%80%91104-Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求二叉树的深度</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>广度优先遍历：利用STL中的queue（队列）进行广度优先遍历，计算层数</li>
<li>深度优先遍历：递归调用，当前节点的高度=max（左孩子节点高度，右孩子结点高度）+ 1</li>
</ol>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxDepth(TreeNode* root) &#123;//BFS广度优先遍历</div><div class="line">        if (NULL == root)</div><div class="line">            return 0;</div><div class="line">        queue &lt;TreeNode *&gt; que;</div><div class="line">        int nCount = 1;</div><div class="line">        int nDepth = 0;// 记树中每一层上的元素个数</div><div class="line"> </div><div class="line">         que.push(root);</div><div class="line">         while(!que.empty()) &#123;</div><div class="line">             TreeNode *pTemp = que.front();</div><div class="line">             que.pop();</div><div class="line">             nCount --; </div><div class="line">             if (pTemp-&gt;left)</div><div class="line">                 que.push(pTemp-&gt;left);</div><div class="line">             if (pTemp-&gt;right)</div><div class="line">                 que.push(pTemp-&gt;right);</div><div class="line">             </div><div class="line">             if (nCount == 0) &#123;</div><div class="line">                 nDepth ++;</div><div class="line">                 nCount = que.size();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     return nDepth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//DFS深度优先遍历</div><div class="line">public:</div><div class="line">    int maxDepth(TreeNode* root) &#123;</div><div class="line">       if (!root) return 0;</div><div class="line"></div><div class="line">    int ldepth = maxDepth(root-&gt;left);</div><div class="line">    int rdepth = maxDepth(root-&gt;right);</div><div class="line"></div><div class="line">    return 1 + max(ldepth, rdepth);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/17/58cb4b776120e.png" alt=""> </p>
<p><img src="https://ooo.0o0.ooo/2017/03/17/58cb4bb9dc6ec.png" alt=""> </p>
<hr>
<p><strong>二叉树的各种遍历以及时间复杂度还要看一下算法导论，看了再来总结</strong></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[交叉熵]]></title>
      <url>/2017/03/16/%E4%BA%A4%E5%8F%89%E7%86%B5/</url>
      <content type="html"><![CDATA[<h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>本质：香农信息量$log\frac{1}{p}$的期望<br>用来衡量一个系统的有序化程度，一个系统越是有序，那么它的信息熵就越低，反之就越高。</p>
<p>随机变量$X$可能的取值$X=\lbrace x_1,x_2,\cdots,x_n \rbrace$，对应的概率为$p(X=x_i)(i=1,2,\cdots,n)$，随机变量$X$的熵定义为$H(X) = -{\sum_{i}^{n}{p(x_i)\log{p(x_i)}}}$</p>
<h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>现有关于样本集的2个概率分布p和q，其中p为真实分布，q非真实分布。按照真实分布p来衡量识别一个样本的所需要的编码长度的期望(即平均编码长度)为：$H(p)=-{\sum_{i}^{n}{p(x_i)\log{p(x_i)}}}$。如果使用错误分布q来表示来自真实分布p的平均编码长度，则应该是：$H(p,q)=-{\sum_{i}^{n}{p(x_i)\log{q(x_i)}}}$。因为用q来编码的样本来自分布p，所以期望H(p,q)中概率是p(i)。H(p,q)我们称之为“交叉熵”。</p>
<h3 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h3><p>$D(p||q)=H(p,q)-H(p)=\sum_{i}^{} p(i)*log\frac{p(i)}{q(i)}$，其又被称为KL散度(Kullback–Leibler divergence，KLD) Kullback–Leibler divergence。它表示2个函数或概率分布的差异性：差异越大则相对熵越大，差异越小则相对熵越小，特别地，若2者相同则熵为0。注意，KL散度的非对称性。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>交叉熵可在神经网络(机器学习)中作为损失函数，p表示真实标记的分布，q则为训练后的模型的预测标记分布，交叉熵损失函数可以衡量p与q的相似性。交叉熵作为损失函数还有一个好处是使用sigmoid函数在梯度下降时能避免均方误差损失函数学习速率降低的问题，因为学习速率可以被输出的误差所控制。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zhihu.com/question/41252833" target="_blank" rel="external">知乎：如何通俗的解释交叉熵与相对熵</a></p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】136. Single Number]]></title>
      <url>/2017/03/15/%E3%80%90leetcode%E3%80%91136-Single-Number/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>输入序列中，每个数字重复出现2次，唯有一个数字只出现一次，找到这个只出现一次的数字</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>hash_table：遍历输入数组，如果hashtable中没有，说明是第一次出现，存到hash table中，如果发现hashtable中已经有了说明是第二次出现，z在hash表中将其删掉，最终hash table中剩下的就是只出现一次的那个数字</li>
<li>bit manipulation：数组中所有数字做异或操作，出现两次的异或之后得0了，最终剩下的就是只出现一次的那个数字。</li>
</ol>
<p><strong>算法复杂度：O(n)</strong><br>2比1要快一点,因为1还涉及hash table的查找、插入、删除等操作</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//hash_table</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int len = nums.size();</div><div class="line">        unordered_set&lt;int&gt; numset;</div><div class="line">    </div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (numset.find(nums[i]) == numset.end()) &#123;//没找到，加入</div><div class="line">                numset.insert(nums[i]);</div><div class="line">            &#125;</div><div class="line">            else//找到了，删除</div><div class="line">            &#123;</div><div class="line">                numset.erase(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        unordered_set&lt;int&gt;::iterator iter = numset.begin();</div><div class="line">        return *iter;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;//逐位异或</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">            int len = nums.size();</div><div class="line">    int result = 0;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        result ^= nums[i];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/15/58c8d54eb147c.png" alt=""> </p>
<p><img src="https://ooo.0o0.ooo/2017/03/15/58c8cf948fa31.png" alt=""> </p>
<hr>
<h3 id="c-STL中list-vector-map-hashmap-的对比"><a href="#c-STL中list-vector-map-hashmap-的对比" class="headerlink" title="c++ STL中list vector map hashmap 的对比"></a>c++ STL中list vector map hashmap 的对比</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>特点：<strong>支持快速的插入和删除，但查找费时。</strong></p>
<p>结构：<strong>线性双向链表</strong>，它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。它<strong>无需分配指定的内存大小</strong>且可以<strong>任意伸缩</strong>，这是因为它存储在<strong>非连续的内存</strong>空间中，并且由指针将有序的元素链接起来。查找元素时需要从头一个一个的<strong>顺序查找</strong>，这样目标元素越靠后，它的检索时间就越长。但是它可以迅速地在任何节点进行插入和删除操作。因为list 的每个节点保存着它在链表中的位置，插入或删除一个元素仅对最多三个元素有所影响，不像vector 会对操作点之后的所有元素的存储地址都有所影响，这一点是vector 不可比拟的。</p>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>特点：<strong>支持快速的查找，时间复杂度是$O(\log n)$，但是插入费时。</strong></p>
<p>结构：存诸结构是<strong>完全二叉检索树</strong>，支持快速的查找，但是vector每当<strong>增加元素</strong>的时候，都需要重新<strong>申请</strong>新的更大的<strong>内存空间</strong>，会调用元素的自身的复制构造函数，存在构造成本。在销毁旧内存的时候，会调用析构函数，存在析构成本。</p>
<h4 id="map、set"><a href="#map、set" class="headerlink" title="map、set"></a>map、set</h4><p>特点：<strong>支持快速的查找，时间复杂度是$O(\log n)$，但是插入费时。</strong></p>
<p>结构：map内部自建一颗<strong>红黑树</strong>(一种非严格意义上的平衡二叉树)，这颗树具有对数据<strong>自动排序</strong>的功能，所以在map内部所有的数据都是<strong>有序</strong>的，根据key值快速查找记录，查找的复杂度基本是$O(\log n)$，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p>
<h4 id="hash-map，hash-set"><a href="#hash-map，hash-set" class="headerlink" title="hash_map，hash_set"></a>hash_map，hash_set</h4><p>特点：<strong>数据的快速存储和查找，几乎可以看成是常数时间$O(1)$，但是会消耗比较多的内存</strong><br>结构：基于hash table（哈希表）。 使用一个下标范围比较大的<strong>数组</strong>来存储元素。可以设计一个<strong>函数</strong>（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素。</p>
<p>其插入过程是：<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。</p>
<p>其取值过程是:<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。</p>
<p>c++ 中没有hash_map、hash_set标准容器，可以自己定义，重点是做好hash函数的防碰撞。刷题的时候用了STL中的<strong>unordered_set</strong>,也是基于hashtable的</p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
            <tag> hash table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Factorization Machine（FM，因子分解机）]]></title>
      <url>/2017/03/14/Factorization-Machine%EF%BC%88FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>Steffen Rendle于2012年提出FM模型，旨在解决<strong>稀疏矩阵</strong>下的<strong>特征组合</strong>问题。传统机器学习问题，一般仅考虑如何对特征赋予权重，而没有考虑<strong>特征间存在相互作用</strong>，FM模型的提出较好地解决了该问题。</p>
</blockquote>
<h3 id="相比于SVM的优势"><a href="#相比于SVM的优势" class="headerlink" title="相比于SVM的优势"></a>相比于SVM的优势</h3><ol>
<li>对于<strong>稀疏数据</strong>有更强的学习能力</li>
<li><strong>线性时间复杂度</strong>，不依赖于支撑向量</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>回归问题</li>
<li>二分类问题</li>
<li>排序</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="传统线性回归模型"><a href="#传统线性回归模型" class="headerlink" title="传统线性回归模型"></a>传统线性回归模型</h4><p>我们用广告的CTR（点击率）预估问题引出FM模型：根据用户和广告位等相关特征，预测用户是否点击广告。源数据如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country</th>
<th style="text-align:center">Day</th>
<th style="text-align:center">Ad_type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">USA</td>
<td style="text-align:center">26/11/15</td>
<td style="text-align:center">Movie</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">China</td>
<td style="text-align:center">1/7/14</td>
<td style="text-align:center">Game</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">China</td>
<td style="text-align:center">19/2/15</td>
<td style="text-align:center">Game</td>
</tr>
</tbody>
</table>
</div>
<p>由于三种特征Country、Day、Ad_type都是categorical类型的，进行ctr预估的时候往往需要经过独热编码（One-Hot Encoding）转换成数值型特征。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clicked?</th>
<th style="text-align:center">Country=USA</th>
<th style="text-align:center">Country=China</th>
<th style="text-align:center">Day=26/11/15</th>
<th style="text-align:center">Day=1/7/14</th>
<th style="text-align:center">Day=19/2/15</th>
<th style="text-align:center">Ad_type=Movie</th>
<th style="text-align:center">Ad_type=Game</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>再利用<strong>传统的线性回归模型</strong>：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c68f490519b.png" alt=""> </p>
<p>根据训练集训练出模型的参数，进行预测。</p>
<p><strong>该方法存在的问题：</strong></p>
<ul>
<li>经过One-Hot编码之后，大部分样本数据特征是比较稀疏的，上面的样例中，每个样本有7维特征，但平均仅有3维特征具有非零值。而且在实际情况中，one-hot编码后的特征空间维度很大。</li>
<li>更重要的是，通过One-Hot编码方式输入到传统线性模型中进行训练，各特征分量$x_i$和$x_j$是相互独立的，但在实际应用中，通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。例如，“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击就极有可能有着正向的影响。</li>
</ul>
<h4 id="FM模型"><a href="#FM模型" class="headerlink" title="FM模型"></a>FM模型</h4><p>由于上述问题，所以引入两个（设置多个）<strong>特征之间的组合</strong>十分有意义：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6943ecf1aa.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/03/13/58c694663d2ce.png" alt=""> </p>
<p>前半部分就是传统的<strong>线性模型</strong>，后半部分引入<strong>两个特征之间的关联特征</strong>。</p>
<p>从上面公式可以看出，组合特征的参数一共有<strong>n(n−1)/2</strong>个， 任意两个参数都是独立的。但是二次项参数训练很<strong>困难</strong>，因为：<strong>数据稀疏性普遍存在</strong>于实际应用场景中，而每个参数$w_{ij}$的训练需要大量 $x_i$和 $x_j$ 都非零的样本，训练样本的不足，很容易导致参数 $x_i$ 和$x_j$训练 不准确，最终将严重影响模型的性能。</p>
<p>那么，如何解决二次项参数的训练问题呢？<strong>矩阵分解</strong>提供了一种解决思路。<br>参考在model-based的协同过滤中的做法：一个rating矩阵可以分解为user矩阵和item矩阵，每个user和item都可以采用一个隐向量表示</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6aa26b83c6.png" alt=""> </p>
<p>FM模型中二次项系数构成的矩阵是对称正定的，故可以用上面的分解方式<strong>分解成两个低维的矩阵相乘</strong>，即$W={V^T}V$，从而解决数据稀疏导致训练不准确的问题。<strong>至此，FM模型可以化为如下形式</strong>：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6ab23c0775.png" alt=""> </p>
<p>总结起来一句话就是：<strong>FM引入二维组合特征，然后利用矩阵分解降维减少了训练参数，从而能够适应数据的稀疏性</strong>。<br>具体解释参考<a href="http://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">美团技术团队关于FM的介绍</a>需要的时候可以细看</p>
<p><img src="https://ooo.0o0.ooo/2017/03/13/58c6ad4950dc3.png" alt=""> </p>
<hr>
<h3 id="FM模型复杂度"><a href="#FM模型复杂度" class="headerlink" title="FM模型复杂度"></a>FM模型复杂度</h3><h4 id="求解复杂度"><a href="#求解复杂度" class="headerlink" title="求解复杂度"></a>求解复杂度</h4><p>模型参数已经训练出来，将新的数据输入模型求解：<br><img src="https://ooo.0o0.ooo/2017/03/13/58c6943ecf1aa.png" alt=""> </p>
<p>时间复杂度为<strong>$O(kn^2)$</strong></p>
<p>但是如果我们依据公式$ab+ac+bc+\cdots=\frac{(a+b+c+\cdots)^2-(a^2+b^2+c^2+\cdots)}{2}$化简交叉项，具体过程如下：<br><img src="https://ooo.0o0.ooo/2017/03/14/58c758f677ff9.png" alt=""> </p>
<p>此时时间复杂度简化为<strong>$O(kn)$</strong>。由此可见，FM可以在<strong>线性时间</strong>对新样本作出预测。</p>
<h4 id="模型训练复杂度"><a href="#模型训练复杂度" class="headerlink" title="模型训练复杂度"></a>模型训练复杂度</h4><ul>
<li><strong>多元统计回归问题</strong></li>
<li>训练方法：<strong>SGD（随机梯度下降法）</strong><br>记FM模型参数为$\Theta={(w_0,w_1,w_2,\cdots,w_n,v_11,v_12,\cdots,v_nk)}^T$，共有$1+n+kn$个参数，模型各个参数的梯度如下：</li>
</ul>
<p><img src="https://ooo.0o0.ooo/2017/03/14/58c79e8acccee.png" alt=""> </p>
<p><img src="https://ooo.0o0.ooo/2017/03/14/58c7a443cf54c.png" alt=""> </p>
<p>详细推导过程参考<a href="http://blog.csdn.net/itplus/article/details/40536025" target="_blank" rel="external">peghoty的博客</a></p>
<p><strong>时间复杂度为$O(kn)$</strong></p>
<h3 id="开源代码库"><a href="#开源代码库" class="headerlink" title="开源代码库"></a>开源代码库</h3><p>libFM</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://my.oschina.net/keyven/blog/648747" target="_blank" rel="external">因子分解机Factorization Machine</a></p>
<p><a href="http://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">深入FFM原理与实践</a></p>
<p><a href="http://blog.csdn.net/itplus/article/details/40536025" target="_blank" rel="external">peghoty的博客：FM学习算法</a></p>
]]></content>
      
        <categories>
            
            <category> machine learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】412. Fizz Buzz]]></title>
      <url>/2017/03/13/%E3%80%90leetcode%E3%80%91412-Fizz-Buzz/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n = 15,</div><div class="line"></div><div class="line">Return:</div><div class="line">[</div><div class="line">    &quot;1&quot;,</div><div class="line">    &quot;2&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;4&quot;,</div><div class="line">    &quot;Buzz&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;7&quot;,</div><div class="line">    &quot;8&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;Buzz&quot;,</div><div class="line">    &quot;11&quot;,</div><div class="line">    &quot;Fizz&quot;,</div><div class="line">    &quot;13&quot;,</div><div class="line">    &quot;14&quot;,</div><div class="line">    &quot;FizzBuzz&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>太简单啦，略</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>遍历赋值，逢15、3、5的倍数赋值“FizzBuzz”，“Fizz”，“Buzz”，其余赋值为自然数顺序数</p>
<p><strong>算法复杂度：O(n)</strong></p>
<p>这里需要注意的是vector的push_back()函数复杂度为O(n)，但是按下标随机访问的时间复杂度为O(1)，所以用下标访问再赋值会比较快</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; fizzBuzz(int n) &#123;</div><div class="line">        vector&lt;string&gt; result(n);</div><div class="line">       for (int i = 1; i &lt;= n; ++i) &#123;</div><div class="line">        if (i % 15 == 0) &#123;</div><div class="line">            result[i-1] = &quot;FizzBuzz&quot;;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            if (i % 5 == 0) &#123;</div><div class="line">                result[i-1] = &quot;Buzz&quot;;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                if (i % 3 == 0) &#123;</div><div class="line">                    result[i-1] = &quot;Fizz&quot;;</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    result[i-1] = to_string(i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/13/58c6813fdde1d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】53. Maximum Subarray]]></title>
      <url>/2017/03/13/%E3%80%90leetcode%E3%80%9153-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example：</p>
<p>given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求一个数组的最大连续子数组，连续和最大的子数组</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>遍历，复杂度O(n^2)</li>
<li>分治法，《算法导论》第四章讲过</li>
</ol>
<p>把数组看作A[low..high]，利用分治策略，将数组划分为两个规模尽量相等的子数组，找到数组的中央位置，A[mid]，然后考虑求解两个子数组A[low..mid]和A[mid+1..high]。那么子数组A[i..j]所有的情况共有以下三种：<br><img src="https://ooo.0o0.ooo/2017/03/13/58c661380c603.png" alt=""> </p>
<p>那么我们可以递归的求解A[low..mid]和A[mid+1..high]的最大子数组，因为这两个子问题仍是最大数组问题，只是规模更小。因此剩下的工作就是寻找跨越中点的最大子数组，然后在三者中选取最大者。</p>
<p><strong>算法复杂度：O(nlogn)</strong></p>
<ol>
<li>动态规划</li>
</ol>
<p>当从头遍历数组元素时，对于数组中的任何一个整数有以下两种选择： </p>
<p><strong>加入之前的subArray；自己另起一个新的subArray</strong></p>
<ul>
<li>当之前subArray 的总和大于 0 时，我们认为 其对后续结果是有贡献的，这种情况下，我们选择加入之前的subArray </li>
<li>当之前subArray 的总和小于等于0时，我们认为其对后续结果是没有贡献的，这种情况下，我们选择以当前数字开始，另起一个subArray</li>
</ul>
<p>设状态f(j) 表示 以 nums[j] 为结尾的最大连续子序列的和，则状态转移方程如下：<br><img src="https://ooo.0o0.ooo/2017/03/13/58c66196a6c84.png" alt=""> </p>
<p><strong>时间复杂度O(n)</strong></p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//分治法</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        return findMaxSubArray(nums,0,nums.size()-1);</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int maxArrayAcrossMid(vector&lt;int&gt;&amp; numsIn, int low, int high) &#123;//求跨越中点的最大子数组数字和</div><div class="line">    int len = (high - low) / 2;</div><div class="line">    int mid = (high + low) / 2;</div><div class="line">    int maxnum = numsIn[mid];</div><div class="line">    int maxnumtemp = numsIn[mid];</div><div class="line">    for (int i = mid - 1; i &gt;= low; i--) &#123;//计算左边最大子数组</div><div class="line">        maxnumtemp += numsIn[i];</div><div class="line">        if (maxnumtemp &gt; maxnum)</div><div class="line">            maxnum = maxnumtemp;</div><div class="line">    &#125;</div><div class="line">    maxnumtemp = maxnum;</div><div class="line">    for (int i = mid + 1; i &lt;= high; i++) &#123;//计算右边最大子数组</div><div class="line">        maxnumtemp += numsIn[i];</div><div class="line">        if (maxnumtemp &gt; maxnum)</div><div class="line">            maxnum = maxnumtemp;</div><div class="line">    &#125;</div><div class="line">    return maxnum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int findMaxSubArray(vector&lt;int&gt;&amp; nums, int low, int high) &#123;//递归调用求解最大子数组</div><div class="line">    int mid = (low + high) / 2;</div><div class="line">    int maxSum = nums[mid];</div><div class="line">    int acrossmid = 0;</div><div class="line">    int leftmax = 0;</div><div class="line">    int rightmax = 0;</div><div class="line">    if (low == high) &#123;</div><div class="line">        return maxSum;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        acrossmid = maxArrayAcrossMid(nums, low, high);</div><div class="line">        leftmax = findMaxSubArray(nums, low, mid);</div><div class="line">        rightmax = findMaxSubArray(nums, mid + 1, high);</div><div class="line">    &#125;</div><div class="line">    if (acrossmid &gt;= leftmax &amp;&amp; acrossmid &gt;= rightmax) return acrossmid;</div><div class="line">    if (leftmax &gt;= acrossmid &amp;&amp; leftmax &gt;= rightmax) return leftmax;</div><div class="line">    else return rightmax;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//动态规划</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">            int maxnum = nums[0];</div><div class="line">    int numtemp = nums[0];</div><div class="line">    for (int i = 1; i &lt; nums.size(); i++) &#123;</div><div class="line">        if (numtemp &lt; 0) numtemp = 0;</div><div class="line">        numtemp += nums[i];</div><div class="line">        if (numtemp &gt; maxnum) &#123;</div><div class="line">            maxnum = numtemp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        return maxnum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/03/13/58c65b79609f7.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GIS]]></title>
      <url>/2017/03/07/GIS/</url>
      <content type="html"><![CDATA[<h2 id="OpenStreetMap"><a href="#OpenStreetMap" class="headerlink" title="OpenStreetMap"></a>OpenStreetMap</h2><p> 开放街道图（OpenStreetMap，简称OSM）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图,其osm数据开源，可以自由下载使用。<a href="https://www.openstreetmap.org/" target="_blank" rel="external">https://www.openstreetmap.org/</a></p>
<p><a href="http://download.bbbike.org/osm/bbbike/Beijing/" target="_blank" rel="external">北京osm数据beijing.osm</a><br><a href="http://download.geofabrik.de/asia/china.html" target="_blank" rel="external">中国osm数据china.osm</a></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>地图数据开源，人人可以编辑，并且可以完整的下载，部署私有的地图服务器</li>
<li>内容丰富，比起ESRI Shapefiles的点、面、线，支持更多复杂的元素</li>
<li>生态圈活跃，从地图数据、数据库、地图渲染、瓦片服务器、前端API，到桌面、Web地图设计工具，具有大量优秀的开源组件</li>
</ul>
<h3 id="osm数据结构"><a href="#osm数据结构" class="headerlink" title="osm数据结构"></a>osm数据结构</h3><p>OpenStreetMap包括空间数据以及属性数据。其中空间数据主要包括三种：点（Nodes）、路（Ways）和关系（Relations），这三种原始构成了整个地图画面。其中，Nodes定义了空间中点的位置；Ways定义了线或区域；Relations（可选的）定义了元素间的关系。</p>
<ol>
<li><strong>Node</strong> 通过经纬度定义了一个地理坐标点。同时，还可以height=<em>标示物体所海拔；通过layer=</em> 和 level=<em>，可以标示物体所在的地图层面与所在建筑物内的层数；通过place=</em> and name=*来表示对象的名称。同时，way也是通过多个点（node）连接成线（面）来构成的。</li>
<li><strong>Way</strong><br>通过2-2000个点（nodes）构成了way。way可表示如下3种图形事物（非闭合线（Open polyline ）、闭合线（Closed polyline）、区域（Area ））。对于超过2000 nodes的way，可以通过分割来处理。<ul>
<li>Open polyline<br>非闭合线：收尾不闭合的线段。通常可用于表示现实中的道路、河流、铁路等。</li>
<li>Closed polyline<br>闭合线：收尾相连的线。例如可以表示现实中的环线地铁。</li>
<li>Area<br>区域：闭合区域。通常使用landuse=* 来标示区域等。 </li>
</ul>
</li>
<li><strong>Relation</strong><br>一个Relation是用来描述两个或多个基元的相互关系（nodes, ways 或者其他的relations），相互的关系通过role来定义，包括：<ul>
<li>route ：定义公路、自行车道、铁路等</li>
<li>多个多边形：定义area例如建筑、河堤等</li>
<li>边界：装门用来定义行政边界</li>
<li>限制：用于描述限制比如“非左转”</li>
</ul>
</li>
<li><strong>Tag </strong><br>标签不是地图基本元素，但是各元素都通过tag来记录数据信息。通过’key’ and a ‘value’来对数据进行记录。例如，可以通过highway=residential来定义居住区道路；同时，可以使用附加的命名空间来添加附加信息，例如：maxspeed:winter=*就表示冬天的最高限速。</li>
</ol>
<h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><p>GeoFabrik：<a href="http://www.geofabrik.de/" target="_blank" rel="external">http://www.geofabrik.de/</a></p>
<p>Metro Extracts：<a href="http://metro.teczno.com/" target="_blank" rel="external">http://metro.teczno.com/</a></p>
<p>HOT Exports：<a href="http://hot.openstreetmap.org/" target="_blank" rel="external">http://hot.openstreetmap.org/</a></p>
<p>BBBike：<a href="http://extract.bbbike.org/" target="_blank" rel="external">http://extract.bbbike.org/</a></p>
<hr>
<h3 id="GIS体系结构"><a href="#GIS体系结构" class="headerlink" title="GIS体系结构"></a>GIS体系结构</h3><p><img src="https://ooo.0o0.ooo/2017/03/06/58bccd74c1230.png" alt=""> </p>
<blockquote>
<ul>
<li>客户端 - 这里所说的客户端是多样化的，可以是 Web 客户端，移动设备或者是通过 HTTP 连接到 Internet 服务或连接到 GIS Server 的桌面应用程序。</li>
<li>Web 服务器 – Web 服务器包含 Web 应用的部署，以及 Web 服务，它们均使用 GIS Server 上的服务资源。</li>
<li>GIS 服务器 – GIS 服务器主要是提供了地理信息可视化、空间数据管理及分析等一系列服务</li>
<li>GIS 渲染引擎– GIS 渲染引擎能够将地图相关数据可视化，并且提供给用户可交互的平台。</li>
<li>空间数据存储库 – 空间数据存储库可以是不同的数据形式，包括空间数据库、矢量数据文件和光栅数据文件。</li>
</ul>
</blockquote>
<h2 id="系统搭建"><a href="#系统搭建" class="headerlink" title="系统搭建"></a>系统搭建</h2><p>系统环境 Windows10 64bit</p>
<h3 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h3><ul>
<li><p><strong>postgresql+postGIS</strong>——Postgresql是一种对象关系型数据库，具备地理信息处理扩展，从而可实现对地理信息的存储；postgis是一个空间数据库，它扩展自Postgresql对象关系型数据库，它添加了地理信息对象通过本地的SQL查询。因为在安装Postgresql是可以选择下载安装postgis所以它是可选的</p>
</li>
<li><p><strong>QGIS</strong>——</p>
</li>
<li><strong>Mapserver</strong></li>
<li><strong>OpenLayers</strong></li>
<li><strong>osm2pgsql</strong>——是由OpenStreetMap开发的一个命令行工具负责将OSM数据导入到基于PostgresSql的Postgis的数据库中，这样GeoServer才能调用数据发布服务器。其次我们还要指定osm2pgsql的gitHub地址因为我们需要的两个文件在里面可以找到一个是900913.sql一个是default.style。</li>
</ul>
<p>以上安装包直接官网下载最新版即可</p>
<h3 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h3><ol>
<li>postgresql+postGIS安装</li>
</ol>
<p>官网下载postgresql，按照提示一步一步安装即可，快结束的时候勾选stack builder，然后用stack builder安装postGIS插件<br>这部分很顺利，不再详细讲述，请直接参考教程：<a href="https://xucheng7112.github.io/2017/02/21/Postgresql+Geoserver%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%80" target="_blank" rel="external">Postgresql+Geoserver搭建本地地图服务器(一)</a>/)</p>
<p>需要<strong>重点注意</strong>是<br>安装完成后，为了在命令中使用方便我们把Postgresql的bin目录添加到环境变量中，win10很方便，直接搜索框搜索环境变量，把目标目录添加进PATH就行了。<br>此时在开始菜单打开pgAdmin就可以进入到装好的Postgresql数据库管理工具了，可以<strong>在管理界面创建自己的数据库</strong>（create database）。</p>
<ol>
<li>利用Osm2pgsql导入osm数据到postgresql</li>
</ol>
<p>安装好数据库软件，建立了自己的数据库，接下来需要将下载下来的osm数据导入数据库了，由于postgresql数据库不能直接导入osm数据，因此我们需要利用openstreetmap开发的工具Osm2pgsql完成数据导入。安装教程仍参考<a href="https://xucheng7112.github.io/2017/02/21/Postgresql+Geoserver%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%80" target="_blank" rel="external">Postgresql+Geoserver搭建本地地图服务器(一)</a>/)</p>
<p>不过这里并没有那么顺利，遇到了两个问题，记下来</p>
<ol>
<li>第四步添加EPSG: 900913支持时，github上找不到相应的900913文件，后来终于在<strong>历史版本</strong>中找到了该文件<a href="https://github.com/openstreetmap/osm2pgsql/tree/0.90.x" target="_blank" rel="external">900913.sql所在github目录</a></li>
<li>第五步：添加OSM数据到数据库 osm2pgsql -U postgres -d osm -s -S ./default.style ./shanghai.osm时提示no password supplied 无法连接到数据库。</li>
</ol>
<p>参考了博客<a href="http://blog.csdn.net/hyj_13/article/details/45130017" target="_blank" rel="external">PostgreSQL+PostGIS+OpenStreeMap+GeoServer环境搭建</a>给出的解决办法：在C:\Users\asus\AppData\Roaming\postgresql路径下有一个pgpass.conf文件，每个用户在登陆postgres并且保存密码后都会在该用户目录下保存一个pgpass.conf 文件，里面有该用户的密码按照如下格式进行设置：hostname:port:database:username:password<br>例如：localhost:5432:osm:postgres:123456</p>
<p>在搜索栏输入“%AppData%”回车进入文件夹，但是发现Roaming文件夹下并<strong>没有postgresql以及下面的pgpass.conf</strong>，查了很久，最后直接在AppData\Roaming文件夹下<strong>自己建postgresql\pgpass.conf</strong>按上面的方法配置好久可以了</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-gis-dev/" target="_blank" rel="external">利用 OpenScales+MapServer+PostGIS 快速构建GIS应用</a></p>
<p><a href="https://xucheng7112.github.io/2017/02/21/Postgresql+Geoserver%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8(%E4%B8%80" target="_blank" rel="external">Postgresql+Geoserver搭建本地地图服务器(一)</a>/)</p>
<p><a href="https://yq.aliyun.com/articles/16907" target="_blank" rel="external">利用OpenStreetMap（OSM）数据搭建一个地图服务</a></p>
<p><a href="http://blog.csdn.net/hyj_13/article/details/45130017" target="_blank" rel="external">PostgreSQL+PostGIS+OpenStreeMap+GeoServer环境搭建</a></p>
<p><a href="http://blog.csdn.net/scy411082514/article/category/1130386" target="_blank" rel="external">Mr.An 的专栏</a></p>
<p><a href="http://blog.csdn.net/hyj_13" target="_blank" rel="external">黄大仙儿的专栏</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】500. Keyboard Row]]></title>
      <url>/2017/03/07/leetcode500-Keyboard-Row/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.</p>
<p><img src="https://ooo.0o0.ooo/2017/03/07/58be531ade5c7.png" alt=""> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Example 1:</div><div class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</div><div class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</div></pre></td></tr></table></figure>
<p>Note:</p>
<ol>
<li>You may use one character in the keyboard more than once.</li>
<li>You may assume the input string will only contain letters of alphabet.</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>输入一组单词，用vector容器封装，判断每个单词的所有字母是否在键盘的同一行，如果在同一行，留在vector中，否则移除，最后输出vector</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>建立键盘三行的大小写字母表</li>
<li>遍历vector内的单词</li>
<li>对于每一个单词先确定首字母所在行号，再依次查看后面的字母是否跟首字母在同一行，一旦不一致，立刻从vector中删除该单词</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ol>
<li>一开始上手打算用字符数组存放键盘表，折腾了好久发现一个严重的问题：数组作为参数传递时，传递的是<strong>指针</strong>，这时候再用sizeof()来求数组的长度实际上求得的是<strong>指针的长度</strong>，而非数组长度，所以数组作为传递参数时需要将其长度也作为一个参数传递，后续运算时才不会出错，所以改用string存储每一行字母。</li>
<li>vector中用earse()删除元素时，返回值为：指向被删除元素的下一个元素的iterator，外层如果用for循环iter++,容易出现越界情况,所以采用了while循环</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;</div><div class="line">        string str1 = &quot;qwertyuiopQWERTYUIOP&quot;;</div><div class="line">        string str2 = &quot;asdfghjklASDFGHJKL&quot;;</div><div class="line">        string str3 = &quot;zxcvbnmZXCVBNM&quot;;</div><div class="line">        vector&lt;string&gt;::iterator it = words.begin();</div><div class="line">        int logo = 0;</div><div class="line">        while (it != words.end())</div><div class="line">        &#123;</div><div class="line">            int linenum = 0;</div><div class="line">            int linenumt = 0;</div><div class="line">            string word = *it;</div><div class="line">            if (word.length() == 1) &#123;</div><div class="line">                it++;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                int wordlen = word.size();</div><div class="line">            char shouzimu = word[0];</div><div class="line">            string::size_type idx = str1.find(shouzimu);</div><div class="line">            if (idx != string::npos)</div><div class="line">                linenum = 1;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                string::size_type idx = str2.find(shouzimu);</div><div class="line">                if (idx != string::npos)</div><div class="line">                    linenum = 2;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    string::size_type idx = str3.find(shouzimu);</div><div class="line">                    if (idx != string::npos)</div><div class="line">                        linenum = 3;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //判断剩余字母是否跟首字母处于同一行</div><div class="line">            for (int i = 1; i &lt; wordlen; i++) &#123;</div><div class="line">                char zimu = word[i];</div><div class="line">                string::size_type idx = str1.find(zimu);</div><div class="line">                if (idx != string::npos)</div><div class="line">                    linenumt = 1;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    string::size_type idx = str2.find(zimu);</div><div class="line">                    if (idx != string::npos)</div><div class="line">                        linenumt = 2;</div><div class="line">                    else</div><div class="line">                    &#123;</div><div class="line">                        string::size_type idx = str3.find(zimu);</div><div class="line">                        if (idx != string::npos)</div><div class="line">                            linenumt = 3;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (linenumt != linenum) &#123;</div><div class="line">                    it = words.erase(it);//删除当前元素，返回值：指向下一个元素的iter</div><div class="line">                    logo = 1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    logo = 0;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (logo == 0)</div><div class="line">            &#123;</div><div class="line">                it++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        return words;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>用STL中的unordered_set采用hash表的存储方式，查找时间复杂度最优可达常数，但尝试后并没有实质上的改变，可能是因为数据量不够大，没有凸显出来他的优势。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;</div><div class="line">    </div><div class="line">        unordered_set&lt;char&gt; row1 &#123;&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;y&apos;,&apos;u&apos;, &apos;i&apos;, &apos;o&apos;, &apos;p&apos;&#125;;</div><div class="line">        unordered_set&lt;char&gt; row2 &#123;&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;&#125;; </div><div class="line">        unordered_set&lt;char&gt; row3 &#123; &apos;z&apos;, &apos;x&apos;, &apos;c&apos;, &apos;v&apos;, &apos;b&apos; ,&apos;n&apos;, &apos;m&apos;&#125;;</div><div class="line">        vector&lt;unordered_set&lt;char&gt;&gt; rows &#123;row1, row2, row3&#125;;</div><div class="line">        </div><div class="line">        vector&lt;string&gt; validWords;</div><div class="line">        for(int i=0; i&lt;words.size(); ++i)&#123;</div><div class="line">            int row=0;</div><div class="line">            </div><div class="line">            for(int k=0; k&lt;3; ++k)&#123;</div><div class="line">                if(rows[k].count((char)tolower(words[i][0])) &gt; 0) row = k;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            validWords.push_back(words[i]);</div><div class="line">            for(int j=1; j&lt;words[i].size(); ++j)&#123;</div><div class="line">                if(rows[row].count((char)tolower(words[i][j])) == 0)&#123;</div><div class="line">                    validWords.pop_back();</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return validWords;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>上面两种方法<br> <img src="https://ooo.0o0.ooo/2017/03/07/58be58bb2d36d.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hash table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】476 number complement]]></title>
      <url>/2017/03/05/leetcode476-number-complement/</url>
      <content type="html"><![CDATA[<p>刷题第二天，好巧哦又是一道bit manipulation的</p>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:<br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.<br>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: 5</div><div class="line">Output: 2</div><div class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</div></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: 1</div><div class="line">Output: 0</div><div class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0.</div></pre></td></tr></table></figure></p>
<p>The above arrows point to positions where the corresponding bits are different.<br>Subscribe to see which companies asked this question.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>就是要将一个整数的二进制表示做取反操作，输出取反后的十进制表示。</p>
<p>需要注意的是二进制表示前面的0，比如5的二进制表示是00000101，如果直接取反得到的是11111010，而我们所要求的是不含前面的占位0的取反十进制表示，也就是(00000)010。</p>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><ol>
<li>首先要求出来输入的整形数字二进制表示的位数n，也就是不含前导0的二进制表达的位数（如5的二进制表达是101，就是三位）</li>
<li>然后将输入数字与n个1做异或操作，就相当于取反了</li>
</ol>
<p>例：<br>int = 5， 二进制表达为  00000101，位数为3，与00000111做异或运算得到00000010</p>
<p>第2步很好求，知道了位数n之后，${2^n}-1$就是末位为n个1的十进制表示</p>
<p>关键是第1步求十进制表示所占的位数，最开始我尝试了用数学的方式来求解，但是费尽周折仍有bug，于是乎上网搜了搜，发现可以用向右移位判断是否为0的方法，记录下移动的位数，就是十进制表示所占位数，哎，我怎么就没想到</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int findComplement(int num) &#123;</div><div class="line">        int numm = num;</div><div class="line">        int bitnum = 0;</div><div class="line">        while (num) &#123;</div><div class="line">            bitnum++;</div><div class="line">            num = num &gt;&gt; 1;</div><div class="line">        &#125;</div><div class="line">        int sec = pow(2, bitnum)-1;</div><div class="line">        int a = numm^sec; </div><div class="line">        return a;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://ooo.0o0.ooo/2017/03/05/58bbc628a6a75.png" alt=""> </p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于二进制的运算以及位操作符还是不够熟练，不能做到手到擒来，看来这个表要牢记在心<br><img src="https://ooo.0o0.ooo/2017/03/05/58bbc6f6a6428.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树（三）：多变量决策树]]></title>
      <url>/2017/03/05/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%9A%E5%8F%98%E9%87%8F%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>前面讲到的都是<strong>单变量决策树</strong>，即<strong>每次只选取一个属性</strong>进行划分<br>其实就是确定分类边界，且单变量决策树的决策边界都是平行于坐标轴，如下图<br><img src="https://ooo.0o0.ooo/2017/03/04/58babfd268ac0.png" alt=""> </p>
<p>有些时候我们希望用斜线甚至曲线去进行划分以得到更好的泛化能力：<br><img src="https://ooo.0o0.ooo/2017/03/04/58bac0c658b28.png" alt=""> </p>
<p>这种“斜划分”的方式就是多变量决策树，划分依据不再是单个属性，而是一个形如$\sum\limits_{i=1}^dw_ia_i=t$的线性分类器，${w_i}$和t是需要学习的参数<br><img src="https://ooo.0o0.ooo/2017/03/04/58babffd27b72.png" alt=""> </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树（二）：连续值和缺失处理]]></title>
      <url>/2017/03/05/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%92%8C%E7%BC%BA%E5%A4%B1%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="连续值"><a href="#连续值" class="headerlink" title="连续值"></a>连续值</h3><h4 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h4><p>连续值属性<strong>离散化</strong>，<strong>二分法</strong><br>对于连续属性a,有n个样本，考察包含n-1个区间的中点作为候选的划分点：<br><img src="https://ooo.0o0.ooo/2017/03/04/58bab3a529574.png" alt=""> </p>
<h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p><img src="https://ooo.0o0.ooo/2017/03/04/58bab4950e852.png" alt=""> </p>
<p>选取能够获得<strong>信息增益最大</strong>的点t进行<strong>二分</strong><br>注意</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>连续值属性</strong>可<strong>多次</strong>作为划分节点（划分值不同），每次划分出两个分支；但<strong>离散值属性只可划分一次</strong>，分出多个分支。</p>
<h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>有些样本缺失某些属性值，如图：<br><img src="https://ooo.0o0.ooo/2017/03/04/58bab8e482daf.png" alt=""><br>如果只要样本有缺失的值就舍弃，会浪费大量数据。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>如何在缺失值的数据集上进行属性划分。也就是<strong>对于某一个或几个属性，样本有缺失的值，我们如何计算信息增益等指标进行划分属性的选取</strong>。</li>
<li>给定划分属性，若样本在该属性上缺失值，如何划分。也就是<strong>选好了划分属性，对于缺失该的样本，如何将其归类</strong>。</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://ooo.0o0.ooo/2017/03/04/58babc3b1bebf.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/03/04/58babc5907282.png" alt=""> </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里总结一下，针对问题1如何选取分类属性，我们就分别针对每一个属性，计算该<strong>属性值没有缺失样</strong>本的信息增益，选择最大的作为分类属性。<br>确定好分类属性后，对于在该属性值缺失的样本，将其<strong>归入所有的分支节点</strong>，同时按可能的概率更改权重</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树（一）：基础]]></title>
      <url>/2017/03/04/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol>
<li>使用不熟悉的数据集合，从中提取出一系列规则，能够对新数据进行分类</li>
<li>极大化信息增益$a_* = argmax_{a\in A}{Gain(D,a)}$</li>
</ol>
<h3 id="构建决策树伪代码"><a href="#构建决策树伪代码" class="headerlink" title="构建决策树伪代码"></a>构建决策树伪代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">createBranch()：</div><div class="line">    检测数据集中的每个项是否属于同一个分类：</div><div class="line">    if so </div><div class="line">       return 类标签</div><div class="line">    else</div><div class="line">       寻找划分数据集的最好特征***</div><div class="line">       划分数据集</div><div class="line">       创建分支节点</div><div class="line">            for 每个分支节点，递归调用createBranch()函数</div><div class="line">        return 分支节点</div></pre></td></tr></table></figure>
<h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><p>显然，构建决策树的关键是<strong>寻找划分数据集的最好特征</strong>，我们希望决策树分支节点包含的样本尽可能属于同一类别——纯度（purity）越高越好</p>
<h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><h3 id="1-信息熵-——-gt-信息增益"><a href="#1-信息熵-——-gt-信息增益" class="headerlink" title="1. 信息熵 ——&gt; 信息增益"></a>1. 信息熵 ——&gt; 信息增益</h3><h5 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h5><ul>
<li>信息论中表示样本的不确定性大小，度量样本集合纯度最常用的指标</li>
<li>样本集合D中第k类占比$p_k$则D的信息熵定义为:<script type="math/tex">Ent(D)=-\sum\limits_{k=1}^{\left |y\right|}p_{k}log_2p_{k}</script></li>
</ul>
<h5 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h5><p>假定离散属性a在D中有V个可能的取值${a^1,a^2,…,a^V}$,若依据属性a对D进行分类，产生V个分支点，根据每个分支点样本数量对分支点赋权重$\left |D^V\right|/D$，于是根据属性a进行划分获得的信息增益为：</p>
<script type="math/tex; mode=display">Gain(D,a) = Ent(D)-\sum\limits_{v=1}^{\left |v\right|}\frac{\left |D^V\right|}{D}Ent(D^v)</script><p>也就是<strong>信息熵的减少量</strong>，越大越好：</p>
<script type="math/tex; mode=display">a_* = argmax_{a\in A}Gain(D,a)</script><p>接下来如果给出下表中关于西瓜的特征数据，据此判断西瓜的好坏<br><img src="https://ooo.0o0.ooo/2017/03/04/58ba9b8304fff.png" alt=""> </p>
<p>我们就可以先算出根节点的信息熵（分为好、坏两类）——&gt;计算依每一个属性进行划分所获得的信息增益，选取信息增益最大的属性作为分支节点——&gt;重复上述过程直到无法分类。得到如下决策树：<br><img src="https://ooo.0o0.ooo/2017/03/04/58ba9d82898b7.png" alt=""> </p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>ID3决策树</p>
<p><strong>思考</strong>：如果我们将数据中“<strong>编号</strong>”这一属性也作为一个候选的划分属性，该属性能够产生17个分支，每个分支只包含一个样本，显然纯度最高，所产生的信息增益也最大，但<strong>不具备泛化能力</strong>。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>实际上<strong>信息增益准则对可取值数目较多的属性有所偏好</strong>（分的越细致的属性越会得到信息增益准则的偏好），但这种偏好会带来<strong>泛化能力差</strong>的不利影响。 </p>
<h3 id="2-增益率"><a href="#2-增益率" class="headerlink" title="2. 增益率"></a>2. 增益率</h3><p><img src="https://ooo.0o0.ooo/2017/03/04/58baa4c1c346e.png" alt=""> </p>
<p>其中IV(a)称为属性a的固有值，属性a的可能取值越多，IV(a)越大，相应地会减小Gain_ration的值。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>与信息增益相反，信息增益准则对可取值数目较少的属性有所偏好，分类性能下降。</p>
<h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>结合信息增益和增益率</p>
<ul>
<li>step1：在候选属性中找出信息增益高于平均水平的属性</li>
<li>step2：在从中选择增益率最高的</li>
</ul>
<h3 id="3-基尼指数"><a href="#3-基尼指数" class="headerlink" title="3. 基尼指数"></a>3. 基尼指数</h3><p><img src="https://ooo.0o0.ooo/2017/03/04/58baa498a3f46.png" alt=""> </p>
<p>用于<strong>度量数据集的纯度</strong>，物理意义：从数据集中随机取两个样本，二者不属于同一类别的概率，<strong>故Gini值越小，数据集纯度越高</strong>。<br>属性a的Gini值定义如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/03/04/58baa6d779529.png" alt=""> </p>
<p>选取使得划分后Gini指数最小的属性作为划分属性，即$a_* = argmax_{a\in A}Gini_index(D,a)$</p>
<h4 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h4><p>采用Gini指数选择属性分类</p>
<h2 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h2><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p><strong>过拟合</strong>（分支过多，泛化能力差）</p>
<h4 id="方法一：预剪枝"><a href="#方法一：预剪枝" class="headerlink" title="方法一：预剪枝"></a>方法一：预剪枝</h4><ul>
<li>预剪枝是在决策树生成过程中，如果这个节点进行划分，不能带来<strong>泛化性能</strong>的提升，则停止划分并将该节点设置为叶子节点</li>
<li>缺点：“贪心”策略禁止决策树分支展开，容易导致<strong>欠拟合</strong><br><img src="https://ooo.0o0.ooo/2017/03/04/58baaf4ca5634.png" alt=""> </li>
</ul>
<h4 id="方法二：后剪枝"><a href="#方法二：后剪枝" class="headerlink" title="方法二：后剪枝"></a>方法二：后剪枝</h4><ul>
<li>先训练好一棵树，然后自底向上对非叶子节点进行考察，如果将该节点对应的子树替换为叶节点能不能带来<strong>泛化性能</strong>的提升，能就将该子树替换为叶节点。 </li>
<li>优点：泛化能力好</li>
<li>缺点：时间开销大<br><img src="https://ooo.0o0.ooo/2017/03/04/58baaf656713d.png" alt=""> </li>
</ul>
<p>这里的<strong>泛化性能</strong>利用<strong>模型在测试集上的准确率</strong>来衡量</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】461 HammingDistance]]></title>
      <url>/2017/03/04/leetcode461-HammingDistance/</url>
      <content type="html"><![CDATA[<p>从今天开始每天刷一道LeetCode算法题，可不能再偷懒了</p>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$$</div><div class="line">0  \leq x, y &lt; 2^&#123;31&#125;</div><div class="line">$$</div><div class="line"></div><div class="line">Note:</div><div class="line">0 ≤ x, y &lt; 231.</div><div class="line"></div><div class="line">Example:</div><div class="line"></div><div class="line">Input: x = 1, y = 4</div><div class="line"></div><div class="line">Output: 2</div><div class="line"></div><div class="line">Explanation:</div><div class="line">1   (0 0 0 1)</div><div class="line">4   (0 1 0 0)</div><div class="line">       ↑   ↑</div></pre></td></tr></table></figure>
<p>The above arrows point to positions where the corresponding bits are different.<br>Subscribe to see which companies asked this question.</p>
<h4 id="问题陈述："><a href="#问题陈述：" class="headerlink" title="问题陈述："></a>问题陈述：</h4><p>求两个数的汉明距离，就是找出这两个数的二进制形式对应位不相同的位，求这样的位的个数</p>
<p>用c++的位操作符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取反</td>
<td>0变1,1变0</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td>后面补0</td>
</tr>
<tr>
<td style="text-align:center">>&gt;</td>
<td style="text-align:center">右移</td>
<td>前面补0，后面吞位</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
<td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
<td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>位或</td>
<td>有一个或2个1，则为1。<strong>用于做and运算</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>从末位开始逐位判断x和y是否不同（或者做异或操作），不同则在距离上加1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int hammingDistance(int x, int y) &#123;</div><div class="line">        int count = 0;  </div><div class="line">        while(x!=0||y!=0)&#123;  </div><div class="line">            if ((x&amp;1) != (y&amp;1)) count++;  </div><div class="line">            x = x&gt;&gt;1;  </div><div class="line">            y = y&gt;&gt;1;  </div><div class="line">        &#125;  </div><div class="line">    return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://ooo.0o0.ooo/2017/03/05/58bbb2a9ace36.png" alt=""> </p>
<p>太艰难了，第一道题做了小半天，哎，一定要坚持下去</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol>
<li>《c++ primer》 位操作符 P134</li>
<li><a href="http://blog.csdn.net/a2331046/article/details/53745469" target="_blank" rel="external">wcxdell的专栏</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bit manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh-key]]></title>
      <url>/2017/03/04/ssh-key/</url>
      <content type="html"><![CDATA[<h1 id="hexo发布博客-“enter-passhrase-for-key-‘…-rsa-id’”"><a href="#hexo发布博客-“enter-passhrase-for-key-‘…-rsa-id’”" class="headerlink" title="hexo发布博客 “enter passhrase for key ‘…/rsa_id’”"></a>hexo发布博客 “enter passhrase for key ‘…/rsa_id’”</h1><p>用hexo在github上搭建好自己的博客<br>接下来发布博客，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$hexo d</div></pre></td></tr></table></figure>
<p>每次都会出现“enter passphrase for key ‘…/id_rsa’的问题:</p>
<p><img src="http://p1.bqimg.com/567571/ebf9c8fcc2fd8aef.png" alt=""></p>
<p>原因：可能在之前部署博客生成ssh秘钥的时候误为私钥id_rsa设置了密码</p>
<p>解决方法：重置ssh私钥密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[zsy@desktop]$ cd ~/.ssh/</div><div class="line">[zsy@desktop]$ ssh-keygen -f id_rsa -p   #修改ssh私钥passphrase</div><div class="line">Enter new passphrase (empty for no passphrase):</div><div class="line">Enter old passphrase:     #输入之前设置的密码</div><div class="line">Key has comment id_rsa      #验证通过，允许修改</div><div class="line">Enter new passphrase (empty for no passphrase):     #此时不要再设置密码了 直接按空格！！！</div><div class="line">Enter same passphrase again:</div><div class="line">Your identification has been saved with the new passphrase.</div></pre></td></tr></table></figure>
<p>好了，现在没有密码了，hexo d 不需要再次输入密码了，问题解决了~</p>
]]></content>
      
        <categories>
            
            <category> tips </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>/2017/03/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> test </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
