<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-02T04:31:57.757Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【九章算法强化班】两指针</title>
    <link href="http://yoursite.com/2018/02/02/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E4%B8%A4%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/02/02/【九章算法强化班】两指针/</id>
    <published>2018-02-02T04:31:57.000Z</published>
    <updated>2018-02-02T04:31:57.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol><li>一个数组，从两边往中间移动（对撞型）</li><li>一个数组，同时向前移动（前向型）</li><li>两个数组两根指针（并行型）</li></ol><h2 id="对撞型或相会型"><a href="#对撞型或相会型" class="headerlink" title="对撞型或相会型"></a>对撞型或相会型</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-12-41-27.png" alt=""> </p><h3 id="leetcode-11-Container-With-Most-Water"><a href="#leetcode-11-Container-With-Most-Water" class="headerlink" title="leetcode 11.Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">leetcode 11.Container With Most Water</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>灌水问题，从两边向内灌水，所以初始两个指针ij一头一尾，此时能够容纳的水量是i和j中比较高度的柱子高度*ij两个柱子之间的距离：</p><p>max(height[i] , height[j]) * (j - i)</p><p>然后考虑将柱子向内移动，其实我们只需要移动比较矮的柱子，因为如果移动长的一边的柱子，根据上面的公式，j-i会变短，max(height[i] , height[j])可能变小可能不变，所以总的水量不会增加，所以我们只有移动短的柱子，才有可能会遇到更高的柱子，使得水量增大。</p><p>这样一来，每次选取较短的柱子向内移动，时间复杂度为<script type="math/tex">O(n)</script></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">                max = Math.max(max,(j-i) *height[i]);</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max,(j-i) * height[j]);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Quick-select-—-Kth-Largest-Element-in-an-Array"><a href="#Quick-select-—-Kth-Largest-Element-in-an-Array" class="headerlink" title="Quick select — Kth Largest Element in an Array"></a>Quick select — <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p></blockquote><p>在一组数字中找到第K大的数字</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一：可以用堆，维护一个大小为K的堆，将数字依次加入堆，找到第k大，时间复杂度<script type="math/tex">O(nlogk)</script></p><p>方法二：quick select，基于quick sort的思想</p><ol><li>每次在数组中随机选取一个数组作为pivort，这里面随机选取，经过大量的验证，选取中间位置的数字作为pivot比较稳妥。</li><li>然后和快排一样，将比它小的放在它左边，比它大的放在右边，找到pivot的位置即是pivot的最终位置。<ol><li>如果此时pivot的位置==k-1，找到了</li><li>如果此时pivot的位置 &gt;k-1，只需在pivot左边寻找第k大</li><li>如果此时pivot的位置 &lt;k-1，只需在pivot右边寻找第k-pivot大</li></ol></li></ol><p>这种方法的时间复杂度为<script type="math/tex">O(n)+O(n/2)+O(n/4)+...+O(1) = O(2n) = O(n)</script></p><p>两种方法的比较：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-15-34-03.png" alt=""> </p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h3 id="lintcode-399-Nuts-amp-Bolts-Problem"><a href="#lintcode-399-Nuts-amp-Bolts-Problem" class="headerlink" title="lintcode 399.Nuts &amp; Bolts Problem"></a><a href="https://www.lintcode.com/en/problem/nuts-bolts-problem/" target="_blank" rel="external">lintcode 399.Nuts &amp; Bolts Problem</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;一个数组，从两边往中间移动（对撞型）&lt;/li&gt;
&lt;li&gt;一个数组，同时向前移动（前向型）
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2018/01/31/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/01/31/堆排序/</id>
    <published>2018-01-31T10:55:23.000Z</published>
    <updated>2018-01-31T10:55:23.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】从用户系统理解数据库和缓存</title>
    <link href="http://yoursite.com/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/01/30/【九章系统设计】从用户系统理解数据库和缓存/</id>
    <published>2018-01-30T15:49:17.000Z</published>
    <updated>2018-01-30T15:49:17.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ul><li>Design User System用户系统<ul><li>Mencached 优化数据库查询软件</li><li>Authentication 用户验证</li><li>SQL VS NoSQL 如何选取数据库</li><li>Friendship 存储好友关系（不用graph DB用什么）</li></ul></li><li>How to Scale?<ul><li>Sharding</li><li>Consistent Hashing(第5节)</li><li>Replica(第5节)</li></ul></li></ul><h2 id="4S分析"><a href="#4S分析" class="headerlink" title="4S分析"></a>4S分析</h2><ul><li><p>Scenario场景</p><ul><li><p>注册、登录、查询、用户修改信息</p><p>哪个需求量最大？查询最大，因为用户登录时给他展示的各种信息邓邓就是通过查询出来的结果</p></li><li><p>支持100M DAU(每日登录用户数)</p></li><li><p>注册，登录，信息修改QPS约：</p><ul><li>100M*0.1/86400 ~ 100</li><li>0.1=平均每个用户每天登陆+注册+信息修改</li><li>Peak = 100*3 = 300</li></ul></li><li><p>查询的QPS约为：</p><ul><li>100M*100/86400 ~ 100k</li><li>100 = 平均每个用户每天查询与用户信息相关的操作次数（查看好友、发信息，更新消息主页等）</li><li>Peak = 100k*3 = 300K</li></ul></li></ul></li><li><p>Service服务</p><ul><li>一个AuthService 负责登录注册</li><li>一个UserService 负责用户信息与存储</li><li>一个FriendshipService存储好友关系</li></ul></li><li><p>Storage:QPS与常用数据存储系统</p><ul><li>MySQL/PostgreSQL等数据库性能<ul><li>约1kQPS</li></ul></li><li>MongoDB/Cassandra等硬盘性NoSQL数据库<ul><li>约10QPS</li></ul></li><li>Redis/memcached等内存型NoSQL数据库性能<ul><li>100k~1mQPS</li></ul></li></ul><p>根据上面的QPS分析，注册、登录、信息修改300QPS，用mysql应该就够了</p><p>用户查询适合什么样的数据存储系统？</p></li></ul><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p><strong>用户系统特点：读非常多，写非常少，一定要用Cache进行优化</strong></p><ul><li>Cache 是什么？<ul><li>缓存，把之后可能要查询的东西先存一下<ul><li>下次用的时候直接从这里拿，无需重新计算和存取数据库</li></ul></li><li>可以理解为一个Java中的HashMap</li><li>key-value的结构</li></ul></li><li>有哪些常用的Cache软件？<ul><li>memcached（不支持数据持久化）</li><li>Redis(支持数据持久化)</li></ul></li><li>Cache一定存在内存中么？<ul><li>不是</li><li>Cache是用于连接不同的介质，解决速度差异的问题</li><li>File System有时候也是一种cache</li><li>CPU也有Cache</li><li>内存是硬盘和CPU的cache</li></ul></li><li>Cache一定是Server Cache 么?<ul><li>不，浏览器也可能有客户端的cache</li></ul></li></ul><h2 id="Mem-Cache"><a href="#Mem-Cache" class="headerlink" title="Mem-Cache"></a>Mem-Cache</h2><p>内存中的Cache</p><p>Memcached：一个内存cache软件，就看成hashmap用</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-31-00-30-58.png" alt=""> </p><p>memcached如何优化DB的查询?</p><p>先去cache中查找，如果没有，再去DB中查找：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-23-56.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-28-05.png" alt=""> </p><p>分析：</p><p>我们认为database中的才是最正确的</p><p>A：database set时可能会出现问题，但没有太大问题，比如你发了一条微博，显示没成功。</p><p>但是如果database成功了，cache更新失败了，那么用户得到的数据都是更新之前的数据。</p><p>B：如果cache成功了，但是database没有成功，cache里存的不是database中的真正数据，看成脏数据。</p><p>C：如果cache delete成功了，但是database更新失败，没关系，还可以去database里面读取</p><p>D：如果database 修改成功了，但是cache失败了，此时用户从cache读取的就是之前的数据</p><p>相比之下C比较好，但是C也存在一定的问题：</p><p>比如第8行和第9行程序，如果我们刚刚获取了user但是这个时候有另一个进程修改了用户信息，此时再更新cache中的user信息就是旧数据了。</p><h2 id="Authentication-Service"><a href="#Authentication-Service" class="headerlink" title="Authentication Service"></a>Authentication Service</h2><ul><li>如何实现用户登录和保持登录</li><li>会话表，session</li></ul><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-44-43.png" alt=""> </p><ul><li>用户Login之后<ul><li>创建一个session对象</li><li>并把seesion_key作为cookie返回给浏览器</li><li>浏览器将该值记录在浏览器的cookie中</li><li>用户每次想服务器发送的访问，都会自动带上该网站所有的cookie</li><li>此时服务器检测到cookie中的session_key是有效的，就认为用户登录了</li></ul></li><li>用户logout之后，从session table中删除对应的数据</li><li>Session table存在哪？<ul><li>数据库？</li><li>缓存？</li><li>都可以？</li><li>理论上都可以的，但是如果只存在cache中，一旦负责cache的机器宕机，就会有很多用户同时需要重新登录，所以存在数据库里更好一些，如果访问用户多的话，可以用cache做优化。</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>对于用户系统而言：<ul><li>写很少</li><li>读很多</li></ul></li><li>写操作很少，意味着<ul><li>从QPS角度来说，一台mysql就够了</li></ul></li><li>读操作很多，意味着<ul><li>可以使用memcached进行读操作的缓存优化</li></ul></li><li>进一步的问题，如果读写操作都很多怎么办？<ul><li>方法一：使用更多的数据库服务器分摊流量</li><li>方法二：使用像Redis这样的读写操作都很快的Cache-through型数据库<ul><li>Memcached是一个Cached-aside型的database,Client需要自己负责管理Cache-miss时的数据的loading</li></ul></li></ul></li></ul><p>35:41</p><p>缓存淘汰算法：</p><ol><li>LRUCache</li><li>LFUCache</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Design User System用户系统&lt;ul&gt;
&lt;li&gt;Mencached 优化数
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java常用笔记</title>
    <link href="http://yoursite.com/2018/01/27/Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/27/Java常用笔记/</id>
    <published>2018-01-27T14:51:05.000Z</published>
    <updated>2018-01-29T10:24:19.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA集合类ArrayList删除指定值元素"><a href="#JAVA集合类ArrayList删除指定值元素" class="headerlink" title="JAVA集合类ArrayList删除指定值元素"></a>JAVA集合类ArrayList删除指定值元素</h2><h3 id="错误做法："><a href="#错误做法：" class="headerlink" title="错误做法："></a>错误做法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i = 0, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    if(list.get(i) == 1) &#123;  </div><div class="line">       list.remove(i);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为删除了元素，但是未改变迭代的下标，这样当迭代到最后一个的时候就会抛异常。</p><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>)&#123;  </div><div class="line">       list.remove(i);  </div><div class="line">       len--;</div><div class="line">       i--;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>更好的一个做法</li></ul><p>List接口内部实现了Iterator接口，提供开发者一个iterator()得到当前list对象的一个iterator对象。所以我们还有一个更好的做法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </div><div class="line">    <span class="keyword">int</span> i = iterator.next();  </div><div class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </div><div class="line">        iterator.remove();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="比较、排序Comparator-Comparable"><a href="#比较、排序Comparator-Comparable" class="headerlink" title="比较、排序Comparator/Comparable"></a>比较、排序Comparator/Comparable</h2><h3 id="1-自定义的类后面需要按指定属性实现排序等操作"><a href="#1-自定义的类后面需要按指定属性实现排序等操作" class="headerlink" title="1.自定义的类后面需要按指定属性实现排序等操作"></a>1.自定义的类后面需要按指定属性实现排序等操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">double</span> salary;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.salary);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-已有模板，定义排序顺序（最大堆、最小堆）"><a href="#2-已有模板，定义排序顺序（最大堆、最小堆）" class="headerlink" title="2.已有模板，定义排序顺序（最大堆、最小堆）"></a>2.已有模板，定义排序顺序（最大堆、最小堆）</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//先定义一个比较器</span></div><div class="line">Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1,Integer e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1 - e2;<span class="comment">//最小堆，默认</span></div><div class="line">         <span class="comment">//return e2-e1;最大堆</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure><p>Long型数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA集合类ArrayList删除指定值元素&quot;&gt;&lt;a href=&quot;#JAVA集合类ArrayList删除指定值元素&quot; class=&quot;headerlink&quot; title=&quot;JAVA集合类ArrayList删除指定值元素&quot;&gt;&lt;/a&gt;JAVA集合类ArrayList删
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】新鲜事系统</title>
    <link href="http://yoursite.com/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/01/27/【九章系统设计】新鲜事系统/</id>
    <published>2018-01-27T13:14:27.000Z</published>
    <updated>2018-01-27T13:14:27.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统涉及面试的两种形式及常见问题"><a href="#系统涉及面试的两种形式及常见问题" class="headerlink" title="系统涉及面试的两种形式及常见问题"></a>系统涉及面试的两种形式及常见问题</h2><h3 id="设计某某系统"><a href="#设计某某系统" class="headerlink" title="设计某某系统"></a>设计某某系统</h3><p>设计微博、滴滴、微信、短网址系统、nosql数据库</p><h3 id="找问题"><a href="#找问题" class="headerlink" title="找问题"></a>找问题</h3><ul><li>网站挂了怎么办</li><li>网站太慢怎么办</li><li>流量增长怎么</li></ul><h3 id="面试官：请设计Twitter"><a href="#面试官：请设计Twitter" class="headerlink" title="面试官：请设计Twitter"></a>面试官：请设计Twitter</h3><h3 id="系统设计问题的4S分析法"><a href="#系统设计问题的4S分析法" class="headerlink" title="系统设计问题的4S分析法"></a>系统设计问题的4S分析法</h3><ul><li>Scenario场景<ul><li>需要设计哪些功能，设计的多牛</li><li>向面试官提问：features/QPS/DAU(日活跃用户)/inerfaces</li></ul></li><li>Servece服务<ul><li>将大系统拆分成小服务</li><li>Split/Application/Module</li></ul></li><li>Storage存储<ul><li>数据如何存储与访问</li><li>Schema(表头字段)/data/sql/nosql/File System</li></ul></li><li>Scale升级<ul><li>解决缺陷，处理可能遇到的问题</li><li>Sharding/optimize/soecial case</li></ul></li></ul><h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><h4 id="Scenario场景-Ask"><a href="#Scenario场景-Ask" class="headerlink" title="Scenario场景-Ask"></a>Scenario场景-Ask</h4><p>询问面试官：</p><ol><li>需要设计哪些功能</li><li>需要承受多大的访问量？<ol><li>日活跃用户DAU</li><li>Twitter:MAU ：313M+ DAU：150M+（一般MAU是DAU的2倍）</li></ol></li></ol><h4 id="Scenario场景-Analyze-amp-predict"><a href="#Scenario场景-Analyze-amp-predict" class="headerlink" title="Scenario场景-Analyze&amp;predict"></a>Scenario场景-Analyze&amp;predict</h4><ul><li>根据DAU计算并发用户数：<ul><li><code>日活跃*每个用户平均请求次数/一天多少秒 = 150M*60/86400 ~100k</code></li><li>峰值peak = 3*QPS ~300k</li><li>快速增长的产品：<ul><li>max peak users in 3 months = peak users*2</li></ul></li></ul></li><li>读频率Read QPS(Queries per second)<ul><li>300k</li></ul></li><li>写频率Write QPS<ul><li>5k</li></ul></li></ul><h4 id="QPS有什么用"><a href="#QPS有什么用" class="headerlink" title="QPS有什么用"></a>QPS有什么用</h4><ul><li>QPS = 100<ul><li>用笔记本做web服务器就可以</li></ul></li><li>QPS = 1k<ul><li>用一台好一点的web服务器就差不多</li><li>需要考虑Single Point Failure</li></ul></li><li>QPS = 1m<ul><li>需要假设一个1000台web服务器的集群</li><li>需要考虑如何Maintanance(某一台挂了怎么办)</li></ul></li><li>QPS和web server/database之间的关系<ul><li>一台web service 承受量是1k QPS</li><li>一台SQL Database 承受量是1k QPS</li><li>一台 no SQL Database 承受量是10k QPS</li></ul></li></ul><h4 id="Scenario场景-需要设计哪些功能"><a href="#Scenario场景-需要设计哪些功能" class="headerlink" title="Scenario场景-需要设计哪些功能"></a>Scenario场景-需要设计哪些功能</h4><ul><li><p>step1:列举需要的功能</p><ul><li>注册、登录</li><li>用户信息展示、编辑</li><li>上传照片、视频</li><li>搜索</li><li>发送、分享推文</li><li>时间轴</li><li>关注、取关用户</li></ul></li><li><p>step2:sort按功能优先级排序</p><p>​</p></li></ul><h3 id="Service服务"><a href="#Service服务" class="headerlink" title="Service服务"></a>Service服务</h3><p>将大的系统拆分为小服务</p><ol><li>replay重放需求</li><li>merge归并需求</li></ol><p><img src="https://i.loli.net/2018/01/17/5a5ec793139ea.png" alt=""> </p><h3 id="storage存储——数据如何存储与访问（最重点占50-）"><a href="#storage存储——数据如何存储与访问（最重点占50-）" class="headerlink" title="storage存储——数据如何存储与访问（最重点占50%）"></a>storage存储——数据如何存储与访问（最重点占50%）</h3><ul><li>关系型数据库SQL Database（结构化数据）MySQL<ul><li>用户信息</li></ul></li><li>非关系型数据库（非结构化数据）MangoDB<ul><li>推文</li><li>社交图谱</li></ul></li><li>文件系统<ul><li>图片、视频（Media files）</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/17/5a5ec9773713d.png" alt=""> </p><p>Step1：为每个service选择合适的存储结构</p><p>Step2：选好合适的存储结构之后，设计数据表的结果，需要存储哪些字段</p><p><img src="https://i.loli.net/2018/01/17/5a5eca2f1b538.png" alt=""> </p><h3 id="新鲜事系统News-Feed"><a href="#新鲜事系统News-Feed" class="headerlink" title="新鲜事系统News Feed"></a>新鲜事系统News Feed</h3><ul><li>什么是新鲜事News Feed?<ul><li>登录Faebook/Twitter/朋友圈之后看到的信息流</li><li>你的所有朋友发的信息的集合</li></ul></li><li>典型新鲜事系统<ul><li>Facebook</li><li>Twitter</li><li>朋友圈</li><li>RSS Reader（头条）</li></ul></li><li>新鲜事系统的核心因素<ul><li>关注与被关注</li><li>每个人看到的新鲜事是不同的</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>Pull模型：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用merge K sorted arrays的思想</div><div class="line">用户的时间线：-&gt;整合成-&gt;feed流</div><div class="line">A：An1,An2,...↘</div><div class="line">B: Bn1,Bn2,...    →An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：Cn1,Cn2,... ↗</div><div class="line">...</div></pre></td></tr></table></figure><ul><li>当用户查看News Feed时，获取其每一个好友的最近100条推文，merge这些推文，按时间排序展示给用户</li><li>复杂度分析：<ul><li>News Feed:加入用户关注了N个对象，则时间为N此DB read的时间（读取数据库）+ N路归并的时间（在内存中计算的O(logK)，时间忽略）读取数据库耗时很长</li><li>Post a tweet:一次DB write（写入数据库）时间</li></ul></li></ul></li><li><p>Push模型：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用户的News Feed List：用户D\E\F发了tweet，推送到其好友的List中</div><div class="line">A：D,E...↘</div><div class="line">B: F,...    →An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：E,F,... ↗</div><div class="line">...</div></pre></td></tr></table></figure><ul><li><p>为每个用户建立一个List存储池存储其好友的News Feed信息，当用户发送一个tweet之后，将该推文推送到每一个关注了他的用户的News Feed中.用户需要查看News Feed时只需要从他的News Feed中读取最近的100条即可</p><p><strong>关键词：Fanout</strong></p></li><li><p>复杂度分析</p><ul><li>News Feed：1次DB read(相比push模型快很多)</li><li>post a tweet：N个粉丝需要N次DB writes<ul><li>如果粉丝数量N巨大，写入粉丝News Feed List耗时大</li><li>但好处是可以用异步任务在后台执行，无需用户等待</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/18/5a5f76ad915ab.png" alt=""> </p><p>所有的用户公用一个表格，当一个用户发送推文时，他自己和他的关注着都将看到，所以插入n+1条数经验，owner_id为他自己和他的好友们，然后读取时在数据表中select owner_id为自己的。</p><p><img src="https://i.loli.net/2018/01/18/5a5f76056f895.png" alt=""> </p><p>Web Server 到Asynct是通过消息队列发送，比如RabitMQ，拿到任务后，先去好友关系表中拿到发文用户的关注者们，然后把消息加入News Feed Table</p><p>缺陷：</p><ol><li><p>浪费数据库，但硬盘很便宜，不需要考虑存储数据量大</p></li><li><p>如果粉丝数量很大，异步操作需要时间，有些粉丝不能及时看到大V发送的tweet</p><p>​</p></li></ol></li></ul></li></ul><h2 id="Design-Twitter"><a href="#Design-Twitter" class="headerlink" title="Design Twitter"></a><a href="https://leetcode.com/problems/design-twitter" target="_blank" rel="external">Design Twitter</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTwitter</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,User&gt; UsersList;</div><div class="line">        <span class="keyword">int</span> tweetTimeStamp = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> id;</div><div class="line">            <span class="keyword">int</span> userId;</div><div class="line">            <span class="keyword">int</span> timeStamp;</div><div class="line">            Tweet(<span class="keyword">int</span> id,<span class="keyword">int</span> useId,<span class="keyword">int</span> timeStamp)&#123;</div><div class="line">                <span class="keyword">this</span>.id = id;</div><div class="line">                <span class="keyword">this</span>.userId = useId;</div><div class="line">                <span class="keyword">this</span>.timeStamp = timeStamp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> uid;</div><div class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;Integer&gt; followers = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//被谁关注</span></div><div class="line">            List&lt;Integer&gt; followees = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//关注了谁</span></div><div class="line">            User(<span class="keyword">int</span> uid)&#123;</div><div class="line">                <span class="keyword">this</span>.uid = uid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</div><div class="line">            UsersList = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Compose a new tweet. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">            &#125;</div><div class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(tweetId,userId,tweetTimeStamp);</div><div class="line">            UsersList.get(userId).tweets.add(tweet);</div><div class="line">            tweetTimeStamp++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">            List&lt;Integer&gt; feeds = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">                <span class="keyword">return</span> feeds;</div><div class="line">            &#125;</div><div class="line">            Comparator&lt;Tweet&gt; cmp = <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet t1,Tweet t2)</span></span>&#123;</div><div class="line">                    <span class="keyword">return</span> t2.timeStamp - t1.timeStamp;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Queue&lt;Tweet&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>,cmp);</div><div class="line">            <span class="comment">//先处理自己的新鲜事</span></div><div class="line">            List&lt;Tweet&gt; ownTweets = UsersList.get(userId).tweets;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = ownTweets.size()-<span class="number">1</span>;i &gt;= ownTweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                heap.add(ownTweets.get(i));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//处理关注的人的新鲜事</span></div><div class="line">            List&lt;Integer&gt; followees = UsersList.get(userId).followees;</div><div class="line">            <span class="keyword">for</span>(Integer followee : followees)&#123;</div><div class="line">                List&lt;Tweet&gt; tweets = UsersList.get(followee).tweets;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tweets.size()-<span class="number">1</span>;i &gt;= tweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                    heap.add(tweets.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty())&#123;</div><div class="line">                feeds.add(heap.poll().id);</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> feeds;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果没有用户，新建用户</span></div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followeeId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followeeId);</div><div class="line">                UsersList.put(followeeId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followerId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followerId);</div><div class="line">                UsersList.put(followerId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || UsersList.get(followerId).followees.contains(followeeId))&#123;<span class="keyword">return</span>;&#125;</div><div class="line">            <span class="comment">//更新用户关注和被关注列表</span></div><div class="line">            UsersList.get(followeeId).followers.add(followerId);</div><div class="line">            UsersList.get(followerId).followees.add(followeeId);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || !UsersList.containsKey(followeeId) || !UsersList.containsKey(followerId) ||</div><div class="line">                    !UsersList.get(followerId).followees.contains(followeeId) || !UsersList.get(followeeId).followers.contains(followerId))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator =  UsersList.get(followeeId).followers.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator.next();</div><div class="line">                <span class="keyword">if</span>(i == followerId)&#123;</div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator2 =  UsersList.get(followerId).followees.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator2.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator2.next();</div><div class="line">                <span class="keyword">if</span>(i == followeeId)&#123;</div><div class="line">                    iterator2.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Twitter obj = <span class="keyword">new</span> Twitter();</div><div class="line">        obj.postTweet(<span class="number">1</span>,<span class="number">5</span>);</div><div class="line">        List&lt;Integer&gt; param_2 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.follow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        obj.postTweet(<span class="number">2</span>,<span class="number">6</span>);</div><div class="line">        List&lt;Integer&gt; param_3 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.unfollow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        List&lt;Integer&gt; param_4 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        DesignTwitter test = <span class="keyword">new</span> DesignTwitter();</div><div class="line">        test.test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实这里有个问题，就是follow unfollow post这些都是用户的操作，应该放在用户类里面的，然后再外部调用。有时间重写一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统涉及面试的两种形式及常见问题&quot;&gt;&lt;a href=&quot;#系统涉及面试的两种形式及常见问题&quot; class=&quot;headerlink&quot; title=&quot;系统涉及面试的两种形式及常见问题&quot;&gt;&lt;/a&gt;系统涉及面试的两种形式及常见问题&lt;/h2&gt;&lt;h3 id=&quot;设计某某系统&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="http://yoursite.com/2018/01/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/01/24/Java垃圾回收机制/</id>
    <published>2018-01-24T07:12:30.000Z</published>
    <updated>2018-01-24T07:12:31.002Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】图与搜索</title>
    <link href="http://yoursite.com/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/01/23/【九章算法基础班】图与搜索/</id>
    <published>2018-01-23T02:52:30.000Z</published>
    <updated>2018-01-25T14:24:22.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><ul><li><p>graph</p><ul><li>Clone Graph</li><li>Topological Sorting</li></ul></li><li><p>Search</p><ul><li><p>DFS</p></li><li><p>BFS:（O(m+n)m为边树，n为点数)</p><ul><li><p>遍历图</p><p>树的BFS需要用队列，在图中除了要用队列还需要用到hash表，用来存储节点是否被访问过</p><p>BFS还可以用于求深度，最短路径</p></li><li><p>简单图求最短路径</p></li><li><p>拓扑排序</p></li></ul></li></ul></li></ul><h2 id="BFS例题"><a href="#BFS例题" class="headerlink" title="BFS例题"></a>BFS例题</h2><h3 id="1-Clone-Graph"><a href="#1-Clone-Graph" class="headerlink" title="1. Clone Graph"></a>1. <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">Clone Graph</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p><p>OJ’s undirected graph serialization:</p><p>Nodes are labeled uniquely.</p><p> We use <code>#</code>as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.</p><p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.</p><p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p><ol><li>First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.</li><li>Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.</li><li>Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.</li></ol><p>Visually, the graph looks like the following:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      /   \</div><div class="line">&gt;     0 --- 2</div><div class="line">&gt;          / \</div><div class="line">&gt;          \_/</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定图中的一个节点，克隆整个图</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>考点：</p><ol><li>从一个点出发，把整张图的所有节点找到（BFS）nodes</li><li>获得nodes之后复制所有的点，将新老节点建立映射关系，存入hashmap中</li><li>根据老节点之间的关系和新老节点的映射关系，复制所有的边</li><li>最后返回给定的node对应的新节点</li></ol><p>还可以用DFS：</p><p>递归调用复制节点和邻居关系。</p><p>DFS的输入是旧结点，返回值是新节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphClone</span> </span>&#123;</div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> label;</div><div class="line">         List&lt;UndirectedGraphNode&gt; neighbors;</div><div class="line">         UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</div><div class="line">     &#125;</div><div class="line">     HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//用于存储新旧节点映射关系</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; oldNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//旧结点</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; newNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新节点</span></div><div class="line"></div><div class="line">    <span class="comment">//bfs获取图中所有的点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node)</span></span>&#123;</div><div class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        HashSet&lt;UndirectedGraphNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        queue.add(node);</div><div class="line">        set.add(node);</div><div class="line">        <span class="comment">//BFS</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            UndirectedGraphNode temp = queue.poll();</div><div class="line">            UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(temp.label);</div><div class="line">            oldNodes.add(temp);<span class="comment">//加入旧点集</span></div><div class="line">            newNodes.add(newNode);<span class="comment">//加入新点集</span></div><div class="line">            nodeMap.put(temp,newNode);<span class="comment">//加入mapping</span></div><div class="line"></div><div class="line">            <span class="comment">//遍历当前节点的所有邻居</span></div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : temp.neighbors)&#123;</div><div class="line">                <span class="comment">//如果已经加入结合了，跳过</span></div><div class="line">                <span class="keyword">if</span>(set.contains(neighbor))&#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果还未加入</span></div><div class="line">                queue.add(neighbor);</div><div class="line">                set.add(neighbor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取图中所有的节点</span></div><div class="line">        bfs(node);</div><div class="line">        <span class="comment">//复制所有的边</span></div><div class="line">        <span class="keyword">for</span>(UndirectedGraphNode oldNode : oldNodes)&#123;</div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : oldNode.neighbors)&#123;</div><div class="line">                nodeMap.get(oldNode).neighbors.add(nodeMap.get(neighbor));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回node对应的新节点</span></div><div class="line">        <span class="keyword">return</span> nodeMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DFS：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">dfs</span><span class="params">(UndirectedGraphNode node,HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(map.containsKey(node))&#123;</div><div class="line">        <span class="keyword">return</span> map.get(node);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新建节点</span></div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node,newNode);</div><div class="line">    <span class="comment">//遍历邻居节点</span></div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">        newNode.neighbors.add(dfs(neighbor,map));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">    HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(node,map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h3><p>下面这个图假设是一种上课顺序，比如上1之前必须上0。求这个图的任意一个拓扑排序（按照这个顺序上课则可以上完所有课）</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></a></p><p>拓扑排序很好的参考资料：<a href="http://www.stoimen.com/blog/2012/10/01/computer-algorithms-topological-sort-of-a-graph/" target="_blank" rel="external">Topological Sort of a Graph</a></p><p>拓扑排序的思路如下：</p><ol><li>统计当前入度为0的点，加入队列</li><li>将当前所有入度为0的点删掉，并将这些点的下一点的连线删掉，将其下一个节点的入度减1</li><li>重复1和2，直到所有的点都被删掉</li><li>如果不能拓扑排序说明图中一定有环</li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" alt="img"></a></p><h3 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a><a href="http://www.lintcode.com/en/problem/topological-sorting/" target="_blank" rel="external">Topological Sorting</a></h3><blockquote><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p><ul><li>For each directed edge <code>A -&gt; B</code> in graph, A must before B in the order list.</li><li>The first node in the order can be any node in the graph with no nodes direct to it.</li></ul><p>Find any topological order for the given graph.</p><p>Example</p><p>For graph as follow:</p></blockquote><p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></p><blockquote><p>The topological order can be:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [0, 1, 2, 3, 4, 5]</div><div class="line">&gt; [0, 2, 3, 1, 5, 4]</div><div class="line">&gt; ...</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>核心就是根据拓扑排序给出一条合理的路径，能够遍历图中所有的点，且不违背箭头顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    HashMap&lt;DirectedGraphNode,Integer&gt; degreeIn = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    Queue&lt;DirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    ArrayList&lt;DirectedGraphNode&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//计算入度出度</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode nodeFrom : graph) &#123;</div><div class="line">        <span class="keyword">for</span> (DirectedGraphNode nodeEnd : nodeFrom.neighbors) &#123;</div><div class="line">            <span class="comment">//计算NodeEnd入度</span></div><div class="line">            <span class="keyword">if</span> (!degreeIn.containsKey(nodeEnd)) &#123;</div><div class="line">                degreeIn.put(nodeFrom, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                degreeIn.put(nodeEnd, degreeIn.get(nodeEnd) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs</span></div><div class="line">    <span class="comment">//queue.add(graph.get(0));</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">        <span class="keyword">if</span>(!degreeIn.containsKey(node))&#123;</div><div class="line">            queue.offer(node);</div><div class="line">            results.add(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        DirectedGraphNode node = queue.poll();</div><div class="line">        <span class="comment">//results.add(node);</span></div><div class="line">        <span class="keyword">for</span>(DirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">            degreeIn.put(neighbor,degreeIn.get(neighbor)-<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(degreeIn.get(neighbor) == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(neighbor);</div><div class="line">                results.add(neighbor);</div><div class="line">                <span class="comment">//numNodes--;</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule" target="_blank" rel="external">Course Schedule</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0]]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0],[0,1]]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p></blockquote><p>给定课程门数，和课程之间的依赖关系，判断是否可以无冲突完成课程。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>BFS和DFS都可以做</p><p>BFS：</p><p>拓扑排序的思想，如果最后所有的点都被访问到了，就是可以的，反之不可以。</p><p>DFS：</p><p>用DFS的核心思想就是遇到某条路径上有环就可以返回false，不用继续判断了。所以需要用一个visited数组来保存节点的访问状态。当沿着某一条路径前进时遇到之前已经访问过的节点，就返回false，如果一直没有出现环则在最后返回true。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] classDegreeIn = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录入度</span></div><div class="line">        <span class="keyword">int</span>[] classDegreeOut = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录出度</span></div><div class="line">        HashMap&lt;Integer,List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            classDegreeIn[edgeEnd]++;</div><div class="line">            classDegreeOut[edgeFrom]++;</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom,<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom,listTemp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//寻找入度为0的点入栈</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numCourses;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(classDegreeIn[i] == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(i);</div><div class="line">                counter++;</div><div class="line">                <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">                hasVisited[i] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> classID = queue.poll();</div><div class="line">            <span class="keyword">if</span>(edges.getOrDefault(classID,<span class="keyword">new</span> ArrayList&lt;&gt;()).size() == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历classID的所有邻居，将其入度-1</span></div><div class="line">            <span class="keyword">for</span>(Integer neighbor : edges.get(classID))&#123;</div><div class="line">                classDegreeIn[neighbor]--;</div><div class="line">                <span class="comment">//如果入度为0,入栈</span></div><div class="line">                <span class="keyword">if</span>(classDegreeIn[neighbor] == <span class="number">0</span>)&#123;</div><div class="line">                    queue.add(neighbor);</div><div class="line">                    counter++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter == numCourses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DFS：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used,HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges,Integer node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(used[node])&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(edges.containsKey(node)) &#123;</div><div class="line">            used[node] = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(Integer next: edges.get(node))&#123;</div><div class="line">                <span class="keyword">if</span>(!dfs(used,edges,next))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            used[node] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line"></div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom, <span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom, listTemp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Integer node : edges.keySet())&#123;</div><div class="line">            <span class="keyword">if</span>(!dfs(used,edges,node))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p></blockquote><p>求从起点到终点的最短路径长度</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>求路径长度一般用BFS，从起点开始把相差一个字母的单词一次入队列，知道遇到结束词时， 此时bfs的深度就是最短路径长度。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(beginWord);</div><div class="line">        <span class="keyword">int</span> step = <span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> queueSize = queue.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;</div><div class="line">                String temp  = queue.peek();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">                        <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;</div><div class="line">                            <span class="keyword">return</span> step;</div><div class="line">                        &#125;</div><div class="line">                        queue.add(wordList.get(j));</div><div class="line">                        isUsed[j] = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                queue.poll();</div><div class="line">            &#125;</div><div class="line">            step++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">        <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a><a href="https://leetcode.com/problems/word-ladder-ii" target="_blank" rel="external">Word Ladder II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>Return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</div><div class="line">&gt;   ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>返回所有的路径长度最短的合法路径。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>找到合法路径，考虑用BFS，找到所有合法的路径，考虑用DFS，这道题目要求找到路径最短的所有合法路径，所以是一道BFS和DFS的综合题目。</p><p>如果只用DFS找的话，要遍历所有的路径，势必会超时（我试了，真的超时）</p><p>所以采用dfs和bfs结合的办法：</p><p>先从endWord到beginWord用BFS找到最短的路径是多少，同时标记经过的点到endWord的最短距离是多少</p><p>然后再用DFS从beginWord到endWord找到确定的路径，此时只需要遍历之前遍历过的点，其余的没有经过的点无需遍历，而且可以按距离顺序来遍历，将所有合法的路径加入的结果结合中。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] disToBegin;<span class="comment">//记录距离起点的距离</span></div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs从后向前寻找最短路径长度,标记点到终点的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(endWord);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//endword深度为0</span></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            depth++;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                String temp = queue.poll();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;wordList.size();i++)&#123;</div><div class="line">                    String word = wordList.get(i);</div><div class="line">                    <span class="comment">//如果单词已经加入过队列了，或者和当前节点相差不为1，跳过</span></div><div class="line">                    <span class="keyword">if</span>(word.equals(endWord) || disToBegin[i] &gt; <span class="number">0</span> || !isValid(temp,word))&#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(word.equals(beginWord))&#123;</div><div class="line">                        <span class="keyword">return</span> depth;<span class="comment">//begin节点深度</span></div><div class="line">                    &#125;</div><div class="line">                    queue.add(word);</div><div class="line">                    disToBegin[i] = depth;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从前向后dfs确定具体路径</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String tempWord, String endWord,List&lt;String&gt; wordList,<span class="keyword">int</span> depth)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            temp.add(endWord);</div><div class="line">            results.add(temp);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disToBegin.length;i++)&#123;</div><div class="line">            String wordNext = wordList.get(i);</div><div class="line">            <span class="comment">//寻找深度和字母都符合的单词</span></div><div class="line">            <span class="keyword">if</span>(disToBegin[i] != depth || !isValid(tempWord,wordNext))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(wordNext);</div><div class="line">            dfs(wordNext,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//List&lt;String&gt; words = new ArrayList&lt;&gt;(wordList);</span></div><div class="line">        wordList.add(beginWord);</div><div class="line">        disToBegin = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</div><div class="line">        <span class="keyword">int</span> depth = bfs(beginWord,endWord,wordList);</div><div class="line">        result.add(beginWord);</div><div class="line">        dfs(beginWord,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="DFS排列组合"><a href="#DFS排列组合" class="headerlink" title="DFS排列组合"></a>DFS排列组合</h2><p>排列：</p><p><a href="https://leetcode.com/problems/permutations" target="_blank" rel="external">Permutations</a>   </p><p><a href="https://leetcode.com/problems/permutations-ii" target="_blank" rel="external">Permutations II</a>   </p><p>组合：</p><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning" target="_blank" rel="external">Palindrome Partitioning</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,<br>Return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>DFS，对字符串进行分割</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            i++;j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//规定左段包含i,右段不包含i</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end;i++)&#123;</div><div class="line">            String left = s.substring(start,i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(!Palindrome(left))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(left);</div><div class="line">            helper(s,i+<span class="number">1</span>,end);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        helper(s,<span class="number">0</span>,s.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/combination-sum" target="_blank" rel="external">Combination Sum</a> </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>找所有方案的问题一般都是DFS，90%的DFS是排列或者组合。</p><h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 <a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="external">Matrix</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p><p>The distance between two adjacent cells is 1.</p><p><strong>Example 1: </strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2: </strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 1 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 2 1</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>计算每个点距离最近的0的距离</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一:</p><p>用BFS，先将所有0的位置放入队列，然后出队列，将其周围点置位1，如队列，然后出队，将其周围点置为2，以此类推。</p><p>方法二：</p><p>动态规划，先从左上到右下计算每个点离最近的0的距离</p><p>然后从右下到左上再来一遍</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">  <span class="keyword">int</span> rows = matrix.length;</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">        dist[i][j] = <span class="number">0</span>;</div><div class="line">        queue.add(i*cols+j);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        dist[i][j] = -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size&gt;<span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> location = queue.poll();</div><div class="line">      <span class="keyword">int</span> row = location/cols;</div><div class="line">      <span class="keyword">int</span> col = location%cols;</div><div class="line">      <span class="keyword">int</span>[] rdelta = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">      <span class="keyword">int</span>[] cdelta = &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> new_row = row+rdelta[i];</div><div class="line">        <span class="keyword">int</span> new_col = col+cdelta[i];</div><div class="line">        <span class="keyword">if</span>(new_row &gt;=<span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_col &lt; cols &amp;&amp; dist[new_row][new_col] == -<span class="number">1</span>)&#123;</div><div class="line">          dist[new_row][new_col] = depth;</div><div class="line">          queue.add(new_row * cols + new_col);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dist;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dist;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="comment">//First pass: check for left and top</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</div><div class="line">                    dist[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    dist[i][j] = rows+cols;</div><div class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//Second pass: check for bottom and right</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Pacific-Atlantic-Water-Flow"><a href="#Pacific-Atlantic-Water-Flow" class="headerlink" title="Pacific Atlantic Water Flow"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="external">Pacific Atlantic Water Flow</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p><p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p><p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p><p><strong>Note:</strong></p><ol><li>The order of returned grid coordinates does not matter.</li><li>Both <em>m</em> and <em>n</em> are less than 150.</li></ol><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 5x5 matrix:</div><div class="line">&gt;</div><div class="line">&gt;   Pacific ~   ~   ~   ~   ~ </div><div class="line">&gt;        ~  1   2   2   3  (5) *</div><div class="line">&gt;        ~  3   2   3  (4) (4) *</div><div class="line">&gt;        ~  2   4  (5)  3   1  *</div><div class="line">&gt;        ~ (6) (7)  1   4   5  *</div><div class="line">&gt;        ~ (5)  1   1   2   4  *</div><div class="line">&gt;           *   *   *   *   * Atlantic</div><div class="line">&gt; Return:</div><div class="line">&gt; [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>矩阵左上是pacific 右下是atlantic,找出所有水能够同时流向两个ocean的位置</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用dfs，对pacific ocean从边缘的每一个点向内dfs搜索可以到达的点，就是考虑每一个点的上下左右四个邻居是否比自己高，如果比自己高而且之前还没有遍历过，就继续dfs。对atlantic做同样的操作。两边都可以到达的加入结果集。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] pacific,<span class="keyword">boolean</span>[][] used)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; rows || j &gt; cols)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        pacific[i][j] = <span class="keyword">true</span>;</div><div class="line">        used[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span>[] r_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] c_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> id = <span class="number">0</span> ; id  &lt; <span class="number">4</span>; id++)&#123;</div><div class="line">            <span class="keyword">int</span> new_row = i + r_delta[id];</div><div class="line">            <span class="keyword">int</span> new_col = j + c_delta[id];</div><div class="line">            <span class="keyword">if</span>(new_row &gt;= <span class="number">0</span> &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &lt; cols &amp;&amp; !used[new_row][new_col] &amp;&amp;matrix[new_row][new_col] &gt;= matrix[i][j])&#123;</div><div class="line">                <span class="comment">//pacific[new_row][new_col] = true;</span></div><div class="line">                dfs(matrix,new_row,new_col,pacific,used);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] pacific = n，ew <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理pacific</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[0][i] = true;</span></div><div class="line">            dfs(matrix,<span class="number">0</span>,i,pacific,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][0] = true;</span></div><div class="line">            dfs(matrix,i,<span class="number">0</span>,pacific,used);</div><div class="line">        &#125;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理atlantic</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[rows-1][i] = true;</span></div><div class="line">            dfs(matrix,rows-<span class="number">1</span>,i,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][cols-1] = true;</span></div><div class="line">            dfs(matrix,i,cols-<span class="number">1</span>,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//两个都是true的位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])&#123;</div><div class="line">                    results.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="external">Minesweeper</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定棋盘和点击的点，返回点击之后的棋盘</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>分两种情况讨论，如果点到的地雷，就显示地雷即可；</p><p>如果没有点到地雷，则要从这个点开始dfs计算其周围的每个点周围的8个点处有多少个地雷，如果没有就改成B，如果有的话显示数字。对于显示数字的点就无需继续dfs其周围的点了。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minesweeper</span> </span>&#123;</div><div class="line">    <span class="comment">//计算某个位置周围有多少个地雷</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calSweeper</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">            <span class="keyword">if</span>(i+x_delta[ii] &lt; <span class="number">0</span> || j+y_delta[ii] &lt; <span class="number">0</span> || i+x_delta[ii] &gt;= rows || j+y_delta[ii] &gt;= cols)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(board[i+x_delta[ii]][j+y_delta[ii]] == <span class="string">'M'</span>)&#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="comment">//如果出界了，返回</span></div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || board[i][j] == <span class="string">'B'</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'E'</span>)&#123;</div><div class="line">            <span class="keyword">int</span> sum = calSweeper(board,i,j);</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'B'</span>;</div><div class="line">                <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">                <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">                    <span class="comment">//如果还没点过，计算它周围有多少个地雷</span></div><div class="line">                    dfs(board,i+x_delta[ii],j+y_delta[ii]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                board[i][j] = Integer.toString(sum).charAt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="comment">//如果点到地雷</span></div><div class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)&#123;</div><div class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没点到地雷</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(board,click[<span class="number">0</span>],click[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Minesweeper test = <span class="keyword">new</span> Minesweeper();</div><div class="line">        <span class="keyword">char</span>[][] board = &#123;&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'M'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;&#125;;</div><div class="line">        <span class="keyword">char</span>[][] result = test.updateBoard(board,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">0</span>&#125;);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="external">Minimum Height Trees</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p><p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p><p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p><p><strong>Example 1:</strong></p><p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         0</div><div class="line">&gt;         |</div><div class="line">&gt;         1</div><div class="line">&gt;        / \</div><div class="line">&gt;       2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[1]</code></p><p><strong>Example 2:</strong></p><p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0  1  2</div><div class="line">&gt;       \ | /</div><div class="line">&gt;         3</div><div class="line">&gt;         |</div><div class="line">&gt;         4</div><div class="line">&gt;         |</div><div class="line">&gt;         5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[3, 4]</code></p></blockquote><p>选取图中某一点作为root，使得形成的树高度最小，返回所有高度最小的root点。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用BFS计算了每一个点作为root的深度，超时了。。。。</p><p>逐层去掉叶子节点，留下的就是作为root树高最小的节点。思路不难，但还是写了好久</p><p>步骤：</p><ol><li>存储图中节点的度数和点边关系</li><li>把度数为1的节点加入叶子节点集合</li><li>遍历叶子节点，将与之相连的节点的度数-1，然后将叶子节点删除，同时，如果有节点的度数为1，说明是下一层的叶子节点，加入新叶子集合</li><li>当新叶子集合的大小&lt;=2时，说明找到了最终的MHT的root</li></ol><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界条件处理</span></div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            res.add(<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储点边关系</span></div><div class="line">        List&lt;HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            map.add(<span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="keyword">int</span>[] edgesNum = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储节点的度数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;edges.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> node1 = edges[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> node2 = edges[i][<span class="number">1</span>];</div><div class="line">            edgesNum[node1]++;</div><div class="line">            edgesNum[node2]++;</div><div class="line">            map.get(node1).add(node2);</div><div class="line">            map.get(node2).add(node1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> counter = n;</div><div class="line">      <span class="comment">//叶子节点加入结合</span></div><div class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(edgesNum[i] == <span class="number">1</span>)&#123;</div><div class="line">                leaves.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//遍历叶子节点，将与之相连的点的度数-1，删去叶子节点</span></div><div class="line">        <span class="keyword">while</span> (counter &gt; <span class="number">2</span>)&#123;</div><div class="line">            counter -= leaves.size();</div><div class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存储下一轮的新叶子节点</span></div><div class="line">            <span class="keyword">for</span>(Integer leave : leaves)&#123;</div><div class="line">                edgesNum[leave]--;</div><div class="line">                <span class="keyword">for</span>(Integer node : map.get(leave))&#123;</div><div class="line">                    edgesNum[node]--;</div><div class="line">                    <span class="keyword">if</span>(edgesNum[node] == <span class="number">1</span>)&#123;<span class="comment">//遇到度数为1的节点就是下一轮的叶子节点</span></div><div class="line">                        newLeaves.add(node);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            leaves = newLeaves;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Maze"><a href="#The-Maze" class="headerlink" title="The Maze"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="external">The Maze</a></h3><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><blockquote><p>There is a <strong>ball</strong> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <strong>up</strong>, <strong>down</strong>, <strong>left</strong> or <strong>right</strong>, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p><p>Given the ball’s <strong>start position</strong>, the <strong>destination</strong> and the <strong>maze</strong>, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of <strong>empty spaces</strong> traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p><p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p><p><strong>Example 1</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (4, 4)</div><div class="line">&gt;</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: One shortest way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</div><div class="line">&gt;              The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (3, 2)</div><div class="line">&gt;</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: There is no way for the ball to stop at the destination.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>矩阵中1是障碍，0是通的，小球从start滚到destination，不遇到障碍或者边界小球不会停下来，返回小球是否可以从start滚到end</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>BFS，小球从起点开始可以向上下左右四个方向滚，每次滚到障碍或者边界处，滚到终点就返回true</p><p>另外需要一个数组记录小球是否到过该节点，如果到过，后续就无需再走这里了。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">if</span>(node[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; node[<span class="number">1</span>] == destination[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">while</span>(newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>)&#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]])&#123;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii],newStartY - y_delta[ii]&#125;);</div><div class="line">                    visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Maze-II"><a href="#The-Maze-II" class="headerlink" title="The Maze II"></a><a href="https://leetcode.com/problems/the-maze-ii" target="_blank" rel="external">The Maze II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>跟上一题一样，这个题要求返回从起点滚到终点的最短路径长度。如果滚不到就返回-1</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>用一个二维数组记录地图中的点到start的距离。BFS更新计算start到能够到达的点的最小距离，最后返回二维数组中的终点的值。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;distance.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; distance[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                distance[i][j] = Integer.MAX_VALUE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录走了多少步</span></div><div class="line">                <span class="keyword">while</span> (newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>) &#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果这条路径到达该点比之前的距离短，更新该点的最短距离</span></div><div class="line">                <span class="keyword">if</span> (distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count &lt; distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]]) &#123;</div><div class="line">                    distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]] = distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii], newStartY - y_delta[ii]&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] &lt; Integer.MAX_VALUE ? distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;graph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clone Graph&lt;/li&gt;
&lt;li&gt;T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】BFS问题</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90leetcode%E3%80%91BFS%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/20/【leetcode】BFS问题/</id>
    <published>2018-01-20T14:42:20.000Z</published>
    <updated>2018-01-20T14:42:20.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares" target="_blank" rel="external">Perfect Squares</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>典型的BFS题目</p><p>方法：</p><p>需要一个队列记录当前剩余的和。</p><p>首先将n加入队列，然后n出队列，计算小于他的最大平方数，然后递减计算剩余的数字差，如如队列，层数+1</p><p>当队列中有某一层出现剩余的和为0的时候说明找到了一条合法相加形式，此时就是所需的最少数组组合，返回此时的depth即可。</p><p>优化：DP</p><p>dp[n]：记录n可以由几个平方数加和得到</p><p>递推公式：dp[n] = min(dp[n-1]+1,dp[n-4]+1,dp[n-9]+1,……)</p><p>初始化：</p><p>​    dp[0] = 0;</p><p>​    dp[1] = 1;</p><p>返回值：dp[n]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(n);</div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = queue.poll();</div><div class="line">      <span class="comment">//计算小于等于n的最大的平方数</span></div><div class="line">      <span class="keyword">int</span> maxSquare = (<span class="keyword">int</span>) Math.sqrt(temp);</div><div class="line">      <span class="keyword">while</span>(maxSquare &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> sumLeft = temp - maxSquare*maxSquare;</div><div class="line">        <span class="keyword">if</span>(sumLeft == <span class="number">0</span>)&#123;<span class="comment">//和等于0了</span></div><div class="line">          <span class="keyword">return</span> depth;</div><div class="line">        &#125;</div><div class="line">        queue.add(sumLeft);</div><div class="line">        maxSquare--;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//动态规划</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)&#123;</div><div class="line">    <span class="keyword">int</span> dpMinTemp = dp[i-<span class="number">1</span>] +<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= i;j++)&#123;</div><div class="line">      dpMinTemp = Math.min(dpMinTemp,dp[i - j*j] +<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    dp[i] = dpMinTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Perfect-Squares&quot;&gt;&lt;a href=&quot;#Perfect-Squares&quot; class=&quot;headerlink&quot; title=&quot;Perfect Squares&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/pe
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】DFS问题</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90leetcode%E3%80%91DFS%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/20/【leetcode】DFS问题/</id>
    <published>2018-01-20T14:31:36.000Z</published>
    <updated>2018-01-21T06:24:24.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p><p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p><p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p><p>如上图的例子，DFS访问数组为：ABDECFG。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p><p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     struct TreeLinkNode &#123;</div><div class="line">&gt;       TreeLinkNode *left;</div><div class="line">&gt;       TreeLinkNode *right;</div><div class="line">&gt;       TreeLinkNode *next;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li></ul><p>For example,<br>Given the following perfect binary tree,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2    3</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4  5  6  7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>After calling your function, the tree should look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1 -&gt; NULL</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2 -&gt; 3 -&gt; NULL</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4-&gt;5-&gt;6-&gt;7 -&gt; NULL</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>就是将同一层上的节点的next指向右边的节点</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>tag是DFS，但我一开始想到的是BFS。</p><ol><li>BFS：</li></ol><p>将每一层节点加入队列，出队列时，左边节点的next指向右边节点。</p><p>但DFS会更快一些</p><ol><li>DFS：</li></ol><p>用DFS的核心思想是对于一个节点来说，将其左孩子的next指向右孩子，其右孩子的next指向其本身next节点的左孩子。</p><p>题目要求不能引入额外的空间，所以更应该用dfs的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersinEachNode</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> val;</div><div class="line">         TreeLinkNode left, right, next;</div><div class="line">         TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">     &#125;</div><div class="line"><span class="comment">//BFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">        Queue&lt;TreeLinkNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> len = queue.size();</div><div class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//如果是本层最后一个了，其next指向NULL</span></div><div class="line">                TreeLinkNode temp = queue.poll();</div><div class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">                    temp.next = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果不是本层最后一个，其next指向下一个节点</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    temp.next = queue.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.right);</div><div class="line">                &#125;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//DFS</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfshelper</span><span class="params">(TreeLinkNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            root.left.next = root.right;</div><div class="line">            <span class="keyword">if</span>(root.next !=<span class="keyword">null</span>)&#123;</div><div class="line">                root.right.next = root.next.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                root.right.next = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            dfshelper(root.left);</div><div class="line">            dfshelper(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//DFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDFS</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">         root.next = <span class="keyword">null</span>;</div><div class="line">         dfshelper(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \      \</div><div class="line">&gt;         7    2      1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p></blockquote><p>给定二叉树和一个整数sum,返回二叉树中是否存在一条从root到叶子的路径，长度为sum</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>DFS，分别对节点的左右孩子做DFS，sum需减掉当前节点的值。</p><p>当遇到叶子节点，且该点的值==sum时，即找到了一条合法路径，返回true</p><p>这里需要注意的是测试样例中有负数的情况，所以不能根据剩余的sum值进行剪枝。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfshelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//sum == root且root是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(sum == root.val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.left, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.right, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dfshelper(root,sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Path Sum II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \    / \</div><div class="line">&gt;         7    2  5   1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;    [5,4,11,2],</div><div class="line">&gt;    [5,8,4,5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>跟上一题一样的，这次要把合法路径全都记录下来返回。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(root.val);</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.add(root.val);</div><div class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.left,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.right,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        helper(root,sum);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii" target="_blank" rel="external">Path Sum III</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</div><div class="line">&gt;</div><div class="line">&gt;       10</div><div class="line">&gt;      /  \</div><div class="line">&gt;     5   -3</div><div class="line">&gt;    / \    \</div><div class="line">&gt;   3   2   11</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 3  -2   1</div><div class="line">&gt;</div><div class="line">&gt; Return 3. The paths that sum to 8 are:</div><div class="line">&gt;</div><div class="line">&gt; 1.  5 -&gt; 3</div><div class="line">&gt; 2.  5 -&gt; 2 -&gt; 1</div><div class="line">&gt; 3. -3 -&gt; 11</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>跟前面两道的不同是：起止点不一定是root和leaf可以是树中的任意两点</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>方法一：双层递归</p><p>对树中的每一个节点都进行搜索，从该点开始是否有合法路径。</p><p>可以转化为，对根节点搜索sum合法路径，然后对根节点的左右节点分别搜索sum合法路径，其中对其左右节点搜索合法路径时，也需要对其自身和其左右节点分别搜索，这是外层递归</p><p>搜索路径长度本身又是一层递归，每次减掉当前节点val，这是第二层递归</p><p>方法二：前缀长度</p><p>计算从root到每一个节点的路径长度，存储在一个hashmap中，key为root到树种节点的路径长度，value为出现次数。</p><p>当计算到某一个节点时，从root到该节点的路径长度为len，则以该节点为结尾的合法路径的个数为map中key为sum-len的value值。</p><p>注意：每次回退时需要将root到这点的路径长度在hashmap中的value-1。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>方法一：双层递归</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果到当前点已经是合法路径了，res+1</span></div><div class="line">        <span class="keyword">if</span>(root.val == sum)&#123;</div><div class="line">            res++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//接续沿着左右节点寻找是否还有合法路径</span></div><div class="line">        res += helper(root.left,sum - root.val);</div><div class="line">        res += helper(root.right,sum - root.val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：前缀搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum,<span class="keyword">int</span> fromR)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = fromR + root.val;</div><div class="line">        res += map.getOrDefault(temp - sum,<span class="number">0</span>);</div><div class="line">        map.put(temp,map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</div><div class="line">        res = res + helper(root.left,sum,temp)+helper(root.right,sum,temp);</div><div class="line">        map.put(temp,map.get(temp)-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-IV"><a href="#Path-Sum-IV" class="headerlink" title="Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv" target="_blank" rel="external">Path Sum IV</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>If the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.</p><p>For each integer in this list:</p><ol><li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li><li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree.</li><li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li></ol><p>Given a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 215, 221]</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is:</div><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   5   1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 5) + (3 + 1) = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 221]</div><div class="line">&gt; Output: 4</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is: </div><div class="line">&gt;     3</div><div class="line">&gt;      \</div><div class="line">&gt;       1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 1) = 4.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>以数组的形式给定一棵二叉树，用三位数表示节点，其中百位代表层数，十位代表在某一层中从左到右的位置，各位代表节点数值，计算从root到每一个leaf的路径长度之和。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>假设一个几点的百位和十位是xy，则其左孩子和右孩子分别是：</p><p>left：(x+1)(2y-1)</p><p>right：(x+1)(2y)</p><p>可以根据这个性质，将数组中的节点放入hashmap中，key为百位十位，value为节点值。然后在map中寻找左右节点进行DFS，当遍历到叶子节点时，将本条路径长度加入路径长度总和。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> root,<span class="keyword">int</span> res)</span></span>&#123;</div><div class="line">  res += map.get(root);</div><div class="line">  <span class="keyword">int</span> left = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>;</div><div class="line">  <span class="comment">//如果左右都没有了路径了，是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(!map.containsKey(left) &amp;&amp; !map.containsKey(right))&#123;</div><div class="line">    sum += res;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果左边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(left))&#123;</div><div class="line">    dfs(map,left,res);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果右边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(right))&#123;</div><div class="line">    dfs(map,right,res);</div><div class="line">  &#125;</div><div class="line">  res -= map.get(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;nums.length;i++)&#123;</div><div class="line">    map.put(nums[i]/<span class="number">10</span>,nums[i] % <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">  dfs(map,<span class="number">11</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">Flatten Binary Tree to Linked List</a></h4><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;         / \</div><div class="line">&gt;        2   5</div><div class="line">&gt;       / \   \</div><div class="line">&gt;      3   4   6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The flattened tree should look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;       \</div><div class="line">&gt;        3</div><div class="line">&gt;         \</div><div class="line">&gt;          4</div><div class="line">&gt;           \</div><div class="line">&gt;            5</div><div class="line">&gt;             \</div><div class="line">&gt;              6</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>将二叉树压到一条右子树上</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是要将每个节点左子树的前序遍历插入到右子树前面。</p><p>所以我的思路是如果遇到节点root有右子树，就先把右子树存下来，然后dfs处理左子树，当左子树处理完之后，再将右子树插入到左子树。</p><p>DSF的时候，把原来的左子树放到节点的右边，然后节点向下移动，递归处理左子树。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreetoLinkedList</span> </span>&#123;</div><div class="line">    TreeNode temp;<span class="comment">//记录当前节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果右节点不空，先把右边节点存下来</span></div><div class="line">        TreeNode right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            right = <span class="keyword">new</span> TreeNode(root.right.val);</div><div class="line">            right.left = root.right.left;</div><div class="line">            right.right = root.right.right;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果左子树非空，将左子树挪到右边，左子树置为空，temp下移，继续dfs temp的左子树</span></div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = temp.left;</div><div class="line">            temp.left = <span class="keyword">null</span>;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果右节点非空，将之前记录下来的右子树放到temp右边，然后temp下移，继续dfs</span></div><div class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = right;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        temp = root;</div><div class="line">        dfs(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的深度优先遍历&quot;&gt;&lt;a href=&quot;#二叉树的深度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的深度优先遍历&quot;&gt;&lt;/a&gt;二叉树的深度优先遍历&lt;/h2&gt;&lt;p&gt;DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回文问题</title>
    <link href="http://yoursite.com/2018/01/19/%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/19/回文问题/</id>
    <published>2018-01-19T05:55:25.000Z</published>
    <updated>2018-01-19T05:55:25.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串-Longest-Palindromic-Substring"><a href="#最长回文子串-Longest-Palindromic-Substring" class="headerlink" title="最长回文子串 Longest Palindromic Substring"></a>最长回文子串 <a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="external">Longest Palindromic Substring</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最长回文子串-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#最长回文子串-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串 Longest Palin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】数据结构</title>
    <link href="http://yoursite.com/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/19/【九章算法基础班】数据结构/</id>
    <published>2018-01-19T03:44:41.000Z</published>
    <updated>2018-01-30T13:04:32.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ul><li>线性数据结构<ul><li>Queue</li><li>Stack</li><li>HashTable</li></ul></li><li>树形数据结构<ul><li>Heap/Priority Queue</li><li>TreeMap</li></ul></li></ul><h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><ul><li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li><li>考点：宽度优先搜索BFS</li><li>多做做BFS就可以了</li></ul><h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><ul><li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li><li>考点：非递归实现DFS</li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="external">Min Stack</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; MinStack minStack = new MinStack();</div><div class="line">&gt; minStack.push(-2);</div><div class="line">&gt; minStack.push(0);</div><div class="line">&gt; minStack.push(-3);</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -3.</div><div class="line">&gt; minStack.pop();</div><div class="line">&gt; minStack.top();      --&gt; Returns 0.</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -2.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>要求实现一个stack能够在0(1)时间内实现push(x),pop(),top(),getMin()获取最小值</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>额外维护一个stack，存储最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; queue;</div><div class="line">    Stack&lt;Integer&gt; minqueue;</div><div class="line">    <span class="comment">//int min = Integer.MAX_VALUE;</span></div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        minqueue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">if</span>(minqueue.isEmpty())&#123;</div><div class="line">            min = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (x &lt; minqueue.peek()) &#123;</div><div class="line">                min = x;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> min = minqueue.peek();</div><div class="line">        &#125;</div><div class="line">        minqueue.add(min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.pop();</div><div class="line">        minqueue.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minqueue.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="external">Implement Queue using Stacks</a></h3><blockquote><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) — Push element x to the back of queue.</li><li>pop() — Removes the element from in front of queue.</li><li>peek() — Get the front element.</li><li>empty() — Return whether the queue is empty.</li></ul></blockquote><p>用stack实现queue</p><p>stack：先进后出</p><p>queue：先进先出</p><p>需要两个stack实现一个queue。</p><p>push时先将元素压入stack1，然后当pop时，如果stack2非空，就从stack2中pop出一个，否则将stack1中元素全部加入stcak2之后再pop</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack1;</div><div class="line">    Stack&lt;Integer&gt; stack2;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x to the back of queue. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        stack1.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the front element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; stack1.isEmpty())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">Largest Rectangle in Histogram</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="img"></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="img"></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return <code>10</code>.</p></blockquote><p>求直方图中的最大举行的面积。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：</p><p>两个指针i和j分别从前往后扫描，k在i和j之间扫描，找i和j中间最低的柱子Kmin，计算Kmin*(j-i)的最大值。时间复杂度<script type="math/tex">O(n^3)</script></p><p>优化：</p><p>K从左向右遍历，在每一位置，向左看，找到左边第一个比它小的位置i，向右看，找到右边第一个比他小的位置j，此时矩形面积为<script type="math/tex">K*(j-i-1)</script> ，找到最小的即可。时间复杂度<script type="math/tex">O(n^2)</script></p><p>Stack：</p><p>对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左以及向右第一个小于bar n的bar的索引位置。</p><p>我们可以从左到右遍历所有bar，并将其push到一个stack中，如果当前bar的高度小于栈顶bar，我们pop出栈顶的bar，同时以该bar计算矩形面积。那么我们如何知道该bar的ln和rn呢？rn就是当前遍历到的bar的索引，而ln则是弹出当前元素之后的栈顶bar的索引，因为此时栈顶中的元素都是递增的。</p><p>为了更好的处理最后一个bar的情况，我们在实际中会插入一个高度为0的bar，这样就能pop出最后一个bar并计算了。</p><p>stack中存储的是下标！！！</p><p>时间复杂度<script type="math/tex">O(n)</script></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.length;i++)&#123;</div><div class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> size = heights[stack.pop()] * (i-stack.peek()-<span class="number">1</span>);</div><div class="line">                max = Math.max(max,size);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> size = heights[stack.pop()] * (heights.length-stack.peek()-<span class="number">1</span>);</div><div class="line">            max = Math.max(max,size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="external">Maximal Rectangle</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>题目给定一个01矩阵，要求求出矩阵中面积最大的全1矩阵。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://upload-images.jianshu.io/upload_images/424375-2a5a361549e471e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>把每一行看作直方图的底，可以把这个题转化成上一道题，对每一行建立一个直方图，利用stack求直方图中的最大矩形，返回全局最大矩形的面积。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calMax</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span>[] heights)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights.length;j++)&#123;</div><div class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[j] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> area = heights[stack.pop()] * (j - stack.peek()- <span class="number">1</span>);</div><div class="line">                max = Math.max(max,area);</div><div class="line">            &#125;</div><div class="line">            stack.push(j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> area = heights[stack.pop()] * (heights.length - stack.peek()- <span class="number">1</span>);</div><div class="line">            max = Math.max(max,area);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;matrix.length;i++)&#123;</div><div class="line">            <span class="comment">//计算本行heights</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</div><div class="line">                    heights[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heights[j] += <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxArea = Math.max(maxArea,calMax(matrix,heights));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="external">Implement Stack using Queues</a></h3><blockquote><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>empty() — Return whether the stack is empty.</li></ul></blockquote><p>题目要求用队列实现栈。</p><p>方法一：</p><p>用两个queue实现，push时间复杂度<script type="math/tex">O(1)</script> , pop时间复杂度<script type="math/tex">O(n)</script></p><p>push的时候加入queue1:</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-45-34.png" alt=""> </p><p>pop的时候利用queue1，每次pop的时候将queue1中的元素放到queue2，保留一个pop，然后再把queue1和queue2交换，此时queue2又是空的了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-48-38.png" alt=""> </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue1.add(x);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.poll();</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.peek();</div><div class="line">  queue2.add(queue1.remove());</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><p>用两个queue实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p><p>push时先将元素push进queue2,然后将queue2中元素加入queue2，然后交换queue1和queue2</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-02.png" alt=""> </p><p>pop时直接pop q1中元素</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-27.png" alt=""> </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue2.add(x);</div><div class="line">  <span class="keyword">while</span>(!queue1.isEmpty())&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">  &#125;</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.poll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.peek();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法三：</p><p>用一个队列实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</div><div class="line">    Queue&lt;Integer&gt; queue;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x onto stack. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">            queue.add(queue.poll());</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.poll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the top element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="哈希表Hash"><a href="#哈希表Hash" class="headerlink" title="哈希表Hash"></a>哈希表Hash</h1><h3 id="hash-特性"><a href="#hash-特性" class="headerlink" title="hash 特性"></a>hash 特性</h3><ul><li>支持操作：Insert/Find/Delete,时间复杂度都是<script type="math/tex">O(1)</script></li><li>Hash Table/Hash Map/Hash Set的区别是什么？<ul><li>hash set 只有key没有value</li><li>hash table是线程安全的数据结构，hash map线程不安全</li><li>多线程和多进程的区别：线程之间共享同一片内存</li><li>hash table有锁，可以保证同一时间只有一个进程对其进行操作，因此是线程安全的</li></ul></li></ul><h3 id="hash-Table实现"><a href="#hash-Table实现" class="headerlink" title="hash Table实现"></a>hash Table实现</h3><p>通过一个Hash function将key映射到一个大数组中，查找的时候计算下标，直接获取<script type="math/tex">O(1)</script></p><p>Hash function的设计：</p><ul><li>无冲突</li><li>大数组的长度大概是key数量的10倍以上才是安全的</li></ul><p>Hash 函数解决冲突的两种办法：</p><ol><li><p>open hashing</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-20-31.png" alt=""> </p><p>每个位置可以维护一个链表，插入时，遇到冲突就加到链表里；查找时，查找下标对应的链表</p></li><li><p>closed hashing</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-23-30.png" alt=""> </p><p>占坑，如果hash函数计算完发现自己的坑被占了，就依次向后找到空位放进去；查找时，hash函数计算应该在的位置，如果不是该元素，继续向后寻找直到空</p></li></ol><p>rehashing问题</p><p>当已经存储的元素个数已经超过大数组的1/10l了就需要扩大hash表数组了，这就是rehashing问题。</p><p>需要把hash表中现有的元素全部扫描一遍，重新计算其在新的大hash表中的位置，放到新位置。</p><h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul><li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p></li><li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p></li><li><p>Heap结构：</p><p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p></li></ul><ul><li><p>MaxHeap vs MinHeap</p><ul><li>MaxHeap：父亲节点比左右孩子都大</li><li>MinHeap：父亲节点比左右孩子都小</li></ul><p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p></li><li><p>堆的存储</p><p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p><p>对于元素A[i]：</p><ul><li>父节点：A[i-2/2] (右移1)</li><li>左孩子：A[2i+1] (左移1，可得到2i)</li><li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li></ul></li><li><p>插入操作</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span><span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line"><span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure><p>​</p></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">      <span class="number">1</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span><span class="number">2</span></div><div class="line"> ↙  ↘       ↙  ↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span><span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     <span class="number">100</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span><span class="number">2</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">      <span class="number">2</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span>  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">      <span class="number">2</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span>  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">100</span></div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure><p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p><p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p><p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p><p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p></li></ul><h2 id="leetcode相关习题"><a href="#leetcode相关习题" class="headerlink" title="leetcode相关习题"></a>leetcode相关习题</h2><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number" target="_blank" rel="external">Ugly Number</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p><p>Note that <code>1</code> is typically treated as an ugly number.</p></blockquote><p>检验输入数组num是否是unly number：因子只有2,3,5</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>思路就是把num中的2、3、5全部除掉，最后==1了就是ugly number，如果最后不是1，说明还有其他因数，因此返回false</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="external">Ugly Number II</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p><p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p></blockquote><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>从1开始分别乘{2,3,5}，得到2,3,5是ugly number，然后对于2，依次乘2,3,5，得到4,6,10是ugly number，此时ugly number有：1,2,3,4,5,6,10，1,2处理过了，继续处理3，由此，我们需要一个最小堆来维护现有ugly number中还未与2,3,5相乘的最小的，相乘之后加入该堆，同时需要一个hashmap记录已经计算过的ugly number，以免重复入堆。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumberII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">                <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div><div class="line">        Long[] prime = &#123;Long.valueOf(<span class="number">2</span>),Long.valueOf(<span class="number">3</span>),Long.valueOf(<span class="number">5</span>)&#125;;</div><div class="line">        heap.add(Long.valueOf(<span class="number">1</span>));</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</div><div class="line">            Long ugly = heap.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i:prime)&#123;</div><div class="line">                <span class="keyword">if</span>(!set.contains(ugly*i))&#123;</div><div class="line">                    heap.add(ugly*i);</div><div class="line">                    set.add(ugly*i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> heap.peek().intValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Outline&quot;&gt;&lt;a href=&quot;#Outline&quot; class=&quot;headerlink&quot; title=&quot;Outline&quot;&gt;&lt;/a&gt;Outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;线性数据结构&lt;ul&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS &amp; DFS</title>
    <link href="http://yoursite.com/2018/01/16/BFS-DFS/"/>
    <id>http://yoursite.com/2018/01/16/BFS-DFS/</id>
    <published>2018-01-16T13:57:03.000Z</published>
    <updated>2018-01-16T13:57:03.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p></blockquote><p>给定起始单词和结束单词，利用wordlist中的单词爬梯子，每次只允许改变一个字母，返回能够到达结束词的最短路径长度</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一开始用了回溯，相当于暴力了所有可能，超时了，看了解答，这道题应该用广度优先搜索（BFS）：</p><p>需要用到队列<code>Queue</code></p><p>因为要求最短路径，如果我们用深度优先搜索的话必须遍历所有的路径才能确定哪个是最短的，而用广度优先搜索的话，一旦搜到目标就可以提前终止了，而且根据广度优先的性质，我们肯定是先通过较短的路径搜到目标。另外，为了避免产生环路和重复计算，我们找到一个存在于字典的新的词时，就要把它从字典中移去。这么做是因为根据广度优先，我们第一次发现词A的路径一定是从初始词到词A最短的路径，对于其他可能再经过词A的路径，我们都没有必要再计算了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line"><span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">      diffSum++;</div><div class="line">      <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(beginWord);</div><div class="line">  <span class="keyword">int</span> step = <span class="number">2</span>;<span class="comment">//记录层数</span></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> queueSize = queue.size();<span class="comment">//当前queue长度</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;<span class="comment">//遍历queue中元素，将其后续节点入队列</span></div><div class="line">      String temp  = queue.peek();</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">        <span class="comment">//如果该词与队列顶端元素只相差一个字母，入队列，标记为使用过</span></div><div class="line">        <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">          <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;<span class="comment">//一旦找到了endword结束搜索，返回当前层数</span></div><div class="line">            <span class="keyword">return</span> step;</div><div class="line">          &#125;</div><div class="line">          queue.add(wordList.get(j));</div><div class="line">          isUsed[j] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      queue.poll();</div><div class="line">    &#125;</div><div class="line">    step++;<span class="comment">//层数+1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">  isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">  <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Word-Ladder&quot;&gt;&lt;a href=&quot;#Word-Ladder&quot; class=&quot;headerlink&quot; title=&quot;Word Ladder&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【DSP系统】Java UDP通信模拟监听模块</title>
    <link href="http://yoursite.com/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/01/10/【DSP系统】Java-UDP通信模拟监听模块/</id>
    <published>2018-01-10T15:52:29.000Z</published>
    <updated>2018-01-10T16:10:52.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ul><li>无连接，不可靠，会造成数据丢失</li><li>速度快，因为无需进行三次握手</li><li>限制数据传输大小64K</li></ul><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p>发送端模拟ADx发送竞价请求，这里采用从文件中按行读取数据，然后发送给接收端的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//DatagramSocket类表示用来发送和接收(udp)数据报包的套接字。</span></div><div class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</div><div class="line"></div><div class="line">  <span class="comment">//获取本机ip地址</span></div><div class="line">  String localIp = InetAddress.getLocalHost().getHostAddress();</div><div class="line"></div><div class="line">  <span class="comment">//读取文件名</span></div><div class="line">  String fileName = <span class="string">"D://datasets//ipinyou.contest.dataset//ipinyou.contest.dataset//training2nd//training2nd//conv.20130610.txt"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// read file content from file</span></div><div class="line">  <span class="comment">//StringBuffer sb= new StringBuffer("");</span></div><div class="line">  FileReader reader = <span class="keyword">new</span> FileReader(fileName);</div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">  String str = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//sb.append(str+"/n");</span></div><div class="line">    System.out.println(str);</div><div class="line"></div><div class="line">    <span class="comment">//需要发送的数据</span></div><div class="line">    <span class="comment">//byte[] buf = "Hello Udp".getBytes();</span></div><div class="line">    <span class="keyword">byte</span>[] buf = str.getBytes();</div><div class="line"></div><div class="line">    <span class="comment">//将数据传送到本地ip，端口为9999</span></div><div class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getByName(localIp), <span class="number">9999</span>);</div><div class="line"></div><div class="line">    <span class="comment">//发送数据报包</span></div><div class="line">    ds.send(dp);</div><div class="line">  &#125;</div><div class="line">  br.close();</div><div class="line">  reader.close();</div><div class="line"></div><div class="line">  <span class="comment">//关闭资源</span></div><div class="line">  ds.close();</div><div class="line">  System.out.println(<span class="string">"Done."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenModule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建udp服务对象，指定接收端口号为9999的报包</span></div><div class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</div><div class="line"></div><div class="line">        <span class="comment">//构造空的数据报包， 用于存储待会接收到的数据报包</span></div><div class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//接收数据</span></div><div class="line">            ds.receive(dp);</div><div class="line"></div><div class="line">            <span class="comment">//显示数据</span></div><div class="line">            String ipAddress = dp.getAddress().getHostAddress();</div><div class="line">            <span class="keyword">int</span> port = dp.getPort();</div><div class="line">            String datas = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line">            <span class="comment">//System.out.println(ipAddress + "::" + datas + "::" + port);</span></div><div class="line">            System.out.println(datas);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ds.close();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行时先运行接收端，后运行发送端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UDP特点&quot;&gt;&lt;a href=&quot;#UDP特点&quot; class=&quot;headerlink&quot; title=&quot;UDP特点&quot;&gt;&lt;/a&gt;UDP特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无连接，不可靠，会造成数据丢失&lt;/li&gt;
&lt;li&gt;速度快，因为无需进行三次握手&lt;/li&gt;
&lt;li&gt;限制数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DSP系统mysql数据库搭建</title>
    <link href="http://yoursite.com/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/01/09/DSP系统mysql数据库搭建/</id>
    <published>2018-01-09T06:38:41.000Z</published>
    <updated>2018-01-09T06:38:41.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h2><h3 id="执行sql脚本方法："><a href="#执行sql脚本方法：" class="headerlink" title="执行sql脚本方法："></a>执行sql脚本方法：</h3><ol><li>cmd执行</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：</div><div class="line">mysql –uroot –p123456 -D database_name &lt; d:\<span class="built_in">test</span>\ss.sql</div></pre></td></tr></table></figure><ol><li>进入mysql的控制台后，使用source命令执行</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">Mysql&gt;</span><span class="bash"><span class="built_in">source</span> 【sql脚本文件的路径全名】 或 Mysql&gt;\. 【sql脚本文件的路径全名】，示例：</span></div><div class="line">source d:\test\ss.sql 或者 \. d:\test\ss.sql</div></pre></td></tr></table></figure><h3 id="从文件导入数据表"><a href="#从文件导入数据表" class="headerlink" title="从文件导入数据表"></a>从文件导入数据表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx;</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx (colA,colB);</div></pre></td></tr></table></figure><h3 id="auto-increment实现自动递增编号"><a href="#auto-increment实现自动递增编号" class="headerlink" title="auto_increment实现自动递增编号"></a>auto_increment实现自动递增编号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1.建表</div><div class="line">CREATE TABLE IF NOT EXISTS `Bid`(</div><div class="line">  `ID` bigint primary key not NULL auto_increment,</div><div class="line">  `BidId` varchar(255) DEFAULT NULL,</div><div class="line">)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</div><div class="line"><span class="meta">#</span><span class="bash"> AUTO_INCREMENT=0设置开始值</span></div><div class="line">2.导入数据</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE Bid (BidId);</div><div class="line">！！需要注意：利用auto_increment生成的列不能导入数据，只导入后面的字段</div></pre></td></tr></table></figure><h3 id="从一个表选取部分数据插入到另一个表"><a href="#从一个表选取部分数据插入到另一个表" class="headerlink" title="从一个表选取部分数据插入到另一个表"></a>从一个表选取部分数据插入到另一个表</h3><p>两个表都带有auto_increment列</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `bid_1458`;</div><div class="line">CREATE TABLE bid_1458 LIKE bid;</div><div class="line">insert into bid_1458 (colA,colB) select colA,colB from bid where AdvertiserID=1458;</div></pre></td></tr></table></figure><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="shell脚本调用sql"><a href="#shell脚本调用sql" class="headerlink" title="shell脚本调用sql"></a>shell脚本调用sql</h3><ol><li>脚本中执行mysql命令</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1、通过mysql的 -e 参数实现</div><div class="line">mysql -uuser -ppasswd -e "show databases;show databases;"</div><div class="line"></div><div class="line">2、通过echo实现</div><div class="line">echo "show databases;show databases"|mysql -uuser -ppassword</div><div class="line"></div><div class="line">3、通过EOF指定要执行的sql</div><div class="line">mysql -uroot  -ppassword &lt;&lt;EOF</div><div class="line">show databases;</div><div class="line">show databases;</div><div class="line">EOF</div><div class="line"></div><div class="line">关于EOF的说明：</div><div class="line">在主shell执行命令，进入其他的命令（如mysql），后面的输入，想作为其他命令（如mysql）的输入，而不是主shell的输入，使用&lt;&lt;EOF，告诉主shell，后续的输入，是其他命令或者子shell的输入，直到遇到EOF为止，再回到主shell。</div></pre></td></tr></table></figure><ol><li>脚本中执行mysql的sql文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1. mysql -uroot -ppassword -e "source /root/temp.sql" </div><div class="line">2. mysql -uroot -ppassword &lt;/root/temp.sql</div></pre></td></tr></table></figure><h3 id="shell脚本字符串连接"><a href="#shell脚本字符串连接" class="headerlink" title="shell脚本字符串连接"></a>shell脚本字符串连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">AAA="abc"</div><div class="line">BBB="def"</div><div class="line">CCC=$AAA$BBB"ghi"</div><div class="line">echo $ccc</div></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">echo $contetn &gt; write.txt#写入</div><div class="line">echo $contetn &gt;&gt; write.txt#追加写入</div></pre></td></tr></table></figure><h2 id="ipinyou2nd数据分析"><a href="#ipinyou2nd数据分析" class="headerlink" title="ipinyou2nd数据分析"></a>ipinyou2nd数据分析</h2><h3 id="广告主"><a href="#广告主" class="headerlink" title="广告主"></a>广告主</h3><p>一共有5个广告主，其中有转化数据的只有3个：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; select distinct AdvertiserId from click;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3476 |</div><div class="line">|         3358 |</div><div class="line">|         3386 |</div><div class="line">|         3427 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select distinct AdvertiserId from conv;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3358 |</div><div class="line">|         3476 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">3 rows in set (0.06 sec)</div><div class="line">其中3476的数据相对较少</div></pre></td></tr></table></figure><p>AdvertiserID_3476</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">bid:<span class="number">6712268</span></div><div class="line">impression:<span class="number">1970360</span></div><div class="line">click:<span class="number">1092</span></div><div class="line">conv:<span class="number">27</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL操作&quot;&gt;&lt;a href=&quot;#MySQL操作&quot; class=&quot;headerlink&quot; title=&quot;MySQL操作&quot;&gt;&lt;/a&gt;MySQL操作&lt;/h2&gt;&lt;h3 id=&quot;执行sql脚本方法：&quot;&gt;&lt;a href=&quot;#执行sql脚本方法：&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】数与数组</title>
    <link href="http://yoursite.com/2017/12/24/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/12/24/【九章算法基础班】数与数组/</id>
    <published>2017-12-24T15:13:33.000Z</published>
    <updated>2018-01-09T16:52:46.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol><li>Sorted Array<ul><li>merge two sorted array<ul><li>Intersection of Two Arrays</li><li>Multiply Two Arrays</li></ul></li><li>median of two sorted array</li></ul></li><li>Subarray<ul><li>Best Time to Buy and Sekk Stoocks I,II,III</li><li>Subarrat I,II,III,IV</li></ul></li><li>Two pointers<ul><li>Two Sum,3Sum,4Sum,kSum,3Sum Closest</li><li>Partition Array</li></ul></li></ol><h1 id="排序数组Sorted-Array"><a href="#排序数组Sorted-Array" class="headerlink" title="排序数组Sorted Array"></a>排序数组Sorted Array</h1><h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><blockquote><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong><br>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p></blockquote><p>给定两个排序数组nums1,nums2，合并到nums1</p><p>三个指针i,j,k分别指向nums1元素结尾，nums2结尾，nums1数组结尾</p><p>依次向前遍历，比较大小，插入nums1</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(j &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(i &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">                k--</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="external">Intersection of Two Arrays</a></h3><blockquote><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p><p><strong>Note:</strong></p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul></blockquote><p>给定两个数组，返回交集，返回的交集中在原数组中的相对位置保持不变，元素只出现一次。</p><p>方法:</p><ol><li>把两个数组排序</li><li>两指针分别遍历两个数组比较大小，如果两指针指向的元素相等，且与result中前一个元素不相等，加入result</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</div><div class="line">                <span class="keyword">if</span>(index == <span class="number">0</span> || nums1[i] != result[index-<span class="number">1</span>])&#123;</div><div class="line">                    result[index] = nums1[i];</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;nums2[j])&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                j++ ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>;idx &lt; index;idx++) &#123;</div><div class="line">            res[idx] = result[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Sparse-Matrix-Multiplication"><a href="#Sparse-Matrix-Multiplication" class="headerlink" title="Sparse Matrix Multiplication"></a><a href="https://leetcode.com/problems/sparse-matrix-multiplication/" target="_blank" rel="external">Sparse Matrix Multiplication</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank" rel="external">sparse matrices</a> <strong>A</strong> and <strong>B</strong>, return the result of <strong>AB</strong>.</p><p>You may assume that <strong>A</strong>‘s column number is equal to <strong>B</strong>‘s row number.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A = [</div><div class="line">&gt;   [ 1, 0, 0],</div><div class="line">&gt;   [-1, 0, 3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; B = [</div><div class="line">&gt;   [ 7, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 1 ]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</div><div class="line">&gt; AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</div><div class="line">&gt;                   | 0 0 1 |</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>逐个遍历计算</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">  <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">  <span class="keyword">int</span> A_rows = A.length;</div><div class="line">  <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span> B_rows = B.length;</div><div class="line">  <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A_cols;k++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i][k] != <span class="number">0</span> &amp;&amp; B[k][j] != <span class="number">0</span>)&#123;</div><div class="line">          result[i][j] = result[i][j] + A[i][k] * B[k][j];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优化</p><ol><li>遍历矩阵B，把B中值不为0的位置（注意是位置不是值）按每一列存下来</li><li>遍历A矩阵，寻找B中对应位置不为0的元素做乘积</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply2(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexB = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexA = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">    <span class="keyword">int</span> A_rows = A.length;</div><div class="line">    <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span> B_rows = B.length;</div><div class="line">    <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">    <span class="comment">//按列将B中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; B_cols;col++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; B_rows;row++)&#123;</div><div class="line">            <span class="keyword">if</span>(B[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(row);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexB.add(rowIndex);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//按行将A中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; A_rows;row++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; A_cols;col++)&#123;</div><div class="line">            <span class="keyword">if</span>(A[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(col);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexA.add(rowIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历矩阵A.B</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">           <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">           <span class="keyword">int</span> jj = <span class="number">0</span>;;</div><div class="line">           <span class="keyword">while</span>(ii &lt; nonZeroIndexA.get(i).size() &amp;&amp; jj &lt; nonZeroIndexB.get(j).size())&#123;</div><div class="line">               <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) == nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   result[i][j] += A[i][nonZeroIndexA.get(i).get(ii)] * B[nonZeroIndexB.get(j).get(jj)][j];</div><div class="line">                   ii++;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) &lt; nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   ii++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> &#123;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>在前面的课程里讲过可以利用堆Heap</p><p>方法二：</p><p>利用quickselect的方法，来源于quicksort</p><p>quicksort核心思想：每次选一个数字作为基准，比它小的放到左边，比它大的放到右边，然后再递归对左右两边数组做quicksort</p><p>步骤：从数组中选取一个数字作为“基准”pivot，找第K大的元素时可以跟基准比较：</p><ol><li>pivot左边元素个数 = K-1，该基准元素就是第K大元素</li><li>pivot左边元素个数 &gt; K-1，丢弃右边全部元素，在左边元素中继续寻找</li><li>pivot左边元素个数 &lt; K-1，丢弃左边全部元素，在右边元素中继续寻找</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="comment">//快速排序，寻找pivot应该放置的位置</span></div><div class="line">  <span class="keyword">int</span> i = start;</div><div class="line">  <span class="keyword">int</span> j = end;</div><div class="line">  <span class="keyword">int</span> pivot = nums[i];</div><div class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    nums[i] = nums[j];</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    nums[j]</div><div class="line">  nums[i] = pivot;</div><div class="line">  <span class="comment">//start~i-1的元素都小于等于pivot，一共用i-start个</span></div><div class="line">  <span class="comment">//i+1到end的元素都大于等于pivot，一共end-i个</span></div><div class="line">  <span class="keyword">if</span>(i-start == k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> quickselect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length+<span class="number">1</span>-k);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Median"><a href="#Median" class="headerlink" title="Median"></a><a href="http://www.lintcode.com/en/problem/median/" target="_blank" rel="external">Median</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a unsorted array with integers, find the median of it.</p><p>A median is the middle number of the array after it is sorted.</p><p>If there are even numbers in the array, return the <code>N/2</code>-th number after sorted.</p><p>Example</p><p>Given <code>[4, 5, 1, 2, 3]</code>, return <code>3</code>.</p><p>Given <code>[7, 9, 4, 5]</code>, return <code>5</code>.</p></blockquote><p>返回给定数组中位数</p><p>和上一题思路一样，K=nums.length/2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = start;</div><div class="line">    <span class="keyword">int</span> j = end;</div><div class="line">    <span class="keyword">int</span> pivot = nums[i];</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        nums[i] = nums[j];</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        nums[j] = nums[i];</div><div class="line">    &#125;</div><div class="line">    nums[i] = pivot;</div><div class="line">    <span class="keyword">if</span>(i - start == k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length - nums.length/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>这道题在二分法里面讲过了，先将找中点的问题转化成找第k大的问题，然后继续沿用二分法中的思路。详见<a href="https://siyaozhang.github.io/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二分法</a></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthInTwo</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> start1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> start2,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//end1中没有元素了，返回nums2中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start1 &gt;= nums1.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//end2中没有元素了，返回nums1中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start2 &gt;= nums2.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums1[start1+k-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line"><span class="comment">//边界条件，递归出口</span></div><div class="line">      <span class="keyword">if</span>(k ==<span class="number">1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//nums1中剩余元素不足K/2个,nums2的前K/2个元素一定在前k个中，</span></div><div class="line">      <span class="comment">// 去掉nums2的前K/2个元素</span></div><div class="line">      <span class="keyword">if</span>(nums1.length - start1 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(nums2.length - start2 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">     </div><div class="line">      <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt; nums2[start2 + k/<span class="number">2</span> - <span class="number">1</span>])&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> len = nums1.length+nums2.length;</div><div class="line">      <span class="comment">//偶数个元素</span></div><div class="line">      <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">int</span> k1 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>);</div><div class="line">          <span class="keyword">int</span> k2 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">          <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//奇数个元素</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h1 id="子数组-Subarray"><a href="#子数组-Subarray" class="headerlink" title="子数组 Subarray"></a>子数组 Subarray</h1><h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p></blockquote><p>最大子数组，找到子数组（连续），和最大</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>前缀和数组prefixSum：<code>sum[i] = SUM(nums[0~i])</code></p><p>数组中从i到j的数组和：<code>sum[i~j] = sum[j]-sum[i-1]</code></p><p>以当前位置i为结尾的最大子数组是sum[i]-min(sum[0]~sum[i-1])</p><p>所以思路就是：从前向后遍历，三个变量存储信息：</p><ol><li>从起点到当前元素的和，前缀和</li><li>截止目前的最大子数组</li><li>前面的最小和</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录前缀和</span></div><div class="line">  <span class="keyword">int</span> min_before = <span class="number">0</span>;<span class="comment">//记录前面最小和,初始化为0,</span></div><div class="line">  <span class="keyword">int</span> max = Integer.MIN_VALUE;<span class="comment">//记录最大子数组</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    sum += nums[i];<span class="comment">//从0到当前元素的前缀和</span></div><div class="line">    max = Math.max(max,sum-min_before);<span class="comment">//更新最大子数组</span></div><div class="line">    min_before = Math.min(min_before,sum);<span class="comment">//更新前面最小和</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二维数组的Maximum-Subarray"><a href="#二维数组的Maximum-Subarray" class="headerlink" title="二维数组的Maximum Subarray"></a>二维数组的Maximum Subarray</h3><p>前缀和</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  i-1  i           x</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">j-1*---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line"> j *-[i,j]-*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">y  *---*---*---*-[x,y]</div><div class="line"></div><div class="line"></div><div class="line">sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</div></pre></td></tr></table></figure><h3 id="Range-Sum-Query-2D-Immutable"><a href="#Range-Sum-Query-2D-Immutable" class="headerlink" title="Range Sum Query 2D - Immutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-immutable" target="_blank" rel="external">Range Sum Query 2D - Immutable</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p><p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given matrix = [</div><div class="line">&gt;   [3, 0, 1, 4, 2],</div><div class="line">&gt;   [5, 6, 3, 2, 1],</div><div class="line">&gt;   [1, 2, 0, 1, 5],</div><div class="line">&gt;   [4, 1, 0, 1, 7],</div><div class="line">&gt;   [1, 0, 3, 0, 5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">&gt; sumRegion(1, 1, 2, 2) -&gt; 11</div><div class="line">&gt; sumRegion(1, 2, 2, 4) -&gt; 12</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><ol><li>You may assume that the matrix does not change.</li><li>There are many calls to <em>sumRegion</em> function.</li><li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li></ol></blockquote><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>利用二维数组的前缀和，给定左上和右下的坐标为(row1, col1)， (row2, col2)</p><p>那么和为sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] Matrix;</div><div class="line">    <span class="keyword">int</span>[][] Sum;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.Matrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">this</span>.Sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        Sum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix.length;i++)&#123;</div><div class="line">            Sum[i][<span class="number">0</span>] = Sum[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            Sum[<span class="number">0</span>][i] = Sum[<span class="number">0</span>][i-<span class="number">1</span>] + matrix[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; matrix.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                Sum[i][j] = Sum[i-<span class="number">1</span>][j] + Sum[i][j-<span class="number">1</span>] - Sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row2][col1 -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2] - Sum[row2][col1 -<span class="number">1</span>] + Sum[row1-<span class="number">1</span>][col1 -<span class="number">1</span> ];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Range-Sum-Query-2D-Mutable"><a href="#Range-Sum-Query-2D-Mutable" class="headerlink" title="Range Sum Query 2D - Mutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-mutable" target="_blank" rel="external">Range Sum Query 2D - Mutable</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p><p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given matrix = [</div><div class="line">  [3, 0, 1, 4, 2],</div><div class="line">  [5, 6, 3, 2, 1],</div><div class="line">  [1, 2, 0, 1, 5],</div><div class="line">  [4, 1, 0, 1, 7],</div><div class="line">  [1, 0, 3, 0, 5]</div><div class="line">]</div><div class="line"></div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">update(3, 2, 2)</div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 10</div></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The matrix is only modifiable by the <em>update</em> function.</li><li>You may assume the number of calls to <em>update</em> and <em>sumRegion</em> function is distributed evenly.</li><li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> delta = val  - Matrix[row][col];<span class="comment">//更新值和原来差值</span></div><div class="line">  <span class="keyword">this</span>.Matrix[row][col] = val;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = row;i &lt; Matrix.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = col;j  &lt; Matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">      Sum[i][j] += delta;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="最小子数组"><a href="#最小子数组" class="headerlink" title="最小子数组"></a><a href="http://www.lintcode.com/en/problem/minimum-subarray/" target="_blank" rel="external">最小子数组</a></h3><blockquote><p>Given an array of integers, find the subarray with smallest sum.</p><p>Return the sum of the subarray.</p><p>Example</p><p>For <code>[1, -1, -2, 1]</code>, return <code>-3</code>.</p></blockquote><p>和最大子数组相同的思路</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArray</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> minsub = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">int</span> maxbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size();i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        minsub = Math.min(minsub,sum - maxbefore);</div><div class="line">        maxbefore = Math.max(maxbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minsub;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p></blockquote><p>求和大于等于s的连续子数组的最小长度</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口来做。</p><p>两个指针i和j分别指向子数组的头和尾</p><p>sumi代表从nums[0]到nums[i]的和</p><p>sumj代表从nums[0]到nums[j]的和</p><p>如果sumj-sumi &gt;= s，将i向后移动，直至sumj-sumi &lt; s，此时子数组和&gt;=s的长度为j-i+2，更新最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sumj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sumi = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length;j++)&#123;</div><div class="line">            sumj += nums[j];</div><div class="line">            <span class="keyword">int</span> delta = sumj - sumi;</div><div class="line">            <span class="keyword">while</span>(delta &gt;= s)&#123;</div><div class="line">                sumi += nums[i];</div><div class="line">                i++;</div><div class="line">                delta = sumj - sumi;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//跳出时sumj-sumi &lt; s</span></div><div class="line">            <span class="keyword">if</span>(sumj &gt;= s)&#123;</div><div class="line">                minlen = Math.min(minlen,j-i+<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen != Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> minlen;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Subarray-II"><a href="#Maximum-Subarray-II" class="headerlink" title="Maximum Subarray II"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-ii/" target="_blank" rel="external">Maximum Subarray II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of integers, find two non-overlapping subarrays which have the largest sum.<br>The number in each subarray should be contiguous.<br>Return the largest sum.</p><p>Example</p><p>For given <code>[1, 3, -1, 2, -1, 2]</code>, the two subarrays are <code>[1, 3]</code> and <code>[2, -1, 2]</code> or <code>[1, 3, -1, 2]</code> and <code>[2]</code>, they both have the largest sum <code>7</code>.</p></blockquote><p>求数组中两个不相交的最大子数组的和最大</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两个数组不相交，两个数组中间必然存在一个分割线，分割线左边求一个maxsubarray，右边求一个maxsubarray，两个子数组的和加在一起，就是当前分割线的最大子数组和</p><p>从左向右遍历分割线，分别求左边和右边的最大子数组，求和，记录最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubarray</span><span class="params">(List&lt;Integer&gt; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (start == end) &#123;</div><div class="line">        <span class="keyword">return</span> nums.get(start);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">int</span> minbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        maxSum = Math.max(maxSum,sum - minbefore);</div><div class="line">        minbefore = Math.min(minbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTwoSubArrays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> sum = MaxSubarray(nums,<span class="number">0</span>,i) + MaxSubarray(nums,i+<span class="number">1</span>,nums.size()-<span class="number">1</span>);</div><div class="line">        maxSum = Math.max(maxSum,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray" target="_blank" rel="external">Maximum Product Subarray</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p></blockquote><p>求乘积最大的子数组</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>子数组乘积最大值的可能性为：累乘的最大值碰到了一个正数；或者，累乘的最小值（负数），碰到了一个负数。所以每次要保存累乘的最大（正数）和最小值（负数）。同时还有一个选择起点的逻辑，如果之前的最大和最小值同当前元素相乘之后，没有当前元素大（或小）那么当前元素就可作为新的起点，比如遇到了0。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//局部最大最小</span></div><div class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">    <span class="comment">//全局最大</span></div><div class="line">    <span class="keyword">int</span> global_max = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//计算局部最大和最小与当前数字的乘积</span></div><div class="line">        <span class="keyword">int</span> a = max * nums[i];</div><div class="line">        <span class="keyword">int</span> b = min * nums[i];</div><div class="line">        <span class="comment">//更新局部最大和最小，必在a,b,nums[i]之中</span></div><div class="line">        max = Math.max(Math.max(a,b),nums[i]);</div><div class="line">        min = Math.min(Math.min(a,b),nums[i]);</div><div class="line">        <span class="comment">//更新全局最大</span></div><div class="line">        global_max = Math.max(global_max,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>  global_max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="最大子数组差"><a href="#最大子数组差" class="headerlink" title="最大子数组差"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-difference/" target="_blank" rel="external">最大子数组差</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array with integers.</p><p>Find two <em>non-overlapping</em> subarrays <em>A</em> and <em>B</em>, which <code>|SUM(A) - SUM(B)|</code> is the largest.</p><p>Return the largest difference.</p><p>The subarray should contain at least one number</p><p>Example</p><p>For <code>[1, 2, -3, 1]</code>, return <code>6</code>.</p></blockquote><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两个不相交的数字，中间必然存在分割线，对分割线左右两边一编求最大一边求最小，<code>|SUM(A) - SUM(B)|</code>最大有两种情况：</p><ol><li>max_sum(A) - min_sum(B)</li><li>min_sum(A) - max_sum(B)</li></ol><p>遍历分割线，计算，取1,2的绝对值的最大值</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        max = Math.max(max,sum - min_before);</div><div class="line">        min_before = Math.min(min_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        min = Math.min(min,sum - max_before);</div><div class="line">        max_before = Math.max(max_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDiffSubArrays</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max_abs = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> left_max = maxSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> left_min = minSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> right_max = maxSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> right_min = minSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> max = Math.max(Math.abs(left_max - right_min),Math.abs(left_min - right_max));</div><div class="line">        max_abs = Math.max(max_abs,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max_abs;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="子数组之和"><a href="#子数组之和" class="headerlink" title="子数组之和"></a><a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">子数组之和</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p><p>There is at least one subarray that it’s sum equals to zero.</p><p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p></blockquote><p>返回和为0的子数组开始和结尾所对应的idx</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>计算出每一个位置的前缀和，然后二重循环计算每一个子数组的和sum[i,j]，遇到有等于0的就返回，时间复杂度<script type="math/tex">O(n^2)</script>，超时了</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            prefixSum[i] = sum;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        prefixSum[nums.length] = sum;</div><div class="line">        System.out.println(prefixSum);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(prefixSum[i] - prefixSum[j] == <span class="number">0</span>)&#123;</div><div class="line">                    result.add(j);</div><div class="line">                    result.add(i-<span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>改进，利用HashMap</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">根据给的例子：[-3, 1, 2, -3, 4]，其累加和:</div><div class="line"></div><div class="line">nums [-3, 1,  2, -3,  4]</div><div class="line">      0   1   2   3   4</div><div class="line">sum  [-3，-2， 0， -3， 1]</div><div class="line">       i           j</div><div class="line">1. i=2出现了一个数0 -&gt; sum[0,i] = 0  ,是一个答案</div><div class="line"></div><div class="line">2. 同时在i,j发现两个-3   -&gt; sum[i+1,j] = 0 ,是一个答案</div><div class="line">因此前缀和中如果有0或者有两个相等的，即为所求</div></pre></td></tr></table></figure><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="number">0</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">            result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k" target="_blank" rel="external">Subarray Sum Equals K</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:nums = [1,1,1], k = 2</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol></blockquote><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>跟上一题类似的思路，利用HashMap，存储前缀和的值和出现的次数，当有相同的前缀和出现时，result增加的数量就是当前map里面改值出现的次数。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="comment">//如果之前出现过该值</span></div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">                result += map.get(sum-k);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                map.put(sum,map.get(sum)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果之前没有出现过该值，加入map</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map.put(sum,<span class="number">1</span>);<span class="comment">//key是前缀和，value是出现次数，初始化为1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Size-Subarray-Sum-Equals-k"><a href="#Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="Maximum Size Subarray Sum Equals k"></a><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k" target="_blank" rel="external">Maximum Size Subarray Sum Equals k</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>nums</em> and a target value <em>k</em>, find the maximum length of a subarray that sums to <em>k</em>. If there isn’t one, return 0 instead.</p><p><strong>Note:</strong><br>The sum of the entire <em>nums</em> array is guaranteed to fit within the 32-bit signed integer range.</p><p><strong>Example 1:</strong></p><p>Given <em>nums</em> = <code>[1, -1, 5, -2, 3]</code>, <em>k</em> = <code>3</code>,<br>return <code>4</code>. (because the subarray <code>[1, -1, 5, -2]</code> sums to 3 and is the longest)</p><p><strong>Example 2:</strong></p><p>Given <em>nums</em> = <code>[-2, -1, 2, 1]</code>, <em>k</em> = <code>1</code>,<br>return <code>2</code>. (because the subarray <code>[-1, 2]</code> sums to 1 and is the longest)</p><p><strong>Follow Up:</strong><br>Can you do it in O(<em>n</em>) time?</p></blockquote><p>计算和为k的子数组的最大长度</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>利用hashmap将出现过的前缀和第一次出现所在的index记录下来，在hashmap中寻找sum[i]-k，若找到，子数组的长度为<code>i - map.get(sum-k)</code> ，记录下满足条件的子数组的最大长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//用以记录子数组的最大长度</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="comment">//如果之前出现过sum-k</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">            maxlen = Math.max(maxlen,i - map.get(sum-k));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该值在map中没有出现过</span></div><div class="line">        <span class="keyword">if</span>(!map.containsKey(sum))&#123;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是index</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Subarray-Sum-Closest"><a href="#Subarray-Sum-Closest" class="headerlink" title="Subarray Sum Closest "></a><a href="http://www.lintcode.com/en/problem/subarray-sum-closest/" target="_blank" rel="external">Subarray Sum Closest </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number</p><p>Example</p><p>Given <code>[-3, 1, 1, -3, 5]</code>, return <code>[0, 2]</code>, <code>[1, 3]</code>, <code>[1, 1]</code>, <code>[2, 2]</code> or <code>[0, 4]</code>.</p></blockquote><p>给定数组，返回和最接近0的子数组的开始和结束位置的index</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>计算前缀和，排序，取每一个位置的前缀和和相邻前缀和的差的最大值，记录其起点终点，取最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param nums: A list of integers</span></div><div class="line"><span class="comment">     * @return: A list of integers includes the index of the first number and the index of the last number</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">node</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> sum;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.sum = sum;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(node b)</span> </span>&#123;<span class="comment">// Comparable接口中的方法</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sum- b.sum; <span class="comment">// 按书的id比较大小，用于默认排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        node[] prefixSum = <span class="keyword">new</span> node[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            prefixSum[i] = <span class="keyword">new</span> node(sum,i);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(prefixSum);</div><div class="line">        <span class="keyword">int</span> min = Math.abs(prefixSum[<span class="number">0</span>].sum);</div><div class="line">        <span class="keyword">int</span> min_a = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> min_b = prefixSum[<span class="number">0</span>].idx;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum);</div><div class="line">                min_a = -<span class="number">1</span>;</div><div class="line">                min_b = prefixSum[i].idx;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum);</div><div class="line">                min_a = prefixSum[i].idx;</div><div class="line">                min_b = prefixSum[i-<span class="number">1</span>].idx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> min_idx = Math.min(min_a,min_b);</div><div class="line">        <span class="keyword">int</span> max_idx = Math.max(min_a,min_b);</div><div class="line">      result[<span class="number">0</span>] = min_idx+<span class="number">1</span>;</div><div class="line">      result[<span class="number">1</span>] = max_idx;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a><a href="https://leetcode.com/problems/contiguous-array" target="_blank" rel="external">Contiguous Array</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1,0]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p></blockquote><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>计算从0到i位中0的个数<code>zeroSum</code>和1的个数<code>oneSum</code>，以及0比1多多少<code>zeroMoreThanOne</code></p><p>利用hashmap将zeroMoreThanOne和index存储起来，当遇到zeroMoreThanOne == 0或者map.containsKey(zeroMoreThanOne )时说明遇到了01数量相等的子数组，记录最大长度</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存储0比1多多少idx</span></div><div class="line">    <span class="keyword">int</span> zeroSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> oneSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> zeroMoreThanOne = <span class="number">0</span>;</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">            zeroSum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            oneSum++;</div><div class="line">        &#125;</div><div class="line">        zeroMoreThanOne = zeroSum - oneSum;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(zeroMoreThanOne))&#123;</div><div class="line">            <span class="keyword">int</span> len = i - map.get(zeroMoreThanOne);</div><div class="line">            maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            map.put(zeroMoreThanOne,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Continuous-Increasing-Subsequence"><a href="#Longest-Continuous-Increasing-Subsequence" class="headerlink" title="Longest Continuous Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence" target="_blank" rel="external">Longest Continuous Increasing Subsequence</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,4,7]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </div><div class="line">&gt; Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,2,2,2]</div><div class="line">&gt; Output: 1</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [2], its length is 1. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong> Length of the array will not exceed 10,000.</p></blockquote><p>求最长递增子数组</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从前向后遍历，两个变量<code>maxlen</code>，<code>len_local</code> 分别记录全局最长递增子数组和局部最长递增子数组的长度，如果</p><ol><li>nums[i]&gt;nums[i-1]，len_local++,更新maxlen</li><li>nums[i]&gt;nums[i-1]，len_local重置为1</li></ol><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> len_local = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">            len_local++;</div><div class="line">            maxlen = Math.max(maxlen,len_local);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            len_local = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Degree-of-an-Array"><a href="#Degree-of-an-Array" class="headerlink" title="Degree of an Array"></a><a href="https://leetcode.com/problems/degree-of-an-array" target="_blank" rel="external">Degree of an Array</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a non-empty array of non-negative integers <code>nums</code>, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p><p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 2, 3, 1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The input array has a degree of 2 because both elements 1 and 2 appear twice.</div><div class="line">&gt; Of the subarrays that have the same degree:</div><div class="line">&gt; [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</div><div class="line">&gt; The shortest length is 2. So return 2.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,2,3,1,4,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><p><code>nums.length</code> will be between 1 and 50,000.</p><p><code>nums[i]</code> will be an integer between 0 and 49,999.</p></blockquote><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用hashmap存储元素出现的次数和第一次出现的idx，从前向后遍历，更新出现次数最多的元素和最小子数组长度</p><p>方法二：遍历数组，用left[val]和right[val]存储val出现的第一次和最后一次，记录出现次数最多的元素和最短长度</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> earlyIdx;</div><div class="line">    <span class="keyword">int</span> nums;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> nums)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.earlyIdx = idx;</div><div class="line">        <span class="keyword">this</span>.nums = nums;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;<span class="comment">//记录元素出现的最多次数</span></div><div class="line">    <span class="keyword">int</span> minlen = <span class="number">1</span>;<span class="comment">//记录最短长度</span></div><div class="line">    HashMap&lt;Integer,node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//如果之前有此元素了</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</div><div class="line">            <span class="comment">//算上这次跟当前出现最多次数的元素一样</span></div><div class="line">            <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> == maxNum) &#123;</div><div class="line">                minlen = Math.min(minlen,i - map.get(nums[i]).earlyIdx+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//算上这次比当前出现最多次数的元素还多</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> &gt; maxNum) &#123;</div><div class="line">                maxNum = map.get(nums[i]).nums + <span class="number">1</span>;<span class="comment">//更新最多次数</span></div><div class="line">                minlen = i - map.get(nums[i]).earlyIdx+<span class="number">1</span>;<span class="comment">//更新最短长度</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//更新map</span></div><div class="line">            node newNode = <span class="keyword">new</span> node(map.get(nums[i]).earlyIdx,map.get(nums[i]).nums+<span class="number">1</span>);</div><div class="line">            map.put(nums[i],newNode);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(nums[i],<span class="keyword">new</span> node(i,<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water</a></h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p></blockquote><p>给定数组<em>a1</em>, <em>a2</em>, …, <em>an</em>,表示边界高度，选取其中两个作为边界，求能够容纳水的最大量。</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>若选取i,j作为边界，能够容纳的水量是：<script type="math/tex">(j-i) * min(a_i,a_j)</script></p><p>步骤：</p><ol><li>初始化：i指向height[0],j指向height[len-1]</li><li>两指针由外向内移动，记录最大的容水量：<ol><li>如果height[i] &lt; height[j],i++</li><li>如果height[i] &gt;= height[j],j—</li></ol></li></ol><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">            max = Math.max(max,(j-i) *height[i]);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            max = Math.max(max,(j-i) * height[j]);</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Array-Nesting"><a href="#Array-Nesting" class="headerlink" title="Array Nesting"></a><a href="https://leetcode.com/problems/array-nesting" target="_blank" rel="external">Array Nesting</a></h3><blockquote><p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p><p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: A = [5,4,0,3,1,6,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt; Explanation: </div><div class="line">&gt; A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</div><div class="line">&gt;</div><div class="line">&gt; One of the longest S[K]:</div><div class="line">&gt; S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><ol><li>N is an integer within the range [1, 20,000].</li><li>The elements of A are all distinct.</li><li>Each element of A is an integer within the range [0, N-1].</li></ol></blockquote><p>求数组中能够成环的最大长度</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>i从头向后遍历，以i为入口访问环，把访问过的标记为-1，记录最大长度</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//记录最大长度</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums.length;i ++)&#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//记录以i为入口的环长度</span></div><div class="line">            <span class="keyword">int</span> j = i;</div><div class="line">            <span class="keyword">while</span>(nums[j] != -<span class="number">1</span>)&#123;</div><div class="line">                len++;</div><div class="line">                <span class="keyword">int</span> temp = j;</div><div class="line">                j = nums[j];</div><div class="line">                nums[temp] = -<span class="number">1</span>;<span class="comment">//访问过的元素标记</span></div><div class="line">            &#125;</div><div class="line">           maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Find-Pivot-Index"><a href="#Find-Pivot-Index" class="headerlink" title="Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index" target="_blank" rel="external">Find Pivot Index</a></h3><blockquote><p>Given an array of integers <code>nums</code>, write a method that returns the “pivot” index of this array.</p><p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p><p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 7, 3, 6, 5, 6]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.</div><div class="line">&gt; Also, 3 is the first index where this occurs.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 2, 3]</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: </div><div class="line">&gt; There is no index that satisfies the conditions in the problem statement.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>先计算数组的全部元素和<code>sum</code> ，再遍历一次，计算前缀和<code>prefixsum</code>，二者做差是右边的和，prefixsum-nums[i]是左边的和，二者相等就返回</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">    sum += nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> prefixsum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    prefixsum += nums[i];</div><div class="line">    <span class="keyword">if</span>(sum - prefixsum == prefixsum - nums[i])&#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="external">Product of Array Except Self</a></h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>要分三种情况讨论：</p><ol><li>如果没有0，计算总乘积、当前乘积</li><li>有1个0，除了0位置不为0，其余位置都是0</li><li>有2个以上0，所有位置都为0</li></ol><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="keyword">int</span> zeros = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> zeroloc = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">      zeros += <span class="number">1</span>;</div><div class="line">      zeroloc = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      product *= nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(zeros == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;res.length;i++)&#123;</div><div class="line">      res[i] = product/nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(zeros == <span class="number">1</span>)&#123;</div><div class="line">    res[zeroloc] = product;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h1><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">Best Time to Buy and Sell Stock</a></h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 1, 5, 3, 6, 4]</div><div class="line">&gt; Output: 5</div><div class="line">&gt;</div><div class="line">&gt; max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 6, 4, 3, 1]</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div><div class="line">&gt; In this case, no transaction is done, i.e. max profit = 0.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p> 第i天卖出所获的最大利润为：</p><p>prices[i] - min(prices[0]~prices[i-1])</p><p>步骤：从前向后遍历，更新到当前天的价格最低值，更新到当前天的利润最大值</p><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//记录最大利润</span></div><div class="line">  <span class="keyword">int</span> maxprofit = Integer.MIN_VALUE;</div><div class="line">  <span class="comment">//记录当前最低价格，初始化不能是0，应该是第一天的价格</span></div><div class="line">  <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">    maxprofit = Math.max(maxprofit,prices[i] - minprice);<span class="comment">//更新最大利润</span></div><div class="line">    minprice = Math.min(minprice,prices[i]);<span class="comment">//更新最低价格</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxprofit;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a></h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p></blockquote><p>相比Best Time to Buy and Sell Stock I，可以多次买卖，计算可获得的最大利润</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>计算每一天跟前一天的价格差，将价格差大于0 的利润累加，就是获得的最大利润</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> delta = prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(delta &gt; <span class="number">0</span>)&#123;</div><div class="line">            max += delta;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p></blockquote><p>可以交易两次，设计算法求出最大利润</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>可以交易两次，可将数组分成左右两段，分别计算左段和右段的最大值</p><p>可以采用两次遍历，第一次从左向右，计算从0到i的最大利润，存在<code>maxprofits[i]</code>里。</p><p>第二次从右向左，计算从i到0的最大利润</p><p>maxprofit[i] = maxprofitfromleft[i]+maxprofitfromright[i]</p><p>以第i天为分割点的最大利润 = 从0到i的最大利润+从i到末尾的最大利润之和</p><p>以第i天为分割点在左右同时计算，包含了只交易一次，即第i天不买不卖的操作</p><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxresult = <span class="number">0</span>;<span class="comment">//最终结果</span></div><div class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitfromleft = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] maxprofits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];<span class="comment">//记录从0到i的最大利润</span></div><div class="line">        <span class="comment">//计算从前到i最大利润</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">            minprice = Math.min(minprice,prices[i]);</div><div class="line">            maxprofitfromleft = Math.max(maxprofitfromleft,prices[i] - minprice);</div><div class="line">            maxprofits[i] = maxprofitfromleft;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//计算从后到i最大利润+从前导i-1最大利润和</span></div><div class="line">        <span class="keyword">int</span> maxprice = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitformright = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</div><div class="line">            maxprice = Math.max(maxprice,prices[i]);<span class="comment">//从后向前最高价格</span></div><div class="line">            maxprofitformright = Math.max(maxprofitformright,maxprice - prices[i]);<span class="comment">//从后向前最大利润</span></div><div class="line">            maxresult = Math.max(maxresult,maxprofitformright + maxprofits[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxresult;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="external">Best Time to Buy and Sell Stock with Transaction Fee</a></h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p><p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p><p>Return the maximum profit you can make.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The maximum profit can be achieved by:</div><div class="line">&gt; Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>不限制交易次数，但需支付交易费用，求最大利润</p><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：</div><div class="line">cash:在第i天不持股所获最大利润</div><div class="line">hold:在第i天持股所获最大利润</div><div class="line"></div><div class="line">转移方程：</div><div class="line">在第i天cash状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天cash，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天hold，第i天卖出，收益prices[i]</div><div class="line">在第i天hold状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天hold，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天cash，第i天买入，扣去prices[i]和交易费用fee</div><div class="line">因此状态转移方程为：</div><div class="line">temp = cash</div><div class="line">cash = max(cash,hold + price[i])</div><div class="line">hold = max(hold,cash - price[i] - fee)</div><div class="line">  </div><div class="line">返回值：</div><div class="line">cash 最后一天结束时不持股的最大利润</div><div class="line"></div><div class="line">初始化：</div><div class="line">cash = <span class="number">0</span> 第<span class="number">0</span>天不持股，利润为<span class="number">0</span></div><div class="line">hold = -prices[<span class="number">0</span>] - fee 为了使第一天买入时利润为<span class="number">0</span>，将第<span class="number">0</span>天持股，利润设置为 ：-prices[<span class="number">0</span>] - fee</div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>] - fee;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> temp = cash;</div><div class="line">            cash = Math.max(cash,hold + prices[i]);</div><div class="line">            hold = Math.max(hold,temp - prices[i] - fee);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cash;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，第i天买入，花费prices[i]+fee</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]-fee)</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[<span class="number">0</span>][<span class="number">1</span>] = -Infinity; </div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> profit[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  profit[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>] - fee;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">    profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">    profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] - fee);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="external">Best Time to Buy and Sell Stock with Cooldown</a></h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; prices = [1, 2, 3, 0, 2]</div><div class="line">&gt; maxProfit = 3</div><div class="line">&gt; transactions = [buy, sell, cooldown, buy, sell]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>买卖股票存在一天的冷却期，卖出股票后第二天不可以买入，需要冷却一天，求最大利润。</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">2</span>天不持股，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>] = T[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">1</span>] = T[-<span class="number">1</span>][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>],-prices[<span class="number">1</span>]);</div><div class="line">        profit[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">2</span>]);</div><div class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i-<span class="number">2</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit[prices.length+<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="external">Best Time to Buy and Sell Stock IV</a></h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p></blockquote><p>最多可以买卖k次，求最大收益</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>动态规划的思想，下面是一种通用解法，前面的题目也同样适用</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][k][<span class="number">0</span>]表示到第i天，交易k次，第i天不持股</div><div class="line">T[i][k][<span class="number">1</span>]表示到第i天，交易k次，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，之前操作k次，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，之前操作k次，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，之前操作k次，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，之前操作k-<span class="number">1</span>次，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][k][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">0</span>],T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][k][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">1</span>]，T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = T[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">0</span>][<span class="number">1</span>] = T[-<span class="number">1</span>][k][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][k][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div></pre></td></tr></table></figure><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(prices.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(prices[i] &gt;= prices[i-<span class="number">1</span>])&#123;</div><div class="line">        profit += prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> profit;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[][][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= prices.length;i++)&#123;<span class="comment">//前i天无操作，持股，不可能</span></div><div class="line">    profit[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k;i++)&#123;<span class="comment">//没有股票持股，不可能</span></div><div class="line">    profit[<span class="number">0</span>][i][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">1</span> ; kk &lt;= k ; kk++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">      profit[i][kk][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">0</span>],profit[i-<span class="number">1</span>][kk][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">      profit[i][kk][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">1</span>],profit[i-<span class="number">1</span>][kk-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][k][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Two-Sum问题"><a href="#Two-Sum问题" class="headerlink" title="Two Sum问题"></a>Two Sum问题</h1><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum</a></h3><blockquote><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">&gt;</div><div class="line">&gt; Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">&gt; return [0, 1].</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>方法一：遍历，用hash表存储下来，然后遍历数组i,在hash表中查找是否有target-i</p><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">11</span>  <span class="number">18</span> ,target=<span class="number">16</span></div><div class="line">↑                ↑</div><div class="line">i                j</div><div class="line">步骤：</div><div class="line"><span class="number">1</span>. 排序，需要把元素在原来数组中的idx存下来</div><div class="line"><span class="number">2</span>. 两个指针i,j，i指向头，j指向尾</div><div class="line"><span class="number">3</span>.<span class="keyword">if</span>(nums[i]+nums[j] &lt; targert) i++</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] &gt; targert) j--</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] == targert) <span class="keyword">return</span></div></pre></td></tr></table></figure><p>若给定数组是有序的<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="external">Two Sum II - Input array is sorted</a>用方法二就非常简单了</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    Arrays.sort(nums);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = i;</div><div class="line">            result[<span class="number">1</span>] = j;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum</a></h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1, 0, 1],</div><div class="line">&gt;   [-1, -1, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法一：hash + 遍历 , 空间<script type="math/tex">O(n)</script> + 时间<script type="math/tex">O(n^2)</script></p><p>方法二：排序后two pointer，空间<script type="math/tex">O(1)</script> + 时间<script type="math/tex">O(n^2)</script></p><ol><li>排序</li><li>求a+b+c = target<br>固定a ， 然后对b + c利用Two Sum方法</li><li>需要注意的是遍历时要跳过重复的元素</li></ol><h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length -<span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到了一组解</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] == <span class="number">0</span>)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        result.add(nums[a]);</div><div class="line">        result.add(nums[b]);</div><div class="line">        result.add(nums[c]);</div><div class="line">        results.add(result);</div><div class="line">        b++;</div><div class="line">        c--;</div><div class="line">        <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] == nums[b - <span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[c] == nums[c + <span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c]+ nums[a] &lt; <span class="number">0</span>)&#123;</div><div class="line">        b++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        c--;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a><a href="https://leetcode.com/problems/3sum-closest" target="_blank" rel="external">3Sum Closest</a></h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line">&gt;</div><div class="line">&gt;     The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>跟上一题一样的思路，计算nums[b] + nums[c] + nums[a] - target的值：</p><ol><li>nums[b] + nums[c] + nums[a] - target == 0，最小差为0，直接返回</li><li>nums[b] + nums[c] + nums[a] - target &lt; 0,跟新最小差，b++</li><li>nums[b] + nums[c] + nums[a] - target &gt; 0,跟新最小差，c—</li></ol><h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="keyword">int</span> min_delta = Integer.MAX_VALUE;<span class="comment">//记录最小差值</span></div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录最小差值时三个数字和</span></div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到和target相等的情况</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] - target == <span class="number">0</span>)&#123;</div><div class="line">        sum = target;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        b++;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        c--;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[c] == nums[c+<span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3Sum-Smaller"><a href="#3Sum-Smaller" class="headerlink" title="3Sum Smaller"></a><a href="https://leetcode.com/problems/3sum-smaller" target="_blank" rel="external">3Sum Smaller</a></h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <em>n</em> integers <em>nums</em> and a <em>target</em>, find the number of index triplets <code>i, j, k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p><p>For example, given <em>nums</em> = <code>[-2, 0, 1, 3]</code>, and <em>target</em> = 2.</p><p>Return 2. Because there are two triplets which sums are less than 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [-2, 0, 1]</div><div class="line">&gt; [-2, 0, 3]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Follow up:</strong><br>Could you solve it in <em>O</em>(<em>n</em>2) runtime?</p></blockquote><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>这道题没有说清楚，重复的元素也可以，步骤如下：</p><ol><li>排序</li><li>从0到len-3遍历a，b从a+1到len-2，c从len-1到b+1</li><li>确定a和b的位置之后，c从后向前遍历，寻找第一个满足nums[b] + nums[c] + nums[a] &lt; target的位置，则从当前的b+1到找到的c的位置之间的c-b个位置都可以作为c，使得nums[b] + nums[c] + nums[a] &lt; target</li></ol><h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++) &#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (b &lt; c) &#123;</div><div class="line">      <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &gt;= target) &#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[b] + nums[c] + nums[a] &lt; target,或者b==c了</span></div><div class="line">      <span class="comment">//找到了第一个c的位置使得nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        res += c - b;<span class="comment">//b+1~c之间的元素都可以做c满足nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a><a href="https://leetcode.com/problems/4sum" target="_blank" rel="external">4Sum</a></h3><blockquote><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p><p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1,  0, 0, 1],</div><div class="line">&gt;   [-2, -1, 1, 2],</div><div class="line">&gt;   [-2,  0, 0, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>跟前面一样的思路，固定a，b对c,d做2Sum</p><h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b = a+<span class="number">1</span>;b &lt; nums.length - <span class="number">2</span>;b++)&#123;</div><div class="line">      <span class="comment">//跳过重复元素</span></div><div class="line">      <span class="keyword">if</span>(b &gt; a+<span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//c和d做TwoSum</span></div><div class="line">      <span class="keyword">int</span> c = b+<span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> d = nums.length-<span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span>(c &lt; d)&#123;</div><div class="line">        <span class="comment">//找到了一组解</span></div><div class="line">        <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] == target)&#123;</div><div class="line">          ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">          result.add(nums[a]);</div><div class="line">          result.add(nums[b]);</div><div class="line">          result.add(nums[c]);</div><div class="line">          result.add(nums[d]);</div><div class="line">          results.add(result);</div><div class="line">          c++;</div><div class="line">          d--;</div><div class="line">          <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[c] == nums[c - <span class="number">1</span>])&#123;</div><div class="line">            c++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[d] == nums[d + <span class="number">1</span>])&#123;</div><div class="line">            d--;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] &lt; target)&#123;</div><div class="line">          c++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          d--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4Sum-II"><a href="#4Sum-II" class="headerlink" title="4Sum II"></a><a href="https://leetcode.com/problems/4sum-ii" target="_blank" rel="external">4Sum II</a></h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; A = [ 1, 2]</div><div class="line">&gt; B = [-2,-1]</div><div class="line">&gt; C = [-1, 2]</div><div class="line">&gt; D = [ 0, 2]</div><div class="line">&gt;</div><div class="line">&gt; Output:</div><div class="line">&gt; 2</div><div class="line">&gt;</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The two tuples are:</div><div class="line">&gt; 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</div><div class="line">&gt; 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给四个数组，从每个数组中选一个数字，和为0的选择方案有多少</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>方法一：直接遍历四个数组，复杂度<script type="math/tex">O(n^4)</script></p><p>方法二：AB为一组，CD为一组，用两个hashmap记录两组中出现的和及其出现次数，互为相反数的和为0。</p><p>改进：存储两个hashmap再遍历速度很慢，所以只计算AB的和存入hashmap，然后计算CD时去AB的hashmap中寻找-sum出现的次数累加到result上即可。</p><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Integer,Integer&gt; mapab = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="comment">//计算AB的和，存入hashmap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sumab = A[i]+B[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(sumab))&#123;</div><div class="line">                    mapab.put(sumab,mapab.get(sumab)+<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    mapab.put(sumab,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum = C[i] + D[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(-sum))&#123;</div><div class="line">                    result += mapab.get(-sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Valid-Triangle-Number"><a href="#Valid-Triangle-Number" class="headerlink" title="Valid Triangle Number"></a><a href="https://leetcode.com/problems/valid-triangle-number" target="_blank" rel="external">Valid Triangle Number</a></h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,3,4]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation:</div><div class="line">&gt; Valid combinations are: </div><div class="line">&gt; 2,3,4 (using the first 2)</div><div class="line">&gt; 2,3,4 (using the second 2)</div><div class="line">&gt; 2,2,3</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>选取三个数组作为三边长度，返回能够组成三角形的选取方案数</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>构成三角形条件：两边之和大于第三边</p><ol><li>排序，两个小边之和大于第三边</li><li>固定a，遍历b、c，寻找第一个nums[a] + nums[b] &gt; nums[c]的位置</li><li>bc之间的位置都可以作为c，使得nums[a] + nums[b] &gt; nums[c]，result+= c-b。</li></ol><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &lt;= nums[c])&#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[a] + nums[b] &gt; nums[c]或者b==c</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &gt; nums[c])&#123;</div><div class="line">        result += c-b;</div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Partition类问题"><a href="#Partition类问题" class="headerlink" title="Partition类问题"></a>Partition类问题</h1><p>不开额外的空间，用两个指针分成两个、三个部分，利用quicksort的思想</p><h3 id="partition-Array"><a href="#partition-Array" class="headerlink" title="partition Array"></a><a href="http://www.lintcode.com/en/problem/partition-array/" target="_blank" rel="external">partition Array</a></h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <code>nums</code> of integers and an int <code>k</code>, partition the array (i.e move the elements in “nums”) such that:</p><ul><li>All elements &lt; <em>k</em> are moved to the <em>left</em></li><li>All elements &gt;= <em>k</em> are moved to the <em>right</em></li></ul><p>Return the partitioning index, i.e the first index <em>i</em> nums[<em>i</em>] &gt;= <em>k</em>.</p><p>Example</p><p>If nums = <code>[3,2,2,1]</code> and <code>k=2</code>, a valid answer is <code>1</code>.</p></blockquote><h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>利用quicksort的思想，两指针一前一后向中间遍历，前面遇到大的，后面遇到小的交换，最后判断nums[j]和target的大小关系，返回结果。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-02-10-28-18.png" alt=""> </p><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; k)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= k)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;<span class="comment">//j右边都&gt;=k</span></div><div class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[i];</div><div class="line">            nums[i] = nums[j];</div><div class="line">            nums[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[j] &gt;= k)&#123;</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个指针，利用快速排序</p><h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a><a href="https://leetcode.com/problems/sort-colors" target="_blank" rel="external">Sort Colors</a></h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p></blockquote><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>方法一：计数排序，遍历，记录0,1,2出现的个数，然后重新输出，时间复杂度<script type="math/tex">O(n)</script></p><p>方法二：两次partition，先把0分一堆，1，2分一堆，然后再把1,2分开</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColorsPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">1</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">1</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">    <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对右半段，分成成左边都&lt;2，右边&gt;=2</span></div><div class="line">  j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">2</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">2</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇了</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法三：背程序，三个指针三分法。</p><ol><li>i，j指向头和尾，mid在中间</li><li>mid向后遍历，遇到0与i交换，遇到2与j交换</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(mid &lt;= j)&#123;</div><div class="line">    <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">1</span>)&#123;</div><div class="line">      mid++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      mid++;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[j];</div><div class="line">      nums[j] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Sort-Colors-II"><a href="#Sort-Colors-II" class="headerlink" title="Sort Colors II"></a><a href="http://www.lintcode.com/en/problem/sort-colors-ii/" target="_blank" rel="external">Sort Colors II</a></h3><blockquote><p>Given an array of <em>n</em> objects with <em>k</em> different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k.</p><p>Example</p><p>Given colors=<code>[3, 2, 2, 1, 4]</code>, <code>k=4</code>, your code should sort colors in-place to <code>[1, 2, 2, 3, 4]</code>.</p></blockquote><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors2</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(colors.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = colors.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kk = <span class="number">2</span>;</div><div class="line">    <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">    <span class="keyword">while</span>(kk &lt;= k)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[i] &lt; kk)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[j] &gt;= kk)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">            <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">            <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">                <span class="keyword">int</span> temp = colors[i];</div><div class="line">                colors[i] = colors[j];</div><div class="line">                colors[j] = temp;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        j = colors.length-<span class="number">1</span>;</div><div class="line">        kk++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Sort-Letters-by-Case"><a href="#Sort-Letters-by-Case" class="headerlink" title="Sort Letters by Case"></a><a href="http://www.lintcode.com/en/problem/sort-letters-by-case/" target="_blank" rel="external">Sort Letters by Case</a></h3><h4 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string which contains only letters. Sort it by lower case first and upper case second.</p><p>For <code>&quot;abAcD&quot;</code>, a reasonable answer is <code>&quot;acbAD&quot;</code></p></blockquote><p>给一串字母，把小写的排在左边，大写的排在右边</p><h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortLetters</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</div><div class="line">  <span class="comment">// write your code here</span></div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = chars.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[i] &gt;= <span class="string">'a'</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[j] &lt;= <span class="string">'Z'</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">      <span class="keyword">char</span> temp = chars[i];</div><div class="line">      chars[i] = chars[j];</div><div class="line">      chars[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Interleaving-Positive-and-Negative-Numbers"><a href="#Interleaving-Positive-and-Negative-Numbers" class="headerlink" title="Interleaving Positive and Negative Numbers"></a><a href="http://www.lintcode.com/en/problem/interleaving-positive-and-negative-numbers/" target="_blank" rel="external">Interleaving Positive and Negative Numbers</a></h3><blockquote><p>Given an array with positive and negative integers. Re-range it to interleaving with positive and negative integers.</p><p>Example</p><p>Given <code>[-1, -2, -3, 4, 5, 6]</code>, after re-range, it will be <code>[-1, 5, -2, 4, -3, 6]</code> or any other reasonable answer.</p></blockquote><p>把正的和负的先都挑出来，然后交替放入数组。如果正的多余负的，先放正的，否则先放负的。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rerange</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] zheng = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="keyword">int</span>[] fu = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> zhengi = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fui = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; A.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)&#123;</div><div class="line">            fu[fui] = A[i];</div><div class="line">            fui++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            zheng[zhengi] = A[i];</div><div class="line">            zhengi++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fui &lt; zhengi)&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = zheng[zhengj];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = fu[fuj];</div><div class="line">        i++;</div><div class="line">        <span class="keyword">if</span>(A.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Two-pointer问题"><a href="#Two-pointer问题" class="headerlink" title="Two pointer问题"></a>Two pointer问题</h1><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code>is a <em>subsequence</em> and not a substring.</p></blockquote><p>给定一个字符串，计算不包含重复字母的最长子串</p><h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口做，窗口边界left、right，用数组<code>int[] map = new int[256]</code>存储当前窗口内出现的元素，用maxlen、len_local记录最大长度和当前窗口长度</p><ol><li>初始化left,right=0</li><li>right向后滑动，直至遇到窗口中已经存在该元素</li><li>left向后滑动，窗口缩小，直至将已经出现过的元素挪到窗口外面</li><li>循环更新local长度和全局最大长度</li></ol><h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> s.length();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  <span class="keyword">int</span> len_local = <span class="number">0</span>;<span class="comment">//局部长度</span></div><div class="line">  <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">  <span class="keyword">while</span>(right &lt; s.length())&#123;</div><div class="line">    <span class="comment">//如果字母还未出现过</span></div><div class="line">    <span class="keyword">if</span>(map[s.charAt(right)] == <span class="number">0</span>)&#123;</div><div class="line">      <span class="comment">//存入字母表</span></div><div class="line">      map[s.charAt(right)]++;</div><div class="line">      <span class="comment">//更新局部长度和全局最大长度</span></div><div class="line">      len_local++;</div><div class="line">      maxlen = Math.max(maxlen,len_local);</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//出现过</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//寻找之前该元素出现的位置</span></div><div class="line">      <span class="keyword">while</span> (s.charAt(left) != s.charAt(right))&#123;</div><div class="line">        <span class="comment">//路上把滑窗缩减的字母从字母表中去掉</span></div><div class="line">        map[s.charAt(left)]--;</div><div class="line">        left++;</div><div class="line">        len_local--;</div><div class="line">      &#125;<span class="comment">//跳出时left和right字母相等</span></div><div class="line">      left++;</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">Implement strStr()</a></h3><h4 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</div><div class="line">&gt; Output: -1</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h4><p>方法一：双指针遍历比较判断每一个字符是否一样</p><p>方法二：<code>return haystack.indexOf(needle);</code></p><p>方法三：<code>haystack.substring(i, i + needle.length()).equals(needle)</code></p><h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(j &lt; haystack.length())&#123;</div><div class="line">    <span class="comment">//遇到相等的字母</span></div><div class="line">    <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(k))&#123;</div><div class="line">      <span class="comment">//j和k同时向后移动</span></div><div class="line">      <span class="keyword">while</span>(j &lt; haystack.length() &amp;&amp; k &lt; needle.length() &amp;&amp; haystack.charAt(j) == needle.charAt(k))&#123;</div><div class="line">        j++;</div><div class="line">        k++;</div><div class="line">      &#125;<span class="comment">//跳出时或者到头了或者有不相等的了</span></div><div class="line">      <span class="comment">//如果k到头了，说明已经包含了needls</span></div><div class="line">      <span class="keyword">if</span>(k == needle.length())&#123;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//j到头了，剩下的字符串不够长了，不可能包含了</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == haystack.length())&#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        i++;</div><div class="line">        j = i;</div><div class="line">        k = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不是相等的字母，ij向后移动</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      i++;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Vowels-of-a-String"><a href="#Reverse-Vowels-of-a-String" class="headerlink" title="Reverse Vowels of a String"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="external">Reverse Vowels of a String</a></h3><h4 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><p><strong>Example 1:</strong><br>Given s = “hello”, return “holle”.</p><p><strong>Example 2:</strong><br>Given s = “leetcode”, return “leotcede”.</p><p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p></blockquote><p>对换元音字母</p><h4 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h4><p>两指针一前一后向中间遍历，遇到元音对换即可。</p><p>这里需要注意的是java的String是不可更改的，需要用StringBuilder复制一份再做修改：<code>result.setCharAt(i,s.charAt(j))</code>;</p><h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseVowelsofaString</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span></div><div class="line">                || ch == <span class="string">'A'</span> || ch == <span class="string">'E'</span> || ch == <span class="string">'I'</span> || ch == <span class="string">'O'</span> || ch == <span class="string">'U'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(s);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(i)))&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(j)))&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">char</span> temp = s.charAt(i);</div><div class="line">            result.setCharAt(i,s.charAt(j));</div><div class="line">            result.setCharAt(j,temp);</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="external">Valid Palindrome</a></h3><h4 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.</p></blockquote><p>有效回文串，判断字符串中的有效字符是否可以构成有效回文串，其中有效字符仅包括字母和数字，大小写算同一个字母</p><h4 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h4><p>步骤</p><ol><li>需要一个确定是否是有效字符的函数<code>isvalid</code>,利用java中的<code>Character.isLetter()</code>和<code>Character.isDigit()</code></li><li>两指针一前一后遍历，遇到无效字符跳过，比较两指针指向的字符是否相等，如果不相等直接返回false</li></ol><h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isvalid</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Character.isLetter(c) || Character.isDigit(c);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(i)))&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//全是invalid字符的情况</span></div><div class="line">    <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(j)))&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    i++;j--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Valid-Palindrome-II"><a href="#Valid-Palindrome-II" class="headerlink" title="Valid Palindrome II"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="external">Valid Palindrome II</a></h3><h4 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;aba&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;abca&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt; Explanation: You could delete the character &apos;c&apos;.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定字符串，判断如果最多可以去掉一个字符，改字符串是否可以成为回文串</p><h4 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h4><p>跟上一题的思路有点不太一样，没有想到巧妙的方法</p><p>两指针指向头尾，如果两个指针指向元素相等，则i++;j—</p><p>如果两指针指向元素不相等，那么s[i+1]~s[j]和s[i]~s[j-1]中必然有一个是回文串</p><h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否是回文串</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(start == end)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = start;</div><div class="line">  <span class="keyword">int</span> right = end;</div><div class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    left++;</div><div class="line">    right--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> isPalindrome(s,i,j-<span class="number">1</span>) || isPalindrome(s,i+<span class="number">1</span>,j);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Word-in-Dictionary-through-Deleting"><a href="#Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="Longest Word in Dictionary through Deleting"></a><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="external">Longest Word in Dictionary through Deleting</a></h3><h4 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;apple&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;a&quot;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个字符串s和一个字符串数组d,返回d中字符串是s的子序列的最长字符串，如果有长度相同的则返回在字母表中顺序最靠前的</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>遍历d中的字符串，看其是否能够由s的子序列构成，如果能，更新最大长度，如果和当前最大长度相等，取字典序小的</p><h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否能够是s的子序列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issubqueue</span><span class="params">(String s,String stemp)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> si = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> stempi = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; stempi &lt; stemp.length())&#123;</div><div class="line">    <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; s.charAt(si) != stemp.charAt(stempi))&#123;</div><div class="line">      si++;</div><div class="line">    &#125;<span class="comment">//跳出时si==len或者遇到相等的了</span></div><div class="line">    <span class="keyword">if</span>(si == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    si++;</div><div class="line">    stempi++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> stempi == stemp.length();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  String result = <span class="keyword">new</span> String();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.size();i++)&#123;</div><div class="line">    String stemp = d.get(i);</div><div class="line">    <span class="keyword">int</span> len = stemp.length();</div><div class="line">    <span class="keyword">boolean</span> flag = issubqueue(s,stemp);</div><div class="line">    <span class="keyword">if</span>(flag)&#123;</div><div class="line">      <span class="keyword">if</span>(len &gt; maxlen)&#123;</div><div class="line">        maxlen = len;</div><div class="line">        result= stemp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(len == maxlen &amp;&amp; stemp.compareTo(result) &lt; <span class="number">0</span>)&#123;</div><div class="line">        result = stemp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里判断t是否是s的子序列存在优化的空间，可以利用Java的String中的indexOf(char,indexfrom)来判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//s是否包含t</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(String s,String t)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(t.length() &gt; s.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length();i++)&#123;</div><div class="line">    pos = s.indexOf(t.charAt(i),pos);</div><div class="line">    <span class="keyword">if</span>(pos != -<span class="number">1</span>)&#123;</div><div class="line">      pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Permutation-in-String"><a href="#Permutation-in-String" class="headerlink" title="Permutation in String"></a><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="external">Permutation in String</a></h3><h4 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</div><div class="line">&gt; Output:True</div><div class="line">&gt; Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</div><div class="line">&gt; Output: False</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定字符串s1和s2，返回s2中是否包含一个子串，使得该子串可以由s1中字母的某种排列方式构成。</p><h4 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h4><p>滑动窗口法，窗口长度设置为s1的长度，在s2中寻找s1的排列子串</p><p>窗口向右滑动，直到窗口内出现的字母以及每个字母出现的次数和s1中一样，此时找到了满足条件的子数组。</p><p>将s1中出现的字母和每个字母出现的次数记录在一个hashtable中，因为只有26个字母，可以用一个长度为26的数组记录每个字母出现的次数</p><h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span>[] s1map,<span class="keyword">int</span>[] s2map)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] != s2map[i])&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(isSame(s1map,s2map))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    s2map[s2.charAt(s1.length()+i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isSame(s1map,s2map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>这里判断字符串相等还有可以优化的空间，用变量count表示当前窗口内和s1出现相同次数的字母的个数，当count == 26，则所有的字母都出现相同次数了，找到了解。当滑窗向后移动时，需要更新count</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion2</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] == s2map[i])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">int</span> r = s2.charAt(s1.length()+i) - <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">int</span> l = s2.charAt(i) - <span class="string">'a'</span>;</div><div class="line">    <span class="comment">//所有字母出现次数相等</span></div><div class="line">    <span class="keyword">if</span>(count == <span class="number">26</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//窗口将右边元素加入</span></div><div class="line">    s2map[r]++;</div><div class="line">    <span class="keyword">if</span>(s1map[r] == s2map[r])&#123;<span class="comment">//新加入元素后这个元素变得个数相等了</span></div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s2map[r] == s1map[r]+<span class="number">1</span>)&#123;<span class="comment">//新加入元素后比s1多一个了</span></div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">////窗口将左边元素去掉</span></div><div class="line">    s2map[l]--;</div><div class="line">    <span class="keyword">if</span>(s1map[l] == s2map[l])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1map[l] == s2map[l]+<span class="number">1</span>)&#123;</div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count == <span class="number">26</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Subarray-Product-Less-Than-K"><a href="#Subarray-Product-Less-Than-K" class="headerlink" title="Subarray Product Less Than K"></a><a href="https://leetcode.com/problems/subarray-product-less-than-k" target="_blank" rel="external">Subarray Product Less Than K</a></h3><h4 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Your are given an array of positive integers <code>nums</code>.</p><p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">&gt; Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h4><p>滑窗+两指针i,j题:</p><p>如果窗口内乘积&gt;=k，i++,窗口缩小</p><p>如果滑窗内乘积&lt;k，窗口内包含的以j为结束的子数组个数为j-i+1</p><h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(start &lt; end &amp;&amp; end &lt; nums.length)&#123;</div><div class="line">    product *= nums[end];</div><div class="line">    <span class="keyword">while</span> (start &lt; end &amp;&amp; product &gt;= k)&#123;</div><div class="line">      product /= nums[start];</div><div class="line">      start++;</div><div class="line">    &#125;</div><div class="line">    count += end - start +<span class="number">1</span>;</div><div class="line">    end++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Wiggle-Sort-II"><a href="#Wiggle-Sort-II" class="headerlink" title="Wiggle Sort II"></a><a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p><p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p><p><strong>Note:</strong><br>You may assume all input has valid answer.</p><p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p></blockquote><h4 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>这道题给了我们一个无序数组，让我们排序成摆动数组，满足nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…，并给了我们例子。我们可以先给数组排序，然后在做调整。调整的方法是找到数组的中间的数，相当于把有序数组从中间分成两部分，然后从前半段的末尾取一个，在从后半的末尾取一个，这样保证了第一个数小于第二个数，然后从前半段取倒数第二个，从后半段取倒数第二个，这保证了第二个数大于第三个数，且第三个数小于第四个数，以此类推直至都取完。</p><p>follow up：要求空间复杂度O(1)，没做上，要问下邓邓</p><h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Super-Ugly-Number"><a href="#Super-Ugly-Number" class="headerlink" title="Super Ugly Number"></a><a href="https://leetcode.com/problems/super-ugly-number" target="_blank" rel="external">Super Ugly Number</a></h3><h4 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the nth super ugly number.</p><p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list <code>primes</code> of size <code>k</code>. For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]</code>is the sequence of the first 12 super ugly numbers given <code>primes</code> = <code>[2, 7, 13, 19]</code> of size 4.</p><p><strong>Note:</strong><br>(1) <code>1</code> is a super ugly number for any given <code>primes</code>.<br>(2) The given numbers in <code>primes</code> are in ascending order.<br>(3) 0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 106, 0 &lt; <code>primes[i]</code> &lt; 1000.<br>(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.</p></blockquote><p>给定n和素数序列，返回第n个ugly number:因子只能出现在素数序列中</p><h4 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h4><p>用上面的hashmap+heap的方法会超时，看了九章的答案和网上大神们给出的答案，才看明白啥意思</p><p>以上一题prime只有三个数字2,3,5为例，我们知道丑陋数序列可以拆分为下面3个子列表：</p><p>(1) <strong>1x2</strong>,  2x2, <strong>2x2</strong>, 3x2, <strong>3x2</strong>, <strong>4x2</strong>, 5x2…</p><p>(2) 1x3,  <strong>1x3</strong>, 2x3, 2x3, <strong>2x3</strong>, 3x3, <strong>3x3</strong>…</p><p>(3) 1x5,  1x5, 1x5, <strong>1x5,</strong> 2x5, 2x5, 2x5…</p><p>仔细观察上述三个列表，我们可以发现每个子列表都是一个丑陋数分别乘以2,3,5，而要求的丑陋数就是从已经生成的序列中取出来的，我们每次都从三个列表中取出当前最小的那个加入序列，比如第一次，ugly number当前只有1，分别于2,3,5相乘之后得到2,3,5三个数字，此时除1外，最小的是2，因此先把2加入ugly number 里，然后此时2就可以与当前ugly number中比1大的下一个数字相乘，与上一轮的3,5，进行比较了，。。。</p><p>因此，上面的规律总结起来就是：</p><ol><li>一共进行n轮计算和选择</li><li>每轮计算a*b，其中b是给定的prime列表中的数字，a是ugly number中的数字</li><li>每一轮选择本轮（本列）最小的元素加入ugly number,下一轮该行所选取的”a”的idx后移一位。</li></ol><h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] uglyNumbers = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];</div><div class="line">        uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; primes.length;j++)&#123;</div><div class="line">                min = Math.min(min,primes[j] * uglyNumbers[idx[j]]);</div><div class="line">            &#125;</div><div class="line">            uglyNumbers[i] = min;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; primes.length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(min == primes[j] * uglyNumbers[idx[j]])&#123;</div><div class="line">                    idx[j]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> uglyNumbers[n-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="external">Meeting Rooms II</a></h3><h4 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p><p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p></blockquote><p>给定一个interval序列，代表会议的开始和结束时间，返回需要的最大会议室数量，也就是同时开会的最大数量。</p><h4 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h4><p>方法一：扫描线的思路+heap实现</p><p>将会议的开始和结束时间排序，然后从较小的开始遍历，初始sum=0,遇到start+1,遇到end-1，过程中最大的sum即为同时召开的最大会议数量。要注意的是，遇到同一时刻既有会议开始也有会议结束时应该先访问end，将sum-1,然后再访问start.</p><p>需要用小顶堆维护会议开始和结束时间，小顶堆的判断依据为time和Start or End</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>方法二：</p><p>将所有开始时间和结束时间分别放入两个数组，分别排序，然后两指针一个指向开始数组i，一个指向结束数组j，初始化sum = 0;</p><p>i后移时sum++;</p><p>j后移时sum—;</p><p>当指向开始数组的指针&gt;=结束数组指针所指的值时，结束数组向后移动一位，否则开始指针后移。</p><h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</div><div class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> time,<span class="keyword">boolean</span> isStart)&#123;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(tmp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].start,<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].end,<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(heap.poll().isStart)&#123;</div><div class="line">                sum++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;sum--;&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">        starts[i] = intervals[i].start;</div><div class="line">        ends[i] = intervals[i].end;</div><div class="line">    &#125;</div><div class="line">    Arrays.sort(starts);</div><div class="line">    Arrays.sort(ends);</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; starts.length &amp;&amp; j &lt; ends.length)&#123;</div><div class="line">        <span class="keyword">if</span>(starts[i] &lt; ends[j])&#123;</div><div class="line">            sum++;</div><div class="line">            max = Math.max(max,sum);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">            sum--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Skyline-Problem"><a href="#The-Skyline-Problem" class="headerlink" title="The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem" target="_blank" rel="external">The Skyline Problem</a></h3><h4 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p><p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt="Buildings"> </p><p><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt="Skyline Contour"></p><p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p><p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p><p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p><p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p></blockquote><p>给定建筑物的坐标和高度，有重叠，计算轮廓</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>扫描线</p><h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Sorted Array&lt;ul&gt;
&lt;li&gt;merge two sorted array&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】课程笔记——链表</title>
    <link href="http://yoursite.com/2017/12/11/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/12/11/【九章算法基础班】链表/</id>
    <published>2017-12-11T14:39:23.000Z</published>
    <updated>2017-12-23T07:47:14.008Z</updated>
    
    <content type="html"><![CDATA[<p>考点重要程度：链表 -&gt; DFS/BFS -&gt;DP</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>test:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//print() 打印完整链表</span></div><div class="line">ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line"></div><div class="line">ListNode head = node1;</div><div class="line">node1.next = node2;</div><div class="line">node2.next = node3;</div><div class="line"></div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line">node1 = node2;</div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line"></div><div class="line">ListNode包括一个值和一个指针，head占<span class="number">4</span>Byte(<span class="number">32</span>bit)空间，head实际上是一个指针，通过head所指向的地址去找对应节点存储的值和下一个指针。</div><div class="line"></div><div class="line">链表结构：</div><div class="line">    [<span class="number">1</span>,] -&gt;  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,]  </div><div class="line">      ↑        ↑       ↑</div><div class="line">   head,n1     n2     n3</div><div class="line">   <span class="number">4</span><span class="keyword">byte</span>     <span class="number">4</span><span class="keyword">byte</span>   <span class="number">4</span><span class="keyword">byte</span></div><div class="line">   </div><div class="line">node1和node2都是指向节点的指针，如果令node1 = node2,那么只是node1存储的地址和node2存储的地址一样了，但是链表的机构没有改变，所以输出依然是:</div><div class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span> </div><div class="line">  </div><div class="line">如果要改变链表的结构，需要node.next = balabala</div></pre></td></tr></table></figure><a id="more"></a><h2 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h2><h3 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>删掉链表中有重复的节点，保留一个</p><p>因为删除某个节点node，需要让node的前序节点.next = node.next，因此需要构造一个dummy node，让其指向前序节点，这样需要删除head的时候就可以令dummy.next = node.next。初始化时令dummy.next=head</p><p>最后返回dummy.next</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev;<span class="comment">//用于记录重复元素第一次出现的位置</span></div><div class="line">  ListNode curt = head;<span class="comment">//用于向后遍历链表</span></div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      prev = curt;<span class="comment">//记录第一个出现的元素</span></div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，curt继续后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="external">Remove Duplicates from Sorted List II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p><p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>删除链表中重复出现的节点，全部删掉一个都不保留</p><p>因为删除某个节点node，需要让node的前序节点.next = node.next，删除全部重复的元素可能删掉head元素，因此需要构造一个dummy node，让其指向head的前序节点，也就是dummy.next = head。这样需要删除head的时候就可以令dummy.next = head.next。</p><p>最后反回dummy.next</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//虚拟节点用于指向head</span></div><div class="line">  dummy.next = head;</div><div class="line"></div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，prev和curt都后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev = prev.next;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="external">Reverse Linked List</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Reverse a singly linked list.、</p><p>Hint:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p></blockquote><p>链表反转</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑</div><div class="line"> prev   curt</div><div class="line"> </div><div class="line"><span class="number">1</span>. 用temp记录下curt.next（因为后面要修改curt.next）</div><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"> </div><div class="line"><span class="number">2</span>. 将curt.next指向其前序节点prev，此时原来的后续链断掉:</div><div class="line"> <span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"><span class="number">3</span>. 将prev移到curt位置，curt移动到原来的curt.next,即temp:</div><div class="line"><span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">         ↑      ↑       ↑</div><div class="line">        prev   curt    temp</div><div class="line"></div><div class="line">ListNode temp = curt.next;</div><div class="line">curt.next = prev</div><div class="line">prev = curt;</div><div class="line">curt = temp;</div></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev = <span class="keyword">null</span>;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    ListNode temp = curt.next;</div><div class="line">    curt.next = prev;</div><div class="line">    prev = curt;</div><div class="line">    curt = temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii" target="_blank" rel="external">Reverse Linked List II</a></h3><blockquote><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p><p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p><strong>Note:</strong><br>Given <em>m</em>, <em>n</em> satisfy the following condition:<br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p></blockquote><p>将链表的第m-n位置上的元素反转</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[<span class="number">1</span>,]-&gt;[<span class="number">2</span>,]-&gt;...-&gt;[m-<span class="number">1</span>,]-&gt;[m,]-&gt;...-&gt;[n,]-&gt;[n+<span class="number">1</span>,]-&gt;...</div><div class="line">翻转m和n之间的部分，分为三个步骤：</div><div class="line"><span class="number">1</span>. 找到m-<span class="number">1</span>和m的点，设为prev和curt</div><div class="line"><span class="number">2</span>. 将m~n反转</div><div class="line"><span class="number">3</span>. 把m-<span class="number">1</span>.next指向n;把m.next指向n.next</div></pre></td></tr></table></figure><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-12-00-49-23.png" alt=""></p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt = head;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第m个节点</span></div><div class="line">        <span class="keyword">while</span> (i &lt; m)&#123;</div><div class="line">            curt = curt.next;</div><div class="line">            prev = prev.next;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时prev指向第m-1个节点，curt指向第m个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//记录下m节点和m-1节点位置，用于反转后连接</span></div><div class="line">        ListNode m_node = curt;</div><div class="line">        ListNode m_prev = prev;</div><div class="line"></div><div class="line">        <span class="comment">//将m到n反转</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= n)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时curt指向第n+1个节点，prev指向第n个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//将m的前序节点的next指向第n个节点</span></div><div class="line">        m_prev.next = prev;</div><div class="line">        <span class="comment">//将m节点的next指向第n+1个节点</span></div><div class="line">        m_node.next = curt;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a><a href="https://leetcode.com/problems/partition-list" target="_blank" rel="external">Partition List</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p><p>给定一个链表和一个数x，将链表中比x小的排在左边，大于等于x的数字排在右边，数字的相对顺序保持不变</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>将链表排成两队，小于x的一队，大于等于x的一队，然后把两个链表连起来。</p><p>链表的结构会发生变化，所以需要两个dummy node，一个用来指向小的队dummy_low，一个用来指向大的队dummy_high。</p><p><strong>解题步骤：</strong></p><ol><li>遍历数组，将比x小的元素放到dummy_low队伍后面，将比x大的元素放到dummy_high队伍后面</li><li>结束后将两个链表连接起来：dummy_low.next指向dummy_high.next</li><li>将链表结尾置空：tail.next = null,否则会保留原始节点的next。</li><li>返回dummy_low.next;</li></ol><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        ListNode next;</div><div class="line"></div><div class="line">        ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">establish</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode curt = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item : array)&#123;</div><div class="line">            ListNode node = <span class="keyword">new</span> ListNode(item);</div><div class="line">            curt.next = node;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        curt.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        ListNode dummy_low = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode dummy_high = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line"></div><div class="line">        ListNode prev_low = dummy_low;<span class="comment">//用于向小链表插入</span></div><div class="line">        ListNode prev_high = dummy_high;<span class="comment">//用于向大链表插入</span></div><div class="line"></div><div class="line">        <span class="comment">//分别放到两个队伍里</span></div><div class="line">        ListNode curt = head;</div><div class="line">        <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt.val &lt; x)&#123;</div><div class="line">                prev_low.next = curt;</div><div class="line">                prev_low = prev_low.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev_high.next = curt;</div><div class="line">                prev_high = prev_high.next;</div><div class="line">            &#125;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将两链表连接</span></div><div class="line">        prev_low.next = dummy_high.next;</div><div class="line">        prev_high.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy_low.next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">            System.out.println(head.val);</div><div class="line">            System.out.println(<span class="string">" -&gt; "</span>);</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        PartitionList test = <span class="keyword">new</span> PartitionList();</div><div class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line">        ListNode head = test.establish(array);</div><div class="line">        head = test.partition(head,x);</div><div class="line">        test.printList(head);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">Merge Two Sorted Lists</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">&gt; Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>链表结构可能改变， 所以需要dummy node</p><p>需要一个prev指针记录当前节点，初始化指向dummy_node两个curt指针分别指向两个链表当前节点，用于比较，将比较小的接在prev后面，知道两个curt中有一个为空，将另一个链表的后面直接接到prev后面。</p><p>最后返回dummy.next</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt1 = l1;</div><div class="line">        ListNode curt2 = l2;</div><div class="line">        <span class="keyword">while</span> (curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt1.val &lt; curt2.val)&#123;</div><div class="line">                prev.next = curt1;</div><div class="line">                curt1 = curt1.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                prev.next = curt2;</div><div class="line">                curt2 = curt2.next;</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a><a href="https://leetcode.com/problems/sort-list" target="_blank" rel="external">Sort List</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p><p>将链表排序，时间复杂度为 <em>O</em>(<em>n</em> log <em>n</em>)</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>时间复杂度为nlogn的排序：quick sort\merge sort\heap sort</p><p>quick sort和merge sort的区别：</p><ol><li><p>算法流程</p><p>quik sort：整体有序 -&gt; 局部有序、不稳定排序</p><ul><li>整体有序：选定一个元素，比它小的都在它左边，比它大的都在它右边</li><li>局部有序：然后再对左段和右段分别做快排</li></ul><p>merge sort：局部有序 -&gt; 整体有序、稳定排序</p><ul><li>局部有序：选取中点将序列分成左右两段，对左右两边分别排序</li><li>整体有序：将左右两边sort list 进行merge操作使得整个list有序</li></ul></li></ol><ol><li><p>排序的稳定性</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[2 , 1&apos; , 1&apos;&apos;, 1&apos;&apos;&apos; , 4 , 3&apos; , 3&apos;&apos;]</div><div class="line">merge sort的merge操作不会改变元素的相对顺序，所以是稳定排序</div><div class="line">quick sort会改变元素的相对位置，所以不是稳定排序</div></pre></td></tr></table></figure><p>​</p></li><li><p>时间复杂度</p><p>quick sort平均时间复杂度<script type="math/tex">O(nlogn)</script>，最坏时间复杂度<script type="math/tex">O(n^2)</script></p><p>merge sort时间复杂度：<script type="math/tex">O(nlogn)</script></p></li><li><p>空间复杂度</p><p>quick sort：<script type="math/tex">O(1)</script></p><p>merge sort：<script type="math/tex">O(n)</script> ，但是在链表中不需要开辟额外的空间</p></li></ol><p><strong>解题步骤：</strong></p><p>merge sort</p><p>​    具体步骤：</p><ol><li>merge sort在链表中找中点，有两种方法：<ol><li>遍历一遍，得到链表的长度n，则中间位置是n/2，再从头遍历一遍，到n/2的位置停止，找到中点</li><li>设置两个错位指针，一个slow一个fast，初始化都指向head，slow每次向右移动一位，fast每次向右移动两位，fast移动到末尾的时候，head指向中间，取到链表中点</li></ol></li><li>对左右两段递归进行排序</li><li>merge两段有序链表</li></ol><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">merge sort:</div><div class="line"><span class="comment">//寻找链表中点,中间偏前</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  ListNode slow = head;</div><div class="line">  ListNode fast = head;</div><div class="line">  <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//merge两段有序链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode left_h,ListNode right_h)</span></span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt_l = left_h;</div><div class="line">  ListNode curt_r = right_h;</div><div class="line">  <span class="keyword">while</span> (curt_l != <span class="keyword">null</span> &amp;&amp; curt_r != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(curt_l.val &lt; curt_r.val)&#123;</div><div class="line">      prev.next = curt_l;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_l = curt_l.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev.next = curt_r;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_r = curt_r.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_l == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_r;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_r == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_l;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归调用merge sort</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//寻找链表中点mid</span></div><div class="line">  ListNode mid = findMid(head);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点.next之后的链表排序</span></div><div class="line">  ListNode right = sortList(mid.next);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点之前包括中点的链表排序</span></div><div class="line">  mid.next = <span class="keyword">null</span>;</div><div class="line">  ListNode left = sortList(head);</div><div class="line"></div><div class="line">  <span class="comment">//merge两段有序链表</span></div><div class="line">  ListNode res = merge(left,right);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="external">Reorder List</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,</p><p>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>You must do this in-place without altering the nodes’ values.</p><p>For example,</p><p>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p></blockquote><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>题目需要从后向前访问链表，但是链表是单向的，所以需要reverse反转操作，再和原链表merge。</p><p><strong>具体步骤：</strong></p><ol><li>找到链表中点，mid</li><li>将mid之后的链表反转</li><li>将mid之前的链表和mid之后反转的链表做merge操作</li></ol><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//找到中间位置的元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    ListNode slow = head;</div><div class="line">    ListNode fast = head;</div><div class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//链表反转</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode prev = <span class="keyword">null</span>;</div><div class="line">    ListNode curt = head;</div><div class="line">    <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">        ListNode temp = curt.next;</div><div class="line">        curt.next = prev;</div><div class="line">        prev = curt;</div><div class="line">        curt = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prev;</div><div class="line">&#125;</div><div class="line"><span class="comment">//交替merge</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">    ListNode prev = left;</div><div class="line">    ListNode curt1 = left.next;</div><div class="line">    ListNode curt2 = right;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">            curt2 = curt2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">            curt1 = curt1.next;</div><div class="line">        &#125;</div><div class="line">        prev = prev.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">        prev.next = curt2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = curt1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="comment">//边界条件</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//找到mid</span></div><div class="line">    ListNode mid = findMid(head);</div><div class="line"></div><div class="line">    <span class="comment">//将mid之后的部分反转</span></div><div class="line">    ListNode right = reverse(mid.next);</div><div class="line">    mid.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//前半部分和反转后的后半部分merge</span></div><div class="line">    merge(head,right);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Fast-slow-pointer"><a href="#Fast-slow-pointer" class="headerlink" title="Fast-slow pointer"></a>Fast-slow pointer</h2><h3 id="1-Middle-of-Linked-List"><a href="#1-Middle-of-Linked-List" class="headerlink" title="1. Middle of Linked List"></a>1. Middle of Linked List</h3><p>寻找指针链表中点，快慢指针，快指针每次走两步，慢指针每次走一步，快指针走到链表结尾时，慢指针在中间</p><h3 id="2-Remove-Nth-Node-From-End-of-List"><a href="#2-Remove-Nth-Node-From-End-of-List" class="headerlink" title="2 .Remove Nth Node From End of List"></a>2 .<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">Remove Nth Node From End of List</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line">&gt;</div><div class="line">&gt;    After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p></blockquote><p>删除掉从末尾开始第n个节点</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>两个指针，fast先走n+！步slow再出发，当fast==null时，slow指向倒数第n+1个节点，删掉slow后面的节点：slow.next = slow.next.next</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    dummy.next = head;</div><div class="line">    ListNode slow = dummy;</div><div class="line">    ListNode fast = dummy;</div><div class="line">    <span class="comment">//fast先走n+1步</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</div><div class="line">        fast = fast.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast、slow同时向后遍历</span></div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</div><div class="line">        fast =fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    slow.next = slow.next.next；</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-Linked-List-Cycle"><a href="#3-Linked-List-Cycle" class="headerlink" title="3. Linked List Cycle"></a>3. <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p></blockquote><p>给定一个链表，判断是否有圈</p><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>判断node是否有被重复访问</p><p>从head出发，把所有访问过的点放到一个hash表里，空间复杂度O(n)</p><p>方法二：</p><p>一个快指针一个慢指针，如果路径上有环，快慢指针一定会相遇</p><p>初始化：slow = head;fast = head.next</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ListNode fast = head.next;</div><div class="line">    ListNode slow = head;</div><div class="line">    <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">        <span class="comment">//fast走到null</span></div><div class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow =slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast和slow相遇了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-Linked-List-Cycle-II"><a href="#4-Linked-List-Cycle-II" class="headerlink" title="4. Linked List Cycle II"></a>4. <a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">Linked List Cycle II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p></blockquote><p>是否有环，如果有，找到环的入口</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>slow从快慢指针相遇的地方出发，fast指针从初始地方出发，两个指针每次走一步，直到相遇，就是环的入口</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  ListNode fast = head.next;</div><div class="line">  ListNode slow = head;</div><div class="line">  <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">    <span class="comment">//fast走到null</span></div><div class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    fast = fast.next.next;</div><div class="line">    slow = slow.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//fast和slow相遇了</span></div><div class="line">  slow = head;</div><div class="line">  fast = fast.next;</div><div class="line">  <span class="keyword">while</span>(slow != fast)&#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-Rotate-List"><a href="#5-Rotate-List" class="headerlink" title="5. Rotate List"></a>5. <a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="external">Rotate List</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</div><div class="line">&gt; return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>将链表向后移k次</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Given <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL and k = <span class="number">2</span>,</div><div class="line">            ↑  ↑  ↑</div><div class="line">node.next=head ↑  ↑</div><div class="line">      dummy.next tail.next=head</div></pre></td></tr></table></figure><p>求解步骤：</p><ol><li>求链表长度len，如果k&gt;len,k = k%len;</li><li>找到从后往前数第k个元素，也就是从前往后数第len-k个元素node，和末尾元素tail</li><li>tail.next = dummy.next;dummy.next = node.next;node.next = null</li></ol><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">           <span class="keyword">return</span> head;</div><div class="line">       &#125;</div><div class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">       dummy.next = head;</div><div class="line">       ListNode tail = dummy;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>)&#123;</div><div class="line">           tail = tail.next;</div><div class="line">           len++;</div><div class="line">       &#125;</div><div class="line">       k = k % len;</div><div class="line">       ListNode node = dummy;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt;= len - k)&#123;</div><div class="line">           node = node.next;</div><div class="line">           i++;</div><div class="line">       &#125;</div><div class="line">       tail.next = dummy.next;</div><div class="line">       dummy.next = node.next;</div><div class="line">       node.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">Merge k Sorted Lists</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p></blockquote><p>merge k 个有序链表</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>一共三种方法，都需要掌握：</p><p>方法一：heap</p><p>用PriorityQueue实现</p><p>第一个参数 - 第二个参数：升序，最小堆</p><p>第二个参数 - 第一个参数：降序，最大堆</p><p>初始化：将链表头放进去</p><p>每次弹出最小的元素，放到结果链表后面，然后将其next入堆，重复上述</p><p>N：所有数的个数</p><p>K：链表个数</p><p>时间复杂度：<script type="math/tex">O(NlogK)</script> ，heap中最多有k各元素，插入操作时间复杂度是<script type="math/tex">O(logk)</script></p><p>空间复杂度：<script type="math/tex">O(K)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//heap</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> k = lists.length;</div><div class="line">        PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</div><div class="line">           <span class="comment">// @Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</div><div class="line">            ListNode head = lists[i];</div><div class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(head);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</div><div class="line">            ListNode curt = minHeap.poll();</div><div class="line">            prev.next = curt;</div><div class="line">            <span class="keyword">if</span>(curt.next != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(curt.next);</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法二：分治法</p><p>merge k 个链表</p><ul><li>拆分成merge前k/2个链表得到list1和merge后k/2个链表得到list2</li><li>合并list1和 list2，得到结果</li></ul><p>递归调用求解上述子问题</p><p>时间复杂度：<script type="math/tex">O(NlogK)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     result</div><div class="line">     ↗    ↖</div><div class="line">   ↗      ↗ ↖</div><div class="line">↗  ↖    ↗   ↗  ↖</div><div class="line"><span class="number">1</span><span class="number">2</span> |<span class="number">3</span> |<span class="number">4</span><span class="number">5</span></div><div class="line"> </div><div class="line"></div><div class="line">    <span class="comment">//分治</span></div><div class="line">    <span class="comment">//merge两个List</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergeTwoList</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode prev1 = left;</div><div class="line">        ListNode prev2 = right;</div><div class="line">        <span class="keyword">while</span>(prev1 != <span class="keyword">null</span> &amp;&amp; prev2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(prev1.val &lt; prev2.val)&#123;</div><div class="line">                prev.next = prev1;</div><div class="line">                prev1 = prev1.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev.next = prev2;</div><div class="line">                prev2 = prev2.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev2 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//分治法mergek个数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">divideMergeKList</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(start == end)&#123;</div><div class="line">            <span class="keyword">return</span> lists[start];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分成两部分</span></div><div class="line">        ListNode left = divideMergeKList(lists,start,start+(end-start)/<span class="number">2</span>);</div><div class="line">        ListNode right = divideMergeKList(lists,start+(end-start)/<span class="number">2</span>+<span class="number">1</span>,end);</div><div class="line">        <span class="comment">//合并两部分结果返回</span></div><div class="line">        <span class="keyword">return</span> MergeTwoList(left,right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">DividemergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> len = lists.length;</div><div class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> divideMergeKList(lists,<span class="number">0</span>,len-<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法三：两两合并</p><p>1、2合并，3、4合并，….n</p><p>向上递归合并</p><p>时间复杂度：<script type="math/tex">O(NlogK)</script></p><p>如果是1、2合并，然后忽然3合并，…n</p><p>时间复杂度O(NK)</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//两两合并</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsOneByOne</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(lists.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  List&lt;ListNode&gt; newlists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length;i++) &#123;</div><div class="line">    newlists.add(lists[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (newlists.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">    List&lt;ListNode&gt; listTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+<span class="number">1</span> &lt; newlists.size();i+=<span class="number">2</span>)&#123;</div><div class="line">      listTemp.add(MergeTwoList(newlists.get(i),newlists.get(i+<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newlists.size() % <span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">      listTemp.add(newlists.get(newlists.size()-<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    newlists = listTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newlists.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">Copy List with Random Pointer</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p></blockquote><p>给定一个链表，每个节点除包含一个next指针以外，还有一个指向任意节点的random pointer，clone链表</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>hash_map</p><p>先按next指针复制链表，把原链表老节点和新链表新节点的映射关系存入hash_map，再遍历一遍原链表，按照hash_map中的对应关系，把random pointer在对应的新节点中标出。</p><p>空间复杂度<script type="math/tex">O(n)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">       RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">       RandomListNode prevNew = dummy;</div><div class="line">       RandomListNode prev = head;</div><div class="line">       HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">       <span class="comment">//将链表和next指针复制，对应点存入hashmap</span></div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           RandomListNode temp = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">           prevNew.next = temp;</div><div class="line">           map.put(prev,prevNew.next);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//复制random poiner</span></div><div class="line">       prev = head;</div><div class="line">       prevNew = dummy.next;</div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           prevNew.random = map.get(prev.random);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>方法二：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-57-14.png" alt=""> </p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList2</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">  RandomListNode prev = head;</div><div class="line">  <span class="comment">//将每个元素都复制一份，插在原来元素的后面一位上</span></div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    RandomListNode node = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">    node.next = prev.next;</div><div class="line">    prev.next = node;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//加入random pointer</span></div><div class="line">  prev = head;</div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(prev.random != <span class="keyword">null</span>)&#123;</div><div class="line">      prev.next.random = prev.random.next;</div><div class="line">    &#125;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//删掉原来元素；</span></div><div class="line">  RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">  dummy.next = head;</div><div class="line">  prev = dummy;</div><div class="line">  RandomListNode curt = head;</div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt.next;</div><div class="line">    curt.next = curt.next.next;</div><div class="line">    prev = prev.next;</div><div class="line">    curt = curt.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-55-46.png" alt=""> </p><h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">Palindrome Linked List</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a singly linked list, determine if it is a palindrome.</p><p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p></blockquote><p>给定链表，判读是否是回文串，要求时间复杂度<script type="math/tex">O(n)</script>，空间复杂度<script type="math/tex">O(1)</script></p><h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>利用stack，先进后出的性质：</p><ol><li>找到终点，过程中将前半部分链表入栈</li><li>继续向后遍历，出栈，对比元素是否一致</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeStack</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="comment">//空链表和只有一个元素</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//快慢指针寻找中点,前半部分元素入栈</span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        stack.push(head.val);</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            stack.push(mid.val);</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是奇数个元素，将mid弹出，无须比较</span></div><div class="line">        <span class="keyword">if</span>(tail.next == <span class="keyword">null</span>)&#123;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        mid = mid.next;</div><div class="line">        <span class="keyword">while</span>(mid != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = stack.peek();</div><div class="line">            <span class="keyword">if</span>(temp != mid.val)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">            mid = mid.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法二：</p><ol><li>先找到中点</li><li>将后半部分的链表反转</li><li>对比前后两部分是否一致</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//快慢指针寻找中点</span></div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//反转后半个链表</span></div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        ListNode curt = mid.next;</div><div class="line">        <span class="keyword">while</span>(curt !=  <span class="keyword">null</span>)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">        &#125;</div><div class="line">        mid.next = prev;</div><div class="line">        <span class="comment">//对比两段元素是否一致</span></div><div class="line">        ListNode first = head;</div><div class="line">        ListNode second = mid.next;</div><div class="line">        <span class="keyword">while</span>(second != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(first.val != second.val)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            first = first.next;</div><div class="line">            second = second.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">160.Intersection of Two Linked Lists</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A:          a1 → a2</div><div class="line">&gt;                    ↘</div><div class="line">&gt;                      c1 → c2 → c3</div><div class="line">&gt;                    ↗            </div><div class="line">&gt; B:     b1 → b2 → b3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>begin to intersect at node c1.</p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul></blockquote><p>找到两个链表相交的地方</p><h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>是个技巧题，想到了就能做出来，想不到就做不出来</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-22-20-02-17.png" alt=""> </p><p>方法：</p><p>两个指针分别遍历，一个先A后B，一个先B后A，两指针指向节点相等即为相交处</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode n1 = headA;</div><div class="line">        ListNode n2 = headB;</div><div class="line">        <span class="comment">//记录是否遍历第二个链表</span></div><div class="line">        <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//两个指针都遍历结束了，没有相交节点</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; flag1)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n1遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; !flag1)&#123;</div><div class="line">                 n1 = headB;</div><div class="line">                 flag1 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n2遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n2 == <span class="keyword">null</span> &amp;&amp; !flag2)&#123;</div><div class="line">                n2 = headA;</div><div class="line">                flag2 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (n1 == n2)&#123;</div><div class="line">                <span class="keyword">return</span> n1;</div><div class="line">            &#125;</div><div class="line">            n1 = n1.next;</div><div class="line">            n2 = n2.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> idx = Math.abs(nums[i]);</div><div class="line">            <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> idx;</div><div class="line">            &#125;</div><div class="line">            nums[idx] = -nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考点重要程度：链表 -&amp;gt; DFS/BFS -&amp;gt;DP&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;test:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//print() 打印完整链表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode node1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode node2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode node3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode head = node1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node1.next = node2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node2.next = node3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(head);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node1 = node2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(head);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode包括一个值和一个指针，head占&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;Byte(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;bit)空间，head实际上是一个指针，通过head所指向的地址去找对应节点存储的值和下一个指针。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;链表结构：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,] -&amp;gt;  [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,] -&amp;gt; [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,]  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      ↑        ↑       ↑&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   head,n1     n2     n3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node1和node2都是指向节点的指针，如果令node1 = node2,那么只是node1存储的地址和node2存储的地址一样了，但是链表的机构没有改变，所以输出依然是:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;如果要改变链表的结构，需要node.next = balabala&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>DeepFM论文笔记</title>
    <link href="http://yoursite.com/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/10/DeepFM论文笔记/</id>
    <published>2017-12-10T13:28:04.000Z</published>
    <updated>2017-12-13T12:12:02.286Z</updated>
    
    <content type="html"><![CDATA[<p>线性模型不好捕捉交叉特征，FM由于模型复杂性，通常只能捕捉到两维特征交互，NN捕获低维特征能力弱。wide&amp;deep模型能够同时获取低维特征，但是需要低纬、高维两部分特征分开输入模型，而且wide部分的特征也是需要专门的特征工程进行的。</p><a id="more"></a><p>现有模型要么偏重于处理低维度模型，或者高维度模型，或者需要依赖于专门的特征工程。本文我们提出一种end to end的方法可以同时获取高维度和低维度特征，无需额外的特征工程，可以将原有特征直接输入模型，主要贡献如下：</p><ol><li>整合FM和DNN，提出了DeepFM模型，像FM一样学习低维度交互特征，像DNN一样学习高维度交互特征，DeepFM可以endtoend训练不需要额外的特征工程</li><li>DeepFM训练高效，因为deep和wide使用同一输入和embedding向量，而在wide&amp;deep模型里，输入向量维度很大，因为有很多人工构造的成对的交叉特征，大大增加了模型的复杂程度</li><li>用benchmark和商用数据集测试后均发现DeepFM效果好于其他CTR预估模型。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性模型不好捕捉交叉特征，FM由于模型复杂性，通常只能捕捉到两维特征交互，NN捕获低维特征能力弱。wide&amp;amp;deep模型能够同时获取低维特征，但是需要低纬、高维两部分特征分开输入模型，而且wide部分的特征也是需要专门的特征工程进行的。&lt;/p&gt;
    
    </summary>
    
      <category term="RTB" scheme="http://yoursite.com/categories/RTB/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】二分法</title>
    <link href="http://yoursite.com/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/07/【九章算法基础班】二分法/</id>
    <published>2017-12-07T13:22:14.000Z</published>
    <updated>2018-01-09T14:40:52.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="classical-Binary-Search"><a href="#classical-Binary-Search" class="headerlink" title="classical Binary Search"></a>classical Binary Search</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定一个排序数组和一个元素n，返回元素n的位置</p><div class="table-container"><table><thead><tr><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>num</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td><td>89</td></tr></tbody></table></div><p>查找元素5的位置</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>初始化:</p><p>​    start = 0;end = 8;mid = 4</p><ol><li>nums[mid] = 13;start = 0;end = 4,mid = 2</li><li>nums[mid] = 5;find it!</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">数据规模为n:</div><div class="line">T(n) = T(n/<span class="number">2</span>)+O(<span class="number">1</span>)</div><div class="line">其中O(<span class="number">1</span>)为比较的时间复杂度，T(n/<span class="number">2</span>)为比较之后</div><div class="line">时间复杂度是:O(logn)</div></pre></td></tr></table></figure><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>递归：</p><ul><li>优点：代码简洁</li><li>缺点：递归利用栈空间，递归层数过多会导致栈溢出</li></ul></li><li><p>while循环</p><ul><li>优点：占用空间小</li><li>缺点：代码可读性稍差，不够简洁</li></ul><p>面试的时候用什么？</p><p>如果用递归的方式写会好理解很多，就用递归写，不然就不用递归，在工程上，递归很容易导致栈溢出。</p></li></ol><p>这道题用最好用非递归的方式写，因为是很简短的</p><h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><ul><li>start + 1 &lt; end</li><li>mid = start +(end - start)/2;如果用(start + end)/2，如果start和end都很大相加就有可能溢出</li><li>A[mid] = &lt; &gt; 三种情况讨论</li><li>A[start] A[end]?target</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="comment">//中值</span></div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="comment">//三种情况讨论</span></div><div class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//结果</span></div><div class="line">        <span class="keyword">if</span> (nums[start] == target) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nums[end] == target) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><a id="more"></a><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a><a href="https://leetcode.com/problems/search-for-a-range" target="_blank" rel="external">Search for a Range</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>需要分别找到n<strong>第一次出现的位置</strong>和<strong>最后一次出现的位置</strong>，返回即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span>[] result = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="comment">//第一次出现的位置，在前半段，end前移</span></div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = end;</div><div class="line">        &#125;</div><div class="line">        start = <span class="number">0</span>;</div><div class="line">        end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找最后一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="comment">//第一次出现的位置，在后半段，start后移</span></div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            result[<span class="number">1</span>] = end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            result[<span class="number">1</span>] = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a><a href="https://leetcode.com/problems/search-insert-position" target="_blank" rel="external">Search Insert Position</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 5</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 2</div><div class="line">&gt; Output: 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 7</div><div class="line">&gt; Output: 4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,6], 0</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>二分法的问题一般都是找满足条件的firstposition和lastposition.</p><p>这道题是需要找到firstposition &gt;= targrt，第一个&gt;=target的位置。</p><p>while结束后，需要找firstposition的话先判断start，找lastposition的话先判断end。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第一次出现的位置</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start +(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="comment">//找到了</span></div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没找到target,在start和end中找比target大的</span></div><div class="line">        <span class="comment">//start&gt;=tartget</span></div><div class="line">        <span class="keyword">if</span>(nums[start] &gt;= target)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//end&gt;=tartget</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[end] &gt;= target)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums中所有元素都比target小</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> end+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a><a href="https://leetcode.com/problems/search-a-2d-matrix" target="_blank" rel="external">Search a 2D Matrix</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p>For example,</p><p>Consider the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,   3,  5,  7],</div><div class="line">&gt;   [10, 11, 16, 20],</div><div class="line">&gt;   [23, 30, 34, 50]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given <strong>target</strong> = <code>3</code>, return <code>true</code>.</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两种做法：</p><ol><li><p>先按每行的首个数字二分确定target所在的行，再在这行里二分。</p></li><li><p>看成一维数组，二分查找，其中看成一维数组的序号n和二维数组中行号、列号对应关系为：</p><p>r = n/columns;</p><p>c = n%columns;</p></li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchA2DMatrix</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">//空矩阵判断</span></div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = rows*cols -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span> &lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> r = mid/cols;</div><div class="line">            <span class="keyword">int</span> c = mid%cols;</div><div class="line">            <span class="keyword">if</span> (matrix[r][c] == target)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c] &lt; target)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c] &gt; target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matrix[start/cols][start%cols]==target)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matrix[end/cols][end%cols]==target)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Search-a-2D-Matrix-II"><a href="#Search-a-2D-Matrix-II" class="headerlink" title="Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii" target="_blank" rel="external">Search a 2D Matrix II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>For example,</p><p>Consider the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1,   4,  7, 11, 15],</div><div class="line">&gt;   [2,   5,  8, 12, 19],</div><div class="line">&gt;   [3,   6,  9, 16, 22],</div><div class="line">&gt;   [10, 13, 14, 17, 24],</div><div class="line">&gt;   [18, 21, 23, 26, 30]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given <strong>target</strong> = <code>5</code>, return <code>true</code>.</p><p>Given <strong>target</strong> = <code>20</code>, return <code>false</code>.</p></blockquote><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ul><li>方法一：</li></ul><p>从对角线开始二分找， 找到第一个&gt;=target的位置，将大矩形分割成4个小矩形，分两种情况讨论：</p><ol><li>元素 = target，返回true</li><li>元素 &gt; target，左上角的矩阵中元素 &lt; target，右下角矩阵中的元素都 &gt; target，都不可能有符合条件的值了，所以只需继续在左下角和右上角的矩阵中继续寻找。</li></ol><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-08-13-20-33.png" alt=""> </p><p>​    时间复杂度分析：</p><p><script type="math/tex">T(n) = 2T(n/4)+O(log\sqrt{n})</script>，其中<script type="math/tex">\sqrt{n}</script>为对角线元素个数。</p><ul><li><p>方法二：</p><p>矩阵特点：每一行和每一列递增</p><p>从左下角往右上角找，有如下三种情况：</p></li></ul><ol><li>元素 = target，返回true</li><li>元素 &lt; target，下一步向右走，因为右边的元素都大于当前元素，上方元素小于当前元素</li><li>元素 &gt; target，下一步向上走，因为右边的元素都大于当前元素，上方元素小于当前元素</li></ol><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-08-09-51-55.png" alt=""> </p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> r = rows-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(r &gt;=<span class="number">0</span> &amp;&amp; c &lt;cols)&#123;</div><div class="line">            <span class="keyword">if</span>(matrix[r][c]==target)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &lt; target)&#123;</div><div class="line">                c++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &gt; target)&#123;</div><div class="line">                r--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div></pre></td></tr></table></figure><h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a><a href="https://leetcode.com/problems/first-bad-version" target="_blank" rel="external">First Bad Version</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p></blockquote><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>有1到n个版本，找到第一个错误版本的位置。利用从第一个错误的开始之后后面的都是错的，用二分查找到第一个错误版本。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = n;</div><div class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">        <span class="keyword">int</span> mid = start+(end=start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(isBadVersion(mid))&#123;</div><div class="line">            end = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isBadVersion(start))&#123;</div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isBadVersion(end))&#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Find-Peak-Element"><a href="#Find-Peak-Element" class="headerlink" title="Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p><p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p></blockquote><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>给定一个数组，返回peak的元素（左边右边都比自己小），如果有多个返回任意一个即可，要求时间复杂度为O(logn)</p><p>遇到O(logn)要考虑到二分法：</p><p>二分法选取mid元素，其跟左右元素的关系有如下四中情况：</p><ol><li>两边元素都比mid小，mid就是peak,，返回</li><li>两边元素都比mid大，左右都有可能有peak，任选一边二分</li><li>左边小又边大，右边一定有peak，继续对右边二分</li><li>左边大右边小，左边一定有peak，继续对左边二分</li></ol><p>需要注意的地方：</p><p>因为要将元素跟其左边和右边的元素比较，所以为了<strong>避免越界，初始需要将start设为1，end设为length-1</strong>；还需要把两个边界值设为负无穷，确保边界值也可以被选上。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length+<span class="number">2</span>];</div><div class="line">    nums2[<span class="number">0</span>] = -Long.MAX_VALUE;</div><div class="line">    nums2[nums.length+<span class="number">1</span>] = -Long.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        nums2[i+<span class="number">1</span>] = nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = nums2.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">        <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>((nums2[mid] &gt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &gt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            <span class="keyword">return</span> mid-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((nums2[mid] &lt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &lt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nums2[mid] &gt; nums2[mid+<span class="number">1</span>]) &amp;&amp; (nums2[mid] &lt; nums2[mid-<span class="number">1</span>]))&#123;</div><div class="line">            end = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            start = mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums2[start] &lt; nums2[end])&#123;</div><div class="line">        <span class="keyword">return</span>  end-<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> start-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="external">Find Minimum in Rotated Sorted Array</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p></blockquote><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">递增数组：</div><div class="line">              ↗</div><div class="line">            ↗</div><div class="line">          ↗</div><div class="line">        ↗</div><div class="line">      ↗</div><div class="line">    ↗</div><div class="line">  ↗</div><div class="line">↗</div><div class="line">旋转数组：</div><div class="line">旋转数组，分成两段上升数组：</div><div class="line">              ↗|</div><div class="line">            ↗  |</div><div class="line">          ↗    |</div><div class="line">        ↗      |</div><div class="line">      ↗        |</div><div class="line">---------------|------------------</div><div class="line">               |    ↗</div><div class="line">               |  ↗</div><div class="line">               |↗</div><div class="line">      ↑     ↑        ↑</div><div class="line">    start  mid      end</div><div class="line">用二分法，判断mid与end的大小，确定mid位于两段上升数组的哪一段：</div><div class="line"><span class="number">1</span>. nums[mid] &lt; nums[end]:</div><div class="line">mid在后段上升数组中，end = mid</div><div class="line"><span class="number">2</span>. nums[mid] &gt; nums[end]:</div><div class="line">mid在前段上升数组中，start = mid</div></pre></td></tr></table></figure><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">    <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</div><div class="line">      end = mid;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</div><div class="line">      start = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(nums[start] &gt; nums[end])&#123;</div><div class="line">    <span class="keyword">return</span> nums[end];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> nums[start];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii" target="_blank" rel="external">Find Minimum in Rotated Sorted Array II</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><blockquote><p><em>Follow up</em> for “Find Minimum in Rotated Sorted Array”:<br>What if <em>duplicates</em> are allowed?</p><p>Would this affect the run-time complexity? How and why?</p></blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p></blockquote><p>延续上一题，有重复数字的旋转数组，找到最小的值。</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>如果存在重复元素，无法使用二分查找使得时间复杂度为O(logn)，最坏时间复杂度只能是o(n)。</p><p>证明方法：<strong>黑盒测试</strong></p><p>假设给定的数组中有一个1和n-1个2，此时mid=2，无法判断1在哪边。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] &lt; min)&#123;</div><div class="line">      min = nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array" target="_blank" rel="external">Search in Rotated Sorted Array</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p></blockquote><p>给定一个旋转递增数组和一个数，返回数在数组中的位置。</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>二分法</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">递增数组：</div><div class="line">              ↗</div><div class="line">            ↗</div><div class="line">          ↗</div><div class="line">        ↗</div><div class="line">      ↗</div><div class="line">    ↗</div><div class="line">  ↗</div><div class="line">↗</div><div class="line"></div><div class="line">旋转数组，分成两段上升数组：</div><div class="line">              ↗|</div><div class="line">            ↗  |</div><div class="line">          ↗    |</div><div class="line">        ↗      |</div><div class="line">      ↗        |</div><div class="line">---------------|------------------</div><div class="line">               |    ↗</div><div class="line">               |  ↗</div><div class="line">               |↗</div><div class="line">      ↑     ↑        ↑</div><div class="line">    start  mid      end</div><div class="line">二分法，mid和end比较：</div><div class="line"><span class="number">1</span>. nums[mid] &gt; nums[end]：</div><div class="line">mid在第一段上升区间，跟target比较：</div><div class="line"><span class="number">1</span>. 如果target在start和mid之间，end= mid</div><div class="line"><span class="number">2</span>. 否则，start = mid,继续做二分查找，仍然是一个search in rotated sorted array问题</div><div class="line"><span class="number">2</span>. nums[mid] &lt; nums[end]：</div><div class="line">mid在第二段上升区间，跟target比较：</div><div class="line"><span class="number">1</span>. 如果target在mid和end之间，end= mid</div><div class="line"><span class="number">2</span>. 否则，start = mid,继续做二分查找，仍然是一个search in rotated sorted array问题</div></pre></td></tr></table></figure><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(target == nums[mid])&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//mid在第一个上升区间</span></div><div class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</div><div class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[start])&#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">///mid在第二个上升区间</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])&#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] == target)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii" target="_blank" rel="external">Search in Rotated Sorted Array II</a></h3><p>有重复元素，无法二分查找，时间复杂度为O(n)，遍历查找即可。</p><h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p> Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p> <strong>Note:</strong><br> You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p></blockquote><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>合并连个有序数组，把S2并入S1，假设S1有足够大的空间。</p><p>考点：从后往前合并，因为后面的空间是空的，不会覆盖原有元素。</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> end1 = m-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end2 = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = m+n-<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (end1 &gt;=<span class="number">0</span> &amp;&amp; end2&gt;=<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(nums1[end1] &lt; nums2[end2])&#123;</div><div class="line">                nums1[end] = nums2[end2];</div><div class="line">                end2--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[end] = nums1[end1];</div><div class="line">                end1--;</div><div class="line">            &#125;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1元素剩下了</span></div><div class="line">        <span class="keyword">if</span> (end1 &gt;= <span class="number">0</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2元素剩下了</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span> (end2 &gt;= <span class="number">0</span>)&#123;</div><div class="line">                nums1[end] = nums2[end2];</div><div class="line">                end--;</div><div class="line">                end2--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>令nums1.length = m;nums2.length = n;总长度m+n。先确定中位数m是多少:</p><ol><li><p>(m+n)%2 == 0:</p><p>m=(m+n)/2,(m+n)/2+1</p></li><li><p>(m+n)%2 == 1:</p><p> m=(m+n)/2</p></li></ol><p>问题转化为找<strong>两个有序数组的第K大</strong>的问题，如果用merge的方法获得merge之后的排序数组需要O(m+n)的时间复杂度，题目要求使用O(log(m+n))的时间复杂度，所以需要使用二分法：</p><p>如果A[k/2] &lt;= B[k/2]：A的前k/2个数一定都在A、B合并后的前K个数中，去掉A的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p><p>如果A[k/2] &gt; B[k/2]：B的前k/2个数一定都在A、B合并后的前K个数中，去掉B的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p><p>如果A[k/2]越界，A中剩余元素不足k/2个，则B中前k/2个元素一定在前K个中，去掉B的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p><p>如果B[k/2]越界，B中剩余元素不足k/2个，则A中前k/2个元素一定在前K个中，去掉A的前k/2个元素，继续寻找A和B的第m-k/2个元素。</p><p>边界条件判断：</p><ol><li>nums1中没有元素了,直接返回nums2中的第k个</li><li>nums2中没有元素了,直接返回nums1中的第k个</li><li>k == 1，递归出口，直接返回min(nums1[start1],nums2[start2])</li></ol><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianOfTwoSortedArrays</span> </span>&#123;</div><div class="line">    <span class="comment">//两个sorted array merge 寻找第k大的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> k,<span class="keyword">int</span> start1,<span class="keyword">int</span> start2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> end1 = nums1.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end2 = nums2.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1空了，</span></div><div class="line">        <span class="keyword">if</span>(start1 &gt; end1)&#123;</div><div class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2空了</span></div><div class="line">        <span class="keyword">if</span>(start2 &gt; end2)&#123;</div><div class="line">            <span class="keyword">return</span> nums1[start1 + k -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums1的前k/2个元素已经超过nums1中剩余的所有元素个数</span></div><div class="line">        <span class="comment">//那么nums2的前k/2个元素都包含在前k个元素中</span></div><div class="line">        <span class="keyword">if</span>(start1 + k/<span class="number">2</span> - <span class="number">1</span> &gt; end1)&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1,start2+k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums2的前k/2个元素已经超过nums2中剩余的所有元素个数</span></div><div class="line">        <span class="comment">//那么nums1的前k/2个元素都包含在前k个元素中</span></div><div class="line">        <span class="keyword">if</span>(start2 + k/<span class="number">2</span> - <span class="number">1</span> &gt; end2)&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1+k/<span class="number">2</span>,start2);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//nums和nums2的前k/2个元素都没有超过个字的末尾</span></div><div class="line">        <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt;nums2[start2+k/<span class="number">2</span>-<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1+k/<span class="number">2</span>,start2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k-k/<span class="number">2</span>,start1,start2+k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len1 = nums1.length;</div><div class="line">        <span class="keyword">int</span> len2 = nums2.length;</div><div class="line">        <span class="keyword">int</span> k = (len1+len2)/<span class="number">2</span>;<span class="comment">//中位数</span></div><div class="line">        <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> k1 = findKth(nums1,nums2,k,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">            <span class="keyword">int</span> k2 = findKth(nums1,nums2,k+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,nums2,k+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        MedianOfTwoSortedArrays test = <span class="keyword">new</span> MedianOfTwoSortedArrays();</div><div class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">double</span> res = test.findMedianSortedArrays(nums1,nums2);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Wood-Cut"><a href="#Wood-Cut" class="headerlink" title="Wood Cut"></a><a href="http://www.lintcode.com/en/problem/wood-cut/" target="_blank" rel="external">Wood Cut</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given n pieces of wood with length <code>L[i]</code> (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L &amp; k, return the maximum length of the small pieces.</p><h5 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h5><p>You couldn’t cut wood into float length.</p><p>If you couldn’t get &gt;= <em>k</em> pieces, return <code>0</code>.</p><p>Example</p><p>For <code>L=[232, 124, 456]</code>, <code>k=7</code>, return <code>114</code>.</p></blockquote><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>给定一些长度为L[i]的木料，将他们据成k段，返回满足条件的最大长度。</p><p>先找到木料中最长的那块，长度为m然后对m进行二分法，判断这些木料是否可以据成长度为mid，个数&gt;=k个木料：</p><ol><li>如果可以，start = mid，进一步二分看是否可以据成更长的</li><li>如果不可以，end = mid，进一步二分据成更短的小段</li></ol><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param L: Given n pieces of wood with length L[i]</span></div><div class="line"><span class="comment">     * @param k: An integer</span></div><div class="line"><span class="comment">     * @return: The maximum length of the small pieces</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] L,<span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;L.length;i++)&#123;</div><div class="line">            sum += L[i]/len;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">woodCut</span><span class="params">(<span class="keyword">int</span>[] L, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到最长的wood，</span></div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(L[i] &gt; max)&#123;</div><div class="line">                max = L[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//对要切割的wood长度做二分法</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = max;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(count(L,mid) &gt;= k)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count(L,end) &gt;= k)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count(L,start) &gt;= k)&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Count-of-Smaller-Numbers-After-Self"><a href="#Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/" target="_blank" rel="external">Count of Smaller Numbers After Self</a></h3><h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title=" Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="external"> Sqrt(x)</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement <code>int sqrt(int x)</code>.</p><p>Compute and return the square root of <em>x</em>.</p><p><strong>x</strong> is guaranteed to be a non-negative integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 4</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 8</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>输入数字x，返回根号x，只保留整数部分</p><p>思路就是找到最后一个number k，满足条件k^2 &lt; x，则k就是结果</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = x;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(mid * mid &lt;= x)&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(end*end &lt;= x)&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Rotate-Array"><a href="#Rotate-Array" class="headerlink" title="Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="external">Rotate Array</a></h3><blockquote><p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p><p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p></blockquote><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>三步翻转法：</p><ol><li><p>翻转左半段</p><p>4,3,2,1,5,6,7</p></li><li><p>翻转右半段</p><p>4,3,2,1,7,6,5</p></li><li><p>翻转整体</p><p>5,6,7,1,2,3,4</p></li></ol><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        k = k % nums.length;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - k - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        start = nums.length - k;</div><div class="line">        end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        start = <span class="number">0</span>;</div><div class="line">        end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[start];</div><div class="line">            nums[start] = nums[end];</div><div class="line">            nums[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Words-in-a-String-II"><a href="#Reverse-Words-in-a-String-II" class="headerlink" title="Reverse Words in a String II"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/description/" target="_blank" rel="external">Reverse Words in a String II</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p><p>The input string does not contain leading or trailing spaces and the words are always separated by a single space.</p><p>For example,<br>Given s = “<code>the sky is blue</code>“,<br>return “<code>blue is sky the</code>“.</p><p>Could you do it <em>in-place</em> without allocating extra space?</p></blockquote><h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>三步翻转法</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(end &lt; str.length)&#123;</div><div class="line">        <span class="keyword">while</span>(end &lt; str.length &amp;&amp; str[end] != <span class="string">' '</span>)&#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> stop = end-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= stop)&#123;</div><div class="line">            <span class="keyword">char</span> temp = str[start];</div><div class="line">            str[start] = str[stop];</div><div class="line">            str[stop] = temp;</div><div class="line">            start++;</div><div class="line">            stop--;</div><div class="line">        &#125;</div><div class="line">        start = end+<span class="number">1</span>;</div><div class="line">        end = end+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    start = <span class="number">0</span>;</div><div class="line">    end = str.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">        <span class="keyword">char</span> temp = str[start];</div><div class="line">        str[start] = str[end];</div><div class="line">        str[end] = temp;</div><div class="line">        start++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">Find the Duplicate Number</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><strong>Note:</strong></p><ol><li>You <strong>must not</strong> modify the array (assume the array is read only).</li><li>You must use only constant, <em>O</em>(1) extra space.</li><li>Your runtime complexity should be less than <code>O(n2)</code>.</li><li>There is only one duplicate number in the array, but it could be repeated more than once.</li></ol></blockquote><h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>题目说有个n+1长的数组，里面的元素的范围在1~n，所以必定会有重复的元素，要求我们找出重复的元素。</p><ol><li><p>baseline：</p><p>遍历，时间复杂度<script type="math/tex">O(n^2)</script>，超时</p></li><li><p>二分法：</p><p>start = 1;end = n</p><p>mid = (1+n)/2;</p><p>遍历数组，记录值&lt;=mid的元素个数sum，分两种情况讨论：</p><p>​    a. sum &lt;= mid，在1~mid之间的数组少于mid，说明重复数字在mid+1~len-1里，故令left = mid+1</p><p>​    b. sum &gt; mid，在1~mid之间的数组多于mid，说明重复数字在1~mid里，故令right = mid</p></li></ol><p>方法二:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">idx: <span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></div><div class="line">val: <span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">2</span></div><div class="line">实质：用下标idx的正负表示该数字idx是否出现过，如果出现过idx对应的数字为负数，否则为正数</div><div class="line">从左向右遍历，把遇到的数字在数组中的下标标记为负值，当遇到下标对应的值已经为负数时，返回该下标：</div><div class="line">i = <span class="number">0</span> , val = <span class="number">1</span>,将nums[<span class="number">1</span>]标记为负数</div><div class="line">idx: <span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></div><div class="line">val: <span class="number">1</span>-<span class="number">2</span><span class="number">3</span><span class="number">2</span></div><div class="line">i = <span class="number">1</span> ，val = abs(-<span class="number">2</span>) = <span class="number">2</span> , 将nums[<span class="number">2</span>]标记为负数</div><div class="line">idx: <span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></div><div class="line">val: <span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span><span class="number">2</span></div><div class="line">i = <span class="number">2</span> ，val = abs(-<span class="number">3</span>) = <span class="number">3</span> , 将nums[<span class="number">3</span>]标记为负数</div><div class="line">idx: <span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></div><div class="line">val: <span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span>-<span class="number">2</span></div><div class="line">i = <span class="number">3</span> ，val = abs(-<span class="number">2</span>) = <span class="number">2</span> , 此时nums[<span class="number">2</span>] &lt; <span class="number">0</span>，则返回<span class="number">2</span></div><div class="line">idx: <span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></div><div class="line">val: <span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span>-<span class="number">2</span></div></pre></td></tr></table></figure><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(left &lt;right)&#123;</div><div class="line">    <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录在1~mid之间的数字有多少个</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt;= mid)&#123;</div><div class="line">        sum++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在1~mid之间的数组少于mid，说明重复数字在mid+1~len-1里</span></div><div class="line">    <span class="keyword">if</span>(sum &lt;= mid)&#123;</div><div class="line">      left = mid + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在1~mid之间的数组多于mid，说明重复数字在1~mid里</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      right = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;h2 id=&quot;classical-Binary-Search&quot;&gt;&lt;a href=&quot;#classical-Binary-Search&quot; class=&quot;headerlink&quot; title=&quot;classical Binary Search&quot;&gt;&lt;/a&gt;classical Binary Search&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;给定一个排序数组和一个元素n，返回元素n的位置&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;index&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;num&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;查找元素5的位置&lt;/p&gt;
&lt;h3 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h3&gt;&lt;p&gt;初始化:&lt;/p&gt;
&lt;p&gt;​    start = 0;end = 8;mid = 4&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nums[mid] = 13;start = 0;end = 4,mid = 2&lt;/li&gt;
&lt;li&gt;nums[mid] = 5;find it!&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;数据规模为n:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;T(n) = T(n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)+O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;其中O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)为比较的时间复杂度，T(n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)为比较之后&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;时间复杂度是:O(logn)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;递归：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：代码简洁&lt;/li&gt;
&lt;li&gt;缺点：递归利用栈空间，递归层数过多会导致栈溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;while循环&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：占用空间小&lt;/li&gt;
&lt;li&gt;缺点：代码可读性稍差，不够简洁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试的时候用什么？&lt;/p&gt;
&lt;p&gt;如果用递归的方式写会好理解很多，就用递归写，不然就不用递归，在工程上，递归很容易导致栈溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这道题用最好用非递归的方式写，因为是很简短的&lt;/p&gt;
&lt;h3 id=&quot;通用模板&quot;&gt;&lt;a href=&quot;#通用模板&quot; class=&quot;headerlink&quot; title=&quot;通用模板&quot;&gt;&lt;/a&gt;通用模板&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;start + 1 &amp;lt; end&lt;/li&gt;
&lt;li&gt;mid = start +(end - start)/2;如果用(start + end)/2，如果start和end都很大相加就有可能溢出&lt;/li&gt;
&lt;li&gt;A[mid] = &amp;lt; &amp;gt; 三种情况讨论&lt;/li&gt;
&lt;li&gt;A[start] A[end]?target&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;findPosition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; target)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums.length &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// write your code here&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end = nums.length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (start + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; end) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//中值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mid = start + (end - start) / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//三种情况讨论&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[mid] == target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                end = mid;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[mid] &amp;lt; target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                start = mid;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[mid] &amp;gt; target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                end = mid;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[start] == target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; start;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[end] == target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>WAND算法</title>
    <link href="http://yoursite.com/2017/12/07/WAND%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/07/WAND算法/</id>
    <published>2017-12-07T03:39:47.000Z</published>
    <updated>2017-12-13T12:12:02.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-24-15.png" alt="所致"> </p><a id="more"></a><p><strong>sort()</strong>：把terms按照posting单钱所指向的documentID排序，比如：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-30-11.png" alt=""> </p><p>图中黄颜色的数字就是posting当前所指的documentID</p><p>pTerm：从上到下累加发现大于U的那个term</p><p>pivot:pTerm这一行当前所指的documentID</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2017-12-07-14-24-15.png&quot; alt=&quot;所致&quot;&gt; &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】二叉树与分治法</title>
    <link href="http://yoursite.com/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>http://yoursite.com/2017/11/29/【九章算法基础班】二叉树与分治法/</id>
    <published>2017-11-29T15:54:50.000Z</published>
    <updated>2018-01-20T13:59:24.956Z</updated>
    
    <content type="html"><![CDATA[<p>数组：内存空间连续，支持下标访问，访问时间复杂度<script type="math/tex">O(1)</script></p><p>链表：内存空间不联系，不支持下表访问，访问时间复杂度<script type="math/tex">O(n)</script></p><h2 id="树形分析法求解时间复杂度："><a href="#树形分析法求解时间复杂度：" class="headerlink" title="树形分析法求解时间复杂度："></a>树形分析法求解时间复杂度：</h2><script type="math/tex; mode=display">T(n) = T(n/2)+O(1)   ->  O(logn)</script><script type="math/tex; mode=display">T(n) = T(n/2)+O(n) -> O(n)</script><script type="math/tex; mode=display">T(n) = 2T(n/2) + O(1) -> O(n)</script><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(<span class="number">1</span>) -&gt; O(n)</div><div class="line">O(<span class="number">1</span>)：一次拆分所需时间</div><div class="line"> --         n</div><div class="line">  |               ↙             ↘       ················O(<span class="number">1</span>)拆分所需时间</div><div class="line">  |            n/<span class="number">2</span>                n/<span class="number">2</span></div><div class="line">log(n)      ↙       ↘          ↙       ↘················O(<span class="number">2</span>)</div><div class="line">  |       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span></div><div class="line">  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘················O(<span class="number">4</span>)</div><div class="line">  |    n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>   n/<span class="number">8</span>  n/<span class="number">8</span>   </div><div class="line">  |································O(n)</div><div class="line">  | n/nn/nn/n·············n/nn/nn/n</div><div class="line"> --</div><div class="line"> O(<span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+....+n) = O(<span class="number">2</span>n-<span class="number">1</span>) = O(n)</div><div class="line"> 由此如果T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(<span class="number">1</span>)，则时间复杂度为O(n)</div></pre></td></tr></table></figure><a id="more"></a><script type="math/tex; mode=display">T(n) = 2T(n/2) + O(n) -> O(n*logn)</script><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(n) -&gt; O(n)</div><div class="line">O(n)：一次拆分所需时间</div><div class="line"> --         n</div><div class="line">  |               ↙             ↘       ··············O(n)拆分所需时间</div><div class="line">  |            n/<span class="number">2</span>                n/<span class="number">2</span></div><div class="line">log(n)      ↙       ↘          ↙       ↘··············O(n/<span class="number">2</span>)*<span class="number">2</span>=O(n)</div><div class="line">  |       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span>       n/<span class="number">4</span></div><div class="line">  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘·············O(n/<span class="number">4</span>)*<span class="number">4</span>=O(n)</div><div class="line">  |    n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>  n/<span class="number">8</span>   n/<span class="number">8</span>  n/<span class="number">8</span>   </div><div class="line">  |·····························O(n/n)*n=O(n)</div><div class="line">  | n/nn/nn/n·············n/nn/nn/n</div><div class="line"> --</div><div class="line"> O(n+n+...+n)*logn = O(nlogn)</div><div class="line"> 由此如果T(n) = <span class="number">2</span>T(n/<span class="number">2</span>) + O(n)，则时间复杂度为O(nlogn)</div></pre></td></tr></table></figure><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>树的遍历三种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     <span class="number">1</span></div><div class="line">    ↙ ↘</div><div class="line">  <span class="number">2</span>     <span class="number">3</span></div><div class="line"> ↙ ↘</div><div class="line"><span class="number">4</span>   <span class="number">5</span></div><div class="line">- 前序遍历（根左右）: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span></div><div class="line">- 中序遍历（左根右）: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></div><div class="line">- 后序遍历（左右根）: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></div></pre></td></tr></table></figure><h3 id="1-前序遍历Binary-Tree-Preorder-Traversal"><a href="#1-前序遍历Binary-Tree-Preorder-Traversal" class="headerlink" title="1.前序遍历Binary Tree Preorder Traversal"></a>1.前序遍历<a href="https://leetcode.com/problems/binary-tree-preorder-traversal" target="_blank" rel="external">Binary Tree Preorder Traversal</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[1,2,3]</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol><li><p>递归法</p><p>首先遍历根节点，然后对其左节点做前序遍历，对其右节点做前序遍历。</p><p><strong>递归三要素</strong>：</p><ul><li>定义：要做什么事情，这道题就是先遍历父亲节点，然后左节点、右节点</li><li>拆分：差分成同样的问题，但规模变小，本题就是拆成左子树和右子树，对左子树和右字数分别做前序遍历</li><li>结束条件：遇到空节点停止。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">  traverse(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    result.add(root.val);</div><div class="line">    traverse(root.left,result);</div><div class="line">    traverse(root.right,result);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>分治法</p><p>分而治之，先分开求结果，再合并</p><p>先得到左子树的结果，再得到右子树的结果，然后将左子、右子树、root结果合并得到最终结果。</p><p>通常来说，分治法的函数是有返回值的。</p><p><strong>分治法三要素：</strong></p><ul><li>定义：要做什么事情</li><li>拆分与合并问题：</li><li>结束条件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">divide</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="comment">//结束条件</span></div><div class="line">  <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分问题，获取子问题结果</span></div><div class="line">  ArrayList&lt;Integer&gt; leftres = divide(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; righttres = divide(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//合并子问题</span></div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  result.add(root.val);</div><div class="line">  result.addAll(leftres);</div><div class="line">  result.addAll(righttres);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​</p></li><li><p>非递归方法</p><p><strong>阅读理解并背诵</strong></p><p>利用stack实现树的前序遍历，每次弹出栈顶元素，先后压入其右孩子和左孩子。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        List&lt;Integer&gt; preorder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> preorder;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根节点入栈</span></div><div class="line">        stack.push(root);</div><div class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</div><div class="line">            TreeNode node = stack.pop();</div><div class="line">            preorder.add(node.val);</div><div class="line">            <span class="comment">//右孩子入栈</span></div><div class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(node.right);</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//左孩子入栈</span></div><div class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(node.left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> preorder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="中序遍历Binary-Tree-Inorder-Traversal"><a href="#中序遍历Binary-Tree-Inorder-Traversal" class="headerlink" title="中序遍历Binary Tree Inorder Traversal"></a>中序遍历<a href="https://leetcode.com/problems/binary-tree-inorder-traversal" target="_blank" rel="external">Binary Tree Inorder Traversal</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[1,3,2]</code>.</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">        <span class="comment">//终止条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分问题</span></div><div class="line">        helper(root.left,result);</div><div class="line">        result.add(root.val);</div><div class="line">        helper(root.right,result);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">        helper(root,result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//终止条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//拆分</span></div><div class="line">        ArrayList&lt;Integer&gt; leftRes = inorderTraversal(root.left);</div><div class="line">        ArrayList&lt;Integer&gt; rightRes = inorderTraversal(root.right);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        result.addAll(leftRes);</div><div class="line">        result.add(root.val);</div><div class="line">        result.addAll(rightRes);</div><div class="line"></div><div class="line">        <span class="comment">//返回结果</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归方法，很重要！！！！！！！！！！！！！！！</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        TreeNode curt = root;</div><div class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.empty()) &#123;</div><div class="line">            <span class="keyword">while</span> (curt != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.add(curt);</div><div class="line">                curt = curt.left;</div><div class="line">            &#125;</div><div class="line">            curt = stack.pop();</div><div class="line">            result.add(curt.val);</div><div class="line">            curt = curt.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="后序遍历Binary-Tree-Postorder-Traversal"><a href="#后序遍历Binary-Tree-Postorder-Traversal" class="headerlink" title="后序遍历Binary Tree Postorder Traversal"></a>后序遍历<a href="https://leetcode.com/problems/binary-tree-postorder-traversal" target="_blank" rel="external">Binary Tree Postorder Traversal</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;     /</div><div class="line">&gt;    3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[3,2,1]</code>.</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="comment">//终止条件</span></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分问题</span></div><div class="line">  helper(root.left,result);</div><div class="line">  helper(root.right,result);</div><div class="line">  result.add(root.val);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</div><div class="line">  helper(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//分治法</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//拆分</span></div><div class="line">  ArrayList&lt;Integer&gt; leftRes = postorderTraversal(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; rightRes = postorderTraversal(root.right);</div><div class="line">  <span class="comment">//合并</span></div><div class="line">  result.addAll(leftRes);</div><div class="line">  result.addAll(rightRes);</div><div class="line">  result.add(root.val);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="分治法相比于遍历法的优点："><a href="#分治法相比于遍历法的优点：" class="headerlink" title="分治法相比于遍历法的优点："></a>分治法相比于遍历法的优点：</h3><ol><li>无需全局变量存储结果，无需helper函数</li><li>可并行</li></ol><h3 id="二叉树三种遍历的非递归实现"><a href="#二叉树三种遍历的非递归实现" class="headerlink" title="二叉树三种遍历的非递归实现"></a>二叉树三种遍历的非递归实现</h3><h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>三种遍历的非递归解决思路核心思想是一致的：</p><ol><li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li><li>使用同样的顺序将“左”节点入栈</li><li>在合适的时机转向（转向后，“右”节点即成为“左”节点）、访问节点、或出栈</li></ol><p>比如{1,2,3}，当cur位于节点1时，1、2属于“左”节点，3属于“右”节点。DFS的非递归实现本质上是在协调入栈、出栈和访问，三种操作的顺序。上述统一使得我们不再需要关注入栈顺序，仅需要关注出栈和访问（第3点），随着更详细的分析，你将更加体会到这种简化带来的好处。</p><p>将对节点的访问定义为<code>results.add(node.val);</code>，分析如下：</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历的顺序是：根-&gt;左-&gt;右，按照上面提到的思路，可以简化为左-&gt;右</p><p>从root节点开始访问，依次向下访问左节点(cur指向当前节点)，此时立即将这些“左”节点输出到结果中，同时把他们压入栈，便于后续访问其右节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">    results.add(cur.val);</div><div class="line">    stack.push(cur);</div><div class="line">    cur = cur.left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面循环结束意味着我们已经访问过所有的“左”节点，现在需要将这些节点出栈，转到其“右”节点，此时右节点也变成了“左”节点，需要对其进行上面的处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">    cur = stack.pop();</div><div class="line">    <span class="comment">// 转向</span></div><div class="line">    cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">nonRecursion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈和cur都为空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先序与中序的区别只在于对“左”节点的处理上，前序遍历是先访问实际根，再访问左节点，而中序是先访问实际左节点，再访问实际根节点，所以需要将中序改为出栈时才访问这个节点的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">  stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">  cur = cur.left;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">  cur = stack.pop();</div><div class="line">  results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">  cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">nonRecursion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈和cur都为空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(cur);<span class="comment">//左节点入栈</span></div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">              results.add(cur.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历的实际访问顺序是：左右根</p><p>入栈顺序不变，需考虑转向和出栈时机。</p><p>对于实际的根，需要保证先后访问了左子树、右子树之后，才能访问根。实际的右节点、左节点、根节点都会成为“左”节点入栈，所以我们只需要<strong>在出栈之前，将该节点视作实际的根节点，并检查其右子树是否已被访问</strong>即可。如果不存在右子树，或右子树已被访问了，那么可以访问根节点，出栈，并不需要转向；如果还没有访问，就转向，使其“右”节点成为“左”节点，等着它先被访问之后，再来访问根节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNodeWithFlag</span> </span>&#123;</div><div class="line">        TreeNode node;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        TreeNodeWithFlag(TreeNode node,<span class="keyword">boolean</span> flag) &#123;</div><div class="line">            <span class="keyword">this</span>.flag = flag;</div><div class="line">            <span class="keyword">this</span>.node = node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNodeWithFlag&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;<span class="comment">//停止条件：栈空或cur空</span></div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">                stack.push(<span class="keyword">new</span> TreeNodeWithFlag(cur,<span class="keyword">false</span>));<span class="comment">//左节点入栈，标记为右子树未访问</span></div><div class="line">                cur = cur.left;<span class="comment">//继续访问左子树</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                <span class="keyword">if</span>(stack.peek().flag)&#123;<span class="comment">//右子树已经处理过</span></div><div class="line">                    results.add(stack.peek().node.val);<span class="comment">//左节点加入结果集</span></div><div class="line">                    stack.pop();<span class="comment">//弹出</span></div><div class="line">                    cur = <span class="keyword">null</span>;<span class="comment">//左右根节点都已处理过，不转向，继续弹栈</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//右子树没有处理过</span></div><div class="line">                    stack.peek().flag = <span class="keyword">true</span>;<span class="comment">//标记为已处理</span></div><div class="line">                    cur = stack.peek().node.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h2><h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="external">Maximum Depth of Binary Tree</a></h3><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p></blockquote><p>给定一个数，求出树的最大深度</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="comment">//终止条件</span></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//拆分成求解左子树和右子树的最大深度</span></div><div class="line">  <span class="keyword">int</span> leftDepth = maxDepth(root.left);</div><div class="line">  <span class="keyword">int</span> rihtDepth = maxDepth(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//合并，根节点的最大深度=max(左子树最大深度，右子树最大深度)+1</span></div><div class="line">  <span class="keyword">int</span> res = Math.max(leftDepth,rihtDepth)+<span class="number">1</span>;</div><div class="line">  <span class="comment">//返回结果</span></div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree" target="_blank" rel="external">Balanced Binary Tree</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><p>判断二叉树是否是平衡二叉树：</p><ol><li>左右子树平衡</li><li>左子树和右子树的高度差不超过1</li></ol><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">考虑某一个时间成立或者不成立需要考虑多个因素的时候，需要定义一个<span class="class"><span class="keyword">class</span> <span class="title">ResultType</span>把这两个值包进去，存储中间结果。</span></div><div class="line"><span class="class">//定义<span class="title">resultType</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isBalanced;<span class="comment">//是否平衡</span></div><div class="line">        <span class="keyword">int</span> maxDepth;<span class="comment">//最大深度</span></div><div class="line">        ResultType(<span class="keyword">boolean</span> isBalanced,<span class="keyword">int</span> maxDepth)&#123;</div><div class="line">            <span class="keyword">this</span>.isBalanced = isBalanced;</div><div class="line">            <span class="keyword">this</span>.maxDepth = maxDepth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="comment">//结束条件</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分成分别计算左子树的右子树信息</span></div><div class="line">        ResultType leftRes = helper(root.left);</div><div class="line">        ResultType rightRes = helper(root.right);</div><div class="line">        </div><div class="line">        <span class="comment">//如果左右有一个不是平衡树</span></div><div class="line">        <span class="keyword">if</span>(!leftRes.isBalanced || !rightRes.isBalanced)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//都是平衡树，但深度差&gt;1</span></div><div class="line">        <span class="keyword">if</span>(Math.abs(leftRes.maxDepth-rightRes.maxDepth) &gt;<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//都是平衡树，深度差&lt;=1，node节点最大深度=max(左、右子树深度)+1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.max(rightRes.maxDepth,leftRes.maxDepth)+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root).isBalanced;<span class="comment">//返回根节点是否是平衡。</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="external">Lowest Common Ancestor of a Binary Tree</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         _______3______</div><div class="line">&gt;        /              \</div><div class="line">&gt;     ___5__          ___1__</div><div class="line">&gt;    /      \        /      \</div><div class="line">&gt;    6      _2       0       8</div><div class="line">&gt;          /  \</div><div class="line">&gt;          7   4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>For example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p></blockquote><p>给一棵二叉树和二叉树上的两个点，返回其最近公共祖先</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">如果二叉树中存储了父亲节点，则可以从两个点出发往上寻找至root:</div><div class="line">比如<span class="number">5</span>和<span class="number">1</span>：</div><div class="line"><span class="number">5</span>:[<span class="number">5</span>,<span class="number">3</span>]</div><div class="line"><span class="number">1</span>:[<span class="number">1</span>,<span class="number">3</span>]</div><div class="line">得到路径之后从后向前遍历，<span class="number">3</span>,<span class="number">3</span>一样，<span class="number">5</span>,<span class="number">1</span>不一样了，所以最近公共祖先是<span class="number">3</span></div><div class="line"></div><div class="line">再比如<span class="number">5</span>和<span class="number">4</span>：</div><div class="line"><span class="number">5</span>:[<span class="number">5</span>,<span class="number">3</span>]</div><div class="line"><span class="number">4</span>:[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</div><div class="line">从后向前遍历，发现<span class="number">3</span>,<span class="number">5</span>之后不一样了，所以公共祖先是<span class="number">5</span></div><div class="line"></div><div class="line">如果没有存储父亲节的信息，给定root节点和连个点n1,n2:</div><div class="line">        _______3______</div><div class="line">       /              \</div><div class="line">    ___5__          ___1__</div><div class="line">   /      \        /      \</div><div class="line">   <span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></div><div class="line">         /  \</div><div class="line">         <span class="number">7</span>   <span class="number">4</span></div><div class="line">n1和n2的分布情况有以下几种：</div><div class="line"><span class="number">1</span>.其中有一个是root -&gt; 返回root</div><div class="line"><span class="number">2</span>.全在左子树 -&gt; 返回左子树root</div><div class="line"><span class="number">3</span>.全在右子树 -&gt; 返回右子树root</div><div class="line"><span class="number">4</span>.一个在左子树、一个在右子树 -&gt; 返回root</div><div class="line"><span class="number">5</span>.这两个点不在这棵树里 -&gt; 返回<span class="keyword">null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;<span class="comment">//其中有一个是根节点</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分,分别在左、右子树中寻找LCA</span></div><div class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;<span class="comment">//一个在左子树，一个在右子树，则LCA为root</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;<span class="comment">//两个节点都在左子树</span></div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;<span class="comment">//两个节点都在右子树</span></div><div class="line">            <span class="keyword">return</span> right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="comment">//左右子树的LCA都是null,都没有这俩节点</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Binary-Tree-Maximum-Path-Sum-II"><a href="#Binary-Tree-Maximum-Path-Sum-II" class="headerlink" title="Binary Tree Maximum Path Sum II"></a>Binary Tree Maximum Path Sum II</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，从根节点root出发，求最大路径和，可以在任一点结束</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">如果是求从root到leaf的最大路径，就用分治法，从上到下，每个节点的最大路径是其左子树和右子树的最大路径的最大值:</div><div class="line">root.val + Math.max(maxleft,maxright)</div><div class="line">如果二叉树上的节点值有负数，那么最大路径就有可能不到leaf就结束了，所以在计算节点最大路径时，如果其左右子树最大路径的最大值为负数，则该节点到leaf的最大路径长度应该为<span class="number">0</span>：</div><div class="line">root.val + Math.max(<span class="number">0</span>,Math.max(maxleft,maxright))</div></pre></td></tr></table></figure><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum2</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> maxleft = maxPathSum2(root.left);</div><div class="line">  <span class="keyword">int</span> maxright = maxPathSum2(root.right);</div><div class="line"></div><div class="line">  <span class="comment">//root-&gt;leaf</span></div><div class="line">  <span class="comment">//return root.val + Math.max(maxleft,maxright);</span></div><div class="line"></div><div class="line">  <span class="comment">//root-&gt;any</span></div><div class="line">  <span class="keyword">return</span> root.val + Math.max(<span class="number">0</span>,Math.max(maxleft,maxright));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之前的题目复杂度基本都是O(n)，分析：</p><p>一共有多少个点<em>每个点上的时间复杂度 = n </em> O(1) = O(n)</p><h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="external">Binary Tree Maximum Path Sum</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p>For example:<br>Given the below binary tree,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return <code>6</code>.</p></blockquote><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">跟LCA问题思考方式类似，考虑某一点root的最大路径的位置可能有如下三种情况：</div><div class="line"><span class="number">1</span>.都在左子树中(root.left:any-&gt;any)</div><div class="line"><span class="number">2</span>.都在右子树中(root.right:any-&gt;any)</div><div class="line"><span class="number">3</span>.跨过root节点左右子树中都有(root:any-&gt;any)</div><div class="line">对三种情况取个最大，就是该root节点的最大路径长度</div><div class="line"></div><div class="line">对于第三种情况，可以分为三个子问题：</div><div class="line">A:从左子节点出发的最大路径长度（root.left-&gt;any）</div><div class="line">root</div><div class="line">B:从右子节点出发的最大路径长度（root.right-&gt;any）</div><div class="line">对三个子问题求和，就是跨过此root节点的最大路径长度</div><div class="line"></div><div class="line"></div><div class="line">这里需要同时计算any-&gt;any和root-&gt;any，所以需要定义一个ResultType存储每个节点的any-&gt;any和root-&gt;any</div></pre></td></tr></table></figure><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> root2any;</div><div class="line">    <span class="keyword">int</span> any2any;</div><div class="line">    ResultType(<span class="keyword">int</span> root2any,<span class="keyword">int</span> any2any)&#123;</div><div class="line">        <span class="keyword">this</span>.any2any = any2any;</div><div class="line">        <span class="keyword">this</span>.root2any = root2any;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    <span class="comment">//题目要求至少要包含一个node，所以此时不满足条件，应返回负无穷</span></div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(Integer.MIN_VALUE,Integer.MIN_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//divide</span></div><div class="line">    ResultType leftRes = helper(root.left);</div><div class="line">    ResultType rightRes = helper(root.right);</div><div class="line"></div><div class="line">    <span class="comment">//conquer</span></div><div class="line">    <span class="comment">//root到左边或右边</span></div><div class="line">    <span class="keyword">int</span> root2any = Math.max(<span class="number">0</span>,Math.max(leftRes.root2any,rightRes.root2any)) + root.val;</div><div class="line"></div><div class="line">    <span class="comment">//包含完全在左边、完全在右边和跨过root三种情况</span></div><div class="line">    <span class="comment">//完全在左边和完全在右边的情况</span></div><div class="line">    <span class="keyword">int</span> any2any = Math.max(leftRes.any2any,rightRes.any2any);</div><div class="line">    </div><div class="line">    <span class="comment">//跨过root,分别在两边的情况</span></div><div class="line">    any2any = Math.max(any2any,</div><div class="line">            Math.max(<span class="number">0</span>,leftRes.root2any) </div><div class="line">            + Math.max(<span class="number">0</span>,rightRes.root2any)</div><div class="line">            + root.val</div><div class="line">            );</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(root2any,any2any);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> helper(root).any2any;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h2><h3 id="二叉搜索树的基本性质"><a href="#二叉搜索树的基本性质" class="headerlink" title="二叉搜索树的基本性质"></a>二叉搜索树的基本性质</h3><ol><li><p>从定义出发</p><p>左子树都比跟节点小</p><p>右子树都比根节点大</p><p>遇到重复的元素，可以自行定义放在左子树还是右子树</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line">  ↙   ↘ ...... 是BST</div><div class="line"> <span class="number">1</span>     <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="number">1</span></div><div class="line">  ↙   ↘ ......不是BST</div><div class="line"> <span class="number">1</span>     <span class="number">1</span></div><div class="line">因为BST的定义是比根节点小（包括相等）的要么都在左边，要么都在右边</div></pre></td></tr></table></figure></li><li><p>从效果出发</p><p><strong>BST的中序遍历是升序序列</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例：</div><div class="line"><span class="number">2</span></div><div class="line">  ↙   ↘ </div><div class="line"> <span class="number">1</span>     <span class="number">4</span>           中序遍历：<span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></div><div class="line">    ↙   ↘ </div><div class="line"><span class="number">3</span>     <span class="number">5</span></div></pre></td></tr></table></figure><p>利用BST的这个性质，可以做排序：<br>比如给定一个无序序列[2,1,4,3,5]<br>可以构造一个BST，然后再中序遍历，输出序列就是有序序列了</p><p>因此，<strong>BST又叫排序二叉树</strong></p><p>相关练习题：</p><p>Binary Search Tree 的insert、remove等</p></li><li><p>性质</p><ul><li><p>如果一棵二叉树的中序遍历不是升序，则一定不是BST</p></li><li><p>如果一棵二叉树的中序遍历是升序，也未必是BST</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">比如：</div><div class="line">    <span class="number">1</span></div><div class="line">  ↙   ↘ </div><div class="line"> <span class="number">1</span>     <span class="number">1</span></div><div class="line">中序遍历得到[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，是升序序列，但是不是BST</div></pre></td></tr></table></figure><p>​</p></li><li><p>存在重复元素时，要么都在左子树要么都在右子树，不可以两边都有</p></li></ul></li></ol><h3 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree" target="_blank" rel="external">Validate Binary Search Tree</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     2</div><div class="line">&gt;    / \</div><div class="line">&gt;   1   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Binary tree </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [2,1,3]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>, return true.</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     1</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Binary tree </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [1,2,3]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>, return false.</p></blockquote><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>给定一个二叉树，判断是否是二叉搜索树，两种思路:</p><ol><li>根据二叉搜索树的性质，中序遍历是升序序列，可以对给定二叉树进行中序遍历，输出序列如果是升序序列则是二叉搜索树，可以利用二叉树的非递归中序遍历，每次弹栈时跟前一个元素进行比较，如果小于等于前一个元素就直接返回false。</li><li>分治法递归判断，需要存储节点以下是否是BST，以及节点以下部分的最大最小值，和root节点进行比较，是否满足左子树所有元素都小于root,右子树所有节点都大于root。</li></ol><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//分治法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isValid;</div><div class="line">        <span class="keyword">long</span> min;</div><div class="line">        <span class="keyword">long</span> max;</div><div class="line">        ResultType(<span class="keyword">boolean</span> isValid,<span class="keyword">long</span> min,<span class="keyword">long</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.isValid = isValid;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">            <span class="keyword">this</span>.min = min;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Long.MAX_VALUE,Long.MIN_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//拆分</span></div><div class="line">        ResultType leftValid = helper(root.left);</div><div class="line">        ResultType rightValid = helper(root.right);</div><div class="line"></div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">if</span>(leftValid.isValid &amp;&amp; rightValid.isValid)&#123;<span class="comment">//左右子树都是BST</span></div><div class="line">            <span class="keyword">if</span>(leftValid.max &lt; root.val &amp;&amp; rightValid.min &gt; root.val)&#123;<span class="comment">//左边元素都比root小，右边元素都比root大</span></div><div class="line">                ResultType res = <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.min(leftValid.min,root.val),Math.max(rightValid.max,root.val));</div><div class="line">                <span class="keyword">return</span> res;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,Math.min(leftValid.min,root.val),Math.max(rightValid.max,root.val));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,Long.MIN_VALUE,Long.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root).isValid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归中序遍历</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> last = Integer.MIN_VALUE;</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ||!stack.empty())&#123;</div><div class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(cur);</div><div class="line">                cur = cur.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">                cur = stack.pop();</div><div class="line">                <span class="keyword">if</span>(cur.val &lt;= last)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator" target="_blank" rel="external">Binary Search Tree Iterator</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p><p>Calling <code>next()</code> will return the next smallest number in the BST.</p><p><strong>Note: </strong><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p></blockquote><p>设计实现一个带有下列属性的二叉查找树的迭代器：</p><ol><li>元素按照递增的顺序被访问（比如中序遍历）</li><li>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</li></ol><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [3, 6, 7, 8, 9, 10, 11, 12]</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     10</div><div class="line">   /    \</div><div class="line">  6      11</div><div class="line"> / \       \</div><div class="line">3   9       12</div><div class="line">   /</div><div class="line">  8</div><div class="line"> /</div><div class="line">7</div></pre></td></tr></table></figure><ul><li>本题相当于考察了BST的非递归中序遍历</li><li>需要maintain一个stack，首先从root开始push入栈直到最左节点<br>初始stack为：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10, 6, 3</div></pre></td></tr></table></figure><ul><li>在遍历过程中，如果某个节点存在右儿子，则继续从右儿子开始push入栈直到其最左节点<br>result = 3, 6<br>因为6有右儿子，所以6被pop出去之后，从6为root开始push入栈直到最左节点，然后stack为：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10， 9， 8， 7</div></pre></td></tr></table></figure><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</div><div class="line">            val = x;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</div><div class="line">        TreeNode root;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">//初始化，将root全部left入栈</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.root = root;</div><div class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> !stack.empty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            TreeNode temp = stack.pop();</div><div class="line">            <span class="keyword">int</span> val = temp.val;</div><div class="line">            temp = temp.right;</div><div class="line"><span class="comment">//如果弹出节点有右节点，右节点视作左节点，全部左孩子入栈</span></div><div class="line">            <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(temp);</div><div class="line">                temp = temp.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> val;<span class="comment">//返回当前节点值</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Inorder-Successor-in-BST"><a href="#Inorder-Successor-in-BST" class="headerlink" title="Inorder Successor in BST"></a><a href="https://leetcode.com/problems/inorder-successor-in-bst" target="_blank" rel="external">Inorder Successor in BST</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p><p><strong>Note</strong>: If the given node has no in-order successor in the tree, return <code>null</code>.</p></blockquote><p>给定一个二叉搜索树和一个节点p，返回p的后继节点（中序遍历时和p相邻比p大的节点）</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><ol><li>BST的stack实现，弹栈遇到p节点时标记下，下一次弹栈的节点即是所求</li><li>递归实现：<ul><li>如果p的值小于root，则在左子树中寻找后继，若没有找到，则root就是p的后继</li><li>如果p的值大于root，则在右子树中寻找后继节点</li></ul></li></ol><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</div><div class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">  TreeNode cur = root;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;</div><div class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">      stack.push(cur);</div><div class="line">      cur = cur.left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">      cur = stack.pop();</div><div class="line">      <span class="keyword">if</span>(flag == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> cur;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(cur == p)&#123;</div><div class="line">        flag = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      cur = cur.right;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor2</span><span class="params">(TreeNode root, TreeNode p)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//后级节点在左子树或root节点中</span></div><div class="line">        <span class="keyword">if</span>(p.val &lt; root.val)&#123;</div><div class="line">            <span class="comment">//后继节点在以左孩子为root的子树中的位置</span></div><div class="line">            TreeNode left = inorderSuccessor2(root.left,p);</div><div class="line">            <span class="comment">//没有刚好比p大一个的，则root就是p的后继节点</span></div><div class="line">          <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span>  root;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//在左子树中找到了p的后继</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//后继节点在右子树中</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> inorderSuccessor2(root.right,p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Search-Range-in-Binary-Search-Tree"><a href="#Search-Range-in-Binary-Search-Tree" class="headerlink" title="Search Range in Binary Search Tree"></a><a href="http://www.lintcode.com/en/problem/search-range-in-binary-search-tree/" target="_blank" rel="external">Search Range in Binary Search Tree</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree. Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&lt;=x&lt;=k2 and x is a key of given BST. Return all the keys in ascending order.</p><p>Have you met this question in a real interview?</p><p>Yes</p><p>Example</p><p>If k1 = <code>10</code> and k2 = <code>22</code>, then your function should return <code>[12, 20, 22]</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     20</div><div class="line">&gt;    /  \</div><div class="line">&gt;   8   22</div><div class="line">&gt;  / \</div><div class="line">&gt; 4   12</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个二叉搜索树和一个区间，要求升序输出二叉搜索树中在给定区间内的节点</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>中序遍历BST，将符合条件的结果输出即可</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">searchRange</span><span class="params">(TreeNode root, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    TreeNode cur = root;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.empty())&#123;</div><div class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(cur);</div><div class="line">            cur = cur.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</div><div class="line">            cur = stack.pop();</div><div class="line">            <span class="keyword">if</span>(cur.val &lt;= k2 &amp;&amp; cur.val &gt;= k1) &#123;</div><div class="line">                results.add(cur.val);</div><div class="line">            &#125;</div><div class="line">            cur = cur.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Insert-Node-in-Binary-Search-Tree"><a href="#Insert-Node-in-Binary-Search-Tree" class="headerlink" title="Insert Node in Binary Search Tree"></a><a href="http://www.lintcode.com/en/problem/insert-node-in-a-binary-search-tree/" target="_blank" rel="external">Insert Node in Binary Search Tree</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary search tree and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.</p><h5 id="Notice"><a href="#Notice" class="headerlink" title="** Notice"></a>** Notice</h5><p>You can assume there is no duplicate values in this tree + node.</p><p>Have you met this question in a real interview?</p><p>Yes</p><p>Example</p><p>Given binary search tree as follow, after Insert node 6, the tree should be:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   2             2</div><div class="line">&gt;  / \           / \</div><div class="line">&gt; 1   4   --&gt;   1   4</div><div class="line">&gt;    /             / \ </div><div class="line">&gt;   3             3   6</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个二叉搜索树和一个新节点，插入新节点，保持二叉树仍然是二叉搜索树</p><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>递归实现，判断node的值和root节点的大小关系，返回值是当前root节点：</p><pre><code>   1. node小于root，要插在左子树，root.left = insertNode(root.left,node); 2. node大于root，要插在右子树，root.right= insertNode(root.right,node);</code></pre><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertNode</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</div><div class="line">        <span class="comment">// 找到插入位置，插入node节点</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//在左子树</span></div><div class="line">        <span class="keyword">if</span>(node.val &lt; root.val)&#123;</div><div class="line">            root.left = insertNode(root.left,node);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//在右子树</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.right = insertNode(root.right,node);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Delete-Node-in-a-BST"><a href="#Delete-Node-in-a-BST" class="headerlink" title="Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst" target="_blank" rel="external">Delete Node in a BST</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><strong>Note:</strong> Time complexity should be O(height of tree).</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [5,3,6,2,4,null,7]</div><div class="line">&gt; key = 3</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   3   6</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 2   4   7</div><div class="line">&gt;</div><div class="line">&gt; Given key to delete is 3. So we find the node with value 3 and delete it.</div><div class="line">&gt;</div><div class="line">&gt; One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   4   6</div><div class="line">&gt;  /     \</div><div class="line">&gt; 2       7</div><div class="line">&gt;</div><div class="line">&gt; Another valid answer is [5,2,6,null,4,null,7].</div><div class="line">&gt;</div><div class="line">&gt;     5</div><div class="line">&gt;    / \</div><div class="line">&gt;   2   6</div><div class="line">&gt;    \   \</div><div class="line">&gt;     4   7</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>首先要找到要删除的节点，然后用它左子树的最大值（或右子树的最小值）的值取代要删除节点的值，再将左子树的最大值（或右子树的最小值）节点删除。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找以root为跟的树的最大节点，root非空</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findMax</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">    root= root.right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找并删除节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span>  <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//在左子树</span></div><div class="line">  <span class="keyword">if</span>(root.val &gt; key)&#123;</div><div class="line">    root.left = deleteNode(root.left,key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//在右子树</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</div><div class="line">    root.right = deleteNode(root.right,key);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//要删除的就是root</span></div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;<span class="comment">//如果左节点是空的</span></div><div class="line">      <span class="keyword">return</span> root.right;<span class="comment">//返回右节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>)&#123;<span class="comment">//左节点非空，右节点为空</span></div><div class="line">      <span class="keyword">return</span> root.left;<span class="comment">//返回左节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//左右节点都非空，用左子树最大节点取代当前节点</span></div><div class="line">    root.val = findMax(root.left).val;</div><div class="line">    <span class="comment">//删除左子树最大值节点</span></div><div class="line">    root.left = deleteNode(root.left,root.val);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal" target="_blank" rel="external">Binary Tree Level Order Traversal</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return its level order traversal as:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [3],</div><div class="line">&gt;   [9,20],</div><div class="line">&gt;   [15,7]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p><strong>广度优先搜索</strong>，利用<code>Queue</code>，先进先出</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-----|--------|-------</div><div class="line">&lt;- <span class="number">3</span> | <span class="number">9</span>   <span class="number">20</span> | <span class="number">15</span>   <span class="number">7</span> </div><div class="line">-----|--------|-------</div></pre></td></tr></table></figure><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  queue.add(root);</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">      TreeNode temp = queue.poll();</div><div class="line">      res.add(temp.val);</div><div class="line">      <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.left);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.right);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    results.add(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>宽度优先搜索最常用的数据结构是队列和hash表，但是在二叉树的问题中不会用到hash表，只会用到Queue队列</p><h3 id="Binary-Tree-Level-Order-Traversal-II"><a href="#Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii" target="_blank" rel="external">Binary Tree Level Order Traversal II</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return its bottom-up level order traversal as:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [15,7],</div><div class="line">&gt;   [9,20],</div><div class="line">&gt;   [3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>跟上一题的差别是层与层之间的顺序是反的，每层元素的顺序不变，所以只需要插入最终的结果集的时候反序插入，所以可以利用LinkedList，每次将每层的结果在前面插入。</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LinkedList&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div><div class="line"></div><div class="line">queue.add(root);</div><div class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">int</span> size = queue.size();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">    TreeNode temp = queue.poll();</div><div class="line">    res.add(temp.val);</div><div class="line">    <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.add(temp.left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.add(temp.right);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  results.addFirst(res);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> results;</div></pre></td></tr></table></figure><h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="external">Binary Tree Zigzag Level Order Traversal</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   9  20</div><div class="line">&gt;     /  \</div><div class="line">&gt;    15   7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return its zigzag level order traversal as:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [3],</div><div class="line">&gt;   [20,9],</div><div class="line">&gt;   [15,7]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>这道题是每一层交替正反序输出，层与层之间的顺序不变，所以result可以使用ArratList，但是每一层的子res要是用LinkedList，额外立flag取定是从前插入还是从后插入。</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  queue.add(root);</div><div class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ;i++)&#123;</div><div class="line">      TreeNode temp = queue.poll();</div><div class="line">      <span class="keyword">if</span>(flag%<span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">        res.addFirst(temp.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        res.addLast(temp.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.left);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">        queue.add(temp.right);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    flag++;</div><div class="line">    results.add(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p><p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p><p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p><p>如上图的例子，DFS访问数组为：ABDECFG。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p><p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>递归是深度优先搜索（DFS）的一种实现形式<ul><li>递归也可以用非递归方式实现</li></ul></li><li>二叉树上的递归<ul><li>遍历法</li><li>分治法</li></ul></li><li>二叉搜索树<ul><li>性质：中序遍历是升序序列</li><li>功能：O(h)的时间复杂度查找、删除、插入，h为BST高度</li></ul></li><li>二叉树上的宽度优先遍历<ul><li>利用队列实现宽度优先搜索</li><li>如何实现分层遍历</li></ul></li><li>必背程序<ul><li>二叉树的前序、中序遍历的非递归实现</li><li>二叉树的层序遍历</li></ul></li><li>二叉树的深度优先遍历DFS<ol><li>递归实现</li><li>非递归实现（stack）</li></ol></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/59e3fde451882578c20858a5" target="_blank" rel="external"><a href="https://link.juejin.im/?target=mailto%3Amonkeysayhi7%40gmail.com" target="_blank" rel="external">猴子007的博客</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组：内存空间连续，支持下标访问，访问时间复杂度&lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;链表：内存空间不联系，不支持下表访问，访问时间复杂度&lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/p&gt;
&lt;h2 id=&quot;树形分析法求解时间复杂度：&quot;&gt;&lt;a href=&quot;#树形分析法求解时间复杂度：&quot; class=&quot;headerlink&quot; title=&quot;树形分析法求解时间复杂度：&quot;&gt;&lt;/a&gt;树形分析法求解时间复杂度：&lt;/h2&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;T(n) = T(n/2)+O(1)   -&gt;  O(logn)&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;T(n) = T(n/2)+O(n) -&gt; O(n)&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;T(n) = 2T(n/2) + O(1) -&gt; O(n)&lt;/script&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;T(n) = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;T(n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) -&amp;gt; O(n)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)：一次拆分所需时间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; --	 			        n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  |               ↙             ↘       ················O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)拆分所需时间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  |            n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;                n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;log(n)      ↙       ↘          ↙       ↘	················O(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  |       n/&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;       n/&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;       n/&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;       n/&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  |      ↙  ↘      ↙  ↘     ↙  ↘      ↙  ↘	················O(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  |    n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;  n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;  n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;  n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;  n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;  n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;  n/&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   			&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  |			················				················O(n)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | n/n	n/n	n/n		·············	n/n	n/n	n/n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; --&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;+....+n) = O(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) = O(n)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 由此如果T(n) = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;T(n/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + O(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)，则时间复杂度为O(n)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
