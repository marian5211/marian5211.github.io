<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-04T08:49:08.612Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++中struct的一些操作</title>
    <link href="http://yoursite.com/2017/11/04/c-%E4%B8%ADstruct%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/04/c-中struct的一些操作/</id>
    <published>2017-11-04T08:49:08.000Z</published>
    <updated>2017-11-04T08:49:08.612Z</updated>
    
    <content type="html"><![CDATA[<p>c++中class和struct的构造函数方式相同：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  Node()：x(<span class="number">0</span>),y(<span class="number">0</span>),z(<span class="number">0</span>)&#123;&#125;;<span class="comment">//无参构造函数</span></div><div class="line">  Node(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k):x(i),y(j),val(k)&#123;&#125;<span class="comment">//有参构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;c++中class和struct的构造函数方式相同：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>c++STL中vector的一些操作</title>
    <link href="http://yoursite.com/2017/11/04/c-STL%E4%B8%ADvector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/04/c-STL中vector的一些操作/</id>
    <published>2017-11-04T08:36:41.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<p>记录c++STL中vector的一些操作</p><h2 id="指定长度vector声明"><a href="#指定长度vector声明" class="headerlink" title="指定长度vector声明"></a>指定长度vector声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);<span class="comment">//长度为n</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n,t);<span class="comment">//长度为n,值为t</span></div></pre></td></tr></table></figure><h2 id="指定长度二维vector声明"><a href="#指定长度二维vector声明" class="headerlink" title="指定长度二维vector声明"></a>指定长度二维vector声明</h2><p>声明一个<script type="math/tex">m*n</script>维的矩阵：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//所有元素都是0</span></div></pre></td></tr></table></figure><h2 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line">sort(vec.begin(),vec.end());</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录c++STL中vector的一些操作&lt;/p&gt;
&lt;h2 id=&quot;指定长度vector声明&quot;&gt;&lt;a href=&quot;#指定长度vector声明&quot; class=&quot;headerlink&quot; title=&quot;指定长度vector声明&quot;&gt;&lt;/a&gt;指定长度vector声明&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vetcor" scheme="http://yoursite.com/tags/vetcor/"/>
    
  </entry>
  
  <entry>
    <title>回溯法、【leetcode】51.52 N-Queens</title>
    <link href="http://yoursite.com/2017/11/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E3%80%90leetcode%E3%80%9151-52-N-Queens/"/>
    <id>http://yoursite.com/2017/11/04/回溯法、【leetcode】51-52-N-Queens/</id>
    <published>2017-11-04T08:35:06.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h2><p>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。<br>如果用爬山来比喻：<br>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。<br>第二点脑子是回溯知道剪枝；如果有一条岔路走不通，那这条路我们不走，就可以少走很多不必要走的路。</p><h2 id="识别回溯问题"><a href="#识别回溯问题" class="headerlink" title="识别回溯问题"></a>识别回溯问题</h2><p>判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。<br>一般回溯的问题有三种：</p><ol><li>Find a path to success 有没有解</li><li>Find all paths to success 求所有解</li></ol><ul><li>求所有解的个数</li><li>求所有解的具体信息</li></ul><ol><li>Find the best path to success 求最优解</li></ol><p>还有一些爱混淆的概念：递归，回溯，DFS。<br>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。<br>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。在树和图上回溯时人们叫它DFS。<br>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</p><p>关于回溯的三种问题，模板略有不同，<br>第一种，返回值是true/false。<br>第二种，求个数，设全局counter，返回值是void；求所有解信息，设result，返回值void。<br>第三种，设个全局变量best，返回值是void。</p><h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>第一种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">boolean solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, return true</div><div class="line">        else return false</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            if solve(c) succeeds, return true</div><div class="line">        &#125;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, count++, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第三种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, update best result, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>八皇后问题是大数学家高斯于1850年提出来的。该问题是在8×8的国际象棋棋盘上放置8个皇后，使得没有一个皇后能“吃掉”任何其他一个皇后，即没有任何两个皇后被放置在棋盘的同一行、同一列或同一斜线上。</p><p>扩展到一般情况就是：在n*n的棋盘上放置n和棋子，使得没有任何两个棋子在同一行、同一列或同一对角线上</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了更好的理解回溯法，把这个问题分解成三个子问题：</p><ol><li>是否有这样的安放方法，满足游戏规则</li><li>如果有，有多少个安放方式[leetcode 52]</li><li>输出所有的安放方式[leetcode 51]</li></ol><p>因为任何两个皇后不可能在同一行，所以我们可以采用如下的策略：<br><strong>一行一行地安放皇后，每次放置皇后时需要确保此次放置的皇后跟之前已经放置的皇后没有处于同行、同列、同对角线上</strong></p><p>需要下面两个函数：</p><ol><li>递归调用安放皇后（回溯法）<br>逐个遍历可以安放皇后的位置，并递归调用取定下一层可以安放皇后的位置。直到最后一行的元素存在合法的放置位置，说明这是一种合理的安放情况。</li></ol><ol><li>判断在某一点放queen是否合法</li></ol><p>因为是一行一行放，所以可以保证不在一行上，需要判断同一列是否已经有皇后，以及左上方和右上方对角线方向是否已经有皇后。</p><p>另外还需要一个额外的空间标记当前皇后们安放的位置</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>三个子问题的函数2，判断某一点是否可以放置皇后的函数一样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断是否可以放置</div><div class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">    //判断左上方对角线是否有皇后</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==1)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断右上方对角线是否有皇后</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==1)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==1)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code>是用来存放当前棋盘上放置的皇后位置。</p><p>差别在于回溯函数：</p><h4 id="1-是否存在"><a href="#1-是否存在" class="headerlink" title="1. 是否存在"></a>1. 是否存在</h4><p>只需要找到一个满足条件的放置方案即可，逐行放置皇后，遇到不满足条件的情况就回退到上一层，继续寻找</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//递归调用，判断皇后放置字当前点之后是否存在合法路径</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一行，安放最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//如果存在合法安放情况，返回true</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//该点合理，将皇后放到该点，递归调用，判断下一层是否存在合法方案</div><div class="line">                vec[k][i]=1;//房子皇后，标记皇后位置</div><div class="line">                if (solve(vec,n,k+1,i))//下一层存在合法方案。返回true 否则回退，将皇后从该点移除</div><div class="line">                    return true;</div><div class="line">                vec[k][i]=0;//取消皇后位置标记</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool ifNQueens(int n) &#123;</div><div class="line">    if(n==1)</div><div class="line">        return true;</div><div class="line">    if(n&lt;4)</div><div class="line">        return false</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));//存储当前棋盘皇后位置</div><div class="line">    //遍历首行放置皇后</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        if(solve(vec,n,1,i))//找到一条合法放置方式，返回true</div><div class="line">            return true</div><div class="line">        vec[0][i]=0;//否则恢复该点未被选中的棋盘，继续遍历下一个点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-存在多少种安放方式-leetcode-51"><a href="#2-存在多少种安放方式-leetcode-51" class="headerlink" title="2. 存在多少种安放方式 [leetcode] 51"></a>2. 存在多少种安放方式 [leetcode] 51</h4><p>在上面存在的基础之上，引入一个count计数变量，记录合法方案的数量，也就是没找到一个合法的安放方式就+1，知道遍历完所有的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l,int&amp; count)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//找到合法方案，计数变量+1</div><div class="line">                count++;break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=1;</div><div class="line">                solve(vec,n,k+1,i,count);</div><div class="line">                vec[k][i]=0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int totalNQueens(int n) &#123;</div><div class="line">    if(n&lt;2)</div><div class="line">        return n;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));</div><div class="line">    int count = 0;//新增计数变量</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        solve(vec,n,1,i,count);</div><div class="line">        vec[0][i]=0;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-输出所有的安放方式-leetcode-51"><a href="#3-输出所有的安放方式-leetcode-51" class="headerlink" title="3.输出所有的安放方式 [leetcode] 51"></a>3.输出所有的安放方式 [leetcode] 51</h4><p>这次需要我们将所有合法的安放方式都输出，也就当找到一条合法安放方式时，就把当前的皇后放置情况输出到结果集。</p><p>另外根据题目输出结果格式要求：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line"> [&quot;.Q..&quot;,  // Solution 1</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;..Q.&quot;],</div><div class="line"></div><div class="line"> [&quot;..Q.&quot;,  // Solution 2</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;.Q..&quot;]</div><div class="line">]</div></pre></td></tr></table></figure><p>对保存安放情况的变量类型作出修改：由原来的<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code> 变为<code>vector&lt;string&gt;&amp; vec</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断该位置是否可以放置</div><div class="line">bool isvalid(vector&lt;string&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">     //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    //判断对角是否已经有元素</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void solve(vector&lt;string&gt;&amp; vec,int n,int k,int l,vector&lt;vector&lt;string&gt;&gt;&amp; res)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=&apos;Q&apos;;</div><div class="line">                res.push_back(vec);//存在合法方案，保存到结果集</div><div class="line">                vec[k][i]=&apos;.&apos;;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=&apos;Q&apos;;</div><div class="line">                solve(vec,n,k+1,i,res);</div><div class="line">                vec[k][i]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">    if(n==1)&#123;</div><div class="line">        vector&lt;string&gt; vv = &#123;&quot;Q&quot;&#125;;</div><div class="line">        res.push_back(vv);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    if(n&lt;4)</div><div class="line">        return res;</div><div class="line">    vector&lt;string&gt; vec(n,string(n,&apos;.&apos;));//用以记录结果</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=&apos;Q&apos;;</div><div class="line">        solve(vec,n,1,i,res);</div><div class="line">        vec[0][i]=&apos;.&apos;;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006121957" target="_blank" rel="external">liuqi627的博客</a><br><a href="http://www.jianshu.com/p/8f3b8df612ae" target="_blank" rel="external">Jason_Yuan的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是回溯&quot;&gt;&lt;a href=&quot;#什么是回溯&quot; class=&quot;headerlink&quot; title=&quot;什么是回溯&quot;&gt;&lt;/a&gt;什么是回溯&lt;/h2&gt;&lt;p&gt;回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++STL中堆的使用</title>
    <link href="http://yoursite.com/2017/11/04/c-STL%E4%B8%AD%E5%A0%86%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/04/c-STL中堆的使用/</id>
    <published>2017-11-04T03:18:38.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：priority-queue"><a href="#方法一：priority-queue" class="headerlink" title="方法一：priority_queue"></a>方法一：priority_queue</h2><p>这种方法需要<code>#include&lt;queue&gt;</code></p><p>最基本的使用方法，对于一串数字建堆：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">riority_queue&lt;<span class="keyword">int</span>&gt; heap;</div></pre></td></tr></table></figure><p>这种情况下默认为最大堆，也就是堆顶元素值最大。</p><p>如果需要建立最小堆，可以采用如下方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最小堆</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最大堆</span></div></pre></td></tr></table></figure><p>然而在多数情况下，我们还需要记录一些排序元素的额外信息，比如索引之类的，则需要以下三个步骤：</p><ol><li><p>定义堆中需要存储的结构体：</p><p>​</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line">Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​</p></li><li><p>确定堆中元素的存储顺序，也就是最大堆还是最小堆</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置比较函数，确定堆中元素的顺序，是最大堆还是最小堆，</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> a.val&gt;b.val;<span class="comment">//最小堆</span></div><div class="line">      <span class="comment">//return a.val&lt;b.val;//最大堆</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​</p></li><li><p>建堆</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; heap;<span class="comment">//建堆</span></div><div class="line">heap.pop();<span class="comment">//出堆</span></div><div class="line">heap.push();<span class="comment">//入堆</span></div><div class="line">heap.top();<span class="comment">//获取堆顶元素</span></div></pre></td></tr></table></figure></li></ol><h2 id="方法二：利用vector"><a href="#方法二：利用vector" class="headerlink" title="方法二：利用vector"></a>方法二：利用vector</h2><p>这种法法需要<code>#include&lt;algorithm&gt;</code> <code>#include &lt;functional&gt;</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</div><div class="line"><span class="comment">//建堆</span></div><div class="line">make_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大堆</span></div><div class="line">make_heap(a.begin(),a.end(), greater&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小堆</span></div><div class="line"><span class="comment">//pop</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大值出堆</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小值出堆</span></div><div class="line"><span class="comment">//插入元素</span></div><div class="line">push_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">//堆排序</span></div><div class="line">sort_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">// push_heap ( begin , end )   将最后一个元素插入堆中（堆自动调整）</span></div><div class="line"><span class="comment">// pop_heap ( begin , end )   将第一个元素从堆中删去（堆自动调整），并放到最后</span></div><div class="line"><span class="comment">// find ( begin , end , value ) 从begin到end查找value，若找不到，返回end</span></div></pre></td></tr></table></figure><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一：priority-queue&quot;&gt;&lt;a href=&quot;#方法一：priority-queue&quot; class=&quot;headerlink&quot; title=&quot;方法一：priority_queue&quot;&gt;&lt;/a&gt;方法一：priority_queue&lt;/h2&gt;&lt;p&gt;这种方法需要
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2</title>
    <link href="http://yoursite.com/2017/11/04/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2017/11/04/九章算法强化班课程笔记2/</id>
    <published>2017-11-04T03:05:07.000Z</published>
    <updated>2017-11-04T08:47:16.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p><ol><li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li><li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li><li>Kth Largest in N Arrays</li></ol><h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p></blockquote><p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p><p><strong>example</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p><p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p><p>看了leetcode题解，有二分查找的方式更快。</p><p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p><ul><li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li><li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li><li>直到min和max回合，此时就找到了第k个元素。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p><p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p><p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p></blockquote><p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>7</th><th>11</th></tr></thead><tbody><tr><td>2</td><td>2+1=3</td><td>2+7=9</td><td>2+11=13</td></tr><tr><td>4</td><td>4+1=5</td><td>4+7=11</td><td>4+11=15</td></tr><tr><td>6</td><td>6+1=7</td><td>6+7=13</td><td>6+11=17</td></tr></tbody></table></div><p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定N个无序数组，从中找出第k大的元素</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p><ol><li>将N个数组中的最大值入堆</li><li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li><li>循环k次，找到第k大的元素</li></ol><p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       <span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li><li>见到第k小，想到用堆维护候选集合，出堆k次</li><li>见到数组要往排序上面想，先排序，然后再其他操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求数组-矩阵的第k大元素&quot;&gt;&lt;a href=&quot;#求数组-矩阵的第k大元素&quot; class=&quot;headerlink&quot; title=&quot;求数组/矩阵的第k大元素&quot;&gt;&lt;/a&gt;求数组/矩阵的第k大元素&lt;/h1&gt;&lt;p&gt;涉及leetcode题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="九章算法" scheme="http://yoursite.com/tags/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>DSP国内硕士论文总结</title>
    <link href="http://yoursite.com/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/11/02/DSP国内硕士论文总结/</id>
    <published>2017-11-02T09:01:51.000Z</published>
    <updated>2017-11-04T08:47:16.413Z</updated>
    
    <content type="html"><![CDATA[<p>准备开题，先看一下国内的相关硕士学位论文，知网上down的。</p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><ul><li><p><strong>针对在线广告实时竞价系统的相关算法研究、电子科大、郭威</strong></p><p>将竞价策略总结为预算控制和估价算法两个步骤，提出一种<strong>预算步进（buget pacing）算法和一个出价模型</strong></p><p>数据集：iPinyou</p><p>2.2介绍计算广告核心问题和<strong>结算方式</strong></p><p>核心问题：广告主、用户、媒体三方博弈，涉及信息检索、机器学习、最优化三个领域。</p><p><strong>结算方式以及适用场景：CPT-&gt;CPM-&gt;CPC-&gt;eCPM</strong> 这里总结的很好</p><p>第3章点击率预估：LR\GBDT \FM\在线算法online SGD，FTRL数据集Criteo</p><p>第4章设计了一个 <strong>buget pacing(预算步进)</strong> 策略</p><p>第5章竞价算法设计：DSP策略中的关键技术图</p><p>这个问题通常是一个约束最优化问题，约束是广告主一天的广告预算，最优某个性能指标，如点击数或转化数。</p></li></ul><ul><li>​</li></ul><h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><ul><li><p><strong>在线广告 DSP 平台实时竞价算法的研究与实现 、上海交通、韩静</strong></p><p>主要研究实时竞价算法，点击率预估和竞价策略。</p><p>ctr预估：LR和GBDT。</p><p>竞价策略：提出固定竞价、分组竞价（M6D）、综合竞价（非线性竞价）三种策略，进行数学推导</p><p>数据集：iPinyou，评价指标KPI</p><p><strong>利用这份数据集做实验的流程</strong> （第四章）：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-02-19-39-45.png" alt=""> </p></li></ul><ul><li>​</li></ul><h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备开题，先看一下国内的相关硕士学位论文，知网上down的。&lt;/p&gt;
&lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h2&gt;&lt;h2 id=&quot;2016&quot;&gt;&lt;a href=&quot;#201
      
    
    </summary>
    
      <category term="DSP" scheme="http://yoursite.com/categories/DSP/"/>
    
    
      <category term="DSP" scheme="http://yoursite.com/tags/DSP/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2017/11/02/test-1/"/>
    <id>http://yoursite.com/2017/11/02/test-1/</id>
    <published>2017-11-02T06:12:42.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hive中静态分区和动态分区</title>
    <link href="http://yoursite.com/2017/11/02/Hive%E4%B8%AD%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2017/11/02/Hive中静态分区和动态分区/</id>
    <published>2017-11-02T01:36:01.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对应列的值自动分区写入，如果该列值对应的分区目录还没有创建， 会自动创建并写入数据。</p><h2 id="静态分区"><a href="#静态分区" class="headerlink" title="静态分区"></a>静态分区</h2><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>create table zhangsiyao.dt_0802_0815 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>load data local inpath ‘/home/warehouse/user.txt’ overwrite into table teacher partition(work_date=”2016-07-12”);</p><p>需要按照分区一个分区一个分区导入数据</p><h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><h3 id="创建分区表（和静态分区一样）"><a href="#创建分区表（和静态分区一样）" class="headerlink" title="创建分区表（和静态分区一样）"></a>创建分区表（和静态分区一样）</h3><p>create table zhangsiyao.dt_0811_0820 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="创建数据表（中间数据）"><a href="#创建数据表（中间数据）" class="headerlink" title="创建数据表（中间数据）"></a>创建数据表（中间数据）</h3><p>create table zhangsiyao.data_analy_11_20 as select a.itime,a.uid,a.gid,a.app_ver,a.unet ,a.device_type,a.device_os,a.client_type,a.crtv_id,a.country,a.province,a.city,a.isp,a.ad_location,a.ad_status,a.dt,b.age_gt,b.sex_gt,b.income_gt,b.marital_status_gt,c.sponsor_id,c.creative_name,c.creative_title,c.creative_abstract,c.category_id,c.create_time,c.update_time from (select <em> from ad.wireless_ad_org_final where dt&gt;’2017-08-10’ and crtv_id &lt;&gt;-1) a left join (select </em> from user_portraint.focus_user_portraint_profile where dt&gt;’2017-08-10’) b on (a.dt=b.dt and a.client_type=b.client_type and a.uid=b.uid) left join (select * from ad.ad_creative_ods where dt&gt;’2017-08-10’) c on (a.dt=b.dt and a.crtv_id=c.creative_id);</p><h3 id="设置动态分区"><a href="#设置动态分区" class="headerlink" title="设置动态分区"></a>设置动态分区</h3><p>set hive.exec.dynamic.partition=true;(可通过这个语句查看：set hive.exec.dynamic.partition;)<br>set hive.exec.dynamic.partition.mode=nonstrict; （strict要求至少有一个静态分区， nonstrict可以都是动态分区）<br>set hive.exec.max.dynamic.partitions=100000;(如果自动分区数大于这个参数，将会报错)<br>set hive.exec.max.dynamic.partitions.pernode=100000;</p><h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><p>insert overwrite table zhangsiyao.dt_0811_0820 partition(dt) select itime,uid,gid,app_ver,unet,device_type,device_os,client_type,crtv_id,country,province,city,isp,ad_location,ad_status,age_gt,sex_gt,income_gt,marital_status_gt,sponsor_id,creative_name,creative_title,creative_abstract,category_id,create_time,update_time,dt from zhangsiyao.data_analy_11_20 where dt&lt;’2017-08-21’;</p><p><strong>这里需要注意的是，用select选择数据导入动态分区时，要把关键字放在最后面，因为动态分区默认以最后一个关键字作为分区关键字</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;差别&quot;&gt;&lt;a href=&quot;#差别&quot; class=&quot;headerlink&quot; title=&quot;差别&quot;&gt;&lt;/a&gt;差别&lt;/h2&gt;&lt;p&gt;两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>利用Hive中percentile_approx计算等频划分分位点</title>
    <link href="http://yoursite.com/2017/11/02/%E5%88%A9%E7%94%A8Hive%E4%B8%ADpercentile-approx%E8%AE%A1%E7%AE%97%E7%AD%89%E9%A2%91%E5%88%92%E5%88%86%E5%88%86%E4%BD%8D%E7%82%B9/"/>
    <id>http://yoursite.com/2017/11/02/利用Hive中percentile-approx计算等频划分分位点/</id>
    <published>2017-11-02T01:34:39.000Z</published>
    <updated>2017-11-04T08:47:16.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等频划分"><a href="#等频划分" class="headerlink" title="等频划分"></a>等频划分</h2><p>等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间</p><p>等比划分：按照数据的全部取值情况，平均划分成k个区间</p><h2 id="Hive-中计算分位数的函数：percentile-approx"><a href="#Hive-中计算分位数的函数：percentile-approx" class="headerlink" title="Hive 中计算分位数的函数：percentile_approx"></a>Hive 中计算分位数的函数：<code>percentile_approx</code></h2><p>hive 中的<code>percentile_approx</code>函数可以确定等频划分的分位点<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">percentile_approx(col,array(0.2,0.4,0.6,0.8))</div><div class="line">[0.0,4001.0,4061.0]</div></pre></td></tr></table></figure></p><p>其中col为要划分的列，array中的数字代表划分的位置，比如(0.2,0.4,0.6,0.8)就是钱20%数量的样本被分到一个区间，然后20%-40%的样本被分到一个区间….</p><p>返回值是一个array</p><p>如果希望变成一列，可以用<code>explode</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explode(percentile_approx(cast(col as double),array(0.05,0.5,0.95),9999))as percentile</div><div class="line"></div><div class="line">percentile</div><div class="line">0.0</div><div class="line">4001.1</div><div class="line">4061.0</div></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table zhangsiyao.percentile_of_dt_fea_0818_0820_2 as select explode(percentile_approx(adloc_age_sex_ctr,array(0.25,0.5,0.75))) as adloc_age_sex_ctr_percentile,explode(percentile_approx(adloc_income_ctr,array(0.25,0.5,0.75))) as adloc_income_ctr_percentile,explode(percentile_approx(adloc_marry_ctr,array(0.25,0.5,0.75))) as adloc_marry_ctr_percentile,explode(percentile_approx(adloc_province_ctr,array(0.25,0.5,0.75))) as adloc_province_ctr_percentile,explode(percentile_approx(adloc_clinttype_ctr,array(0.25,0.5,0.75))) as adloc_clinttype_ctr_percentile,explode(percentile_approx(adloc_sponsorid_ctr,array(0.25,0.5,0.75))) as adloc_sponsorid_ctr_percentile,explode(percentile_approx(adloc_categoryid_ctr,array(0.25,0.5,0.75))) as adloc_categoryid_ctr_percentile,explode(percentile_approx(adloc_crtvid_ctr,array(0.25,0.5,0.75))) as adloc_crtvid_ctr_percentile,explode(percentile_approx(adloc_unet_ctr,array(0.25,0.5,0.75))) as adloc_unet_ctr_percentile,explode(percentile_approx(adloc_isp_ctr,array(0.25,0.5,0.75))) as adloc_isp_ctr_percentile,explode(percentile_approx(adloc_appver_ctr,array(0.25,0.5,0.75))) as adloc_appver_ctr_percentile,explode(percentile_approx(adloc_devicetype_ctr ,adloc_deviceos_ctr,array(0.25,0.5,0.75))) as adloc_devicetype_ctr ,adloc_deviceos_ctr_percentile,explode(percentile_approx(age_province_ctr,array(0.25,0.5,0.75))) as age_province_ctr_percentile,explode(percentile_approx(age_marry_ctr,array(0.25,0.5,0.75))) as age_marry_ctr_percentile,explode(percentile_approx(age_categoryid_ctr,array(0.25,0.5,0.75))) as age_categoryid_ctr_percentile,explode(percentile_approx(age_crtvid_ctr,array(0.25,0.5,0.75))) as age_crtvid_ctr_percentile,explode(percentile_approx(sex_marry_ctr,array(0.25,0.5,0.75))) as sex_marry_ctr_percentile,explode(percentile_approx(sex_categoryid_ctr,array(0.25,0.5,0.75))) as sex_categoryid_ctr_percentile,explode(percentile_approx(income_categoryid_ctr,array(0.25,0.5,0.75))) as income_categoryid_ctr_percentile,explode(percentile_approx(income_crtvid_ctr,array(0.25,0.5,0.75))) as income_crtvid_ctr_percentile,explode(percentile_approx(marry_categoryid_ctr,array(0.25,0.5,0.75))) as marry_categoryid_ctr_percentile,explode(percentile_approx(marry_crtvid_ctr,sponsorid_unet_ctr,array(0.25,0.5,0.75))) as marry_crtvid_ctr,sponsorid_unet_ctr_percentile from zhangsiyao.dt_fea_0818_0820;</div></pre></td></tr></table></figure><p>由此就找到了将特征等频划分的分位点，可以按照得到的分位点队连续型特征进行分桶操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;等频划分&quot;&gt;&lt;a href=&quot;#等频划分&quot; class=&quot;headerlink&quot; title=&quot;等频划分&quot;&gt;&lt;/a&gt;等频划分&lt;/h2&gt;&lt;p&gt;等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间&lt;/p&gt;
&lt;p&gt;等比划分：按照数据的全部取值情况，平
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>TPC_DS工具生成数据导入Hive</title>
    <link href="http://yoursite.com/2017/11/02/TPC-DS%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Hive/"/>
    <id>http://yoursite.com/2017/11/02/TPC-DS工具生成数据导入Hive/</id>
    <published>2017-11-02T01:29:43.000Z</published>
    <updated>2017-11-04T08:47:16.411Z</updated>
    
    <content type="html"><![CDATA[<p>生成步骤</p><p>1.在官网上(<a href="http://www.tpc.org/tpcds/" target="_blank" rel="external">http://www.tpc.org/tpcds/</a> )去下载最新的：TPC-DS. </p><p>2.解压: 下载的 zip 文件放在 Linux 上解压,并进入他的 tools 目录.</p><p>3.编译：make (忽略编译警告，只保证生成过程成功完成). 这里需要Linux安装上了 gcc , gcc c++, expect 等.</p><p>4.生成数据：在tools目录下执行：./dsdgen -scale 100 -force (-force:会覆盖原来生成的data,否则不覆盖);生成的25个.dat 的数据文件.</p><p>默认只能生成 100GB, 300GB, 1TB, 3TB, 10TB, 30TB and 100TB大小的数据，如果想要生成一个比较小的数据集，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">100M:</div><div class="line">./dsdgen -scale 1000 -dir tmp/ -parallel 1000 -child 1</div></pre></td></tr></table></figure></p><ol><li>hive中创建相应的数据表，导入之前生成的数据<br>运行脚本<code>hive_create_table.sql</code></li></ol><p>“hive -f hive_create_table.sql”<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">use tpc_ds;</div><div class="line"></div><div class="line">create table if not exists dbgen_version</div><div class="line">(</div><div class="line">    dv_version varchar(16),</div><div class="line">    dv_create_date date,</div><div class="line">    dv_create_time string,</div><div class="line">    dv_cmdline_args varchar(200) </div><div class="line">)</div><div class="line">row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/dbgen_version_1_10000.dat&quot; overwrite into table tpc_ds.dbgen_version;</div><div class="line"></div><div class="line">create table if not exists customer_address</div><div class="line">(</div><div class="line">    ca_address_sk int,</div><div class="line">    ca_address_id char(16),</div><div class="line">    ca_street_number char(10),</div><div class="line">    ca_street_name varchar(60),</div><div class="line">    ca_street_type char(15),</div><div class="line">    ca_suite_number char(10),</div><div class="line">    ca_city varchar(60),</div><div class="line">    ca_county varchar(30),</div><div class="line">    ca_state char(2),</div><div class="line">    ca_zip char(10),</div><div class="line">    ca_country varchar(20),</div><div class="line">    ca_gmt_offset decimal(5,2),</div><div class="line">    ca_location_type char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_address_1_10000.dat&quot; overwrite into table tpc_ds.customer_address;</div><div class="line"></div><div class="line">create table if not exists customer_demographics</div><div class="line">(</div><div class="line">    cd_demo_sk int,</div><div class="line">    cd_gender char(1),</div><div class="line">    cd_marital_status char(1),</div><div class="line">    cd_education_status char(20),</div><div class="line">    cd_purchase_estimate int,</div><div class="line">    cd_credit_rating char(10),</div><div class="line">    cd_dep_count int,</div><div class="line">    cd_dep_employed_count int,</div><div class="line">    cd_dep_college_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_demographics_1_10000.dat&quot; overwrite into table tpc_ds.customer_demographics;</div><div class="line"></div><div class="line">create table if not exists date_dim</div><div class="line">(</div><div class="line">    d_date_sk int,</div><div class="line">    d_date_id char(16) ,</div><div class="line">    d_date date ,</div><div class="line">    d_month_seq int,</div><div class="line">    d_week_seq int,</div><div class="line">    d_quarter_seq int,</div><div class="line">    d_year int,</div><div class="line">    d_dow int,</div><div class="line">    d_moy int,</div><div class="line">    d_dom int,</div><div class="line">    d_qoy int,</div><div class="line">    d_fy_year int,</div><div class="line">    d_fy_quarter_seq int,</div><div class="line">    d_fy_week_seq int,</div><div class="line">    d_day_name char(9),</div><div class="line">    d_quarter_name char(6),</div><div class="line">    d_holiday char(1),</div><div class="line">    d_weekend char(1),</div><div class="line">    d_following_holiday char(1),</div><div class="line">    d_first_dom int,</div><div class="line">    d_last_dom int,</div><div class="line">    d_same_day_ly int,</div><div class="line">    d_same_day_lq int,</div><div class="line">    d_current_day char(1),</div><div class="line">    d_current_week char(1),</div><div class="line">    d_current_month char(1),</div><div class="line">    d_current_quarter char(1),</div><div class="line">    d_current_year char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/date_dim_1_10000.dat&quot; overwrite into table tpc_ds.date_dim;</div><div class="line"></div><div class="line">create table if not exists warehouse</div><div class="line">(</div><div class="line">    w_warehouse_sk int,</div><div class="line">    w_warehouse_id char(16),</div><div class="line">    w_warehouse_name varchar(20),</div><div class="line">    w_warehouse_sq_ft int,</div><div class="line">    w_street_number char(10),</div><div class="line">    w_street_name varchar(60),</div><div class="line">    w_street_type char(15),</div><div class="line">    w_suite_number char(10),</div><div class="line">    w_city varchar(60),</div><div class="line">    w_county varchar(30),</div><div class="line">    w_state char(2),</div><div class="line">    w_zip char(10),</div><div class="line">    w_country varchar(20),</div><div class="line">    w_gmt_offset decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/warehouse_1_10000.dat&quot; overwrite into table tpc_ds.warehouse;</div><div class="line"></div><div class="line">create table if not exists ship_mode</div><div class="line">(</div><div class="line">    sm_ship_mode_sk int,</div><div class="line">    sm_ship_mode_id char(16),</div><div class="line">    sm_type char(30),</div><div class="line">    sm_code char(10),</div><div class="line">    sm_carrier char(20),</div><div class="line">    sm_contract char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/ship_mode_1_10000.dat&quot; overwrite into table tpc_ds.ship_mode;</div><div class="line"></div><div class="line">create table if not exists time_dim</div><div class="line">(</div><div class="line">    t_time_sk int,</div><div class="line">    t_time_id char(16),</div><div class="line">    t_time int,</div><div class="line">    t_hour int,</div><div class="line">    t_minute int,</div><div class="line">    t_second int,</div><div class="line">    t_am_pm char(2),</div><div class="line">    t_shift char(20),</div><div class="line">    t_sub_shift char(20),</div><div class="line">    t_meal_time char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/time_dim_1_10000.dat&quot; overwrite into table tpc_ds.time_dim;</div><div class="line"></div><div class="line">create table if not exists reason</div><div class="line">(</div><div class="line">    r_reason_sk int,</div><div class="line">    r_reason_id char(16),</div><div class="line">    r_reason_desc char(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/reason_1_10000.dat&quot; overwrite into table tpc_ds.reason;</div><div class="line"></div><div class="line">create table if not exists income_band</div><div class="line">(</div><div class="line">    ib_income_band_sk int,</div><div class="line">    ib_lower_bound int,</div><div class="line">    ib_upper_bound int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/income_band_1_10000.dat&quot; overwrite into table tpc_ds.income_band;</div><div class="line"></div><div class="line">create table if not exists item</div><div class="line">(</div><div class="line">    i_item_sk int,</div><div class="line">    i_item_id char(16),</div><div class="line">    i_rec_start_date date ,</div><div class="line">    i_rec_end_date date ,</div><div class="line">    i_item_desc varchar(200),</div><div class="line">    i_current_price decimal(7,2),</div><div class="line">    i_wholesale_cost decimal(7,2),</div><div class="line">    i_brand_id int,</div><div class="line">    i_brand char(50),</div><div class="line">    i_class_id int,</div><div class="line">    i_class char(50),</div><div class="line">    i_category_id int,</div><div class="line">    i_category char(50),</div><div class="line">    i_manufact_id int,</div><div class="line">    i_manufact char(50),</div><div class="line">    i_size char(20),</div><div class="line">    i_formulation char(20),</div><div class="line">    i_color char(20),</div><div class="line">    i_units char(10),</div><div class="line">    i_container char(10),</div><div class="line">    i_manager_id int,</div><div class="line">    i_product_name char(50)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/item_1_10000.dat&quot; overwrite into table tpc_ds.item;</div><div class="line"></div><div class="line">create table if not exists store</div><div class="line">(</div><div class="line">    s_store_sk int,</div><div class="line">    s_store_id char(16),</div><div class="line">    s_rec_start_date date ,</div><div class="line">    s_rec_end_date date ,</div><div class="line">    s_closed_date_sk int,</div><div class="line">    s_store_name varchar(50),</div><div class="line">    s_number_employees int,</div><div class="line">    s_floor_space int,</div><div class="line">    s_hours char(20),</div><div class="line">    s_manager varchar(40),</div><div class="line">    s_market_id int,</div><div class="line">    s_geography_class varchar(100),</div><div class="line">    s_market_desc varchar(100),</div><div class="line">    s_market_manager varchar(40),</div><div class="line">    s_division_id int,</div><div class="line">    s_division_name varchar(50),</div><div class="line">    s_company_id int,</div><div class="line">    s_company_name varchar(50),</div><div class="line">    s_street_number varchar(10),</div><div class="line">    s_street_name varchar(60),</div><div class="line">    s_street_type char(15),</div><div class="line">    s_suite_number char(10),</div><div class="line">    s_city varchar(60),</div><div class="line">    s_county varchar(30),</div><div class="line">    s_state char(2),</div><div class="line">    s_zip char(10),</div><div class="line">    s_country varchar(20),</div><div class="line">    s_gmt_offset decimal(5,2),</div><div class="line">    s_tax_precentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_1_10000.dat&quot; overwrite into table tpc_ds.store;</div><div class="line"></div><div class="line">create table if not exists call_center</div><div class="line">(</div><div class="line">    cc_call_center_sk int,</div><div class="line">    cc_call_center_id char(16),</div><div class="line">    cc_rec_start_date date ,</div><div class="line">    cc_rec_end_date date ,</div><div class="line">    cc_closed_date_sk int,</div><div class="line">    cc_open_date_sk int,</div><div class="line">    cc_name varchar(50),</div><div class="line">    cc_class varchar(50),</div><div class="line">    cc_employees int,</div><div class="line">    cc_sq_ft int,</div><div class="line">    cc_hours char(20),</div><div class="line">    cc_manager varchar(40),</div><div class="line">    cc_mkt_id int,</div><div class="line">    cc_mkt_class char(50),</div><div class="line">    cc_mkt_desc varchar(100),</div><div class="line">    cc_market_manager varchar(40),</div><div class="line">    cc_division int,</div><div class="line">    cc_division_name varchar(50),</div><div class="line">    cc_company int,</div><div class="line">    cc_company_name char(50),</div><div class="line">    cc_street_number char(10),</div><div class="line">    cc_street_name varchar(60),</div><div class="line">    cc_street_type char(15),</div><div class="line">    cc_suite_number char(10),</div><div class="line">    cc_city varchar(60),</div><div class="line">    cc_county varchar(30),</div><div class="line">    cc_state char(2),</div><div class="line">    cc_zip char(10),</div><div class="line">    cc_country varchar(20),</div><div class="line">    cc_gmt_offset decimal(5,2),</div><div class="line">    cc_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/call_center_1_10000.dat&quot; overwrite into table tpc_ds.call_center;</div><div class="line"></div><div class="line">create table if not exists customer</div><div class="line">(</div><div class="line">    c_customer_sk int,</div><div class="line">    c_customer_id char(16),</div><div class="line">    c_current_cdemo_sk int,</div><div class="line">    c_current_hdemo_sk int,</div><div class="line">    c_current_addr_sk int,</div><div class="line">    c_first_shipto_date_sk int,</div><div class="line">    c_first_sales_date_sk int,</div><div class="line">    c_salutation char(10),</div><div class="line">    c_first_name char(20),</div><div class="line">    c_last_name char(30),</div><div class="line">    c_preferred_cust_flag char(1),</div><div class="line">    c_birth_day int,</div><div class="line">    c_birth_month int,</div><div class="line">    c_birth_year int,</div><div class="line">    c_birth_country varchar(20),</div><div class="line">    c_login char(13),</div><div class="line">    c_email_address char(50),</div><div class="line">    c_last_review_date char(10)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_1_10000.dat&quot; overwrite into table tpc_ds.customer;</div><div class="line"></div><div class="line">create table if not exists web_site</div><div class="line">(</div><div class="line">    web_site_sk int,</div><div class="line">    web_site_id char(16),</div><div class="line">    web_rec_start_date date ,</div><div class="line">    web_rec_end_date date ,</div><div class="line">    web_name varchar(50),</div><div class="line">    web_open_date_sk int,</div><div class="line">    web_close_date_sk int,</div><div class="line">    web_class varchar(50),</div><div class="line">    web_manager varchar(40),</div><div class="line">    web_mkt_id int,</div><div class="line">    web_mkt_class varchar(50),</div><div class="line">    web_mkt_desc varchar(100),</div><div class="line">    web_market_manager varchar(40),</div><div class="line">    web_company_id int,</div><div class="line">    web_company_name char(50),</div><div class="line">    web_street_number char(10),</div><div class="line">    web_street_name varchar(60),</div><div class="line">    web_street_type char(15),</div><div class="line">    web_suite_number char(10),</div><div class="line">    web_city varchar(60),</div><div class="line">    web_county varchar(30),</div><div class="line">    web_state char(2),</div><div class="line">    web_zip char(10),</div><div class="line">    web_country varchar(20),</div><div class="line">    web_gmt_offset decimal(5,2),</div><div class="line">    web_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_site_1_10000.dat&quot; overwrite into table tpc_ds.web_site;</div><div class="line"></div><div class="line">create table if not exists store_returns</div><div class="line">(</div><div class="line">    sr_returned_date_sk int,</div><div class="line">    sr_return_time_sk int,</div><div class="line">    sr_item_sk int,</div><div class="line">    sr_customer_sk int,</div><div class="line">    sr_cdemo_sk int,</div><div class="line">    sr_hdemo_sk int,</div><div class="line">    sr_addr_sk int,</div><div class="line">    sr_store_sk int,</div><div class="line">    sr_reason_sk int,</div><div class="line">    sr_ticket_number int,</div><div class="line">    sr_return_quantity int,</div><div class="line">    sr_return_amt decimal(7,2),</div><div class="line">    sr_return_tax decimal(7,2),</div><div class="line">    sr_return_amt_inc_tax decimal(7,2),</div><div class="line">    sr_fee decimal(7,2),</div><div class="line">    sr_return_ship_cost decimal(7,2),</div><div class="line">    sr_refunded_cash decimal(7,2),</div><div class="line">    sr_reversed_charge decimal(7,2),</div><div class="line">    sr_store_credit decimal(7,2),</div><div class="line">    sr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_returns_1_10000.dat&quot; overwrite into table tpc_ds.store_returns;</div><div class="line"></div><div class="line">create table if not exists household_demographics</div><div class="line">(</div><div class="line">    hd_demo_sk int,</div><div class="line">    hd_income_band_sk int,</div><div class="line">    hd_buy_potential char(15),</div><div class="line">    hd_dep_count int,</div><div class="line">    hd_vehicle_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/household_demographics_1_10000.dat&quot; overwrite into table tpc_ds.household_demographics;</div><div class="line"></div><div class="line">create table if not exists web_page</div><div class="line">(</div><div class="line">    wp_web_page_sk int,</div><div class="line">    wp_web_page_id char(16),</div><div class="line">    wp_rec_start_date date ,</div><div class="line">    wp_rec_end_date date ,</div><div class="line">    wp_creation_date_sk int,</div><div class="line">    wp_access_date_sk int,</div><div class="line">    wp_autogen_flag char(1),</div><div class="line">    wp_customer_sk int,</div><div class="line">    wp_url varchar(100),</div><div class="line">    wp_type char(50),</div><div class="line">    wp_char_count int,</div><div class="line">    wp_link_count int,</div><div class="line">    wp_image_count int,</div><div class="line">    wp_max_ad_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_page_1_10000.dat&quot; overwrite into table tpc_ds.web_page;</div><div class="line"></div><div class="line">create table if not exists promotion</div><div class="line">(</div><div class="line">    p_promo_sk int,</div><div class="line">    p_promo_id char(16),</div><div class="line">    p_start_date_sk int,</div><div class="line">    p_end_date_sk int,</div><div class="line">    p_item_sk int,</div><div class="line">    p_cost decimal(15,2),</div><div class="line">    p_response_target int,</div><div class="line">    p_promo_name char(50),</div><div class="line">    p_channel_dmail char(1),</div><div class="line">    p_channel_email char(1),</div><div class="line">    p_channel_catalog char(1),</div><div class="line">    p_channel_tv char(1),</div><div class="line">    p_channel_radio char(1),</div><div class="line">    p_channel_press char(1),</div><div class="line">    p_channel_event char(1),</div><div class="line">    p_channel_demo char(1),</div><div class="line">    p_channel_details varchar(100),</div><div class="line">    p_purpose char(15),</div><div class="line">    p_discount_active char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/promotion_1_10000.dat&quot; overwrite into table tpc_ds.promotion;</div><div class="line"></div><div class="line">create table if not exists catalog_page</div><div class="line">(</div><div class="line">    cp_catalog_page_sk int,</div><div class="line">    cp_catalog_page_id char(16),</div><div class="line">    cp_start_date_sk int,</div><div class="line">    cp_end_date_sk int,</div><div class="line">    cp_department varchar(50),</div><div class="line">    cp_catalog_number int,</div><div class="line">    cp_catalog_page_number int,</div><div class="line">    cp_description varchar(100),</div><div class="line">    cp_type varchar(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_page_1_10000.dat&quot; overwrite into table tpc_ds.catalog_page;</div><div class="line"></div><div class="line">create table if not exists inventory</div><div class="line">(</div><div class="line">    inv_date_sk int,</div><div class="line">    inv_item_sk int,</div><div class="line">    inv_warehouse_sk int,</div><div class="line">    inv_quantity_on_hand int)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/inventory_1_10000.dat&quot; overwrite into table tpc_ds.inventory;</div><div class="line"></div><div class="line">create table if not exists catalog_returns</div><div class="line">(</div><div class="line">    cr_returned_date_sk int,</div><div class="line">    cr_returned_time_sk int,</div><div class="line">    cr_item_sk int,</div><div class="line">    cr_refunded_customer_sk int,</div><div class="line">    cr_refunded_cdemo_sk int,</div><div class="line">    cr_refunded_hdemo_sk int,</div><div class="line">    cr_refunded_addr_sk int,</div><div class="line">    cr_returning_customer_sk int,</div><div class="line">    cr_returning_cdemo_sk int,</div><div class="line">    cr_returning_hdemo_sk int,</div><div class="line">    cr_returning_addr_sk int,</div><div class="line">    cr_call_center_sk int,</div><div class="line">    cr_catalog_page_sk int,</div><div class="line">    cr_ship_mode_sk int,</div><div class="line">    cr_warehouse_sk int,</div><div class="line">    cr_reason_sk int,</div><div class="line">    cr_order_number int,</div><div class="line">    cr_return_quantity int,</div><div class="line">    cr_return_amount decimal(7,2),</div><div class="line">    cr_return_tax decimal(7,2),</div><div class="line">    cr_return_amt_inc_tax decimal(7,2),</div><div class="line">    cr_fee decimal(7,2),</div><div class="line">    cr_return_ship_cost decimal(7,2),</div><div class="line">    cr_refunded_cash decimal(7,2),</div><div class="line">    cr_reversed_charge decimal(7,2),</div><div class="line">    cr_store_credit decimal(7,2),</div><div class="line">    cr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_returns_1_10000.dat&quot; overwrite into table tpc_ds.catalog_returns;</div><div class="line"></div><div class="line">create table if not exists web_returns</div><div class="line">(</div><div class="line">    wr_returned_date_sk int,</div><div class="line">    wr_returned_time_sk int,</div><div class="line">    wr_item_sk int,</div><div class="line">    wr_refunded_customer_sk int,</div><div class="line">    wr_refunded_cdemo_sk int,</div><div class="line">    wr_refunded_hdemo_sk int,</div><div class="line">    wr_refunded_addr_sk int,</div><div class="line">    wr_returning_customer_sk int,</div><div class="line">    wr_returning_cdemo_sk int,</div><div class="line">    wr_returning_hdemo_sk int,</div><div class="line">    wr_returning_addr_sk int,</div><div class="line">    wr_web_page_sk int,</div><div class="line">    wr_reason_sk int,</div><div class="line">    wr_order_number int,</div><div class="line">    wr_return_quantity int,</div><div class="line">    wr_return_amt decimal(7,2),</div><div class="line">    wr_return_tax decimal(7,2),</div><div class="line">    wr_return_amt_inc_tax decimal(7,2),</div><div class="line">    wr_fee decimal(7,2),</div><div class="line">    wr_return_ship_cost decimal(7,2),</div><div class="line">    wr_refunded_cash decimal(7,2),</div><div class="line">    wr_reversed_charge decimal(7,2),</div><div class="line">    wr_account_credit decimal(7,2),</div><div class="line">    wr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_returns_1_10000.dat&quot; overwrite into table tpc_ds.web_returns;</div><div class="line"></div><div class="line">create table if not exists web_sales</div><div class="line">(</div><div class="line">    ws_sold_date_sk int,</div><div class="line">    ws_sold_time_sk int,</div><div class="line">    ws_ship_date_sk int,</div><div class="line">    ws_item_sk int,</div><div class="line">    ws_bill_customer_sk int,</div><div class="line">    ws_bill_cdemo_sk int,</div><div class="line">    ws_bill_hdemo_sk int,</div><div class="line">    ws_bill_addr_sk int,</div><div class="line">    ws_ship_customer_sk int,</div><div class="line">    ws_ship_cdemo_sk int,</div><div class="line">    ws_ship_hdemo_sk int,</div><div class="line">    ws_ship_addr_sk int,</div><div class="line">    ws_web_page_sk int,</div><div class="line">    ws_web_site_sk int,</div><div class="line">    ws_ship_mode_sk int,</div><div class="line">    ws_warehouse_sk int,</div><div class="line">    ws_promo_sk int,</div><div class="line">    ws_order_number int,</div><div class="line">    ws_quantity int,</div><div class="line">    ws_wholesale_cost decimal(7,2),</div><div class="line">    ws_list_price decimal(7,2),</div><div class="line">    ws_sales_price decimal(7,2),</div><div class="line">    ws_ext_discount_amt decimal(7,2),</div><div class="line">    ws_ext_sales_price decimal(7,2),</div><div class="line">    ws_ext_wholesale_cost decimal(7,2),</div><div class="line">    ws_ext_list_price decimal(7,2),</div><div class="line">    ws_ext_tax decimal(7,2),</div><div class="line">    ws_coupon_amt decimal(7,2),</div><div class="line">    ws_ext_ship_cost decimal(7,2),</div><div class="line">    ws_net_paid decimal(7,2),</div><div class="line">    ws_net_paid_inc_tax decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    ws_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_sales_1_10000.dat&quot; overwrite into table tpc_ds.web_sales;</div><div class="line"></div><div class="line">create table if not exists catalog_sales</div><div class="line">(</div><div class="line">    cs_sold_date_sk int,</div><div class="line">    cs_sold_time_sk int,</div><div class="line">    cs_ship_date_sk int,</div><div class="line">    cs_bill_customer_sk int,</div><div class="line">    cs_bill_cdemo_sk int,</div><div class="line">    cs_bill_hdemo_sk int,</div><div class="line">    cs_bill_addr_sk int,</div><div class="line">    cs_ship_customer_sk int,</div><div class="line">    cs_ship_cdemo_sk int,</div><div class="line">    cs_ship_hdemo_sk int,</div><div class="line">    cs_ship_addr_sk int,</div><div class="line">    cs_call_center_sk int,</div><div class="line">    cs_catalog_page_sk int,</div><div class="line">    cs_ship_mode_sk int,</div><div class="line">    cs_warehouse_sk int,</div><div class="line">    cs_item_sk int,</div><div class="line">    cs_promo_sk int,</div><div class="line">    cs_order_number int,</div><div class="line">    cs_quantity int,</div><div class="line">    cs_wholesale_cost decimal(7,2),</div><div class="line">    cs_list_price decimal(7,2),</div><div class="line">    cs_sales_price decimal(7,2),</div><div class="line">    cs_ext_discount_amt decimal(7,2),</div><div class="line">    cs_ext_sales_price decimal(7,2),</div><div class="line">    cs_ext_wholesale_cost decimal(7,2),</div><div class="line">    cs_ext_list_price decimal(7,2),</div><div class="line">    cs_ext_tax decimal(7,2),</div><div class="line">    cs_coupon_amt decimal(7,2),</div><div class="line">    cs_ext_ship_cost decimal(7,2),</div><div class="line">    cs_net_paid decimal(7,2),</div><div class="line">    cs_net_paid_inc_tax decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    cs_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_sales_1_10000.dat&quot; overwrite into table tpc_ds.catalog_sales;</div><div class="line"></div><div class="line">create table if not exists store_sales</div><div class="line">(</div><div class="line">    ss_sold_date_sk int,</div><div class="line">    ss_sold_time_sk int,</div><div class="line">    ss_item_sk int,</div><div class="line">    ss_customer_sk int,</div><div class="line">    ss_cdemo_sk int,</div><div class="line">    ss_hdemo_sk int,</div><div class="line">    ss_addr_sk int,</div><div class="line">    ss_store_sk int,</div><div class="line">    ss_promo_sk int,</div><div class="line">    ss_ticket_number int,</div><div class="line">    ss_quantity int,</div><div class="line">    ss_wholesale_cost decimal(7,2),</div><div class="line">    ss_list_price decimal(7,2),</div><div class="line">    ss_sales_price decimal(7,2),</div><div class="line">    ss_ext_discount_amt decimal(7,2),</div><div class="line">    ss_ext_sales_price decimal(7,2),</div><div class="line">    ss_ext_wholesale_cost decimal(7,2),</div><div class="line">    ss_ext_list_price decimal(7,2),</div><div class="line">    ss_ext_tax decimal(7,2),</div><div class="line">    ss_coupon_amt decimal(7,2),</div><div class="line">    ss_net_paid decimal(7,2),</div><div class="line">    ss_net_paid_inc_tax decimal(7,2),</div><div class="line">    ss_net_profit decimal(7,2))row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_sales_1_10000.dat&quot; overwrite into table tpc_ds.store_sales;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生成步骤&lt;/p&gt;
&lt;p&gt;1.在官网上(&lt;a href=&quot;http://www.tpc.org/tpcds/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tpc.org/tpcds/&lt;/a&gt; )去下载最新的：TPC-DS. &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【算法导论】动态规划（二）矩阵链乘法</title>
    <link href="http://yoursite.com/2017/11/01/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/"/>
    <id>http://yoursite.com/2017/11/01/【算法导论】动态规划（二）矩阵链乘法/</id>
    <published>2017-11-01T14:54:11.000Z</published>
    <updated>2017-11-04T08:47:16.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵链乘法问题"><a href="#矩阵链乘法问题" class="headerlink" title="矩阵链乘法问题"></a>矩阵链乘法问题</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>两个矩阵A和B相乘，维度分别为$ p×q$和$ q×r$，则$A*B$的时间复杂度为$pqr$</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MATRIX_MULTIPLY(A,B)&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;A.rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; B.cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A.cols;k++)&#123;</div><div class="line">        C[i,j] = A[i,k]*B[k,j];</div><div class="line">&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure><h3 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h3><p>​    首先，给定一个矩阵链 <script type="math/tex"><A_1,A_2,A_3></script>  ，三个矩阵的规模分别为：10×100 ， 100×5 ，5×50 ，计算他们的乘积有两种方式：</p><div class="table-container"><table><thead><tr><th>$((A_1A_2)A_3)$</th><th style="text-align:left"><script type="math/tex">10*100*5+10*5*50=7500</script></th></tr></thead><tbody><tr><td>$(A_1(A_2A_3))$</td><td style="text-align:left"><script type="math/tex">100*5*50+10*100*50=75000</script></td></tr></tbody></table></div><p>可以看出，对一串矩阵做乘法操作，乘法的顺序影响到算法的时间复杂度。由此，引出矩阵链乘法问题：</p><p><strong>给定n个矩阵的链<script type="math/tex"><A_1,A_2,...,A_n></script>，矩阵<script type="math/tex">A_i</script> 的规模为<script type="math/tex">p_{i-1} \times p_i</script>，确定代价最低的计算顺序，使得计算乘积$A_1A_2A_n$所需标量乘法次数最小。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩阵链乘法问题&quot;&gt;&lt;a href=&quot;#矩阵链乘法问题&quot; class=&quot;headerlink&quot; title=&quot;矩阵链乘法问题&quot;&gt;&lt;/a&gt;矩阵链乘法问题&lt;/h2&gt;&lt;h3 id=&quot;矩阵乘法&quot;&gt;&lt;a href=&quot;#矩阵乘法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【算法导论】动态规划（一）钢条切割</title>
    <link href="http://yoursite.com/2017/10/31/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/"/>
    <id>http://yoursite.com/2017/10/31/【算法导论】动态规划（一）钢条切割/</id>
    <published>2017-10-31T14:44:19.000Z</published>
    <updated>2017-11-04T08:47:16.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-动态规划（Dynamic-programming）"><a href="#1-动态规划（Dynamic-programming）" class="headerlink" title="1. 动态规划（Dynamic programming）"></a>1. 动态规划（Dynamic programming）</h2><p>这里programming指的是<strong>表格</strong>，而非编程。动态规划通常用来<strong>求解最优化问题</strong></p><p>与分治法对比：</p><ol><li>相同点：都是通过子问题组合求解原问题</li><li>不同点：分治法将问题划分为<strong>不相交</strong>的子问题，求解再合并，动态规划应用于<strong>子问题重叠</strong>的情况，即不同的子问题具有公共的子子问题，此时如果用分治法就会出现重复计算求解。为了避免重复动态规划对子问题只求解一次，将其保存在表格中，从而无需每求解一个子子问题时重复计算。</li></ol><h2 id="2-求解步骤"><a href="#2-求解步骤" class="headerlink" title="2. 求解步骤"></a>2. 求解步骤</h2><ol><li>刻画最优解的结构特征</li><li>递归定义最优解的值</li><li>计算最优解的值，通常采用自底向上的方法</li><li>利用计算出的信息构造最优解</li></ol><p>其中不是所有的题目都会要求4，仅仅要求3，要求4的时候，我们需要在得到3的同事维护一些额外的信息来求出4。</p><p>看到这四个步骤的时候，还是挺懵逼的，继续往下看=.=</p><h2 id="3-钢条切割问题"><a href="#3-钢条切割问题" class="headerlink" title="3. 钢条切割问题"></a>3. 钢条切割问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Serling公司购买一根长钢管，将其切割成短钢管出售，给定钢管长度和对应的价钱如下表：</p><p><img src="https://i.loli.net/2017/10/31/59f7536b8fc8f.png" alt=""> </p><p>问题要求根据上面的价格，给出最佳的切割方案，使得收益最大。</p><p>以n=4为例，可以将钢条切割成如下图所示的8种情况，其中收益岁大的是(c)：</p><p><img src="https://ooo.0o0.ooo/2017/10/30/59f73938d2f50.png" alt=""> </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>钢条长度为n时，共有$2^{n-1}$种分割方式。</p><ol><li><p>递归</p><p>把长度为n的钢条切割问题转化为：将钢条从左边切下长度为i的一段，对右边剩下的长度为n-i的钢条进行进一步的切割。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if n==0:</div><div class="line">2 return 0</div><div class="line">3 q=MIN</div><div class="line">4 for i = 1 to n:</div><div class="line">5 q=max(q,p[i],CUT-ROD(p,n-i))</div><div class="line">6 return q</div></pre></td></tr></table></figure><p>当n=4时，上面递推方式的工作量如图所示，复杂度为$T(n)=2^n$</p><p><img src="https://i.loli.net/2017/10/31/59f759167976c.png" alt=""> </p></li><li><p>动态规划（DP）</p><p>可以看出来用上面递归的方式计算，中间会重复求解相同子问题。使用动态规划，<strong>仔细安排求解顺序，对每个子问题只求解一次所以，并把结果保存下来</strong>，供后续使用避免重复计算。</p><p>​    对于钢条切割的问题，我们可以将长度为n的钢条切割问题转化为规模更小的子问题：当完成首次切割后，将两段钢条看成<strong>两个独立的钢条切割</strong>问题，通过<strong>组合</strong>两个相关子问题的最优解，选取组合收益最大者，构成原问题的最优解。</p><p>因此，将长度为n的钢条切割成两段，共有下面n种切割方式，求解下面n个子问题的最优解，再选取其中最大的作为原问题的最优解。</p><script type="math/tex; mode=display">r_n=max(p_n,r_{1}+r_{n-1},r_{2}+r_{n-2},...,r_{n-1}+r_1)</script><p>​以n=4为例：</p><p>$r_1=1$</p><p>$r_2=max(p_2,max(r_1)+max(r_1))=max(5,1+1)=5$</p><p>$r_3=max(p_3,max(r_1)+max(r_2))=max(8,5+1)=8$</p><p>$r_4=max(p_4,max(r_1)+max(r_3),max(r_2)+max(r_2))=max(9,8+1,5+5)=10$</p><p>…</p><p>​    动态规划两种实现方法：</p></li></ol><ul><li><p>自顶向下：</p><p>仍按照递归的方式实现，过程中保存每个子问题的解，后续过程中先检查是否已经保存过此解，如果是，直接返回保存的值。就好像带了一个“备忘录”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">memorized-CUT-ROD[] = MIN//用于记录子问题结果</div><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if memorized-CUT-ROD[n] &gt; 0:</div><div class="line">2 return memorized-CUT-ROD[n]</div><div class="line">3 else</div><div class="line">4 for i = 1 to n:</div><div class="line">5 q=max(q,p[i],memorized-CUT-ROD(p,n-i))</div><div class="line">6 memorized-CUT-ROD[n] = q</div></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>自底向上</p><p>需要恰当定义子问题的“规模”，使得任何子问题的求解都只依赖于“更小的”子问题，进而将子问题按规律排序，按由小到大的顺序进行求解，当求解某个自问题时，它所以来的子问题都已经求解完毕。</p><p>伪代码略，直接上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            maxvalue[i] = max(maxvalue[i],maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 至此，可以求出该问题的最优解了~</p></li></ul><h3 id="重构解"><a href="#重构解" class="headerlink" title="重构解"></a>重构解</h3><p>​    上面的求解过程可以求出最优解的值，但并没有返回解本身（具体的切割方案），为了得到最优解，需要在求解最优解的同时，保存切割信息。扩展上面的算法，使之对子问题不仅保存最优收益值$r_j$，还保存该最优方案对应的第一段钢条的切割长度，也就是第一段钢条的切割位置距离钢条左端的长度$s_j$，最后输出最优方案时，根据$s_j$即可复原出最优解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);<span class="comment">//记录最优方案值</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftlen(len,<span class="number">0</span>);<span class="comment">//记录第一段钢条距左端距离</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        leftlen[i] = i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]&gt;maxvalue[i])&#123;</div><div class="line">                maxvalue[i] = maxvalue[j<span class="number">-1</span>]+maxvalue[i-j];</div><div class="line">                leftlen[i] = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//输出最优解方案</span></div><div class="line">    <span class="keyword">int</span> m = n<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;leftlen[m]&lt;&lt;<span class="string">"\t"</span>;</div><div class="line">        m -= leftlen[m];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果如图：</p><p>​                <img src="http://omaby2s5z.bkt.clouddn.com/2017-10-31-22-25-25.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-动态规划（Dynamic-programming）&quot;&gt;&lt;a href=&quot;#1-动态规划（Dynamic-programming）&quot; class=&quot;headerlink&quot; title=&quot;1. 动态规划（Dynamic programming）&quot;&gt;&lt;/a&gt;1. 动
      
    
    </summary>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】713.Subarray-Product-Less-Than-K.md</title>
    <link href="http://yoursite.com/2017/10/26/%E3%80%90leetcode%E3%80%91713-Subarray-Product-Less-Than-K-md/"/>
    <id>http://yoursite.com/2017/10/26/【leetcode】713-Subarray-Product-Less-Than-K-md/</id>
    <published>2017-10-26T08:28:31.000Z</published>
    <updated>2017-10-26T09:14:15.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Your are given an array of positive integers nums.</p><p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">Output: 8</div><div class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个正整数组，和一个整数k，求成绩小于k的连续子数组个数</p><p>这道题真的是做了很久，想到了用滑窗，用一个数字记录窗口内数字成绩，但是算不明白个数</p><p>问题的关键在于:</p><p><strong>每次滑窗的末尾向后移动一位之后，满足条件的窗口内新增的连续子数组数目为：end-start+1</strong></p><p>因为每次滑窗末尾向后移动一位，新增的子数组必然包含最后一个数字，又必须是连续子数组，所以新增的个数是end-start+1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后附上很简单的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class="line">    int product = 1;</div><div class="line">    int count = 0;</div><div class="line">    int start = 0;</div><div class="line">    int end = 0;</div><div class="line">    while(end &lt; nums.size()&amp;&amp;start&lt;=end)&#123;</div><div class="line">        product = product*nums[end];</div><div class="line">        while(product&gt;=k&amp;&amp;start&lt;=end)&#123;</div><div class="line">            product = product/nums[start];</div><div class="line">            start++;</div><div class="line">        &#125;</div><div class="line">        count+=end-start+1;</div><div class="line">        end++;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="http://omaby2s5z.bkt.clouddn.com/blog/171026/1g02kLeb0H.png?imageslim" alt=""><br><img src="http://omaby2s5z.bkt.clouddn.com/201710261713_719.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Your are given an array of positive integers nums.&lt;/p&gt;
&lt;p&gt;Count and pr
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】 628. Maximum Product of Three Numbers</title>
    <link href="http://yoursite.com/2017/08/01/%E3%80%90leetcode%E3%80%91-628-Maximum-Product-of-Three-Numbers/"/>
    <id>http://yoursite.com/2017/08/01/【leetcode】-628-Maximum-Product-of-Three-Numbers/</id>
    <published>2017-08-01T12:27:59.000Z</published>
    <updated>2017-08-01T12:28:42.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p><p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3]</div><div class="line">Output: 6</div></pre></td></tr></table></figure></p><p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3,4]</div><div class="line">Output: 24</div></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>The length of the given array will be in range [3,$10^4$] and all elements are in the range [-1000, 1000].<br>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果数组里面没有负整数，那最大的乘积就是三个最大的数字乘积，题目说明数组中的数字范围是<strong>[-1000, 1000]</strong>，所以会有两种情况：</p><ol><li>两个最小的负数*一个最大的正数</li><li>三个最大的正数相乘</li></ol><p>所以只需要定义5个变量用来存储两个最小的和三个最大的数字，遍历一遍数组获取5个变量的值，然后返回两种情况中值较大的那种。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    //声明变量用来存储两个最小的数字和三个最大的数字</div><div class="line">    int min1 = 1001, min2 = 1001, max1 = -1001, max2 = -1001, max3 = -1001;</div><div class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</div><div class="line">        //遇到比min1还小的</div><div class="line">        if (nums[i] &lt; min1) &#123;</div><div class="line">            min2 = min1;</div><div class="line">            min1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &lt; min2) &#123;</div><div class="line">            min2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        if (nums[i] &gt; max1) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = max1;</div><div class="line">            max1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max2) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max3) &#123;</div><div class="line">            max3 = nums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = min1*min2*max1;</div><div class="line">    int y = max1*max2*max3;</div><div class="line">    if (x &gt; y)</div><div class="line">        return x;</div><div class="line">    else</div><div class="line">        return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597ffda9bb7c7.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an integer array, find three numbers whose product is maximum an
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1. Two Sum</title>
    <link href="http://yoursite.com/2017/08/01/%E3%80%90leetcode%E3%80%911-Two-Sum/"/>
    <id>http://yoursite.com/2017/08/01/【leetcode】1-Two-Sum/</id>
    <published>2017-07-31T16:33:36.000Z</published>
    <updated>2017-07-31T16:34:41.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line"></div><div class="line">return [0, 1].</div></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给一个数组和一个整数，返回数组中和恰好等于这个整数的两个数组的位置</p><p>自己就只想出来了从前向后遍历的方法，时间复杂度$O(n^2)$</p><p>代码如下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        hash_map&lt;int,int&gt; map;</div><div class="line">        for(int i = 0;i &lt; nums.size();i++)&#123;</div><div class="line">            int res = target-nums[i];</div><div class="line">            if (map.)</div><div class="line">            for(int j = i+1;j &lt; nums.size();j++)&#123;</div><div class="line">                if (res == nums[j])&#123;</div><div class="line">                    result.push_back(i);</div><div class="line">                    result.push_back(j);</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>看了solution才知道这道题正确的打开方式是用hash_map，可以先把数组中的元素存入hash_map中，这样就可以实现O(1)复杂度的按值查找了。</p><p>不过还有更好的方式，就是采用边查找边插入的方式，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt; a,int b) &#123;</div><div class="line">    vector&lt;int&gt; res;</div><div class="line">    unordered_map&lt;int, int&gt; map;</div><div class="line">    for (int i = 0; i &lt; a.size(); i++) &#123;</div><div class="line">        int temp = b - a[i];</div><div class="line">        //查看map里是否已经有要找的元素</div><div class="line">        unordered_map&lt;int, int&gt;::iterator it = map.find(temp);</div><div class="line">        //如果没有，把当前元素的值和idx插入map</div><div class="line">        if (it == map.end()) &#123;</div><div class="line">            map.insert(make_pair(a[i], i));</div><div class="line">        &#125;</div><div class="line">        //找到了符合要求的，返回idx</div><div class="line">        else&#123;</div><div class="line">            res.push_back(it-&gt;second);</div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样在查找指定值元素的时候就可以有$O(1)$的复杂度了，遍历的复杂度是$O(n)$,总的复杂度是$O(n)$</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597f5b7c55158.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such tha
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="hash_table" scheme="http://yoursite.com/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2017/07/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/23/归并排序/</id>
    <published>2017-07-23T15:50:46.000Z</published>
    <updated>2017-07-23T15:56:02.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>分治法</strong><br>将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p><p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//将两个有序数组合并成一个有序数组</div><div class="line">void merge(int a[], int begin,int mid,int end,int b[]) &#123;</div><div class="line">    int i = begin;</div><div class="line">    int j = mid + 1;</div><div class="line">    int k = 0;</div><div class="line">    while ((i &lt;= mid) &amp;&amp; (j &lt;= end)) &#123;</div><div class="line">        if (a[i] &lt; a[j]) &#123;</div><div class="line">            b[k] = a[i];</div><div class="line">            k++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            b[k] = a[j];</div><div class="line">            k++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (i&lt;=mid)&#123;</div><div class="line">        b[k] = a[i];</div><div class="line">        k++;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= end)&#123;</div><div class="line">        b[k] = a[j];</div><div class="line">        k++;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; k; i++)&#123;</div><div class="line">        a[begin + i] = b[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//归并排序</div><div class="line">void MergeSort(int a[], int begin,int end,int b[]) &#123;</div><div class="line">    if (begin &lt; end) &#123;</div><div class="line">        int mid = (begin + end) / 2;</div><div class="line">        MergeSort(a, begin, mid, b);</div><div class="line">        MergeSort(a, mid + 1, end, b);</div><div class="line">        merge(a, begin, mid, end, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况$O(n\log(n))$<br>平均情况$O(n\log(n))$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;分治法&lt;/strong&gt;&lt;br&gt;将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>不使用中间变量交换两个数字</title>
    <link href="http://yoursite.com/2017/07/22/%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2017/07/22/不使用中间变量交换两个数字/</id>
    <published>2017-07-22T14:18:13.000Z</published>
    <updated>2017-07-22T14:18:26.178Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数字a和b，要求不使用中间变量交换二者</p><h3 id="一般做法"><a href="#一般做法" class="headerlink" title="一般做法"></a>一般做法</h3><p>一般的做法很简单</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    int temp = a;</div><div class="line">    a = b;</div><div class="line">    b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不使用中间变量的做法"><a href="#不使用中间变量的做法" class="headerlink" title="不使用中间变量的做法"></a>不使用中间变量的做法</h3><p>采用位操作符中的异或操作<code>^</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">功能</th><th>用法</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">取反</td><td>0变1,1变0</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td><td>后面补0</td></tr><tr><td style="text-align:center">>&gt;</td><td style="text-align:center">右移</td><td>前面补0，后面吞位</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center"></td><td>位或</td><td>有一个或2个1，则为1。<strong>用于做and运算</strong></td></tr></tbody></table></div><p>容易发现<code>^</code>的性质：</p><ol><li>两个相同的数字做<code>^</code>操作得0</li><li>任何数字跟0做<code>^</code>操作还是它本身</li></ol><p>所以可以通过下面的方式交换两个数字</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    a = a^b;</div><div class="line">    b = b^a;</div><div class="line">    a = a^b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个程序大部分时间正确，但是有个致命缺陷，当a和b指向同一个位置时，计算a^b得0，也就是说a和b所指向的地址是同一个，所以此时a=b=0。所以上面这样写的前提是假设两个指针不会指向同一个位置。这也是编译器优化时经常考虑的一点，这种两个指针指向同一个存储器的情况叫做存储器别名使用（memory aliasing）。</p><p>因此正确的程序应该如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    if (a!=b)&#123;</div><div class="line">        a = a^b;</div><div class="line">        b = b^a;</div><div class="line">        a = a^b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个数字a和b，要求不使用中间变量交换二者&lt;/p&gt;
&lt;h3 id=&quot;一般做法&quot;&gt;&lt;a href=&quot;#一般做法&quot; class=&quot;headerlink&quot; title=&quot;一般做法&quot;&gt;&lt;/a&gt;一般做法&lt;/h3&gt;&lt;p&gt;一般的做法很简单&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2017/07/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/22/选择排序/</id>
    <published>2017-07-22T14:17:57.000Z</published>
    <updated>2017-07-22T14:18:45.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次从无序区选择一个最小的放大有序区的最后</p><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p></li><li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//选择排序</div><div class="line">void SekectSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        int min = a[i];</div><div class="line">        int loc = i;</div><div class="line">        //寻找最小的元素</div><div class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</div><div class="line">            if (a[j] &lt; min) &#123;</div><div class="line">                min = a[j];</div><div class="line">                loc = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //把最小的元素放在有序区后面</div><div class="line">        int temp = a[loc];</div><div class="line">        a[loc] = a[i];</div><div class="line">        a[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;每次从无序区选择一个最小的放大有序区的最后&lt;/p&gt;
&lt;p&gt;设数组为a[0…n-1]。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始时，数组全为无序区
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2017/07/22/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/22/希尔排序/</id>
    <published>2017-07-22T09:09:32.000Z</published>
    <updated>2017-07-22T09:09:54.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>希尔排序的实质是分组插入排序，又称缩小增量排序。</p><p>该方法的基本思想是：</p><ol><li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的），对这些子序列分别进行直接插入排序</li><li>依次缩减增量再进行排序</li><li>待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li></ol><p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在我们要将这样一个数组排序，一共有10个元素</p><p><img src="https://i.loli.net/2017/07/20/59701858e5e96.png" alt=""> </p><ul><li><strong>第一次 增量 gap = 10/2 = 5</strong></li></ul><p><img src="https://i.loli.net/2017/07/20/59701a2be3ef5.png" alt=""> </p><p>整个数组被分成了5个子数组，分别是[49,13]，[38,27]，[65,49]，[97,55]，[26,4]<br>然后对这五个子数组进行插入排序，得到下面结果</p><p><img src="https://i.loli.net/2017/07/20/59701b9f8c66f.png" alt=""> </p><ul><li><strong>第二次 增量 gap = 5/2 = 2</strong></li></ul><p><img src="https://ooo.0o0.ooo/2017/07/20/59701bfe5a204.png" alt=""> </p><p>这次我们把整个数组分成了两个子数组，分别是[13,49,4,38,97],[27,55,49,65,26]<br>对这个两个子数组排序，结果如下：<br><img src="https://i.loli.net/2017/07/20/59701d3805da5.png" alt=""> </p><ul><li><strong>第三次 增量 gap = 2/2 = 1</strong><br>此时整个数组已经接近有序，对整个数组进行全排列</li></ul><p><img src="https://i.loli.net/2017/07/20/59701e32a8bb1.png" alt=""> </p><p>最终得到数组有序</p><p><img src="https://ooo.0o0.ooo/2017/07/20/59701fd2c547a.png" alt=""> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; delta; i++) &#123;//分成了delta个子序列</div><div class="line">            //对每个子序列进行插入排序</div><div class="line">            for (int j = i + delta; j &lt; len; j = j + delta) &#123;</div><div class="line">                int jj = j - delta;</div><div class="line">                int temp = a[j];</div><div class="line">                while ((a[jj] &gt; temp)&amp;&amp;(jj&gt;=0)) &#123;</div><div class="line">                    a[jj + delta] = a[jj];</div><div class="line">                    jj -= delta;</div><div class="line">                &#125;</div><div class="line">                //插入</div><div class="line">                a[jj + delta] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">白话经典算法系列</a>原文是这么说的</p><blockquote><p>很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较…….。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。</p></blockquote><p>我理解了一下，思路就是把在序列中提取子序列的过程简化了，我们可以从第gap个元素开始，向后遍历到序列末尾，可以个元素都跟其所在的子序列中位于它前面的数字做插入排序，最终就会得到一个有序数列了~</p><p>画个图表示一下吧，还是刚才那个序列，比如说此时进行到第二次排序了，gap=2的情况：</p><p>从a[2]开始遍历，此时a[2]所在的子序列为[a[0],a[2],a[4],a[6],a[8]]，需要将a[2]和位于它前面的a[0]比较，插入到合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731239a3cd2.png" alt=""> </p><p>指针后移一位， 同上此时a[3]所在的子序列为[a[1],a[3],a[5],a[7],a[9]]，需要将a[3]和位于它前面的a[1]比较，插入合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731264440fc.png" alt=""> </p><p>接下来指针指向a[4],此时需要将a[4]和位于它前面的a[2]、a[0]比较，插入合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731282140fd.png" alt=""> </p><p>下面重复上面的步骤：</p><p><img src="https://i.loli.net/2017/07/22/597312a912c5c.png" alt=""> </p><p><img src="https://i.loli.net/2017/07/22/597312ca290dc.png" alt=""> </p><p>此处省略剩余步骤…..最终可以将数组排列至有序状态</p><p>现在可以上代码了~<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = delta; i &lt; len; i++) &#123;//遍历</div><div class="line">            //对该元素子前面的子数组进行插入排序</div><div class="line">            int temp = a[i];</div><div class="line">            int jj = i - delta;</div><div class="line">            while ((jj &gt;=0)&amp;&amp;(a[jj]&gt;temp))&#123;</div><div class="line">                swap(a[jj], a[jj+delta]);</div><div class="line">                jj -= delta;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;希尔排序的实质是分组插入排序，又称缩小增量排序。&lt;/p&gt;
&lt;p&gt;该方法的基本思想是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先将整个待排元素序列分割成若
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2017/07/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/20/插入排序/</id>
    <published>2017-07-20T01:47:19.000Z</published>
    <updated>2017-07-22T08:21:53.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p></li><li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><p>在查找某元素应该插入到前面有序序列的位置时，我们可以采用边交换边插入的方式，直到无需交换</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                int temp = a[j];</div><div class="line">                a[j] = a[j - 1];</div><div class="line">                a[j - 1] = temp;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中交换元素部分可以调用STL中的swap函数实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//插入排序</div><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                swap(a[j], a[j - 1]);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
</feed>
