<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-20T06:43:23.804Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【RTB论文笔记】</title>
    <link href="http://yoursite.com/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/"/>
    <id>http://yoursite.com/2017/11/20/【RTB论文笔记】/</id>
    <published>2017-11-20T06:43:23.000Z</published>
    <updated>2017-11-20T06:43:23.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><h3 id="Attribution-Modeling-Increases-Efficiency-of-Bidding-in-Display-Advertising-by-Eustache-Diemert-et-al-ADKDD-2017"><a href="#Attribution-Modeling-Increases-Efficiency-of-Bidding-in-Display-Advertising-by-Eustache-Diemert-et-al-ADKDD-2017" class="headerlink" title="Attribution Modeling Increases Efficiency of Bidding in Display Advertising by Eustache Diemert et al. ADKDD 2017."></a><a href="https://arxiv.org/pdf/1707.06409.pdf" target="_blank" rel="external">Attribution Modeling Increases Efficiency of Bidding in Display Advertising</a> by Eustache Diemert et al. ADKDD 2017.</h3><p>数据集：Criteo、Facebook真实场景</p><p>归因模型提高展示广告竞价效率</p><h4 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h4><p>衡量展示广告效果基于广告展示带来的价值，目前主要的两种方式：CPC，CPA（cost per action）,工业界中归因转化的标准是：归因于转化之前30天之内最后一次点击行为。</p><p>对于广告引擎和平台来说，目前最先进的出价策略是：Expected Value Bidder (EVB),也就是根据展示机会的预期价值来出价。预期价值是广告主payment*预测的转化率</p><p>在博弈论和经济学领域，转化归因已有深入研究，已经有一些机制被提出去较好地衡量广告主的payment，尤其是在多个广告点击或者转化行为同时发生或多个者渠道同时存在的情况下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h2&gt;&lt;h3 id=&quot;Attribution-Modeling-Increases-Efficiency-of-Bidding-in-D
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】动态规划</title>
    <link href="http://yoursite.com/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2017/11/18/【九章算法基础班】动态规划/</id>
    <published>2017-11-18T15:35:24.000Z</published>
    <updated>2017-11-20T08:22:11.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">Triangle</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;      [2],</div><div class="line">&gt;     [3,4],</div><div class="line">&gt;    [6,5,7],</div><div class="line">&gt;   [4,1,8,3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p></blockquote><p>题目是说，从三角形的最上层走到最下层，每次只走到下一层的相邻元素，求从顶点走到最下层的最短路径长度。</p><h3 id="方法1：DFS遍历"><a href="#方法1：DFS遍历" class="headerlink" title="方法1：DFS遍历"></a>方法1：DFS遍历</h3><p>从上往下深度优先遍历搜索，记录所有情况之中最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> best = Integer.MAX_VALUE;;</div><div class="line"></div><div class="line"><span class="comment">//sum为走到当前节点但不包含当前节点的路径和</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//搜索结束条件：走过了最下面一层</span></div><div class="line">  <span class="keyword">int</span> height = triangle.size();</div><div class="line">  <span class="keyword">if</span>(i==height)&#123;</div><div class="line">    best = Math.min(best,sum);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  dfs(triangle,i+<span class="number">1</span>,j,sum+triangle.get(i).get(j));</div><div class="line">  dfs(triangle,i+<span class="number">1</span>,j+<span class="number">1</span>,sum+triangle.get(i).get(j));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span> </span>&#123;</div><div class="line">  dfs(triangles,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> best;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度<script type="math/tex">O(2^n)</script></p><h3 id="方法2：分治法"><a href="#方法2：分治法" class="headerlink" title="方法2：分治法"></a>方法2：分治法</h3><p>从最底层走到某个点[i,j]的最短路径长度可以分解为两个子问题：</p><ol><li>这个点自身的路径 长度+下一层左边节点路径长度</li><li>这个点自身的路径 长度+下一层左右边节点路径长度</li></ol><p>最终的结果需要取这两种情况的最小值。</p><p><strong>边界条件</strong>：最下面一层的最小路径长度是1</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="comment">//边界条件：最下面一层的路径长度是0</span></div><div class="line">  <span class="keyword">int</span> height = triangles.size();</div><div class="line">  <span class="keyword">if</span>(x==height)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="comment">//其余点的路径长度是下一层左右两个路径长度+自身长度的最小值。</span></div><div class="line">  <span class="keyword">return</span> triangles.get(x).get(y) + Math.min(</div><div class="line">    divide(triangles,x+<span class="number">1</span>,y),</div><div class="line">    divide(triangles,x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度<script type="math/tex">O(2^n)</script></p><h3 id="方法3：记忆化搜索"><a href="#方法3：记忆化搜索" class="headerlink" title="方法3：记忆化搜索"></a>方法3：记忆化搜索</h3><p>显然上面的方法有很多重复计算的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">  [x,y]</div><div class="line">    ↓    ↘</div><div class="line">[x+1,y] [x+1,y+1]</div><div class="line">   ↓      ↘ ↓       ↘</div><div class="line">[x+2,y] [x+2,y+1] [x+2,y+2]</div><div class="line">**/</div></pre></td></tr></table></figure><p>其中[x+2,y+1]就被重复计算了两次。</p><p>可以将这些多次重复计算的值存下来，计算过一次之后后面再用到就可以避免重复计算了。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> best = Integer.MAX_VALUE;</div><div class="line">List&lt;List&lt;Integer&gt;&gt; tri = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">int</span>[][] hash;<span class="comment">//存储已经计算过的节点值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">memorySearch</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(x == tri.size()-<span class="number">1</span>)&#123;</div><div class="line">    hash[x][y]=tri.get(x).get(y);</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(hash[x][y]!= Integer.MAX_VALUE)&#123;</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  hash[x][y] = tri.get(x).get(y)+Math.min(</div><div class="line">    memorySearch(x+<span class="number">1</span>,y),</div><div class="line">    memorySearch(x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> hash[x][y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span> </span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangles.get(i).size();j++)&#123;</div><div class="line">      hash[i][j] = Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> memorySearch(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="comment">//return best;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度<script type="math/tex">O(n^2)</script></p><h3 id="方法4：多重循环"><a href="#方法4：多重循环" class="headerlink" title="方法4：多重循环"></a>方法4：多重循环</h3><h4 id="实现方式1：自底向上"><a href="#实现方式1：自底向上" class="headerlink" title="实现方式1：自底向上"></a>实现方式1：自底向上</h4><p>从终点（最下面一层）出发，逐层向上至终点。</p><p><strong>状态：</strong>f[i,j]表示从最下面一层到点[i,j]最短路径长度</p><p><strong>方程：</strong>f[i,j] = a[i,j]+min(f[i+1,j],f[i+1,j+1])</p><p><strong>初始化：</strong>f[i,j] = a[i,j],其中i是最下面一行</p><p><strong>答案：</strong>f[0,0]</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpUp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span></span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; triangles.size();i++)&#123;</div><div class="line">    hash[triangles.size()-<span class="number">1</span>][i] = triangles.get(triangles.size()-<span class="number">1</span>).get(i);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =triangles.size()-<span class="number">2</span>; i &gt;= <span class="number">0</span> ;i--)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;i+<span class="number">1</span>;j++)&#123;</div><div class="line">      hash[i][j] = triangles.get(i).get(j) + Math.min(hash[i+<span class="number">1</span>][j],hash[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> hash[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现方式2：自顶向下"><a href="#实现方式2：自顶向下" class="headerlink" title="实现方式2：自顶向下"></a>实现方式2：自顶向下</h4><p>从起点（顶点）出发，逐层向下至最后一层。</p><p><strong>状态：</strong>f[i,j]表示从最顶点到点[i,j]最短路径长度</p><p><strong>方程：</strong>f[i,j] = a[i,j]+min(f[i-1,j-1],f[i-1,j])</p><p><strong>初始化：</strong>f[0,0] = a[0,0]</p><p><strong>答案：</strong>min(f[i,j]),其中i是最下面一层</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpDown</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangles)</span></span>&#123;</div><div class="line">  hash = <span class="keyword">new</span> <span class="keyword">int</span>[triangles.size()][triangles.get(triangles.size()-<span class="number">1</span>).size()];</div><div class="line">  hash[<span class="number">0</span>][<span class="number">0</span>] = triangles.get(<span class="number">0</span>).get(<span class="number">0</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; triangles.size();i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;i+<span class="number">1</span>;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j) + hash[i-<span class="number">1</span>][j];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j) + hash[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        hash[i][j] = triangles.get(i).get(j)+Math.min(hash[i-<span class="number">1</span>][j-<span class="number">1</span>],hash[i-<span class="number">1</span>][j]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; triangles.get(triangles.size()-<span class="number">1</span>).size();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(hash[triangles.size()-<span class="number">1</span>][i] &lt; min)&#123;</div><div class="line">      min = hash[triangles.size()-<span class="number">1</span>][i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><h3 id="什么时候用DP"><a href="#什么时候用DP" class="headerlink" title="什么时候用DP"></a>什么时候用DP</h3><p>三个条件满足其一则极有可能是需要用DP求解：</p><ol><li>求最大、最小值</li><li>判断是否可行</li><li>统计方案个数</li></ol><h3 id="什么时候不用DP"><a href="#什么时候不用DP" class="headerlink" title="什么时候不用DP"></a>什么时候不用DP</h3><p>三个条件满足其一则极不可能用DP：</p><ol><li>输出所有方案</li><li>给得是集合，不是序列（元素顺序不可换）</li><li>暴力算法的时间复杂度已经是多项式复杂度了（n^2,n^3）,dp擅长将指数复杂度优化到多相似复杂度</li></ol><h2 id="动态规划四要素："><a href="#动态规划四要素：" class="headerlink" title="动态规划四要素："></a>动态规划四要素：</h2><p><strong>状态</strong>：<code>f[][]</code>的含义，<strong>最难</strong>！</p><p><strong>方程</strong>：状态之间的联系，怎么用小状态算大状态</p><p><strong>初始化</strong>：最小状态是什么，起点</p><p><strong>答案</strong>：最大状态是什么，终点</p><p><strong>两种方法：</strong></p><ol><li>自顶向下：从起点出发到终点</li><li>自底向上：从终点出发，反推至起点</li></ol><p><strong>VS递归三要素</strong></p><ul><li>定义（状态）<ul><li>接受了什么参数</li><li>做了什么事情</li><li>返回了什么值</li></ul></li><li>拆解（方程）<ul><li>符合将参数变小</li></ul></li><li>出口（初始化）<ul><li>什么时候可以直接return</li></ul></li></ul><h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">Minimum Path Sum</a></h2><blockquote><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [[1,3,1],</div><div class="line">&gt;  [1,5,1],</div><div class="line">&gt;  [4,2,1]]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given the above grid map, return </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 7</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>. Because the path 1→3→1→1→1 minimizes the sum.</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>坐标性动态规划</p><p><strong>状态：</strong>f[i,j]表示从(0,0)出发走到(i,j)的路径长度</p><p><strong>方程：</strong>f[i,j] = a[i,j] + min(f[i-1,j],f[i,j-1]),只能从左边和上边走过来</p><p><strong>初始化：</strong>初始化二维数组时，初始化第0行和第0列</p><p><strong>答案：</strong>f[end,end]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</div><div class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            path[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + path[<span class="number">0</span>][i-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid.length;j++)&#123;</div><div class="line">            path[j][<span class="number">0</span>] = grid[j][<span class="number">0</span>] + path[j-<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                path[i][j] = grid[i][j] + Math.min(path[i - <span class="number">1</span>][j], path[i][j - <span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> path[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">Unique Paths</a></h2><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><p><img src="https://leetcode.com/static/images/problemset/robot_maze.png" alt="img"></p></blockquote><p>从左上角走到右下角的方案个数</p><p>到右下角可能从上面或者左边的点过来。</p><p>f[i,j]：从(0,0)到(i,j)的方案个数</p><p>状态转移方程：f[i,j] = f[i-1,j]+f[i,j-1]</p><p>初始化：第0行和第0列的方案数为1，f[i,0]=f[0,j]=1</p><h2 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii" target="_blank" rel="external">Unique Paths II</a></h2><h2 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs" target="_blank" rel="external">Climbing Stairs</a></h2><blockquote><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 2</div><div class="line">&gt; Output:  2</div><div class="line">&gt; Explanation:  There are two ways to climb to the top.</div><div class="line">&gt;</div><div class="line">&gt; 1. 1 step + 1 step</div><div class="line">&gt; 2. 2 steps</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 3</div><div class="line">&gt; Output:  3</div><div class="line">&gt; Explanation:  There are three ways to climb to the top.</div><div class="line">&gt;</div><div class="line">&gt; 1. 1 step + 1 step + 1 step</div><div class="line">&gt; 2. 1 step + 2 steps</div><div class="line">&gt; 3. 2 steps + 1 step</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看成是一维数组，从起点走到终点，每次只能走1或2步。</p><p>f[i]：走到i点的方案数</p><p>转移方程：f[i] = f[i-1]+f[i-1]，因为只能走一步或者两步，所以只能从前一个或者两个格子过来。</p><h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a><a href="https://leetcode.com/problems/jump-game" target="_blank" rel="external">Jump Game</a></h2><p>动态规划可以做，但是贪心法是最优方法</p><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>For example:<br>A = <code>[2,3,1,1,4]</code>, return <code>true</code>.</p><p>A = <code>[3,2,1,0,4]</code>, return <code>false</code>.</p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>判断是否可以跳到最后一步：是否有可行方案问题</p><p>坐标型动态规划，一维坐标</p><p>state：s[i]，是否能从起点跳到i点</p><p>取决于前面是否存在点j：</p><ol><li>从起点是否能跳到j点：s[j]</li><li>从j是否能跳到i：j+s[j]&gt;=i</li></ol><p>转移方程：s[i] = s[j] &amp;&amp; j+s[j]&gt;=i（j&lt;i）</p><h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii" target="_blank" rel="external">Jump Game II</a></h2><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>For example:<br>Given array A = <code>[2,3,1,1,4]</code></p><p>The minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)</p></blockquote><p>求跳跃最少的方案跳跃次数</p><p>求最小，坐标型动态规划</p><p>state:s[i]从起点出发跳到i点需要步数</p><p>转移方程：s[i] = min(s[j]+1),j满足条件可以一步跳到i，加个判断</p><h2 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="external">Longest Increasing Subsequence</a></h2><blockquote><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p><p>Your algorithm should run in O(<em>n2</em>) complexity.</p></blockquote><p>subqequence：子序列，可以跳着取</p><p>substring：子串，相连的，不可以跳着取</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP和二分法</p><p>判断是否使用DP：</p><ol><li>求最长</li><li>一维序列，元素位置不可交换</li><li>暴力复杂度是O(2^n)</li></ol><p>看成是小人跳木桩，数组的值为木桩的高度，小人每次踩一个更高的木桩</p><p>state：f[i]表示从任意一个木桩出发，从低到高，跳到i点，最多踩过多少个木桩</p><p>转移方程：f[i] = max(f[j]+1) j满足：j&lt;i &amp;&amp; nums[j]&lt;nums[i]</p><p>初始化：f[0] = f[1] = …= f[n-1] = 1 从前面的任何一个点出发跳到此处要经过多少根木桩，初始化时，只经过自己跳到自己踩过的木桩树为1。</p><p>return：max(f[1],f[2],….,f[n-1]) 因为递增子序列不一定以最后一个元素为结尾，这道题要求的是最长的子序列，所以需要在所有的点里面找到最大的值返回。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Triangle&quot;&gt;&lt;a href=&quot;#Triangle&quot; class=&quot;headerlink&quot; title=&quot;Triangle&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/triangle&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记3——堆Heap</title>
    <link href="http://yoursite.com/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%A0%86Heap/"/>
    <id>http://yoursite.com/2017/11/18/【九章算法强化班】课程笔记3——堆Heap/</id>
    <published>2017-11-18T07:15:48.000Z</published>
    <updated>2017-11-18T07:15:48.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">Trapping Rain Water</a></h2><blockquote><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p><p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt="img"></p></blockquote><p>向柱子中灌水，求能够灌水的总量。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以从边缘向内灌水，灌水的高度不会超过边缘柱子的高度的最小值，所以说：<strong>边缘高度奠定了灌水的基调</strong></p><p>从低的一边（高度为h）向内灌水，能够灌水的量为（h-h_temp），遇到更高的柱子时，更新边缘。</p><p>显然，这是一个<strong>双指针</strong>问题。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-31-18.png" alt=""> </p><p>开始时，令总水量sum=0，双指针指向边缘，左选择较小的向内移动，假如选择左边指针。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-32-16.png" alt=""> </p><p>sum += 1，指针继续向右移动</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-33-23.png" alt=""> </p><p>此时左边指针遇到了跟高的边缘，右边指针开始向内移动</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-34-14.png" alt=""> </p><p>右边指针也同样遇到了更高的柱子，此时再从左右两边指针中选择一个较小的向内移动，假如选的依然是左边的，向内移动，更新sum，知道遇到更高的柱子</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-35-36.png" alt=""> </p><p>右侧指针左移，直到两指针相遇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public int trap(int[] height) &#123;</div><div class="line">    int left = 0;</div><div class="line">    int right = height.length-1;</div><div class="line">    int sum = 0;</div><div class="line">    while(left &lt; right)&#123;</div><div class="line">        if(height[left]&lt;height[right])&#123;</div><div class="line">            int min = height[left];</div><div class="line">            left++;</div><div class="line">            while(height[left]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[left];</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            int min = height[right];</div><div class="line">            right--;</div><div class="line">            while(height[right]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[right];</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Trapping-Rain-Water-II"><a href="#Trapping-Rain-Water-II" class="headerlink" title="Trapping Rain Water II"></a><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">Trapping Rain Water II</a></h2><blockquote><p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p><p><strong>Note:</strong><br>Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 3x6 height map:</div><div class="line">&gt; [</div><div class="line">&gt;   [1,4,3,1,3,2],</div><div class="line">&gt;   [3,2,1,3,2,4],</div><div class="line">&gt;   [2,3,3,2,3,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; Return 4.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><img src="https://leetcode.com/static/images/problemset/rainwater_empty.png" alt="img"><br>The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.</p><p><img src="https://leetcode.com/static/images/problemset/rainwater_fill.png" alt="img"><br>After the rain, water are trapped between the blocks. The total volume of water trapped is 4.</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这一题是上一题在二维空间上的扩展。</p><p>对比上一题的思路，上一题的围墙是左右两边的柱子，而这道题的围墙是矩阵四周一圈的墙。我们可以从最矮的墙头向内灌水，然后将被灌水的位置加入围墙。</p><p>有两个要解决的点：</p><ol><li>找到围墙中最矮的墙头</li><li>从最矮的墙头向围墙内灌水，要知道那边是围墙“内”</li></ol><p>对于第1点，要求围墙中最矮的墙头，且墙头是动态插入的，可以维护一个最小堆，每次出堆元素即为最小的。</p><p>对于第2点，可以额外维护一个标记数组，记录是否已经被访问过，每次入堆就将该点对应的位置标记，若某一点没有被标记则是在围墙内。</p><p>以上图为例：</p><p>首先将四周设为围墙，将围墙元素入堆[1,4,3,1,3,2,3,4,2,3,3,2,3,1]</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-30-45.png" alt=""> </p><p>选取围墙中最小的，向内灌水，比如：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-53-16.png" alt=""> </p><p>由于3&gt;1，不能灌水，将3所在位置加入围墙[<del>1</del>,4,3,1,3,2,3,4,2,3,3,2,3,1, 3]</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-55-43.png" alt=""> </p><p>然后依次选取高度为1的其他几个围墙作为最矮的围墙，发现都不能够往里灌水，接下来选择高度为2的围墙，发现也不能向内灌水了，选取高度为3的围墙，比如：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-56-45.png" alt=""> </p><p>发现可以灌水量为2，然后将此点灌水后的高度加入围墙，[<del>1</del>,4,<del>3</del>,<del>1,</del>3,<del>2</del>,3,4,<del>2</del>,3,3,<del>2</del>,3,<del>1</del>,3,  3]：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-11-03-13.png" alt=""> </p><p>继续重复上边的步骤，知道堆为空</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRain2</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        Node(<span class="keyword">int</span> val,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node e1,Node e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1.val-e2.val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(heightMap.length == <span class="number">0</span> || heightMap[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[heightMap.length][heightMap[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(cmp);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="comment">//初始边界入堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heightMap.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; heightMap[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == heightMap.length-<span class="number">1</span> || j == heightMap[<span class="number">0</span>].length-<span class="number">1</span>)&#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(heightMap[i][j],i,j));</div><div class="line">                    visited[i][j] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            Node top =  heap.peek();</div><div class="line">            heap.remove();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">                <span class="keyword">int</span> x_new = top.x+x_delta[i];</div><div class="line">                <span class="keyword">int</span> y_new = top.y+y_delta[i];</div><div class="line">                <span class="keyword">if</span>(x_new &gt;=<span class="number">0</span> &amp;&amp; x_new &lt; heightMap.length &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt; heightMap[<span class="number">0</span>].length &amp;&amp; !visited[x_new][y_new])&#123;</div><div class="line">                    <span class="keyword">if</span>(heightMap[x_new][y_new] &lt; top.val)&#123;</div><div class="line">                        sum += top.val-heightMap[x_new][y_new];</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(top.val,x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(heightMap[x_new][y_new],x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    visited[x_new][y_new] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TrappingRain2 test = <span class="keyword">new</span> TrappingRain2();</div><div class="line">        <span class="keyword">int</span>[][] heightMap = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> sum = test.trapRainWater(heightMap);</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;h2 id=&quot;Trapping-Rain-Water&quot;&gt;&lt;a href=&quot;#Trapping-Rain-Water&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2——扫描线</title>
    <link href="http://yoursite.com/2017/11/17/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <id>http://yoursite.com/2017/11/17/【九章算法强化班】课程笔记2——扫描线/</id>
    <published>2017-11-17T09:38:49.000Z</published>
    <updated>2017-11-17T09:39:12.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h2 id="lintcode391-数飞机"><a href="#lintcode391-数飞机" class="headerlink" title="lintcode391. 数飞机"></a><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给出飞机的起飞和降落时间的列表，用 interval 序列表示. 请计算出天上同时最多有多少架飞机？</p><p>样例</p><p>对于每架飞机的起降时间列表：<code>[[1,10],[2,3],[5,8],[4,7]]</code>, 返回<code>3</code>。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-17-20-40-58.png" alt=""> </p><p>计算空中的飞机个数，可以看成用一个线从左到右扫描的过程，计算每一时刻空中飞机的数量。</p><p>优化：只计算所有线段起始位置时天上的飞机即可，因为只有起始点是可能发生变化的点。遇到起点，天上的飞机数+1，遇到终点则-1。</p><p>因此，我们先将所有线段的起点、终点排序，并标记是起点还是终点，然后从小到大遍历这些点，遇到起点则+1，遇到终点-1，返回过程中最大的数值即为空中飞机数的最大值。</p><p><strong>需要注意的是</strong>：在同一点上会同时有开始点和结尾点，此时应该把结尾点放在前面，否则会出现多计算的情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.operations.Bool;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">airplane_count</span> </span>&#123;</div><div class="line">    <span class="comment">//Definition of Interval:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span></span>&#123;</div><div class="line">        Integer start, end;</div><div class="line">        Interval(Integer start, Integer end) &#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Definition of node:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line">        Integer val;</div><div class="line">        <span class="keyword">boolean</span> isstart;</div><div class="line">        Node(Integer val, <span class="keyword">boolean</span> isstart) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.isstart = isstart;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//定义排序接口</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node Other)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.val == Other.val)&#123;<span class="comment">//如果连个节点位置相同，把结束点排在前面</span></div><div class="line">                <span class="keyword">return</span> Boolean.compare(<span class="keyword">this</span>.isstart,Other.isstart);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.val, Other.val);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(List&lt;Interval&gt; airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> size = airplanes.size();</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        Node[] array = <span class="keyword">new</span> Node[<span class="number">2</span> * size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.size(); i++) &#123;</div><div class="line">            array[<span class="number">2</span> * i] = (<span class="keyword">new</span> Node(airplanes.get(i).start, <span class="keyword">true</span>));</div><div class="line">            array[<span class="number">2</span> * i + <span class="number">1</span>] = (<span class="keyword">new</span> Node(airplanes.get(i).end, <span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(array);</div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i].isstart) &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252.Meeting Rooms"></a><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></h4><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), determine if a person could attend all meetings.</p><p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>false</code>.</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目是说判断一个人是否可以参加给出的所有的会议，可以沿用扫描线的思路：同一时刻最多只有一个会议正在召开，就可以参加所有会议。</p><p>还有另外一种更快的思路：</p><p>如果每一个会议的开始都在上一个会议结束之后，那么就不会有时间冲突的会议，就可以都参加了，所以可以将给出的所有会议的开始时间和结束时间分别放入两个数组中，分别排序，然后判断是否所有的时间满足：starts[i]&gt;ends[i-1]。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line"></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.length; i++) &#123;</div><div class="line">            starts[i] = airplanes[i].start;</div><div class="line">            ends[i] = airplanes[i].end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(starts);</div><div class="line">        Arrays.sort(ends);</div><div class="line"></div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; starts.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (starts[i]&lt;ends[i-<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253.Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扫描线&quot;&gt;&lt;a href=&quot;#扫描线&quot; class=&quot;headerlink&quot; title=&quot;扫描线&quot;&gt;&lt;/a&gt;扫描线&lt;/h1&gt;&lt;h2 id=&quot;lintcode391-数飞机&quot;&gt;&lt;a href=&quot;#lintcode391-数飞机&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sweep_line" scheme="http://yoursite.com/tags/sweep-line/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】题目摘要</title>
    <link href="http://yoursite.com/2017/11/16/%E3%80%90leetcode%E3%80%91%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81/"/>
    <id>http://yoursite.com/2017/11/16/【leetcode】题目摘要/</id>
    <published>2017-11-16T01:56:40.000Z</published>
    <updated>2017-11-16T01:56:40.749Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>题目</th><th>题意</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">208.Implement Trie (Prefix Tree)</a></td><td>实现一个Trie树模板，支持插入、搜索、前缀搜索操作</td><td>Trie</td></tr><tr><td><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">211.Add and Search Word - Data structure design</a></td><td>实现Trie树的插入、搜索，支持搜索”a.b”格式，”.”表示通配符</td><td>Trie+DFS</td></tr><tr><td><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">677.Map Sum Pairs</a></td><td>单词有权重，输入前缀词，给出所有以此为前缀的词的权重之和</td><td>Trie+DFS</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">200.Number of Islands</a></td><td>统计中有0,1，相邻1为island，统计island个数(连通子图)</td><td>并查集、DFS</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-islands-ii/" target="_blank" rel="external">305.Number of Islands II</a></td><td>初始矩阵为0，每次随机将某一位改变成1，统计每一时刻island个数</td><td>并查集</td></tr><tr><td><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="external">130.Surrounded Regions</a></td><td>“XXOO”将被X包围的O改成X，处于边界的O不算被包围</td><td>DFS、并查集</td></tr><tr><td><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="external">261.Graph Valid Tree</a></td><td>给定点集和边集，判断此图是否为树</td><td>并查集</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="external">323.Number of Connected Components in an Undirected Graph</a></td><td>给定点集和边集，返回连通子图个数</td><td>并查集</td></tr><tr><td><a href="https://leetcode.com/problems/word-search" target="_blank" rel="external">79.Word Search</a></td><td>给一个字母矩阵和一个单词，查找字母矩阵中是否有该单词</td><td>回溯+BFS</td></tr><tr><td><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">212.Word Search II</a></td><td>给一个字母矩阵和一个单词数组，返回数组，里面包含出现在矩阵中的所有单词</td><td>Trie+DFS</td></tr><tr><td><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></td><td>给定一些区间，求同一时刻空中最多有多少飞机</td><td>扫描线</td></tr><tr><td><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></td><td>给定一些区间，判断是否可以参加所有会议（所有会议没有冲突）</td><td>排序扫描/扫描线</td></tr><tr><td><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></td><td>给定一些区间，求最多需要多少间会议室（最多有多少会议同时开）</td><td>扫描线</td></tr><tr><td><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">42.Trapping Rain Water</a></td><td>一维接雨水</td><td>双指针</td></tr><tr><td><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">407.Trapping Rain Water II</a></td><td>二维接雨水</td><td>堆</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">120.Triangle</a></td><td>给定一个三角形，求从顶端走到最下面的最短路径</td><td>DP</td></tr><tr><td></td><td></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;题意&lt;/th&gt;
&lt;th&gt;知识点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://lee
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2——Trie树</title>
    <link href="http://yoursite.com/2017/11/14/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2017/11/14/【九章算法强化班】课程笔记2——Trie树/</id>
    <published>2017-11-14T14:11:55.000Z</published>
    <updated>2017-11-15T12:57:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="leetcode相关题目"><a href="#leetcode相关题目" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><ul><li><del><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></del></li><li><del><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></del></li><li><del><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></del></li><li>​</li></ul><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p><p>Trie树，即字典树/前缀树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p><p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p><p>将单词插入Trie树，只在跟之前的字符串出现分歧时分裂，对最后一个字母做标记，这样查找的时候，根据最后一个字母的标记，即可判断出该单词是否出现过。</p><p>这里有一个巧妙的操作，可以让插入和查询操作同时完成，所以查询的时间复杂度简化为所要查询的单词的长度，即<script type="math/tex">O(1)</script>。</p><p>它有3个基本性质：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container"><table><thead><tr><th></th><th>hash_table</th><th>TIRE树</th></tr></thead><tbody><tr><td>查找时间复杂度</td><td>O(1)</td><td>O(1)</td></tr><tr><td>空间复杂度</td><td></td><td>优于hash_table</td></tr></tbody></table></div><p>对于a,aa,aaa,aaaa的情况</p><div class="table-container"><table><thead><tr><th></th><th>hash</th><th>trie</th></tr></thead><tbody><tr><td>存储</td><td>10个a</td><td>5个a节点</td></tr><tr><td>可用操作</td><td>有/无/查询</td><td>有/无/前缀查询</td></tr><tr><td></td><td>1行</td><td>75~100行</td></tr></tbody></table></div><p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p><h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p><p>需要节约空间</p><p>查找前缀</p><h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>有两种方式来实现Trie树，对于存储char类型的Trie树，因为只有26个字母，故可采用映射的方式将字母映射到长度为26的数组上，而下标就是字母。</p><p>而对于其他类型，比如int数目未知，可以考虑用hashmap的方式来实现。</p><h3 id="1-hashmap实现Trie树"><a href="#1-hashmap实现Trie树" class="headerlink" title="1. hashmap实现Trie树"></a>1. hashmap实现Trie树</h3><p>c++版：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">char</span> ch;</div><div class="line"><span class="keyword">bool</span> istail;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childern;</div><div class="line"></div><div class="line">TrieNode() &#123;</div><div class="line">childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line"><span class="comment">//childern = NULL;</span></div><div class="line">istail = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">TrieNode(<span class="keyword">char</span> c) &#123;</div><div class="line">ch = c;</div><div class="line">childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line"><span class="comment">//childern = NULL;</span></div><div class="line">istail = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">TrieNode* root;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line">Trie() &#123;</div><div class="line">root = <span class="keyword">new</span> TrieNode();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Inserts a word into the trie. */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">TrieNode* node = <span class="keyword">this</span>-&gt;root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line"><span class="keyword">char</span> chtemp = word[i];</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">iter = (*childrenmap).find(chtemp);</div><div class="line"><span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">node = iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">TrieNode* newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">node = newnode;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; newmap;</div><div class="line">TrieNode *newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">node = newnode;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">node-&gt;istail = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns if the word is in the trie. */</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (word.size() == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">TrieNode* node = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line"><span class="keyword">char</span> chtemp = word[i];</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">iter = (*childrenmap).find(chtemp);</div><div class="line"><span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">node = iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//children为空</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (node-&gt;ch == word[word.size() - <span class="number">1</span>] &amp;&amp; node-&gt;istail) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line">TrieNode* node = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.size(); i++) &#123;</div><div class="line"><span class="keyword">char</span> chtemp = prefix[i];</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">iter = (*childrenmap).find(chtemp);</div><div class="line"><span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">node = iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//children空</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>java版本：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        HashMap&lt;Character,TrieNode&gt; children;</div><div class="line">        <span class="keyword">boolean</span> istail;</div><div class="line">        TrieNode()&#123;</div><div class="line">            children = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">        TrieNode root;</div><div class="line">        Trie()&#123;</div><div class="line">            root = <span class="keyword">new</span> TrieNode();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;word.length();i++) &#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span> (node.children.containsKey(chtemp)) &#123;<span class="comment">//已经包含此字母</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">                    node.children.put(chtemp, <span class="keyword">new</span> TrieNode());</div><div class="line">                &#125;</div><div class="line">                node = node.children.get(chtemp);</div><div class="line">            &#125;</div><div class="line">            node.istail=<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(word.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length();i++)&#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(chtemp)) &#123;<span class="comment">//包含此字母</span></div><div class="line">                    node = node.children.get(chtemp);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(node.istail)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span> (prefix.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(prefix.charAt(i)))&#123;</div><div class="line">                    node = node.children.get(prefix.charAt(i));</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure><h3 id="2-数组实现Trie树"><a href="#2-数组实现Trie树" class="headerlink" title="2. 数组实现Trie树"></a>2. 数组实现Trie树</h3><p>对于char类型的数据，只有26个字母，所以，可以用一个长度为26的数组存储后续的节点，数组index对应的就是字母的顺序：a~z</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[prefix.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="leetcode相关题目-1"><a href="#leetcode相关题目-1" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><h3 id="Add-and-Search-Word-Data-structure-design"><a href="#Add-and-Search-Word-Data-structure-design" class="headerlink" title="Add and Search Word - Data structure design"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; void addWord(word)</div><div class="line">&gt; bool search(word)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; addWord(&quot;bad&quot;)</div><div class="line">&gt; addWord(&quot;dad&quot;)</div><div class="line">&gt; addWord(&quot;mad&quot;)</div><div class="line">&gt; search(&quot;pad&quot;) -&gt; false</div><div class="line">&gt; search(&quot;bad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;.ad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;b..&quot;) -&gt; true</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用Tire树，搜索时遇到”.”对所有节点进行DFS</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Adds a word into the data structure. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchHelper</span><span class="params">(String word,<span class="keyword">int</span> startIdx,TrieNode node)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIdx ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word.charAt(i) == <span class="string">'.'</span>)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>;j++) &#123;</div><div class="line">                    <span class="keyword">if</span> (node.children[j] != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//TrieNode nodetemp = node.children[j];</span></div><div class="line">                        <span class="keyword">boolean</span> has = searchHelper(word, i + <span class="number">1</span>, node.children[j]);</div><div class="line">                        <span class="keyword">if</span> (has) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> searchHelper(word,<span class="number">0</span>,<span class="keyword">this</span>.root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></div><div class="line"><span class="comment"> * obj.addWord(word);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><h3 id="Map-Sum-Pairs"><a href="#Map-Sum-Pairs" class="headerlink" title="Map Sum Pairs"></a><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement a MapSum class with <code>insert</code>, and <code>sum</code> methods.</p><p>For the method <code>insert</code>, you’ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.</p><p>For the method <code>sum</code>, you’ll be given a string representing the prefix, and you need to return the sum of all the pairs’ value whose key starts with the prefix.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: insert(&quot;apple&quot;, 3), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 3</div><div class="line">&gt; Input: insert(&quot;app&quot;, 2), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>建立Trie树，将原来的标记是否为单词结尾的bool型属性改为int型权重属性，单词结尾的字母值为该单词的权重值，其余字母权重设为0，找到前缀所在分支之后，DFS该前缀词下面的所有节点，累加权重值。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">int</span> weight;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.weight = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; key.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[key.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[key.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[key.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.weight=val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode node)</span></span>&#123;</div><div class="line">        res = res+node.weight;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[i]!=<span class="keyword">null</span>)&#123;</div><div class="line">                dfs(node.children[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (node.children[prefix.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i) - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        res=<span class="number">0</span>;</div><div class="line">        dfs(node);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * MapSum obj = new MapSum();</span></div><div class="line"><span class="comment"> * obj.insert(key,val);</span></div><div class="line"><span class="comment"> * int param_2 = obj.sum(prefix);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><h3 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p><p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>For example,<br>Given <strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</div><div class="line">&gt;   [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [&quot;eat&quot;,&quot;oath&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>Word Search 1要求我们返回某一个单词是否在矩阵中，Word Search 2作为升级版。给出了一串单词，搜索是否在矩阵中，如果一个一个搜索效率会很低，尤其是在要搜索的单词序列中有大量相同的前缀时，所以，考虑<strong>将搜索的单词序列构建Trie树，然后再在字母矩阵中用DFS的方式搜索</strong>。</p><p>然而想到了思路，要想完整地写出这道题，也十分艰难。</p><p>这里有几个需要注意的点：</p><ol><li><p>要将能够搜索到的单词加入最终的结果表中，可以适当修改Trie的结构，在叶子节点存储该条路径对应的word，方便后续找到路径之后将该单词加入结果表</p></li><li><p>已经用过的字母不能用第二次，所以要对字母矩阵中遍历过的字母做标记，DFS搜索结束后要恢复标记，后面还可以继续使用。这里我一开始用的方法是额外建立一个boolean型矩阵进行存储，看了大神的代码发现可以直接在原字母矩阵中进行标记即可。</p></li><li><p>在矩阵中某点周围寻找下一个字母是否存在时，我一开始采用的方式是：</p><p>在Trie树中遍历下一层node中的字母然后再去字母矩阵中某点周围四个点搜索，这样遍历下一层node判断是否还有字母，每次需要遍历26个字母，看了大神的代码有更好的方式：</p><p>从矩阵当前点周围的四个点入手，获取周围四个点的字母（实际上最多是三个，因为至少已经有一个被访问了），然后再去node中直接获取下层节是否存在该字母即可。</p></li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="comment">//boolean istail;//记录是否是某个单词的末尾</span></div><div class="line">        String word;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="comment">//this.istail=false;</span></div><div class="line">            <span class="keyword">this</span>.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.word = word;</div><div class="line">        <span class="comment">//node.istail=true;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchBoard</span><span class="params">(<span class="keyword">char</span>[][] board, TrieNode node,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,List&lt;String&gt; result)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> ch = board[x_idx][y_idx];</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'#'</span> || node.children[ch-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        node = node.children[ch-<span class="string">'a'</span>];</div><div class="line">        <span class="keyword">if</span>(node.word != <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(node.word);</div><div class="line">            node.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = <span class="string">'#'</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">            <span class="keyword">int</span> x = x_idx+x_delta[i];</div><div class="line">            <span class="keyword">int</span> y = y_idx+y_delta[i];</div><div class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length)&#123;</div><div class="line">                searchBoard(board,node,x,y,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = ch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length;i++)&#123;</div><div class="line">            insert(words[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board.length;j++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; board[<span class="number">0</span>].length;k++)&#123;</div><div class="line">                searchBoard(board,root,j,k,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title=&quot;Trie树&quot;&gt;&lt;/a&gt;Trie树&lt;/h1&gt;&lt;h2 id=&quot;leetcode相关题目&quot;&gt;&lt;a href=&quot;#leetcode相关题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Logistic Regression相关</title>
    <link href="http://yoursite.com/2017/11/06/Logistic-Regression%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/11/06/Logistic-Regression相关/</id>
    <published>2017-11-06T14:47:50.000Z</published>
    <updated>2017-11-06T14:47:50.130Z</updated>
    
    <content type="html"><![CDATA[<p>LR真的很基础而且也非常非常重要，算法面试必考，啃了好多遍，总结一下，希望能够经常复习。</p><p>暑假去头条面试，一面的面试官问到：</p><ol><li>推导一下LR吧</li><li>为什么要用sigmod函数</li><li>如何优化求解（梯度下降）</li><li>代码实现一下</li></ol><h2 id="LR模型推导"><a href="#LR模型推导" class="headerlink" title="LR模型推导"></a>LR模型推导</h2><h2 id="梯度下降求解LR"><a href="#梯度下降求解LR" class="headerlink" title="梯度下降求解LR"></a>梯度下降求解LR</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LR真的很基础而且也非常非常重要，算法面试必考，啃了好多遍，总结一下，希望能够经常复习。&lt;/p&gt;
&lt;p&gt;暑假去头条面试，一面的面试官问到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推导一下LR吧&lt;/li&gt;
&lt;li&gt;为什么要用sigmod函数&lt;/li&gt;
&lt;li&gt;如何优化求解（梯度下降）&lt;/
      
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
  </entry>
  
  <entry>
    <title>【神经网络和深度学习】课程笔记1</title>
    <link href="http://yoursite.com/2017/11/06/%E3%80%90%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2017/11/06/【神经网络和深度学习】课程笔记1/</id>
    <published>2017-11-06T12:26:32.000Z</published>
    <updated>2017-11-06T12:26:32.269Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="DeepLearning" scheme="http://yoursite.com/categories/DeepLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2——并查集</title>
    <link href="http://yoursite.com/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2017/11/05/【九章算法强化班】课程笔记2——并查集/</id>
    <published>2017-11-05T08:28:47.000Z</published>
    <updated>2017-11-15T12:57:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Union-Find并查集"><a href="#Union-Find并查集" class="headerlink" title="Union Find并查集"></a>Union Find并查集</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>一种用来解决集合查询合并的数据结构</strong></p><p>假如A、B、C三人在Microsoft工作，D、E、F、G四人在Linkedin工作，给七个人都分发一个工牌，上面写着自己的公司名字，告诉他们自己的老大是哪家公司，则可以表示成如下形式。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-10-31.png" alt=""></p><p>如果A遇到F，看一眼对方的工牌，跟自己是不是一个boss，就知道对方是不是跟自己是同一家公司的人了。</p><p>如果有一天M公司把L公司收购了，那么此时，需要对两个公司的员工进行合并操作，给员工分发新的工牌，为了减少重新分配的麻烦，就把L的boss指向M，此时L下面的员工最大的boss是M了，那么A和E就在一个阵营了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-15-16.png" alt=""></p><p>如果在M公司三个员工和L公司四个员工中分别选出一个作为该公司的boss，可以表示成如下形式：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-34.png" alt=""></p><p>那么合并之后，J的boss设置为B，此时大家都是一个阵营的了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-45.png" alt=""></p><h2 id="并查集的精髓"><a href="#并查集的精髓" class="headerlink" title="并查集的精髓"></a><strong>并查集的精髓</strong></h2><p>一共包含三个操作</p><ol><li><p>初始化</p><p>初始化操作中，每个元素的boss指向自己.</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">HashMap&lt;Integer,Integer&gt; father = <span class="keyword">new</span> HashMap&lt;integer,integer&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    father.put(nums[i],nums[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​</p></li><li><p>查找</p><p>查找元素所在的集合，也就是最大的boss。</p><p>如果要判断两个点是否属于同一个集合，就看这两个点的boss是否是同一个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> parent = x;</div><div class="line">  <span class="keyword">while</span>(parent!=father.get(parent))&#123;</div><div class="line">    parent = fater.get(parent);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度：<script type="math/tex">O(n)</script></p></li><li><p>合并</p><p>两个不想交的集合，其中一个的大boss认另一个为boss。</p><p>找到两个元素的boss，如果不是同一个，就把一个的boss指向另一个的boss。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> fa_x = find(x);</div><div class="line">  <span class="keyword">int</span> fa_y = find(y);</div><div class="line">  <span class="keyword">if</span>(fa_x != f_y)&#123;</div><div class="line">    father.put(fa_X,fa_y);<span class="comment">//合并两个boss</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度：<script type="math/tex">O(n)</script></p></li></ol><h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a><strong>并查集的优化</strong></h2><p>baseline的find流程：</p><p>如果有这样一条路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F</div></pre></td></tr></table></figure><p>查找A的boss时，需要遍历整个路径，寻找B、C、D时还需要再遍历一次，这显然是大量重复的工作，所以我们可以把一次遍历途中经过的节点都直接指向boss，下次再查询的时候，时间复杂的就是<script type="math/tex">O(1)</script>了，这就是<strong>带路径压缩的并查集</strong>的查找：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-41-32.png" alt=""></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-42-34.png" alt=""></p><p>平均时间复杂度降至<script type="math/tex">O(1)</script></p><h2 id="并查集模板-c-版"><a href="#并查集模板-c-版" class="headerlink" title="并查集模板(c++版)"></a>并查集模板(c++版)</h2><ol><li><p>hash_map实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; father;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">//初始化并查集</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements)</span></span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; elements.size();i++)&#123;</div><div class="line">                father.insert(make_pair(elements[i],elements[i]));</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//并查集中插入操作，不支持删除</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> x_fa)</span></span>&#123;</div><div class="line">            father.insert(make_pair(x,x_fa));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在并查集中查找元素的boss</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> parent = x;</div><div class="line">            <span class="keyword">while</span>(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//带路径压缩的并查集</span></div><div class="line">            <span class="keyword">while</span>(father.find(x)-&gt;second != x)&#123;</div><div class="line">                x = father[x];</div><div class="line">                father[x] = parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//合并两个元素</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> x_father = findfather(x);</div><div class="line">            <span class="keyword">int</span> y_father = findfather(y);</div><div class="line">            <span class="keyword">if</span>(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//计算并查集中有多少个不想交的子集合</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">countsets</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; father_set;</div><div class="line">            <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter = father.begin();iter != father.end();iter++)&#123;</div><div class="line">                <span class="keyword">int</span> parent = findfather(iter-&gt;first);</div><div class="line">                iter-&gt;second = parent;</div><div class="line">                father_set.insert(parent);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>vector实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>用vector会比hashmap快，但如果数据很稀疏，空间复杂度会比较高。</p></li></ol><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external"><del>leetcode200. Number of Islands</del></a></li><li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/" target="_blank" rel="external"><del>leetcode323. Number of Connected Components in an Undirected Graph</del></a></li><li><a href="https://leetcode.com/problems/number-of-islands-ii/description/" target="_blank" rel="external"><del>leetcode305. Number of Islands II</del></a></li><li><a href="https://leetcode.com/problems/graph-valid-tree/description/" target="_blank" rel="external"><del>leetcode261. Graph Valid Tree</del></a></li><li><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="external"><del>leetcode130. Surrounded Regions</del></a></li><li><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="external">leetcode128. Longest Consecutive Sequence</a></li><li><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="external">leetcode547. Friend Circles</a></li></ul><h3 id="leetcode200-Number-of-Islands"><a href="#leetcode200-Number-of-Islands" class="headerlink" title="leetcode200. Number of Islands"></a>leetcode200. Number of Islands</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11110</div><div class="line">&gt; 11010</div><div class="line">&gt; 11000</div><div class="line">&gt; 00000</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Answer: 1</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11000</div><div class="line">&gt; 11000</div><div class="line">&gt; 00100</div><div class="line">&gt; 00011</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Answer: 3</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目的意思是说矩阵中的1代表陆地，0代表海洋，如果某个1的上或下或左或右也是1的话，就是属于同一片陆地，要求矩阵中陆地的个数。也就是找出矩阵中连接子图的个数。</p><p>有两种思路：</p><ol><li><p>并查集</p><p>找出矩阵中子图的个数，可以利用并查集，在每个点附近做查找和合并操作，如果其周围有1，就讲其归为一类，最后返回并查集的集合个数就是所求的。</p><p>并查集处理二维矩阵时索引比较麻烦，所以这里需要先将二维坐标转化为一维并查集坐标：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">矩阵维度：m*n</div><div class="line">二维坐标：(i,j) --&gt; 一维坐标：x*n+j</div><div class="line">一维坐标：idx     --&gt; 二维坐标：(idx/m,idx%m)</div></pre></td></tr></table></figure><p>经过坐标转化，可以使用并查集进行计算了</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = grid.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    UnionFind unionfindset;<span class="comment">//声明并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; island;<span class="comment">//存储是1的元素</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isseen(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//记录是否遍历过</span></div><div class="line">    <span class="comment">//初始化,插入元素</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</div><div class="line">                <span class="comment">//father.insert(make_pair(i*cols+j,i*cols+j));</span></div><div class="line">                unionfindset.add(i*cols+j,i*cols+j);</div><div class="line">                island.push_back(&#123;i,j&#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; island.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> x_idx = island[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> y_idx = island[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> idx = x_idx*cols+y_idx;</div><div class="line">        <span class="keyword">if</span>(isseen[x_idx][y_idx]==<span class="number">0</span>)&#123;</div><div class="line">            isseen[x_idx][y_idx] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(x_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx<span class="number">-1</span>][y_idx]==<span class="string">'1'</span>)&#123;<span class="comment">//上</span></div><div class="line">                isseen[x_idx<span class="number">-1</span>][y_idx] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx-cols,idx);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(y_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx][y_idx<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;<span class="comment">//左</span></div><div class="line">                isseen[x_idx][y_idx<span class="number">-1</span>] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx<span class="number">-1</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> unionfindset.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BFS/DFS</p><p>从矩阵中的一个1开始做深度或广度优先遍历，其周围能够遍历到的1都是跟其属于同片陆地的，把遍历过的陆地标记为0，并把count++；然后继续从下一个出现1的地方开始遍历，跟前面的操作一样，最后就可以得到count就是矩阵中陆地的个数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,<span class="keyword">int</span>&amp; rows,<span class="keyword">int</span>&amp; cols)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x_idx&lt;<span class="number">0</span> || x_idx &gt;=rows || y_idx&lt;<span class="number">0</span> || y_idx &gt;= cols || grid[x_idx][y_idx]==<span class="string">'0'</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    grid[x_idx][y_idx]=<span class="string">'0'</span>;</div><div class="line">    bfs(grid,x_idx,y_idx<span class="number">-1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx<span class="number">-1</span>,y_idx,rows,cols);</div><div class="line">    bfs(grid,x_idx,y_idx+<span class="number">1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx+<span class="number">1</span>,y_idx,rows,cols);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>int numIslands(vector<vector<char>&gt;&amp; grid) {</vector<char></p><pre><code>int rows = grid.size();if(rows==0){    return 0;}int cols = grid[0].size();if(cols==0){    return 0;}//unordered_map&lt;int,int&gt; father;//并查集//vector&lt;vector&lt;int&gt;&gt; island;//存储是1的元素int count = 0;for(int i = 0; i &lt; rows;i++){    for(int j = 0 ; j &lt; cols;j++){        if(grid[i][j]==&#39;1&#39;){            count++;            bfs(grid,i,j,rows,cols);        }    }}return count;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### leetcode305.Number of Islands II </div><div class="line"></div><div class="line">#### 题目</div><div class="line">&gt; A 2d grid map of `m` rows and `n` columns is initially filled with water. We may perform an *addLand* operation which turns the water at position (row, col) into a land. Given a list of positions to operate, **count the number of islands after each addLand operation**. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</div><div class="line">&gt;</div><div class="line">&gt; **Example:**</div><div class="line">&gt;</div><div class="line">&gt; Given `m = 3, n = 3`, `positions = [[0,0], [0,1], [1,2], [2,1]]`.</div><div class="line">&gt; Initially, the 2d grid `grid` is filled with water. (Assume 0 represents water and 1 represents land).</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ol><blockquote><p>0 0 0<br>0 0 0<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 0 0<br>0 0 0   Number of islands = 1<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 1 0<br>0 0 0   Number of islands = 1<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 1 0<br>0 0 1   Number of islands = 2<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 1 0<br>0 0 1   Number of islands = 3<br>0 1 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; We return the result as an array: `[1, 1, 2, 3]`</div><div class="line"></div><div class="line">一个矩阵，元素都是0，代表海洋，每次选择一个元素标记为1，代表陆地，输出每轮矩阵中的island个数。</div><div class="line"></div><div class="line">#### 思路</div><div class="line"></div><div class="line">这道题目跟上面题目不同的地方在于这次是每次选择一个点进行更新，所以如果每次用DFS/BFS遍历的话，会有大量重复的运算，如果用并查集，则只需要每次对于新加入的island对其周围进行检查然后对并查集进行更新即可。</div><div class="line"></div><div class="line">#### 代码</div><div class="line"></div><div class="line">​```c++</div><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">public:</div><div class="line">vector&lt;int&gt; numIslands2(int m, int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; positions) &#123;</div><div class="line">    int count = 0;</div><div class="line">    vector&lt;int&gt; results;</div><div class="line">    UnionFind UnionFindset;</div><div class="line">    vector&lt;int&gt; x_add = &#123;0,0,1,-1&#125;;</div><div class="line">    vector&lt;int&gt; y_add = &#123;1,-1,0,0&#125;;</div><div class="line">    //初始化地图</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; mapmatrix(m,vector&lt;int&gt;(n,0));</div><div class="line">    for(int i = 0; i &lt; positions.size();i++)&#123;</div><div class="line">        int x = positions[i].first;</div><div class="line">        int y = positions[i].second;</div><div class="line">        mapmatrix[x][y] = 1;</div><div class="line">        int idx_demension_one = x*n+y;</div><div class="line">        UnionFindset.add(idx_demension_one,idx_demension_one);//加入并查集</div><div class="line">        count++;</div><div class="line">        for(int j = 0 ; j &lt; 4;j++)&#123;</div><div class="line">            //相邻元素的坐标</div><div class="line">            int x_neighbor = x+x_add[j];</div><div class="line">            int y_neighbor = y+y_add[j];</div><div class="line">            int idx_demension_one_neighbor = x_neighbor*n+y_neighbor;</div><div class="line">            //如果相邻元素还在地图中，而且是陆地（val=1）</div><div class="line">            if(x_neighbor&gt;=0 &amp;&amp; x_neighbor&lt;m &amp;&amp; y_neighbor&gt;=0 &amp;&amp; y_neighbor&lt;n &amp;&amp; mapmatrix[x_neighbor][y_neighbor]==1 &amp;&amp; UnionFindset.findfather(idx_demension_one) != UnionFindset.findfather(idx_demension_one_neighbor))&#123;</div><div class="line">                UnionFindset.unionset(idx_demension_one,idx_demension_one_neighbor);</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        results.push_back(count);</div><div class="line">    &#125;</div><div class="line">    return results;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h3 id="leetcode261-Graph-Valid-Tree"><a href="#leetcode261-Graph-Valid-Tree" class="headerlink" title="leetcode261. Graph Valid Tree"></a>leetcode261. Graph Valid Tree</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p><p>For example:</p><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.</p><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.</p><p><strong>Note</strong>: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code>and thus will not appear together in <code>edges</code>.</p></blockquote><p>给定n个节点和节点之间的边集，判断由这些节点和边集是否能够构成树。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>给定n个几点和边集构成树的条件有两个：</p><ol><li>所有的点都在一个并查集中，也就是都属于一个root节点</li><li>不能有环</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        <span class="keyword">int</span> start_fa = UnionFindgraph.findfather(start);</div><div class="line">        <span class="keyword">int</span> end_fa = UnionFindgraph.findfather(end);</div><div class="line">        <span class="keyword">if</span>(start_fa == end_fa)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            UnionFindgraph.unionset(start_fa,end_fa);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(UnionFindgraph.countsets()==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph"><a href="#leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph" class="headerlink" title="leetcode323. Number of Connected Components in an Undirected Graph"></a>leetcode323. Number of Connected Components in an Undirected Graph</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0          3</div><div class="line">&gt;      |          |</div><div class="line">&gt;      1 --- 2    4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, return <code>2</code>.</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0           4</div><div class="line">&gt;      |           |</div><div class="line">&gt;      1 --- 2 --- 3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</code>, return <code>1</code>.</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>判断矩阵中联通子图图的个数，遍历边集，将边首尾节点合并，最终的并查集boss数就是联通子图的个数。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        UnionFindgraph.unionset(start,end);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> UnionFindgraph.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="leetcode130-Surrounded-Regions"><a href="#leetcode130-Surrounded-Regions" class="headerlink" title="leetcode130. Surrounded Regions"></a>leetcode130. Surrounded Regions</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the <strong>letter</strong> O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p><p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X O O X</div><div class="line">&gt; X X O X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>After running your function, the board should be:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>将被X围住的O标记为X。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>通过分析可知，就是要将所有以O组成、但没有连通到网格边缘的区域变为X。</p><ol><li>BFS/DFS：沿着四个边向内找O，找到每一个O就把相连的都变成N，因为 他们都是要保留的，最后遍历二维数组，遇到O变成X，遇到N变回O</li><li>并查集：将区域内的O合并，组成集合，如果有元素在边界，就将该集合的father设为N，最后遍历所有的0，如果其father为N，就标记为O，否则标记为X。</li></ol><p>显然，1会比较快，下面使用BFS实现的.</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>&#123;</div><div class="line">    <span class="comment">// if(x&lt;0 || x &gt;= rows || y&lt;0 || y &gt;= cols || board[x][y]=='X')&#123;</span></div><div class="line">    <span class="comment">//     return;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; board[x][y]==<span class="string">'O'</span>)&#123;</div><div class="line">        board[x][y]=<span class="string">'N'</span>;</div><div class="line">        dfs(board,x<span class="number">-1</span>,y,rows,cols);</div><div class="line">        dfs(board,x+<span class="number">1</span>,y,rows,cols);</div><div class="line">        dfs(board,x,y<span class="number">-1</span>,rows,cols);</div><div class="line">        dfs(board,x,y+<span class="number">1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> rows = board.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//上下边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">        dfs(board,<span class="number">0</span>,i,rows,cols);</div><div class="line">        dfs(board,rows<span class="number">-1</span>,i,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//左右边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        dfs(board,i,<span class="number">0</span>,rows,cols);</div><div class="line">        dfs(board,i,cols<span class="number">-1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'N'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'O'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'X'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么时候用并查集？</p><ul><li>集合合并</li><li>判断两个点是否在同一个集合内</li></ul><h1 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h1><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p><p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p><h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container"><table><thead><tr><th></th><th>hash_table</th><th>TIRE树</th></tr></thead><tbody><tr><td>查找时间复杂度</td><td>O(1)</td><td>O(1)</td></tr><tr><td>空间复杂度</td><td></td><td>优于hash_table</td></tr></tbody></table></div><p>对于a,aa,aaa,aaaa的情况</p><div class="table-container"><table><thead><tr><th></th><th>hash</th><th>trie</th></tr></thead><tbody><tr><td>存储</td><td>10个a</td><td>5个a节点</td></tr><tr><td>可用操作</td><td>有/无/查询</td><td>有/无/前缀查询</td></tr><tr><td></td><td>1行</td><td>75~100行</td></tr></tbody></table></div><p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p><h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p><p>需要节约空间</p><p>查找前缀</p><h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>例题：</p><p>Word search II</p><h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://stomachache007.wordpress.com/2017/10/23/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E9%AB%98%E7%BA%A7%E7%8F%AD%E7%AC%94%E8%AE%B02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/" target="_blank" rel="external">stomachache007的blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Union-Find并查集&quot;&gt;&lt;a href=&quot;#Union-Find并查集&quot; class=&quot;headerlink&quot; title=&quot;Union Find并查集&quot;&gt;&lt;/a&gt;Union Find并查集&lt;/h1&gt;&lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="UnionFind" scheme="http://yoursite.com/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班习题集】</title>
    <link href="http://yoursite.com/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E4%B9%A0%E9%A2%98%E9%9B%86%E3%80%91/"/>
    <id>http://yoursite.com/2017/11/05/【九章算法强化班习题集】/</id>
    <published>2017-11-05T06:54:00.000Z</published>
    <updated>2017-11-05T07:00:42.265Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 请输入文章密码！ "/> <label for="pass"> 请输入文章密码！ </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      私密文章！
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>c++中struct的一些操作</title>
    <link href="http://yoursite.com/2017/11/04/c-%E4%B8%ADstruct%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/04/c-中struct的一些操作/</id>
    <published>2017-11-04T08:49:08.000Z</published>
    <updated>2017-11-04T08:49:08.612Z</updated>
    
    <content type="html"><![CDATA[<p>c++中class和struct的构造函数方式相同：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  Node()：x(<span class="number">0</span>),y(<span class="number">0</span>),z(<span class="number">0</span>)&#123;&#125;;<span class="comment">//无参构造函数</span></div><div class="line">  Node(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k):x(i),y(j),val(k)&#123;&#125;<span class="comment">//有参构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;c++中class和struct的构造函数方式相同：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>c++STL中vector的一些操作</title>
    <link href="http://yoursite.com/2017/11/04/c-STL%E4%B8%ADvector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/04/c-STL中vector的一些操作/</id>
    <published>2017-11-04T08:36:41.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<p>记录c++STL中vector的一些操作</p><h2 id="指定长度vector声明"><a href="#指定长度vector声明" class="headerlink" title="指定长度vector声明"></a>指定长度vector声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);<span class="comment">//长度为n</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n,t);<span class="comment">//长度为n,值为t</span></div></pre></td></tr></table></figure><h2 id="指定长度二维vector声明"><a href="#指定长度二维vector声明" class="headerlink" title="指定长度二维vector声明"></a>指定长度二维vector声明</h2><p>声明一个<script type="math/tex">m*n</script>维的矩阵：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//所有元素都是0</span></div></pre></td></tr></table></figure><h2 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line">sort(vec.begin(),vec.end());</div></pre></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>resize()可以用来重新定义vector的大小，也可以用在声明数组时指定数组的长度</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;<span class="comment">//重定义vector的长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, value_type val)</span></span>;<span class="comment">//重定义vector的长度和数值</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录c++STL中vector的一些操作&lt;/p&gt;
&lt;h2 id=&quot;指定长度vector声明&quot;&gt;&lt;a href=&quot;#指定长度vector声明&quot; class=&quot;headerlink&quot; title=&quot;指定长度vector声明&quot;&gt;&lt;/a&gt;指定长度vector声明&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vetcor" scheme="http://yoursite.com/tags/vetcor/"/>
    
  </entry>
  
  <entry>
    <title>回溯法、【leetcode】51.52 N-Queens</title>
    <link href="http://yoursite.com/2017/11/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E3%80%90leetcode%E3%80%9151-52-N-Queens/"/>
    <id>http://yoursite.com/2017/11/04/回溯法、【leetcode】51-52-N-Queens/</id>
    <published>2017-11-04T08:35:06.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h2><p>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。<br>如果用爬山来比喻：<br>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。<br>第二点脑子是回溯知道剪枝；如果有一条岔路走不通，那这条路我们不走，就可以少走很多不必要走的路。</p><h2 id="识别回溯问题"><a href="#识别回溯问题" class="headerlink" title="识别回溯问题"></a>识别回溯问题</h2><p>判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。<br>一般回溯的问题有三种：</p><ol><li>Find a path to success 有没有解</li><li>Find all paths to success 求所有解</li></ol><ul><li>求所有解的个数</li><li>求所有解的具体信息</li></ul><ol><li>Find the best path to success 求最优解</li></ol><p>还有一些爱混淆的概念：递归，回溯，DFS。<br>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。<br>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。在树和图上回溯时人们叫它DFS。<br>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</p><p>关于回溯的三种问题，模板略有不同，<br>第一种，返回值是true/false。<br>第二种，求个数，设全局counter，返回值是void；求所有解信息，设result，返回值void。<br>第三种，设个全局变量best，返回值是void。</p><h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>第一种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">boolean solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, return true</div><div class="line">        else return false</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            if solve(c) succeeds, return true</div><div class="line">        &#125;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, count++, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第三种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, update best result, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>八皇后问题是大数学家高斯于1850年提出来的。该问题是在8×8的国际象棋棋盘上放置8个皇后，使得没有一个皇后能“吃掉”任何其他一个皇后，即没有任何两个皇后被放置在棋盘的同一行、同一列或同一斜线上。</p><p>扩展到一般情况就是：在n*n的棋盘上放置n和棋子，使得没有任何两个棋子在同一行、同一列或同一对角线上</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了更好的理解回溯法，把这个问题分解成三个子问题：</p><ol><li>是否有这样的安放方法，满足游戏规则</li><li>如果有，有多少个安放方式[leetcode 52]</li><li>输出所有的安放方式[leetcode 51]</li></ol><p>因为任何两个皇后不可能在同一行，所以我们可以采用如下的策略：<br><strong>一行一行地安放皇后，每次放置皇后时需要确保此次放置的皇后跟之前已经放置的皇后没有处于同行、同列、同对角线上</strong></p><p>需要下面两个函数：</p><ol><li>递归调用安放皇后（回溯法）<br>逐个遍历可以安放皇后的位置，并递归调用取定下一层可以安放皇后的位置。直到最后一行的元素存在合法的放置位置，说明这是一种合理的安放情况。</li></ol><ol><li>判断在某一点放queen是否合法</li></ol><p>因为是一行一行放，所以可以保证不在一行上，需要判断同一列是否已经有皇后，以及左上方和右上方对角线方向是否已经有皇后。</p><p>另外还需要一个额外的空间标记当前皇后们安放的位置</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>三个子问题的函数2，判断某一点是否可以放置皇后的函数一样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断是否可以放置</div><div class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">    //判断左上方对角线是否有皇后</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==1)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断右上方对角线是否有皇后</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==1)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==1)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code>是用来存放当前棋盘上放置的皇后位置。</p><p>差别在于回溯函数：</p><h4 id="1-是否存在"><a href="#1-是否存在" class="headerlink" title="1. 是否存在"></a>1. 是否存在</h4><p>只需要找到一个满足条件的放置方案即可，逐行放置皇后，遇到不满足条件的情况就回退到上一层，继续寻找</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//递归调用，判断皇后放置字当前点之后是否存在合法路径</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一行，安放最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//如果存在合法安放情况，返回true</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//该点合理，将皇后放到该点，递归调用，判断下一层是否存在合法方案</div><div class="line">                vec[k][i]=1;//房子皇后，标记皇后位置</div><div class="line">                if (solve(vec,n,k+1,i))//下一层存在合法方案。返回true 否则回退，将皇后从该点移除</div><div class="line">                    return true;</div><div class="line">                vec[k][i]=0;//取消皇后位置标记</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool ifNQueens(int n) &#123;</div><div class="line">    if(n==1)</div><div class="line">        return true;</div><div class="line">    if(n&lt;4)</div><div class="line">        return false</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));//存储当前棋盘皇后位置</div><div class="line">    //遍历首行放置皇后</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        if(solve(vec,n,1,i))//找到一条合法放置方式，返回true</div><div class="line">            return true</div><div class="line">        vec[0][i]=0;//否则恢复该点未被选中的棋盘，继续遍历下一个点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-存在多少种安放方式-leetcode-51"><a href="#2-存在多少种安放方式-leetcode-51" class="headerlink" title="2. 存在多少种安放方式 [leetcode] 51"></a>2. 存在多少种安放方式 [leetcode] 51</h4><p>在上面存在的基础之上，引入一个count计数变量，记录合法方案的数量，也就是没找到一个合法的安放方式就+1，知道遍历完所有的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l,int&amp; count)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//找到合法方案，计数变量+1</div><div class="line">                count++;break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=1;</div><div class="line">                solve(vec,n,k+1,i,count);</div><div class="line">                vec[k][i]=0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int totalNQueens(int n) &#123;</div><div class="line">    if(n&lt;2)</div><div class="line">        return n;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));</div><div class="line">    int count = 0;//新增计数变量</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        solve(vec,n,1,i,count);</div><div class="line">        vec[0][i]=0;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-输出所有的安放方式-leetcode-51"><a href="#3-输出所有的安放方式-leetcode-51" class="headerlink" title="3.输出所有的安放方式 [leetcode] 51"></a>3.输出所有的安放方式 [leetcode] 51</h4><p>这次需要我们将所有合法的安放方式都输出，也就当找到一条合法安放方式时，就把当前的皇后放置情况输出到结果集。</p><p>另外根据题目输出结果格式要求：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line"> [&quot;.Q..&quot;,  // Solution 1</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;..Q.&quot;],</div><div class="line"></div><div class="line"> [&quot;..Q.&quot;,  // Solution 2</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;.Q..&quot;]</div><div class="line">]</div></pre></td></tr></table></figure><p>对保存安放情况的变量类型作出修改：由原来的<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code> 变为<code>vector&lt;string&gt;&amp; vec</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断该位置是否可以放置</div><div class="line">bool isvalid(vector&lt;string&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">     //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    //判断对角是否已经有元素</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void solve(vector&lt;string&gt;&amp; vec,int n,int k,int l,vector&lt;vector&lt;string&gt;&gt;&amp; res)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=&apos;Q&apos;;</div><div class="line">                res.push_back(vec);//存在合法方案，保存到结果集</div><div class="line">                vec[k][i]=&apos;.&apos;;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=&apos;Q&apos;;</div><div class="line">                solve(vec,n,k+1,i,res);</div><div class="line">                vec[k][i]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">    if(n==1)&#123;</div><div class="line">        vector&lt;string&gt; vv = &#123;&quot;Q&quot;&#125;;</div><div class="line">        res.push_back(vv);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    if(n&lt;4)</div><div class="line">        return res;</div><div class="line">    vector&lt;string&gt; vec(n,string(n,&apos;.&apos;));//用以记录结果</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=&apos;Q&apos;;</div><div class="line">        solve(vec,n,1,i,res);</div><div class="line">        vec[0][i]=&apos;.&apos;;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006121957" target="_blank" rel="external">liuqi627的博客</a><br><a href="http://www.jianshu.com/p/8f3b8df612ae" target="_blank" rel="external">Jason_Yuan的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是回溯&quot;&gt;&lt;a href=&quot;#什么是回溯&quot; class=&quot;headerlink&quot; title=&quot;什么是回溯&quot;&gt;&lt;/a&gt;什么是回溯&lt;/h2&gt;&lt;p&gt;回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++STL中堆的使用</title>
    <link href="http://yoursite.com/2017/11/04/c-STL%E4%B8%AD%E5%A0%86%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/04/c-STL中堆的使用/</id>
    <published>2017-11-04T03:18:38.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：priority-queue"><a href="#方法一：priority-queue" class="headerlink" title="方法一：priority_queue"></a>方法一：priority_queue</h2><p>这种方法需要<code>#include&lt;queue&gt;</code></p><p>最基本的使用方法，对于一串数字建堆：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">riority_queue&lt;<span class="keyword">int</span>&gt; heap;</div></pre></td></tr></table></figure><p>这种情况下默认为最大堆，也就是堆顶元素值最大。</p><p>如果需要建立最小堆，可以采用如下方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最小堆</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最大堆</span></div></pre></td></tr></table></figure><p>然而在多数情况下，我们还需要记录一些排序元素的额外信息，比如索引之类的，则需要以下三个步骤：</p><ol><li><p>定义堆中需要存储的结构体：</p><p>​</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line">Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​</p></li><li><p>确定堆中元素的存储顺序，也就是最大堆还是最小堆</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置比较函数，确定堆中元素的顺序，是最大堆还是最小堆，</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> a.val&gt;b.val;<span class="comment">//最小堆</span></div><div class="line">      <span class="comment">//return a.val&lt;b.val;//最大堆</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​</p></li><li><p>建堆</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; heap;<span class="comment">//建堆</span></div><div class="line">heap.pop();<span class="comment">//出堆</span></div><div class="line">heap.push();<span class="comment">//入堆</span></div><div class="line">heap.top();<span class="comment">//获取堆顶元素</span></div></pre></td></tr></table></figure></li></ol><h2 id="方法二：利用vector"><a href="#方法二：利用vector" class="headerlink" title="方法二：利用vector"></a>方法二：利用vector</h2><p>这种法法需要<code>#include&lt;algorithm&gt;</code> <code>#include &lt;functional&gt;</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</div><div class="line"><span class="comment">//建堆</span></div><div class="line">make_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大堆</span></div><div class="line">make_heap(a.begin(),a.end(), greater&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小堆</span></div><div class="line"><span class="comment">//pop</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大值出堆</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小值出堆</span></div><div class="line"><span class="comment">//插入元素</span></div><div class="line">push_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">//堆排序</span></div><div class="line">sort_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">// push_heap ( begin , end )   将最后一个元素插入堆中（堆自动调整）</span></div><div class="line"><span class="comment">// pop_heap ( begin , end )   将第一个元素从堆中删去（堆自动调整），并放到最后</span></div><div class="line"><span class="comment">// find ( begin , end , value ) 从begin到end查找value，若找不到，返回end</span></div></pre></td></tr></table></figure><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一：priority-queue&quot;&gt;&lt;a href=&quot;#方法一：priority-queue&quot; class=&quot;headerlink&quot; title=&quot;方法一：priority_queue&quot;&gt;&lt;/a&gt;方法一：priority_queue&lt;/h2&gt;&lt;p&gt;这种方法需要
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记1</title>
    <link href="http://yoursite.com/2017/11/04/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2017/11/04/九章算法强化班课程笔记1/</id>
    <published>2017-11-04T03:05:07.000Z</published>
    <updated>2017-11-05T06:54:43.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p><ol><li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li><li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li><li>Kth Largest in N Arrays</li></ol><h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p></blockquote><p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p><p><strong>example</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p><p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p><p>看了leetcode题解，有二分查找的方式更快。</p><p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p><ul><li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li><li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li><li>直到min和max回合，此时就找到了第k个元素。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p><p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p><p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p></blockquote><p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>7</th><th>11</th></tr></thead><tbody><tr><td>2</td><td>2+1=3</td><td>2+7=9</td><td>2+11=13</td></tr><tr><td>4</td><td>4+1=5</td><td>4+7=11</td><td>4+11=15</td></tr><tr><td>6</td><td>6+1=7</td><td>6+7=13</td><td>6+11=17</td></tr></tbody></table></div><p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定N个无序数组，从中找出第k大的元素</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p><ol><li>将N个数组中的最大值入堆</li><li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li><li>循环k次，找到第k大的元素</li></ol><p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       <span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li><li>见到第k小，想到用堆维护候选集合，出堆k次</li><li>见到数组要往排序上面想，先排序，然后再其他操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求数组-矩阵的第k大元素&quot;&gt;&lt;a href=&quot;#求数组-矩阵的第k大元素&quot; class=&quot;headerlink&quot; title=&quot;求数组/矩阵的第k大元素&quot;&gt;&lt;/a&gt;求数组/矩阵的第k大元素&lt;/h1&gt;&lt;p&gt;涉及leetcode题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="九章算法" scheme="http://yoursite.com/tags/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2</title>
    <link href="http://yoursite.com/2017/11/04/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2017/11/04/【九章算法强化班】课程笔记1/</id>
    <published>2017-11-04T03:05:07.000Z</published>
    <updated>2017-11-04T08:47:16.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p><ol><li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li><li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li><li>Kth Largest in N Arrays</li></ol><h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p></blockquote><p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p><p><strong>example</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p><p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p><p>看了leetcode题解，有二分查找的方式更快。</p><p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p><ul><li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li><li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li><li>直到min和max回合，此时就找到了第k个元素。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p><p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p><p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p></blockquote><p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>7</th><th>11</th></tr></thead><tbody><tr><td>2</td><td>2+1=3</td><td>2+7=9</td><td>2+11=13</td></tr><tr><td>4</td><td>4+1=5</td><td>4+7=11</td><td>4+11=15</td></tr><tr><td>6</td><td>6+1=7</td><td>6+7=13</td><td>6+11=17</td></tr></tbody></table></div><p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定N个无序数组，从中找出第k大的元素</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p><ol><li>将N个数组中的最大值入堆</li><li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li><li>循环k次，找到第k大的元素</li></ol><p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       <span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li><li>见到第k小，想到用堆维护候选集合，出堆k次</li><li>见到数组要往排序上面想，先排序，然后再其他操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求数组-矩阵的第k大元素&quot;&gt;&lt;a href=&quot;#求数组-矩阵的第k大元素&quot; class=&quot;headerlink&quot; title=&quot;求数组/矩阵的第k大元素&quot;&gt;&lt;/a&gt;求数组/矩阵的第k大元素&lt;/h1&gt;&lt;p&gt;涉及leetcode题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="九章算法" scheme="http://yoursite.com/tags/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>DSP国内硕士论文总结</title>
    <link href="http://yoursite.com/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/11/02/DSP国内硕士论文总结/</id>
    <published>2017-11-02T09:01:51.000Z</published>
    <updated>2017-11-15T12:57:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>准备开题，先看一下国内的相关硕士学位论文，知网上down的。</p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><ul><li><p><strong>大数据平台下的互联网广告点击率预估模型</strong></p><p>基于腾讯社交广告数据集，hive+hadoop环境下实现GBDT+FM分布式点击率预估，用到贝叶斯平滑等，竞赛在分布式环境下的扩展。</p></li></ul><ul><li>​</li></ul><h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><ul><li><p><strong>针对在线广告实时竞价系统的相关算法研究、电子科大、郭威</strong></p><p>将竞价策略总结为预算控制和估价算法两个步骤，提出一种<strong>预算步进（buget pacing）算法和一个出价模型</strong></p><p>数据集：iPinyou</p><p>2.2介绍计算广告核心问题和<strong>结算方式</strong></p><p>核心问题：广告主、用户、媒体三方博弈，涉及信息检索、机器学习、最优化三个领域。</p><p><strong>结算方式以及适用场景：CPT-&gt;CPM-&gt;CPC-&gt;eCPM</strong> 这里总结的很好</p><p>第3章点击率预估：LR\GBDT \FM\在线算法online SGD，FTRL数据集Criteo</p><p>第4章设计了一个 <strong>buget pacing(预算步进)</strong> 策略</p><p>第5章竞价算法设计：DSP策略中的关键技术图</p><p>这个问题通常是一个约束最优化问题，约束是广告主一天的广告预算，最优某个性能指标，如点击数或转化数。</p></li></ul><h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><ul><li><p><strong>在线广告 DSP 平台实时竞价算法的研究与实现 、上海交通、韩静</strong></p><p>主要研究实时竞价算法，点击率预估和竞价策略。</p><p>ctr预估：LR和GBDT。</p><p>竞价策略：提出固定竞价、分组竞价（M6D）、综合竞价（非线性竞价）三种策略，进行数学推导</p><p>数据集：iPinyou，评价指标KPI</p><p><strong>利用这份数据集做实验的流程</strong> （第四章）：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-02-19-39-45.png" alt=""> </p></li></ul><ul><li><p><strong>广告点击率预估的深层神经网络模型研究</strong> 北邮 王孝舒</p><p>Criteo竞赛数据</p><p>baseline：LR</p><p>优化：DNN，分别选取sigmod和Relu作为激活函数进行实验</p></li><li><p>互联网广告精准投放平台设计与实现 成都理工 葛泽泽</p><p>基于hadoop、hive实现DSP平台</p><p><strong>国内外发展情况可参考</strong></p></li><li><p>基于流式计算的广告特征提取系统的设计与实现 钟晓诚 南京大学</p><p>做的是搜索广告的</p><p>流式广告特征提取系统，实时处理广告数据，不断训练、更新ctr预估模型，基于百度开发的流式计算框架Task Manager，集合HDFS\MapReduce</p><p>可以将广告特征数据反映到线上模型的时间缩短至分钟级</p><p>​</p></li><li><p>基于逻辑回归的在线广告ctr优化和预测 浙江大学 代成雷</p><p>用了LR和FTRL进行ctr预估</p></li><li><p>基于深度学习的搜索广告点击率预测方法研究 哈工大 李思琴</p><p>GPU、深度学习CTR预估与贝叶斯分类、LR、svm对比</p><p><strong>卷积神经网络</strong></p><p>KDD2012数据集</p><p>特征用到w2v</p><p>评估：AUC</p><p>​</p></li><li><p>在线广告中实时竞价机制研究与算法实现 华中师范 朱丽辉</p><p>当竞价较低时，提升竞价能大幅增加赢得竞价的概率；当竞价较高时，降低竞价对赢得竞价的概率影响不大。提出了预算再分配模型，将竞价空间分成不同的区间，将预算消耗在最优价格区间。结合上述两点给出了一个基于动态点击率预估的分段竞价算法，很好地解决了小广告主的利益问题。</p><p>本文提出了一个＂预算再分配＂的竞价策略：将广告主的整个竞价空间按照价格的高低划分为三个区间Ｐｉ，Ｐ２，Ｐ３，当估价在ＰＩ，Ｐ３的时候，对其进行相应的降价措施，当估价在Ｐ２的时候对其进行提价操作。</p><p>核心思想：当广告主的预算在非常有限的情况下，应该放弃那些过高的竞价以及没意义的竞价（估价过低），将预算尽量分配在适当的竞价范围。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-16-22-39-56.png" alt=""> </p><p>数据集：ipinyou</p></li><li><p>​</p></li></ul><h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><ul><li><p>互联网广告精准投放平台研究 华中师范 李志</p><p>实现了一个DSP平台</p><p>用贝叶斯分类，对用户特征进行分类</p><p><strong>背景写的很好，有国内外DSP产品比较</strong></p><p><strong>平台设计和流程需要参考</strong></p><p>​</p></li><li><p>​</p></li></ul><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备开题，先看一下国内的相关硕士学位论文，知网上down的。&lt;/p&gt;
&lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;大数据平台下的
      
    
    </summary>
    
      <category term="DSP" scheme="http://yoursite.com/categories/DSP/"/>
    
    
      <category term="DSP" scheme="http://yoursite.com/tags/DSP/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2017/11/02/test-1/"/>
    <id>http://yoursite.com/2017/11/02/test-1/</id>
    <published>2017-11-02T06:12:42.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hive中静态分区和动态分区</title>
    <link href="http://yoursite.com/2017/11/02/Hive%E4%B8%AD%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2017/11/02/Hive中静态分区和动态分区/</id>
    <published>2017-11-02T01:36:01.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对应列的值自动分区写入，如果该列值对应的分区目录还没有创建， 会自动创建并写入数据。</p><h2 id="静态分区"><a href="#静态分区" class="headerlink" title="静态分区"></a>静态分区</h2><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>create table zhangsiyao.dt_0802_0815 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>load data local inpath ‘/home/warehouse/user.txt’ overwrite into table teacher partition(work_date=”2016-07-12”);</p><p>需要按照分区一个分区一个分区导入数据</p><h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><h3 id="创建分区表（和静态分区一样）"><a href="#创建分区表（和静态分区一样）" class="headerlink" title="创建分区表（和静态分区一样）"></a>创建分区表（和静态分区一样）</h3><p>create table zhangsiyao.dt_0811_0820 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="创建数据表（中间数据）"><a href="#创建数据表（中间数据）" class="headerlink" title="创建数据表（中间数据）"></a>创建数据表（中间数据）</h3><p>create table zhangsiyao.data_analy_11_20 as select a.itime,a.uid,a.gid,a.app_ver,a.unet ,a.device_type,a.device_os,a.client_type,a.crtv_id,a.country,a.province,a.city,a.isp,a.ad_location,a.ad_status,a.dt,b.age_gt,b.sex_gt,b.income_gt,b.marital_status_gt,c.sponsor_id,c.creative_name,c.creative_title,c.creative_abstract,c.category_id,c.create_time,c.update_time from (select <em> from ad.wireless_ad_org_final where dt&gt;’2017-08-10’ and crtv_id &lt;&gt;-1) a left join (select </em> from user_portraint.focus_user_portraint_profile where dt&gt;’2017-08-10’) b on (a.dt=b.dt and a.client_type=b.client_type and a.uid=b.uid) left join (select * from ad.ad_creative_ods where dt&gt;’2017-08-10’) c on (a.dt=b.dt and a.crtv_id=c.creative_id);</p><h3 id="设置动态分区"><a href="#设置动态分区" class="headerlink" title="设置动态分区"></a>设置动态分区</h3><p>set hive.exec.dynamic.partition=true;(可通过这个语句查看：set hive.exec.dynamic.partition;)<br>set hive.exec.dynamic.partition.mode=nonstrict; （strict要求至少有一个静态分区， nonstrict可以都是动态分区）<br>set hive.exec.max.dynamic.partitions=100000;(如果自动分区数大于这个参数，将会报错)<br>set hive.exec.max.dynamic.partitions.pernode=100000;</p><h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><p>insert overwrite table zhangsiyao.dt_0811_0820 partition(dt) select itime,uid,gid,app_ver,unet,device_type,device_os,client_type,crtv_id,country,province,city,isp,ad_location,ad_status,age_gt,sex_gt,income_gt,marital_status_gt,sponsor_id,creative_name,creative_title,creative_abstract,category_id,create_time,update_time,dt from zhangsiyao.data_analy_11_20 where dt&lt;’2017-08-21’;</p><p><strong>这里需要注意的是，用select选择数据导入动态分区时，要把关键字放在最后面，因为动态分区默认以最后一个关键字作为分区关键字</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;差别&quot;&gt;&lt;a href=&quot;#差别&quot; class=&quot;headerlink&quot; title=&quot;差别&quot;&gt;&lt;/a&gt;差别&lt;/h2&gt;&lt;p&gt;两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>利用Hive中percentile_approx计算等频划分分位点</title>
    <link href="http://yoursite.com/2017/11/02/%E5%88%A9%E7%94%A8Hive%E4%B8%ADpercentile-approx%E8%AE%A1%E7%AE%97%E7%AD%89%E9%A2%91%E5%88%92%E5%88%86%E5%88%86%E4%BD%8D%E7%82%B9/"/>
    <id>http://yoursite.com/2017/11/02/利用Hive中percentile-approx计算等频划分分位点/</id>
    <published>2017-11-02T01:34:39.000Z</published>
    <updated>2017-11-04T08:47:16.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等频划分"><a href="#等频划分" class="headerlink" title="等频划分"></a>等频划分</h2><p>等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间</p><p>等比划分：按照数据的全部取值情况，平均划分成k个区间</p><h2 id="Hive-中计算分位数的函数：percentile-approx"><a href="#Hive-中计算分位数的函数：percentile-approx" class="headerlink" title="Hive 中计算分位数的函数：percentile_approx"></a>Hive 中计算分位数的函数：<code>percentile_approx</code></h2><p>hive 中的<code>percentile_approx</code>函数可以确定等频划分的分位点<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">percentile_approx(col,array(0.2,0.4,0.6,0.8))</div><div class="line">[0.0,4001.0,4061.0]</div></pre></td></tr></table></figure></p><p>其中col为要划分的列，array中的数字代表划分的位置，比如(0.2,0.4,0.6,0.8)就是钱20%数量的样本被分到一个区间，然后20%-40%的样本被分到一个区间….</p><p>返回值是一个array</p><p>如果希望变成一列，可以用<code>explode</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explode(percentile_approx(cast(col as double),array(0.05,0.5,0.95),9999))as percentile</div><div class="line"></div><div class="line">percentile</div><div class="line">0.0</div><div class="line">4001.1</div><div class="line">4061.0</div></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table zhangsiyao.percentile_of_dt_fea_0818_0820_2 as select explode(percentile_approx(adloc_age_sex_ctr,array(0.25,0.5,0.75))) as adloc_age_sex_ctr_percentile,explode(percentile_approx(adloc_income_ctr,array(0.25,0.5,0.75))) as adloc_income_ctr_percentile,explode(percentile_approx(adloc_marry_ctr,array(0.25,0.5,0.75))) as adloc_marry_ctr_percentile,explode(percentile_approx(adloc_province_ctr,array(0.25,0.5,0.75))) as adloc_province_ctr_percentile,explode(percentile_approx(adloc_clinttype_ctr,array(0.25,0.5,0.75))) as adloc_clinttype_ctr_percentile,explode(percentile_approx(adloc_sponsorid_ctr,array(0.25,0.5,0.75))) as adloc_sponsorid_ctr_percentile,explode(percentile_approx(adloc_categoryid_ctr,array(0.25,0.5,0.75))) as adloc_categoryid_ctr_percentile,explode(percentile_approx(adloc_crtvid_ctr,array(0.25,0.5,0.75))) as adloc_crtvid_ctr_percentile,explode(percentile_approx(adloc_unet_ctr,array(0.25,0.5,0.75))) as adloc_unet_ctr_percentile,explode(percentile_approx(adloc_isp_ctr,array(0.25,0.5,0.75))) as adloc_isp_ctr_percentile,explode(percentile_approx(adloc_appver_ctr,array(0.25,0.5,0.75))) as adloc_appver_ctr_percentile,explode(percentile_approx(adloc_devicetype_ctr ,adloc_deviceos_ctr,array(0.25,0.5,0.75))) as adloc_devicetype_ctr ,adloc_deviceos_ctr_percentile,explode(percentile_approx(age_province_ctr,array(0.25,0.5,0.75))) as age_province_ctr_percentile,explode(percentile_approx(age_marry_ctr,array(0.25,0.5,0.75))) as age_marry_ctr_percentile,explode(percentile_approx(age_categoryid_ctr,array(0.25,0.5,0.75))) as age_categoryid_ctr_percentile,explode(percentile_approx(age_crtvid_ctr,array(0.25,0.5,0.75))) as age_crtvid_ctr_percentile,explode(percentile_approx(sex_marry_ctr,array(0.25,0.5,0.75))) as sex_marry_ctr_percentile,explode(percentile_approx(sex_categoryid_ctr,array(0.25,0.5,0.75))) as sex_categoryid_ctr_percentile,explode(percentile_approx(income_categoryid_ctr,array(0.25,0.5,0.75))) as income_categoryid_ctr_percentile,explode(percentile_approx(income_crtvid_ctr,array(0.25,0.5,0.75))) as income_crtvid_ctr_percentile,explode(percentile_approx(marry_categoryid_ctr,array(0.25,0.5,0.75))) as marry_categoryid_ctr_percentile,explode(percentile_approx(marry_crtvid_ctr,sponsorid_unet_ctr,array(0.25,0.5,0.75))) as marry_crtvid_ctr,sponsorid_unet_ctr_percentile from zhangsiyao.dt_fea_0818_0820;</div></pre></td></tr></table></figure><p>由此就找到了将特征等频划分的分位点，可以按照得到的分位点队连续型特征进行分桶操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;等频划分&quot;&gt;&lt;a href=&quot;#等频划分&quot; class=&quot;headerlink&quot; title=&quot;等频划分&quot;&gt;&lt;/a&gt;等频划分&lt;/h2&gt;&lt;p&gt;等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间&lt;/p&gt;
&lt;p&gt;等比划分：按照数据的全部取值情况，平
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
</feed>
