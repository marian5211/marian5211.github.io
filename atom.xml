<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-02T09:01:51.925Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DSP国内硕士论文总结</title>
    <link href="http://yoursite.com/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/11/02/DSP国内硕士论文总结/</id>
    <published>2017-11-02T09:01:51.000Z</published>
    <updated>2017-11-02T09:01:51.925Z</updated>
    
    <content type="html"><![CDATA[<p>准备开题，先看一下国内的相关硕士学位论文，知网上down的。</p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><ul><li><p><strong>针对在线广告实时竞价系统的相关算法研究、电子科大、郭威</strong></p><p>将竞价策略总结为预算控制和股价算法两个步骤，提出一种<strong>预算步进算法和一个出价模型</strong></p><p>数据集：iPinyou</p><p>​</p></li></ul><ul><li>​</li></ul><h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><ul><li><p><strong>在线广告 DSP 平台实时竞价算法的研究与实现 、上海交通、韩静</strong></p><p>主要研究实时竞价算法，点击率预估和竞价策略。</p><p>ctr预估：LR和GBDT。</p><p>竞价策略：提出固定竞价、分组竞价（M6D）、综合竞价（非线性竞价）三种策略，进行数学推导</p><p>数据集：iPinyou，评价指标KPI</p><p><strong>利用这份数据集做实验的流程</strong> （第四章）：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-02-19-39-45.png" alt=""> </p></li></ul><ul><li>​</li></ul><h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备开题，先看一下国内的相关硕士学位论文，知网上down的。&lt;/p&gt;
&lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h2&gt;&lt;h2 id=&quot;2016&quot;&gt;&lt;a href=&quot;#201
      
    
    </summary>
    
      <category term="DSP" scheme="http://yoursite.com/categories/DSP/"/>
    
    
      <category term="DSP" scheme="http://yoursite.com/tags/DSP/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2017/11/02/test-1/"/>
    <id>http://yoursite.com/2017/11/02/test-1/</id>
    <published>2017-11-02T06:12:42.000Z</published>
    <updated>2017-11-02T06:12:42.806Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hive中静态分区和动态分区</title>
    <link href="http://yoursite.com/2017/11/02/Hive%E4%B8%AD%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2017/11/02/Hive中静态分区和动态分区/</id>
    <published>2017-11-02T01:36:01.000Z</published>
    <updated>2017-11-02T01:36:01.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对应列的值自动分区写入，如果该列值对应的分区目录还没有创建， 会自动创建并写入数据。</p><h2 id="静态分区"><a href="#静态分区" class="headerlink" title="静态分区"></a>静态分区</h2><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>create table zhangsiyao.dt_0802_0815 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>load data local inpath ‘/home/warehouse/user.txt’ overwrite into table teacher partition(work_date=”2016-07-12”);</p><p>需要按照分区一个分区一个分区导入数据</p><h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><h3 id="创建分区表（和静态分区一样）"><a href="#创建分区表（和静态分区一样）" class="headerlink" title="创建分区表（和静态分区一样）"></a>创建分区表（和静态分区一样）</h3><p>create table zhangsiyao.dt_0811_0820 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="创建数据表（中间数据）"><a href="#创建数据表（中间数据）" class="headerlink" title="创建数据表（中间数据）"></a>创建数据表（中间数据）</h3><p>create table zhangsiyao.data_analy_11_20 as select a.itime,a.uid,a.gid,a.app_ver,a.unet ,a.device_type,a.device_os,a.client_type,a.crtv_id,a.country,a.province,a.city,a.isp,a.ad_location,a.ad_status,a.dt,b.age_gt,b.sex_gt,b.income_gt,b.marital_status_gt,c.sponsor_id,c.creative_name,c.creative_title,c.creative_abstract,c.category_id,c.create_time,c.update_time from (select <em> from ad.wireless_ad_org_final where dt&gt;’2017-08-10’ and crtv_id &lt;&gt;-1) a left join (select </em> from user_portraint.focus_user_portraint_profile where dt&gt;’2017-08-10’) b on (a.dt=b.dt and a.client_type=b.client_type and a.uid=b.uid) left join (select * from ad.ad_creative_ods where dt&gt;’2017-08-10’) c on (a.dt=b.dt and a.crtv_id=c.creative_id);</p><h3 id="设置动态分区"><a href="#设置动态分区" class="headerlink" title="设置动态分区"></a>设置动态分区</h3><p>set hive.exec.dynamic.partition=true;(可通过这个语句查看：set hive.exec.dynamic.partition;)<br>set hive.exec.dynamic.partition.mode=nonstrict; （strict要求至少有一个静态分区， nonstrict可以都是动态分区）<br>set hive.exec.max.dynamic.partitions=100000;(如果自动分区数大于这个参数，将会报错)<br>set hive.exec.max.dynamic.partitions.pernode=100000;</p><h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><p>insert overwrite table zhangsiyao.dt_0811_0820 partition(dt) select itime,uid,gid,app_ver,unet,device_type,device_os,client_type,crtv_id,country,province,city,isp,ad_location,ad_status,age_gt,sex_gt,income_gt,marital_status_gt,sponsor_id,creative_name,creative_title,creative_abstract,category_id,create_time,update_time,dt from zhangsiyao.data_analy_11_20 where dt&lt;’2017-08-21’;</p><p><strong>这里需要注意的是，用select选择数据导入动态分区时，要把关键字放在最后面，因为动态分区默认以最后一个关键字作为分区关键字</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;差别&quot;&gt;&lt;a href=&quot;#差别&quot; class=&quot;headerlink&quot; title=&quot;差别&quot;&gt;&lt;/a&gt;差别&lt;/h2&gt;&lt;p&gt;两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>利用Hive中percentile_approx计算等频划分分位点</title>
    <link href="http://yoursite.com/2017/11/02/%E5%88%A9%E7%94%A8Hive%E4%B8%ADpercentile-approx%E8%AE%A1%E7%AE%97%E7%AD%89%E9%A2%91%E5%88%92%E5%88%86%E5%88%86%E4%BD%8D%E7%82%B9/"/>
    <id>http://yoursite.com/2017/11/02/利用Hive中percentile-approx计算等频划分分位点/</id>
    <published>2017-11-02T01:34:39.000Z</published>
    <updated>2017-11-02T01:34:39.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等频划分"><a href="#等频划分" class="headerlink" title="等频划分"></a>等频划分</h2><p>等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间</p><p>等比划分：按照数据的全部取值情况，平均划分成k个区间</p><h2 id="Hive-中计算分位数的函数：percentile-approx"><a href="#Hive-中计算分位数的函数：percentile-approx" class="headerlink" title="Hive 中计算分位数的函数：percentile_approx"></a>Hive 中计算分位数的函数：<code>percentile_approx</code></h2><p>hive 中的<code>percentile_approx</code>函数可以确定等频划分的分位点<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">percentile_approx(col,array(0.2,0.4,0.6,0.8))</div><div class="line">[0.0,4001.0,4061.0]</div></pre></td></tr></table></figure></p><p>其中col为要划分的列，array中的数字代表划分的位置，比如(0.2,0.4,0.6,0.8)就是钱20%数量的样本被分到一个区间，然后20%-40%的样本被分到一个区间….</p><p>返回值是一个array</p><p>如果希望变成一列，可以用<code>explode</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explode(percentile_approx(cast(col as double),array(0.05,0.5,0.95),9999))as percentile</div><div class="line"></div><div class="line">percentile</div><div class="line">0.0</div><div class="line">4001.1</div><div class="line">4061.0</div></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table zhangsiyao.percentile_of_dt_fea_0818_0820_2 as select explode(percentile_approx(adloc_age_sex_ctr,array(0.25,0.5,0.75))) as adloc_age_sex_ctr_percentile,explode(percentile_approx(adloc_income_ctr,array(0.25,0.5,0.75))) as adloc_income_ctr_percentile,explode(percentile_approx(adloc_marry_ctr,array(0.25,0.5,0.75))) as adloc_marry_ctr_percentile,explode(percentile_approx(adloc_province_ctr,array(0.25,0.5,0.75))) as adloc_province_ctr_percentile,explode(percentile_approx(adloc_clinttype_ctr,array(0.25,0.5,0.75))) as adloc_clinttype_ctr_percentile,explode(percentile_approx(adloc_sponsorid_ctr,array(0.25,0.5,0.75))) as adloc_sponsorid_ctr_percentile,explode(percentile_approx(adloc_categoryid_ctr,array(0.25,0.5,0.75))) as adloc_categoryid_ctr_percentile,explode(percentile_approx(adloc_crtvid_ctr,array(0.25,0.5,0.75))) as adloc_crtvid_ctr_percentile,explode(percentile_approx(adloc_unet_ctr,array(0.25,0.5,0.75))) as adloc_unet_ctr_percentile,explode(percentile_approx(adloc_isp_ctr,array(0.25,0.5,0.75))) as adloc_isp_ctr_percentile,explode(percentile_approx(adloc_appver_ctr,array(0.25,0.5,0.75))) as adloc_appver_ctr_percentile,explode(percentile_approx(adloc_devicetype_ctr ,adloc_deviceos_ctr,array(0.25,0.5,0.75))) as adloc_devicetype_ctr ,adloc_deviceos_ctr_percentile,explode(percentile_approx(age_province_ctr,array(0.25,0.5,0.75))) as age_province_ctr_percentile,explode(percentile_approx(age_marry_ctr,array(0.25,0.5,0.75))) as age_marry_ctr_percentile,explode(percentile_approx(age_categoryid_ctr,array(0.25,0.5,0.75))) as age_categoryid_ctr_percentile,explode(percentile_approx(age_crtvid_ctr,array(0.25,0.5,0.75))) as age_crtvid_ctr_percentile,explode(percentile_approx(sex_marry_ctr,array(0.25,0.5,0.75))) as sex_marry_ctr_percentile,explode(percentile_approx(sex_categoryid_ctr,array(0.25,0.5,0.75))) as sex_categoryid_ctr_percentile,explode(percentile_approx(income_categoryid_ctr,array(0.25,0.5,0.75))) as income_categoryid_ctr_percentile,explode(percentile_approx(income_crtvid_ctr,array(0.25,0.5,0.75))) as income_crtvid_ctr_percentile,explode(percentile_approx(marry_categoryid_ctr,array(0.25,0.5,0.75))) as marry_categoryid_ctr_percentile,explode(percentile_approx(marry_crtvid_ctr,sponsorid_unet_ctr,array(0.25,0.5,0.75))) as marry_crtvid_ctr,sponsorid_unet_ctr_percentile from zhangsiyao.dt_fea_0818_0820;</div></pre></td></tr></table></figure><p>由此就找到了将特征等频划分的分位点，可以按照得到的分位点队连续型特征进行分桶操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;等频划分&quot;&gt;&lt;a href=&quot;#等频划分&quot; class=&quot;headerlink&quot; title=&quot;等频划分&quot;&gt;&lt;/a&gt;等频划分&lt;/h2&gt;&lt;p&gt;等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间&lt;/p&gt;
&lt;p&gt;等比划分：按照数据的全部取值情况，平
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>TPC_DS工具生成数据导入Hive</title>
    <link href="http://yoursite.com/2017/11/02/TPC-DS%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Hive/"/>
    <id>http://yoursite.com/2017/11/02/TPC-DS工具生成数据导入Hive/</id>
    <published>2017-11-02T01:29:43.000Z</published>
    <updated>2017-11-02T01:29:43.299Z</updated>
    
    <content type="html"><![CDATA[<p>生成步骤</p><p>1.在官网上(<a href="http://www.tpc.org/tpcds/" target="_blank" rel="external">http://www.tpc.org/tpcds/</a> )去下载最新的：TPC-DS. </p><p>2.解压: 下载的 zip 文件放在 Linux 上解压,并进入他的 tools 目录.</p><p>3.编译：make (忽略编译警告，只保证生成过程成功完成). 这里需要Linux安装上了 gcc , gcc c++, expect 等.</p><p>4.生成数据：在tools目录下执行：./dsdgen -scale 100 -force (-force:会覆盖原来生成的data,否则不覆盖);生成的25个.dat 的数据文件.</p><p>默认只能生成 100GB, 300GB, 1TB, 3TB, 10TB, 30TB and 100TB大小的数据，如果想要生成一个比较小的数据集，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">100M:</div><div class="line">./dsdgen -scale 1000 -dir tmp/ -parallel 1000 -child 1</div></pre></td></tr></table></figure></p><ol><li>hive中创建相应的数据表，导入之前生成的数据<br>运行脚本<code>hive_create_table.sql</code></li></ol><p>“hive -f hive_create_table.sql”<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">use tpc_ds;</div><div class="line"></div><div class="line">create table if not exists dbgen_version</div><div class="line">(</div><div class="line">    dv_version varchar(16),</div><div class="line">    dv_create_date date,</div><div class="line">    dv_create_time string,</div><div class="line">    dv_cmdline_args varchar(200) </div><div class="line">)</div><div class="line">row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/dbgen_version_1_10000.dat&quot; overwrite into table tpc_ds.dbgen_version;</div><div class="line"></div><div class="line">create table if not exists customer_address</div><div class="line">(</div><div class="line">    ca_address_sk int,</div><div class="line">    ca_address_id char(16),</div><div class="line">    ca_street_number char(10),</div><div class="line">    ca_street_name varchar(60),</div><div class="line">    ca_street_type char(15),</div><div class="line">    ca_suite_number char(10),</div><div class="line">    ca_city varchar(60),</div><div class="line">    ca_county varchar(30),</div><div class="line">    ca_state char(2),</div><div class="line">    ca_zip char(10),</div><div class="line">    ca_country varchar(20),</div><div class="line">    ca_gmt_offset decimal(5,2),</div><div class="line">    ca_location_type char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_address_1_10000.dat&quot; overwrite into table tpc_ds.customer_address;</div><div class="line"></div><div class="line">create table if not exists customer_demographics</div><div class="line">(</div><div class="line">    cd_demo_sk int,</div><div class="line">    cd_gender char(1),</div><div class="line">    cd_marital_status char(1),</div><div class="line">    cd_education_status char(20),</div><div class="line">    cd_purchase_estimate int,</div><div class="line">    cd_credit_rating char(10),</div><div class="line">    cd_dep_count int,</div><div class="line">    cd_dep_employed_count int,</div><div class="line">    cd_dep_college_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_demographics_1_10000.dat&quot; overwrite into table tpc_ds.customer_demographics;</div><div class="line"></div><div class="line">create table if not exists date_dim</div><div class="line">(</div><div class="line">    d_date_sk int,</div><div class="line">    d_date_id char(16) ,</div><div class="line">    d_date date ,</div><div class="line">    d_month_seq int,</div><div class="line">    d_week_seq int,</div><div class="line">    d_quarter_seq int,</div><div class="line">    d_year int,</div><div class="line">    d_dow int,</div><div class="line">    d_moy int,</div><div class="line">    d_dom int,</div><div class="line">    d_qoy int,</div><div class="line">    d_fy_year int,</div><div class="line">    d_fy_quarter_seq int,</div><div class="line">    d_fy_week_seq int,</div><div class="line">    d_day_name char(9),</div><div class="line">    d_quarter_name char(6),</div><div class="line">    d_holiday char(1),</div><div class="line">    d_weekend char(1),</div><div class="line">    d_following_holiday char(1),</div><div class="line">    d_first_dom int,</div><div class="line">    d_last_dom int,</div><div class="line">    d_same_day_ly int,</div><div class="line">    d_same_day_lq int,</div><div class="line">    d_current_day char(1),</div><div class="line">    d_current_week char(1),</div><div class="line">    d_current_month char(1),</div><div class="line">    d_current_quarter char(1),</div><div class="line">    d_current_year char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/date_dim_1_10000.dat&quot; overwrite into table tpc_ds.date_dim;</div><div class="line"></div><div class="line">create table if not exists warehouse</div><div class="line">(</div><div class="line">    w_warehouse_sk int,</div><div class="line">    w_warehouse_id char(16),</div><div class="line">    w_warehouse_name varchar(20),</div><div class="line">    w_warehouse_sq_ft int,</div><div class="line">    w_street_number char(10),</div><div class="line">    w_street_name varchar(60),</div><div class="line">    w_street_type char(15),</div><div class="line">    w_suite_number char(10),</div><div class="line">    w_city varchar(60),</div><div class="line">    w_county varchar(30),</div><div class="line">    w_state char(2),</div><div class="line">    w_zip char(10),</div><div class="line">    w_country varchar(20),</div><div class="line">    w_gmt_offset decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/warehouse_1_10000.dat&quot; overwrite into table tpc_ds.warehouse;</div><div class="line"></div><div class="line">create table if not exists ship_mode</div><div class="line">(</div><div class="line">    sm_ship_mode_sk int,</div><div class="line">    sm_ship_mode_id char(16),</div><div class="line">    sm_type char(30),</div><div class="line">    sm_code char(10),</div><div class="line">    sm_carrier char(20),</div><div class="line">    sm_contract char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/ship_mode_1_10000.dat&quot; overwrite into table tpc_ds.ship_mode;</div><div class="line"></div><div class="line">create table if not exists time_dim</div><div class="line">(</div><div class="line">    t_time_sk int,</div><div class="line">    t_time_id char(16),</div><div class="line">    t_time int,</div><div class="line">    t_hour int,</div><div class="line">    t_minute int,</div><div class="line">    t_second int,</div><div class="line">    t_am_pm char(2),</div><div class="line">    t_shift char(20),</div><div class="line">    t_sub_shift char(20),</div><div class="line">    t_meal_time char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/time_dim_1_10000.dat&quot; overwrite into table tpc_ds.time_dim;</div><div class="line"></div><div class="line">create table if not exists reason</div><div class="line">(</div><div class="line">    r_reason_sk int,</div><div class="line">    r_reason_id char(16),</div><div class="line">    r_reason_desc char(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/reason_1_10000.dat&quot; overwrite into table tpc_ds.reason;</div><div class="line"></div><div class="line">create table if not exists income_band</div><div class="line">(</div><div class="line">    ib_income_band_sk int,</div><div class="line">    ib_lower_bound int,</div><div class="line">    ib_upper_bound int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/income_band_1_10000.dat&quot; overwrite into table tpc_ds.income_band;</div><div class="line"></div><div class="line">create table if not exists item</div><div class="line">(</div><div class="line">    i_item_sk int,</div><div class="line">    i_item_id char(16),</div><div class="line">    i_rec_start_date date ,</div><div class="line">    i_rec_end_date date ,</div><div class="line">    i_item_desc varchar(200),</div><div class="line">    i_current_price decimal(7,2),</div><div class="line">    i_wholesale_cost decimal(7,2),</div><div class="line">    i_brand_id int,</div><div class="line">    i_brand char(50),</div><div class="line">    i_class_id int,</div><div class="line">    i_class char(50),</div><div class="line">    i_category_id int,</div><div class="line">    i_category char(50),</div><div class="line">    i_manufact_id int,</div><div class="line">    i_manufact char(50),</div><div class="line">    i_size char(20),</div><div class="line">    i_formulation char(20),</div><div class="line">    i_color char(20),</div><div class="line">    i_units char(10),</div><div class="line">    i_container char(10),</div><div class="line">    i_manager_id int,</div><div class="line">    i_product_name char(50)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/item_1_10000.dat&quot; overwrite into table tpc_ds.item;</div><div class="line"></div><div class="line">create table if not exists store</div><div class="line">(</div><div class="line">    s_store_sk int,</div><div class="line">    s_store_id char(16),</div><div class="line">    s_rec_start_date date ,</div><div class="line">    s_rec_end_date date ,</div><div class="line">    s_closed_date_sk int,</div><div class="line">    s_store_name varchar(50),</div><div class="line">    s_number_employees int,</div><div class="line">    s_floor_space int,</div><div class="line">    s_hours char(20),</div><div class="line">    s_manager varchar(40),</div><div class="line">    s_market_id int,</div><div class="line">    s_geography_class varchar(100),</div><div class="line">    s_market_desc varchar(100),</div><div class="line">    s_market_manager varchar(40),</div><div class="line">    s_division_id int,</div><div class="line">    s_division_name varchar(50),</div><div class="line">    s_company_id int,</div><div class="line">    s_company_name varchar(50),</div><div class="line">    s_street_number varchar(10),</div><div class="line">    s_street_name varchar(60),</div><div class="line">    s_street_type char(15),</div><div class="line">    s_suite_number char(10),</div><div class="line">    s_city varchar(60),</div><div class="line">    s_county varchar(30),</div><div class="line">    s_state char(2),</div><div class="line">    s_zip char(10),</div><div class="line">    s_country varchar(20),</div><div class="line">    s_gmt_offset decimal(5,2),</div><div class="line">    s_tax_precentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_1_10000.dat&quot; overwrite into table tpc_ds.store;</div><div class="line"></div><div class="line">create table if not exists call_center</div><div class="line">(</div><div class="line">    cc_call_center_sk int,</div><div class="line">    cc_call_center_id char(16),</div><div class="line">    cc_rec_start_date date ,</div><div class="line">    cc_rec_end_date date ,</div><div class="line">    cc_closed_date_sk int,</div><div class="line">    cc_open_date_sk int,</div><div class="line">    cc_name varchar(50),</div><div class="line">    cc_class varchar(50),</div><div class="line">    cc_employees int,</div><div class="line">    cc_sq_ft int,</div><div class="line">    cc_hours char(20),</div><div class="line">    cc_manager varchar(40),</div><div class="line">    cc_mkt_id int,</div><div class="line">    cc_mkt_class char(50),</div><div class="line">    cc_mkt_desc varchar(100),</div><div class="line">    cc_market_manager varchar(40),</div><div class="line">    cc_division int,</div><div class="line">    cc_division_name varchar(50),</div><div class="line">    cc_company int,</div><div class="line">    cc_company_name char(50),</div><div class="line">    cc_street_number char(10),</div><div class="line">    cc_street_name varchar(60),</div><div class="line">    cc_street_type char(15),</div><div class="line">    cc_suite_number char(10),</div><div class="line">    cc_city varchar(60),</div><div class="line">    cc_county varchar(30),</div><div class="line">    cc_state char(2),</div><div class="line">    cc_zip char(10),</div><div class="line">    cc_country varchar(20),</div><div class="line">    cc_gmt_offset decimal(5,2),</div><div class="line">    cc_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/call_center_1_10000.dat&quot; overwrite into table tpc_ds.call_center;</div><div class="line"></div><div class="line">create table if not exists customer</div><div class="line">(</div><div class="line">    c_customer_sk int,</div><div class="line">    c_customer_id char(16),</div><div class="line">    c_current_cdemo_sk int,</div><div class="line">    c_current_hdemo_sk int,</div><div class="line">    c_current_addr_sk int,</div><div class="line">    c_first_shipto_date_sk int,</div><div class="line">    c_first_sales_date_sk int,</div><div class="line">    c_salutation char(10),</div><div class="line">    c_first_name char(20),</div><div class="line">    c_last_name char(30),</div><div class="line">    c_preferred_cust_flag char(1),</div><div class="line">    c_birth_day int,</div><div class="line">    c_birth_month int,</div><div class="line">    c_birth_year int,</div><div class="line">    c_birth_country varchar(20),</div><div class="line">    c_login char(13),</div><div class="line">    c_email_address char(50),</div><div class="line">    c_last_review_date char(10)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_1_10000.dat&quot; overwrite into table tpc_ds.customer;</div><div class="line"></div><div class="line">create table if not exists web_site</div><div class="line">(</div><div class="line">    web_site_sk int,</div><div class="line">    web_site_id char(16),</div><div class="line">    web_rec_start_date date ,</div><div class="line">    web_rec_end_date date ,</div><div class="line">    web_name varchar(50),</div><div class="line">    web_open_date_sk int,</div><div class="line">    web_close_date_sk int,</div><div class="line">    web_class varchar(50),</div><div class="line">    web_manager varchar(40),</div><div class="line">    web_mkt_id int,</div><div class="line">    web_mkt_class varchar(50),</div><div class="line">    web_mkt_desc varchar(100),</div><div class="line">    web_market_manager varchar(40),</div><div class="line">    web_company_id int,</div><div class="line">    web_company_name char(50),</div><div class="line">    web_street_number char(10),</div><div class="line">    web_street_name varchar(60),</div><div class="line">    web_street_type char(15),</div><div class="line">    web_suite_number char(10),</div><div class="line">    web_city varchar(60),</div><div class="line">    web_county varchar(30),</div><div class="line">    web_state char(2),</div><div class="line">    web_zip char(10),</div><div class="line">    web_country varchar(20),</div><div class="line">    web_gmt_offset decimal(5,2),</div><div class="line">    web_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_site_1_10000.dat&quot; overwrite into table tpc_ds.web_site;</div><div class="line"></div><div class="line">create table if not exists store_returns</div><div class="line">(</div><div class="line">    sr_returned_date_sk int,</div><div class="line">    sr_return_time_sk int,</div><div class="line">    sr_item_sk int,</div><div class="line">    sr_customer_sk int,</div><div class="line">    sr_cdemo_sk int,</div><div class="line">    sr_hdemo_sk int,</div><div class="line">    sr_addr_sk int,</div><div class="line">    sr_store_sk int,</div><div class="line">    sr_reason_sk int,</div><div class="line">    sr_ticket_number int,</div><div class="line">    sr_return_quantity int,</div><div class="line">    sr_return_amt decimal(7,2),</div><div class="line">    sr_return_tax decimal(7,2),</div><div class="line">    sr_return_amt_inc_tax decimal(7,2),</div><div class="line">    sr_fee decimal(7,2),</div><div class="line">    sr_return_ship_cost decimal(7,2),</div><div class="line">    sr_refunded_cash decimal(7,2),</div><div class="line">    sr_reversed_charge decimal(7,2),</div><div class="line">    sr_store_credit decimal(7,2),</div><div class="line">    sr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_returns_1_10000.dat&quot; overwrite into table tpc_ds.store_returns;</div><div class="line"></div><div class="line">create table if not exists household_demographics</div><div class="line">(</div><div class="line">    hd_demo_sk int,</div><div class="line">    hd_income_band_sk int,</div><div class="line">    hd_buy_potential char(15),</div><div class="line">    hd_dep_count int,</div><div class="line">    hd_vehicle_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/household_demographics_1_10000.dat&quot; overwrite into table tpc_ds.household_demographics;</div><div class="line"></div><div class="line">create table if not exists web_page</div><div class="line">(</div><div class="line">    wp_web_page_sk int,</div><div class="line">    wp_web_page_id char(16),</div><div class="line">    wp_rec_start_date date ,</div><div class="line">    wp_rec_end_date date ,</div><div class="line">    wp_creation_date_sk int,</div><div class="line">    wp_access_date_sk int,</div><div class="line">    wp_autogen_flag char(1),</div><div class="line">    wp_customer_sk int,</div><div class="line">    wp_url varchar(100),</div><div class="line">    wp_type char(50),</div><div class="line">    wp_char_count int,</div><div class="line">    wp_link_count int,</div><div class="line">    wp_image_count int,</div><div class="line">    wp_max_ad_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_page_1_10000.dat&quot; overwrite into table tpc_ds.web_page;</div><div class="line"></div><div class="line">create table if not exists promotion</div><div class="line">(</div><div class="line">    p_promo_sk int,</div><div class="line">    p_promo_id char(16),</div><div class="line">    p_start_date_sk int,</div><div class="line">    p_end_date_sk int,</div><div class="line">    p_item_sk int,</div><div class="line">    p_cost decimal(15,2),</div><div class="line">    p_response_target int,</div><div class="line">    p_promo_name char(50),</div><div class="line">    p_channel_dmail char(1),</div><div class="line">    p_channel_email char(1),</div><div class="line">    p_channel_catalog char(1),</div><div class="line">    p_channel_tv char(1),</div><div class="line">    p_channel_radio char(1),</div><div class="line">    p_channel_press char(1),</div><div class="line">    p_channel_event char(1),</div><div class="line">    p_channel_demo char(1),</div><div class="line">    p_channel_details varchar(100),</div><div class="line">    p_purpose char(15),</div><div class="line">    p_discount_active char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/promotion_1_10000.dat&quot; overwrite into table tpc_ds.promotion;</div><div class="line"></div><div class="line">create table if not exists catalog_page</div><div class="line">(</div><div class="line">    cp_catalog_page_sk int,</div><div class="line">    cp_catalog_page_id char(16),</div><div class="line">    cp_start_date_sk int,</div><div class="line">    cp_end_date_sk int,</div><div class="line">    cp_department varchar(50),</div><div class="line">    cp_catalog_number int,</div><div class="line">    cp_catalog_page_number int,</div><div class="line">    cp_description varchar(100),</div><div class="line">    cp_type varchar(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_page_1_10000.dat&quot; overwrite into table tpc_ds.catalog_page;</div><div class="line"></div><div class="line">create table if not exists inventory</div><div class="line">(</div><div class="line">    inv_date_sk int,</div><div class="line">    inv_item_sk int,</div><div class="line">    inv_warehouse_sk int,</div><div class="line">    inv_quantity_on_hand int)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/inventory_1_10000.dat&quot; overwrite into table tpc_ds.inventory;</div><div class="line"></div><div class="line">create table if not exists catalog_returns</div><div class="line">(</div><div class="line">    cr_returned_date_sk int,</div><div class="line">    cr_returned_time_sk int,</div><div class="line">    cr_item_sk int,</div><div class="line">    cr_refunded_customer_sk int,</div><div class="line">    cr_refunded_cdemo_sk int,</div><div class="line">    cr_refunded_hdemo_sk int,</div><div class="line">    cr_refunded_addr_sk int,</div><div class="line">    cr_returning_customer_sk int,</div><div class="line">    cr_returning_cdemo_sk int,</div><div class="line">    cr_returning_hdemo_sk int,</div><div class="line">    cr_returning_addr_sk int,</div><div class="line">    cr_call_center_sk int,</div><div class="line">    cr_catalog_page_sk int,</div><div class="line">    cr_ship_mode_sk int,</div><div class="line">    cr_warehouse_sk int,</div><div class="line">    cr_reason_sk int,</div><div class="line">    cr_order_number int,</div><div class="line">    cr_return_quantity int,</div><div class="line">    cr_return_amount decimal(7,2),</div><div class="line">    cr_return_tax decimal(7,2),</div><div class="line">    cr_return_amt_inc_tax decimal(7,2),</div><div class="line">    cr_fee decimal(7,2),</div><div class="line">    cr_return_ship_cost decimal(7,2),</div><div class="line">    cr_refunded_cash decimal(7,2),</div><div class="line">    cr_reversed_charge decimal(7,2),</div><div class="line">    cr_store_credit decimal(7,2),</div><div class="line">    cr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_returns_1_10000.dat&quot; overwrite into table tpc_ds.catalog_returns;</div><div class="line"></div><div class="line">create table if not exists web_returns</div><div class="line">(</div><div class="line">    wr_returned_date_sk int,</div><div class="line">    wr_returned_time_sk int,</div><div class="line">    wr_item_sk int,</div><div class="line">    wr_refunded_customer_sk int,</div><div class="line">    wr_refunded_cdemo_sk int,</div><div class="line">    wr_refunded_hdemo_sk int,</div><div class="line">    wr_refunded_addr_sk int,</div><div class="line">    wr_returning_customer_sk int,</div><div class="line">    wr_returning_cdemo_sk int,</div><div class="line">    wr_returning_hdemo_sk int,</div><div class="line">    wr_returning_addr_sk int,</div><div class="line">    wr_web_page_sk int,</div><div class="line">    wr_reason_sk int,</div><div class="line">    wr_order_number int,</div><div class="line">    wr_return_quantity int,</div><div class="line">    wr_return_amt decimal(7,2),</div><div class="line">    wr_return_tax decimal(7,2),</div><div class="line">    wr_return_amt_inc_tax decimal(7,2),</div><div class="line">    wr_fee decimal(7,2),</div><div class="line">    wr_return_ship_cost decimal(7,2),</div><div class="line">    wr_refunded_cash decimal(7,2),</div><div class="line">    wr_reversed_charge decimal(7,2),</div><div class="line">    wr_account_credit decimal(7,2),</div><div class="line">    wr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_returns_1_10000.dat&quot; overwrite into table tpc_ds.web_returns;</div><div class="line"></div><div class="line">create table if not exists web_sales</div><div class="line">(</div><div class="line">    ws_sold_date_sk int,</div><div class="line">    ws_sold_time_sk int,</div><div class="line">    ws_ship_date_sk int,</div><div class="line">    ws_item_sk int,</div><div class="line">    ws_bill_customer_sk int,</div><div class="line">    ws_bill_cdemo_sk int,</div><div class="line">    ws_bill_hdemo_sk int,</div><div class="line">    ws_bill_addr_sk int,</div><div class="line">    ws_ship_customer_sk int,</div><div class="line">    ws_ship_cdemo_sk int,</div><div class="line">    ws_ship_hdemo_sk int,</div><div class="line">    ws_ship_addr_sk int,</div><div class="line">    ws_web_page_sk int,</div><div class="line">    ws_web_site_sk int,</div><div class="line">    ws_ship_mode_sk int,</div><div class="line">    ws_warehouse_sk int,</div><div class="line">    ws_promo_sk int,</div><div class="line">    ws_order_number int,</div><div class="line">    ws_quantity int,</div><div class="line">    ws_wholesale_cost decimal(7,2),</div><div class="line">    ws_list_price decimal(7,2),</div><div class="line">    ws_sales_price decimal(7,2),</div><div class="line">    ws_ext_discount_amt decimal(7,2),</div><div class="line">    ws_ext_sales_price decimal(7,2),</div><div class="line">    ws_ext_wholesale_cost decimal(7,2),</div><div class="line">    ws_ext_list_price decimal(7,2),</div><div class="line">    ws_ext_tax decimal(7,2),</div><div class="line">    ws_coupon_amt decimal(7,2),</div><div class="line">    ws_ext_ship_cost decimal(7,2),</div><div class="line">    ws_net_paid decimal(7,2),</div><div class="line">    ws_net_paid_inc_tax decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    ws_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_sales_1_10000.dat&quot; overwrite into table tpc_ds.web_sales;</div><div class="line"></div><div class="line">create table if not exists catalog_sales</div><div class="line">(</div><div class="line">    cs_sold_date_sk int,</div><div class="line">    cs_sold_time_sk int,</div><div class="line">    cs_ship_date_sk int,</div><div class="line">    cs_bill_customer_sk int,</div><div class="line">    cs_bill_cdemo_sk int,</div><div class="line">    cs_bill_hdemo_sk int,</div><div class="line">    cs_bill_addr_sk int,</div><div class="line">    cs_ship_customer_sk int,</div><div class="line">    cs_ship_cdemo_sk int,</div><div class="line">    cs_ship_hdemo_sk int,</div><div class="line">    cs_ship_addr_sk int,</div><div class="line">    cs_call_center_sk int,</div><div class="line">    cs_catalog_page_sk int,</div><div class="line">    cs_ship_mode_sk int,</div><div class="line">    cs_warehouse_sk int,</div><div class="line">    cs_item_sk int,</div><div class="line">    cs_promo_sk int,</div><div class="line">    cs_order_number int,</div><div class="line">    cs_quantity int,</div><div class="line">    cs_wholesale_cost decimal(7,2),</div><div class="line">    cs_list_price decimal(7,2),</div><div class="line">    cs_sales_price decimal(7,2),</div><div class="line">    cs_ext_discount_amt decimal(7,2),</div><div class="line">    cs_ext_sales_price decimal(7,2),</div><div class="line">    cs_ext_wholesale_cost decimal(7,2),</div><div class="line">    cs_ext_list_price decimal(7,2),</div><div class="line">    cs_ext_tax decimal(7,2),</div><div class="line">    cs_coupon_amt decimal(7,2),</div><div class="line">    cs_ext_ship_cost decimal(7,2),</div><div class="line">    cs_net_paid decimal(7,2),</div><div class="line">    cs_net_paid_inc_tax decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    cs_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_sales_1_10000.dat&quot; overwrite into table tpc_ds.catalog_sales;</div><div class="line"></div><div class="line">create table if not exists store_sales</div><div class="line">(</div><div class="line">    ss_sold_date_sk int,</div><div class="line">    ss_sold_time_sk int,</div><div class="line">    ss_item_sk int,</div><div class="line">    ss_customer_sk int,</div><div class="line">    ss_cdemo_sk int,</div><div class="line">    ss_hdemo_sk int,</div><div class="line">    ss_addr_sk int,</div><div class="line">    ss_store_sk int,</div><div class="line">    ss_promo_sk int,</div><div class="line">    ss_ticket_number int,</div><div class="line">    ss_quantity int,</div><div class="line">    ss_wholesale_cost decimal(7,2),</div><div class="line">    ss_list_price decimal(7,2),</div><div class="line">    ss_sales_price decimal(7,2),</div><div class="line">    ss_ext_discount_amt decimal(7,2),</div><div class="line">    ss_ext_sales_price decimal(7,2),</div><div class="line">    ss_ext_wholesale_cost decimal(7,2),</div><div class="line">    ss_ext_list_price decimal(7,2),</div><div class="line">    ss_ext_tax decimal(7,2),</div><div class="line">    ss_coupon_amt decimal(7,2),</div><div class="line">    ss_net_paid decimal(7,2),</div><div class="line">    ss_net_paid_inc_tax decimal(7,2),</div><div class="line">    ss_net_profit decimal(7,2))row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_sales_1_10000.dat&quot; overwrite into table tpc_ds.store_sales;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生成步骤&lt;/p&gt;
&lt;p&gt;1.在官网上(&lt;a href=&quot;http://www.tpc.org/tpcds/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tpc.org/tpcds/&lt;/a&gt; )去下载最新的：TPC-DS. &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【算法导论】动态规划（二）矩阵链乘法</title>
    <link href="http://yoursite.com/2017/11/01/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/"/>
    <id>http://yoursite.com/2017/11/01/【算法导论】动态规划（二）矩阵链乘法/</id>
    <published>2017-11-01T14:54:11.000Z</published>
    <updated>2017-11-02T07:18:38.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵链乘法问题"><a href="#矩阵链乘法问题" class="headerlink" title="矩阵链乘法问题"></a>矩阵链乘法问题</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>两个矩阵A和B相乘，维度分别为$ p×q$ 和$ q×r$ ，则$A*B$ 的时间复杂度为$pqr$</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MATRIX_MULTIPLY(A,B)&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;A.rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; B.cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A.cols;k++)&#123;</div><div class="line">        C[i,j] = A[i,k]*B[k,j];</div><div class="line">&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure><h3 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h3><p>​    首先，给定一个矩阵链 <script type="math/tex"><A_1,A_2,A_3></script>  ，三个矩阵的规模分别为：10×100 ， 100×5 ，5×50 ，计算他们的乘积有两种方式：</p><div class="table-container"><table><thead><tr><th>$((A_1A_2)A_3)$</th><th style="text-align:left"><script type="math/tex">10*100*5+10*5*50=7500</script></th></tr></thead><tbody><tr><td>$(A_1(A_2A_3))$</td><td style="text-align:left"><script type="math/tex">100*5*50+10*100*50=75000</script></td></tr></tbody></table></div><p>可以看出，对一串矩阵做乘法操作，乘法的顺序影响到算法的时间复杂度。由此，引出矩阵链乘法问题：</p><p><strong>给定n个矩阵的链<script type="math/tex"><A_1,A_2,...,A_n></script>，矩阵<script type="math/tex">A_i</script> 的规模为<script type="math/tex">p_{i-1} \times p_i</script>，确定代价最低的计算顺序，使得计算乘积$A_1A_2A_n$所需标量乘法次数最小。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩阵链乘法问题&quot;&gt;&lt;a href=&quot;#矩阵链乘法问题&quot; class=&quot;headerlink&quot; title=&quot;矩阵链乘法问题&quot;&gt;&lt;/a&gt;矩阵链乘法问题&lt;/h2&gt;&lt;h3 id=&quot;矩阵乘法&quot;&gt;&lt;a href=&quot;#矩阵乘法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【算法导论】动态规划（一）钢条切割</title>
    <link href="http://yoursite.com/2017/10/31/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/"/>
    <id>http://yoursite.com/2017/10/31/【算法导论】动态规划（一）钢条切割/</id>
    <published>2017-10-31T14:44:19.000Z</published>
    <updated>2017-11-02T02:06:20.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-动态规划（Dynamic-programming）"><a href="#1-动态规划（Dynamic-programming）" class="headerlink" title="1. 动态规划（Dynamic programming）"></a>1. 动态规划（Dynamic programming）</h2><p>这里programming指的是<strong>表格</strong>，而非编程。动态规划通常用来<strong>求解最优化问题</strong></p><p>与分治法对比：</p><ol><li>相同点：都是通过子问题组合求解原问题</li><li>不同点：分治法将问题划分为<strong>不相交</strong>的子问题，求解再合并，动态规划应用于<strong>子问题重叠</strong>的情况，即不同的子问题具有公共的子子问题，此时如果用分治法就会出现重复计算求解。为了避免重复动态规划对子问题只求解一次，将其保存在表格中，从而无需每求解一个子子问题时重复计算。</li></ol><h2 id="2-求解步骤"><a href="#2-求解步骤" class="headerlink" title="2. 求解步骤"></a>2. 求解步骤</h2><ol><li>刻画最优解的结构特征</li><li>递归定义最优解的值</li><li>计算最优解的值，通常采用自底向上的方法</li><li>利用计算出的信息构造最优解</li></ol><p>其中不是所有的题目都会要求4，仅仅要求3，要求4的时候，我们需要在得到3的同事维护一些额外的信息来求出4。</p><p>看到这四个步骤的时候，还是挺懵逼的，继续往下看=.=</p><h2 id="3-钢条切割问题"><a href="#3-钢条切割问题" class="headerlink" title="3. 钢条切割问题"></a>3. 钢条切割问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Serling公司购买一根长钢管，将其切割成短钢管出售，给定钢管长度和对应的价钱如下表：</p><p><img src="https://i.loli.net/2017/10/31/59f7536b8fc8f.png" alt=""> </p><p>问题要求根据上面的价格，给出最佳的切割方案，使得收益最大。</p><p>以n=4为例，可以将钢条切割成如下图所示的8种情况，其中收益岁大的是(c)：</p><p><img src="https://ooo.0o0.ooo/2017/10/30/59f73938d2f50.png" alt=""> </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>钢条长度为n时，共有$2^{n-1}$种分割方式。</p><ol><li><p>递归</p><p>把长度为n的钢条切割问题转化为：将钢条从左边切下长度为i的一段，对右边剩下的长度为n-i的钢条进行进一步的切割。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if n==0:</div><div class="line">2 return 0</div><div class="line">3 q=MIN</div><div class="line">4 for i = 1 to n:</div><div class="line">5 q=max(q,p[i],CUT-ROD(p,n-i))</div><div class="line">6 return q</div></pre></td></tr></table></figure><p>当n=4时，上面递推方式的工作量如图所示，复杂度为$T(n)=2^n$</p><p><img src="https://i.loli.net/2017/10/31/59f759167976c.png" alt=""> </p></li><li><p>动态规划（DP）</p><p>可以看出来用上面递归的方式计算，中间会重复求解相同子问题。使用动态规划，<strong>仔细安排求解顺序，对每个子问题只求解一次所以，并把结果保存下来</strong>，供后续使用避免重复计算。</p><p>​    对于钢条切割的问题，我们可以将长度为n的钢条切割问题转化为规模更小的子问题：当完成首次切割后，将两段钢条看成<strong>两个独立的钢条切割</strong>问题，通过<strong>组合</strong>两个相关子问题的最优解，选取组合收益最大者，构成原问题的最优解。</p><p>因此，将长度为n的钢条切割成两段，共有下面n种切割方式，求解下面n个子问题的最优解，再选取其中最大的作为原问题的最优解。</p><script type="math/tex; mode=display">r_n=max(p_n,r_{1}+r_{n-1},r_{2}+r_{n-2},...,r_{n-1}+r_1)</script><p>​以n=4为例：</p><p>$r_1=1$</p><p>$r_2=max(p_2,max(r_1)+max(r_1))=max(5,1+1)=5$</p><p>$r_3=max(p_3,max(r_1)+max(r_2))=max(8,5+1)=8$</p><p>$r_4=max(p_4,max(r_1)+max(r_3),max(r_2)+max(r_2))=max(9,8+1,5+5)=10$</p><p>…</p><p>​    动态规划两种实现方法：</p></li></ol><ul><li><p>自顶向下：</p><p>仍按照递归的方式实现，过程中保存每个子问题的解，后续过程中先检查是否已经保存过此解，如果是，直接返回保存的值。就好像带了一个“备忘录”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">memorized-CUT-ROD[] = MIN//用于记录子问题结果</div><div class="line">CUT-ROD(p,n)//p:价格数组，n：钢条长度</div><div class="line">1 if memorized-CUT-ROD[n] &gt; 0:</div><div class="line">2 return memorized-CUT-ROD[n]</div><div class="line">3 else</div><div class="line">4 for i = 1 to n:</div><div class="line">5 q=max(q,p[i],memorized-CUT-ROD(p,n-i))</div><div class="line">6 memorized-CUT-ROD[n] = q</div></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>自底向上</p><p>需要恰当定义子问题的“规模”，使得任何子问题的求解都只依赖于“更小的”子问题，进而将子问题按规律排序，按由小到大的顺序进行求解，当求解某个自问题时，它所以来的子问题都已经求解完毕。</p><p>伪代码略，直接上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            maxvalue[i] = max(maxvalue[i],maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 至此，可以求出该问题的最优解了~</p></li></ul><h3 id="重构解"><a href="#重构解" class="headerlink" title="重构解"></a>重构解</h3><p>​    上面的求解过程可以求出最优解的值，但并没有返回解本身（具体的切割方案），为了得到最优解，需要在求解最优解的同时，保存切割信息。扩展上面的算法，使之对子问题不仅保存最优收益值$r_j$，还保存该最优方案对应的第一段钢条的切割长度，也就是第一段钢条的切割位置距离钢条左端的长度$s_j$，最后输出最优方案时，根据$s_j$即可复原出最优解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_rod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvalue(len,<span class="number">0</span>);<span class="comment">//记录最优方案值</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftlen(len,<span class="number">0</span>);<span class="comment">//记录第一段钢条距左端距离</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">//i=n-1</span></div><div class="line">        maxvalue[i] = p[i];</div><div class="line">        leftlen[i] = i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (i+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(maxvalue[j<span class="number">-1</span>]+maxvalue[i-j]&gt;maxvalue[i])&#123;</div><div class="line">                maxvalue[i] = maxvalue[j<span class="number">-1</span>]+maxvalue[i-j];</div><div class="line">                leftlen[i] = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//输出最优解方案</span></div><div class="line">    <span class="keyword">int</span> m = n<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;leftlen[m]&lt;&lt;<span class="string">"\t"</span>;</div><div class="line">        m -= leftlen[m];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxvalue[n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果如图：</p><p>​                <img src="http://omaby2s5z.bkt.clouddn.com/2017-10-31-22-25-25.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-动态规划（Dynamic-programming）&quot;&gt;&lt;a href=&quot;#1-动态规划（Dynamic-programming）&quot; class=&quot;headerlink&quot; title=&quot;1. 动态规划（Dynamic programming）&quot;&gt;&lt;/a&gt;1. 动
      
    
    </summary>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】713.Subarray-Product-Less-Than-K.md</title>
    <link href="http://yoursite.com/2017/10/26/%E3%80%90leetcode%E3%80%91713-Subarray-Product-Less-Than-K-md/"/>
    <id>http://yoursite.com/2017/10/26/【leetcode】713-Subarray-Product-Less-Than-K-md/</id>
    <published>2017-10-26T08:28:31.000Z</published>
    <updated>2017-10-26T09:14:15.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Your are given an array of positive integers nums.</p><p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">Output: 8</div><div class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个正整数组，和一个整数k，求成绩小于k的连续子数组个数</p><p>这道题真的是做了很久，想到了用滑窗，用一个数字记录窗口内数字成绩，但是算不明白个数</p><p>问题的关键在于:</p><p><strong>每次滑窗的末尾向后移动一位之后，满足条件的窗口内新增的连续子数组数目为：end-start+1</strong></p><p>因为每次滑窗末尾向后移动一位，新增的子数组必然包含最后一个数字，又必须是连续子数组，所以新增的个数是end-start+1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后附上很简单的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class="line">    int product = 1;</div><div class="line">    int count = 0;</div><div class="line">    int start = 0;</div><div class="line">    int end = 0;</div><div class="line">    while(end &lt; nums.size()&amp;&amp;start&lt;=end)&#123;</div><div class="line">        product = product*nums[end];</div><div class="line">        while(product&gt;=k&amp;&amp;start&lt;=end)&#123;</div><div class="line">            product = product/nums[start];</div><div class="line">            start++;</div><div class="line">        &#125;</div><div class="line">        count+=end-start+1;</div><div class="line">        end++;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="http://omaby2s5z.bkt.clouddn.com/blog/171026/1g02kLeb0H.png?imageslim" alt=""><br><img src="http://omaby2s5z.bkt.clouddn.com/201710261713_719.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Your are given an array of positive integers nums.&lt;/p&gt;
&lt;p&gt;Count and pr
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】 628. Maximum Product of Three Numbers</title>
    <link href="http://yoursite.com/2017/08/01/%E3%80%90leetcode%E3%80%91-628-Maximum-Product-of-Three-Numbers/"/>
    <id>http://yoursite.com/2017/08/01/【leetcode】-628-Maximum-Product-of-Three-Numbers/</id>
    <published>2017-08-01T12:27:59.000Z</published>
    <updated>2017-08-01T12:28:42.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p><p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3]</div><div class="line">Output: 6</div></pre></td></tr></table></figure></p><p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3,4]</div><div class="line">Output: 24</div></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>The length of the given array will be in range [3,$10^4$] and all elements are in the range [-1000, 1000].<br>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果数组里面没有负整数，那最大的乘积就是三个最大的数字乘积，题目说明数组中的数字范围是<strong>[-1000, 1000]</strong>，所以会有两种情况：</p><ol><li>两个最小的负数*一个最大的正数</li><li>三个最大的正数相乘</li></ol><p>所以只需要定义5个变量用来存储两个最小的和三个最大的数字，遍历一遍数组获取5个变量的值，然后返回两种情况中值较大的那种。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    //声明变量用来存储两个最小的数字和三个最大的数字</div><div class="line">    int min1 = 1001, min2 = 1001, max1 = -1001, max2 = -1001, max3 = -1001;</div><div class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</div><div class="line">        //遇到比min1还小的</div><div class="line">        if (nums[i] &lt; min1) &#123;</div><div class="line">            min2 = min1;</div><div class="line">            min1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &lt; min2) &#123;</div><div class="line">            min2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        if (nums[i] &gt; max1) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = max1;</div><div class="line">            max1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max2) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max3) &#123;</div><div class="line">            max3 = nums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = min1*min2*max1;</div><div class="line">    int y = max1*max2*max3;</div><div class="line">    if (x &gt; y)</div><div class="line">        return x;</div><div class="line">    else</div><div class="line">        return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597ffda9bb7c7.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an integer array, find three numbers whose product is maximum an
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1. Two Sum</title>
    <link href="http://yoursite.com/2017/08/01/%E3%80%90leetcode%E3%80%911-Two-Sum/"/>
    <id>http://yoursite.com/2017/08/01/【leetcode】1-Two-Sum/</id>
    <published>2017-07-31T16:33:36.000Z</published>
    <updated>2017-07-31T16:34:41.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line"></div><div class="line">return [0, 1].</div></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给一个数组和一个整数，返回数组中和恰好等于这个整数的两个数组的位置</p><p>自己就只想出来了从前向后遍历的方法，时间复杂度$O(n^2)$</p><p>代码如下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        hash_map&lt;int,int&gt; map;</div><div class="line">        for(int i = 0;i &lt; nums.size();i++)&#123;</div><div class="line">            int res = target-nums[i];</div><div class="line">            if (map.)</div><div class="line">            for(int j = i+1;j &lt; nums.size();j++)&#123;</div><div class="line">                if (res == nums[j])&#123;</div><div class="line">                    result.push_back(i);</div><div class="line">                    result.push_back(j);</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>看了solution才知道这道题正确的打开方式是用hash_map，可以先把数组中的元素存入hash_map中，这样就可以实现O(1)复杂度的按值查找了。</p><p>不过还有更好的方式，就是采用边查找边插入的方式，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt; a,int b) &#123;</div><div class="line">    vector&lt;int&gt; res;</div><div class="line">    unordered_map&lt;int, int&gt; map;</div><div class="line">    for (int i = 0; i &lt; a.size(); i++) &#123;</div><div class="line">        int temp = b - a[i];</div><div class="line">        //查看map里是否已经有要找的元素</div><div class="line">        unordered_map&lt;int, int&gt;::iterator it = map.find(temp);</div><div class="line">        //如果没有，把当前元素的值和idx插入map</div><div class="line">        if (it == map.end()) &#123;</div><div class="line">            map.insert(make_pair(a[i], i));</div><div class="line">        &#125;</div><div class="line">        //找到了符合要求的，返回idx</div><div class="line">        else&#123;</div><div class="line">            res.push_back(it-&gt;second);</div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样在查找指定值元素的时候就可以有$O(1)$的复杂度了，遍历的复杂度是$O(n)$,总的复杂度是$O(n)$</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597f5b7c55158.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such tha
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="hash_table" scheme="http://yoursite.com/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2017/07/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/23/归并排序/</id>
    <published>2017-07-23T15:50:46.000Z</published>
    <updated>2017-07-23T15:56:02.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>分治法</strong><br>将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p><p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//将两个有序数组合并成一个有序数组</div><div class="line">void merge(int a[], int begin,int mid,int end,int b[]) &#123;</div><div class="line">    int i = begin;</div><div class="line">    int j = mid + 1;</div><div class="line">    int k = 0;</div><div class="line">    while ((i &lt;= mid) &amp;&amp; (j &lt;= end)) &#123;</div><div class="line">        if (a[i] &lt; a[j]) &#123;</div><div class="line">            b[k] = a[i];</div><div class="line">            k++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            b[k] = a[j];</div><div class="line">            k++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (i&lt;=mid)&#123;</div><div class="line">        b[k] = a[i];</div><div class="line">        k++;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= end)&#123;</div><div class="line">        b[k] = a[j];</div><div class="line">        k++;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; k; i++)&#123;</div><div class="line">        a[begin + i] = b[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//归并排序</div><div class="line">void MergeSort(int a[], int begin,int end,int b[]) &#123;</div><div class="line">    if (begin &lt; end) &#123;</div><div class="line">        int mid = (begin + end) / 2;</div><div class="line">        MergeSort(a, begin, mid, b);</div><div class="line">        MergeSort(a, mid + 1, end, b);</div><div class="line">        merge(a, begin, mid, end, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况$O(n\log(n))$<br>平均情况$O(n\log(n))$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;分治法&lt;/strong&gt;&lt;br&gt;将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>不使用中间变量交换两个数字</title>
    <link href="http://yoursite.com/2017/07/22/%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2017/07/22/不使用中间变量交换两个数字/</id>
    <published>2017-07-22T14:18:13.000Z</published>
    <updated>2017-07-22T14:18:26.178Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数字a和b，要求不使用中间变量交换二者</p><h3 id="一般做法"><a href="#一般做法" class="headerlink" title="一般做法"></a>一般做法</h3><p>一般的做法很简单</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    int temp = a;</div><div class="line">    a = b;</div><div class="line">    b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不使用中间变量的做法"><a href="#不使用中间变量的做法" class="headerlink" title="不使用中间变量的做法"></a>不使用中间变量的做法</h3><p>采用位操作符中的异或操作<code>^</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">功能</th><th>用法</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">取反</td><td>0变1,1变0</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td><td>后面补0</td></tr><tr><td style="text-align:center">>&gt;</td><td style="text-align:center">右移</td><td>前面补0，后面吞位</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center"></td><td>位或</td><td>有一个或2个1，则为1。<strong>用于做and运算</strong></td></tr></tbody></table></div><p>容易发现<code>^</code>的性质：</p><ol><li>两个相同的数字做<code>^</code>操作得0</li><li>任何数字跟0做<code>^</code>操作还是它本身</li></ol><p>所以可以通过下面的方式交换两个数字</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    a = a^b;</div><div class="line">    b = b^a;</div><div class="line">    a = a^b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个程序大部分时间正确，但是有个致命缺陷，当a和b指向同一个位置时，计算a^b得0，也就是说a和b所指向的地址是同一个，所以此时a=b=0。所以上面这样写的前提是假设两个指针不会指向同一个位置。这也是编译器优化时经常考虑的一点，这种两个指针指向同一个存储器的情况叫做存储器别名使用（memory aliasing）。</p><p>因此正确的程序应该如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    if (a!=b)&#123;</div><div class="line">        a = a^b;</div><div class="line">        b = b^a;</div><div class="line">        a = a^b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个数字a和b，要求不使用中间变量交换二者&lt;/p&gt;
&lt;h3 id=&quot;一般做法&quot;&gt;&lt;a href=&quot;#一般做法&quot; class=&quot;headerlink&quot; title=&quot;一般做法&quot;&gt;&lt;/a&gt;一般做法&lt;/h3&gt;&lt;p&gt;一般的做法很简单&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2017/07/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/22/选择排序/</id>
    <published>2017-07-22T14:17:57.000Z</published>
    <updated>2017-07-22T14:18:45.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次从无序区选择一个最小的放大有序区的最后</p><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p></li><li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//选择排序</div><div class="line">void SekectSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        int min = a[i];</div><div class="line">        int loc = i;</div><div class="line">        //寻找最小的元素</div><div class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</div><div class="line">            if (a[j] &lt; min) &#123;</div><div class="line">                min = a[j];</div><div class="line">                loc = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //把最小的元素放在有序区后面</div><div class="line">        int temp = a[loc];</div><div class="line">        a[loc] = a[i];</div><div class="line">        a[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;每次从无序区选择一个最小的放大有序区的最后&lt;/p&gt;
&lt;p&gt;设数组为a[0…n-1]。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始时，数组全为无序区
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2017/07/22/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/22/希尔排序/</id>
    <published>2017-07-22T09:09:32.000Z</published>
    <updated>2017-07-22T09:09:54.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>希尔排序的实质是分组插入排序，又称缩小增量排序。</p><p>该方法的基本思想是：</p><ol><li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的），对这些子序列分别进行直接插入排序</li><li>依次缩减增量再进行排序</li><li>待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li></ol><p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在我们要将这样一个数组排序，一共有10个元素</p><p><img src="https://i.loli.net/2017/07/20/59701858e5e96.png" alt=""> </p><ul><li><strong>第一次 增量 gap = 10/2 = 5</strong></li></ul><p><img src="https://i.loli.net/2017/07/20/59701a2be3ef5.png" alt=""> </p><p>整个数组被分成了5个子数组，分别是[49,13]，[38,27]，[65,49]，[97,55]，[26,4]<br>然后对这五个子数组进行插入排序，得到下面结果</p><p><img src="https://i.loli.net/2017/07/20/59701b9f8c66f.png" alt=""> </p><ul><li><strong>第二次 增量 gap = 5/2 = 2</strong></li></ul><p><img src="https://ooo.0o0.ooo/2017/07/20/59701bfe5a204.png" alt=""> </p><p>这次我们把整个数组分成了两个子数组，分别是[13,49,4,38,97],[27,55,49,65,26]<br>对这个两个子数组排序，结果如下：<br><img src="https://i.loli.net/2017/07/20/59701d3805da5.png" alt=""> </p><ul><li><strong>第三次 增量 gap = 2/2 = 1</strong><br>此时整个数组已经接近有序，对整个数组进行全排列</li></ul><p><img src="https://i.loli.net/2017/07/20/59701e32a8bb1.png" alt=""> </p><p>最终得到数组有序</p><p><img src="https://ooo.0o0.ooo/2017/07/20/59701fd2c547a.png" alt=""> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; delta; i++) &#123;//分成了delta个子序列</div><div class="line">            //对每个子序列进行插入排序</div><div class="line">            for (int j = i + delta; j &lt; len; j = j + delta) &#123;</div><div class="line">                int jj = j - delta;</div><div class="line">                int temp = a[j];</div><div class="line">                while ((a[jj] &gt; temp)&amp;&amp;(jj&gt;=0)) &#123;</div><div class="line">                    a[jj + delta] = a[jj];</div><div class="line">                    jj -= delta;</div><div class="line">                &#125;</div><div class="line">                //插入</div><div class="line">                a[jj + delta] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">白话经典算法系列</a>原文是这么说的</p><blockquote><p>很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较…….。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。</p></blockquote><p>我理解了一下，思路就是把在序列中提取子序列的过程简化了，我们可以从第gap个元素开始，向后遍历到序列末尾，可以个元素都跟其所在的子序列中位于它前面的数字做插入排序，最终就会得到一个有序数列了~</p><p>画个图表示一下吧，还是刚才那个序列，比如说此时进行到第二次排序了，gap=2的情况：</p><p>从a[2]开始遍历，此时a[2]所在的子序列为[a[0],a[2],a[4],a[6],a[8]]，需要将a[2]和位于它前面的a[0]比较，插入到合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731239a3cd2.png" alt=""> </p><p>指针后移一位， 同上此时a[3]所在的子序列为[a[1],a[3],a[5],a[7],a[9]]，需要将a[3]和位于它前面的a[1]比较，插入合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731264440fc.png" alt=""> </p><p>接下来指针指向a[4],此时需要将a[4]和位于它前面的a[2]、a[0]比较，插入合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731282140fd.png" alt=""> </p><p>下面重复上面的步骤：</p><p><img src="https://i.loli.net/2017/07/22/597312a912c5c.png" alt=""> </p><p><img src="https://i.loli.net/2017/07/22/597312ca290dc.png" alt=""> </p><p>此处省略剩余步骤…..最终可以将数组排列至有序状态</p><p>现在可以上代码了~<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = delta; i &lt; len; i++) &#123;//遍历</div><div class="line">            //对该元素子前面的子数组进行插入排序</div><div class="line">            int temp = a[i];</div><div class="line">            int jj = i - delta;</div><div class="line">            while ((jj &gt;=0)&amp;&amp;(a[jj]&gt;temp))&#123;</div><div class="line">                swap(a[jj], a[jj+delta]);</div><div class="line">                jj -= delta;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;希尔排序的实质是分组插入排序，又称缩小增量排序。&lt;/p&gt;
&lt;p&gt;该方法的基本思想是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先将整个待排元素序列分割成若
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2017/07/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/20/插入排序/</id>
    <published>2017-07-20T01:47:19.000Z</published>
    <updated>2017-07-22T08:21:53.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p></li><li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><p>在查找某元素应该插入到前面有序序列的位置时，我们可以采用边交换边插入的方式，直到无需交换</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                int temp = a[j];</div><div class="line">                a[j] = a[j - 1];</div><div class="line">                a[j - 1] = temp;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中交换元素部分可以调用STL中的swap函数实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//插入排序</div><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                swap(a[j], a[j - 1]);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2017/07/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/20/冒泡排序/</id>
    <published>2017-07-19T16:54:24.000Z</published>
    <updated>2017-07-19T16:54:57.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>依次比较相邻的两个数据，如果前面的比后面的大，就将其交换</li><li>这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置</li><li>重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        for (int j = 0; j &lt; len -1-i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来可以优化一下，上面的程序中一共进行了N轮比较，其实如果有一趟没有发生交换就说明这时候每两个相邻数据都已经呈现前边比后边小的状态了，此时已经达到有序状态了，所以后面就无需再继续比较了</p><h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int flag = 1;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        int flag = 0;//用来记录本轮是否发生交换</div><div class="line">        for (int j = 0; j &lt; len - 1 - i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = 1;//本轮发生交换了</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 0) &#123;//如果本轮未发生交换，跳出</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还可以进一步优化，假设有100个数的数组，只有前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。</p><p>一般地，冒泡排序在进行过程中，也会出现后面已经排好了的情况，所以如果记录一下有序的位置，下一次就可以不用向后遍历了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int k ;//用于记录从那个数据开始之后的数据为</div><div class="line">    int flag = len-1;//用于几率从哪个数据开始之后的数据有序</div><div class="line">    while (flag &gt; 0) &#123;</div><div class="line">        k = flag;//计算到k之前</div><div class="line">        flag = 0;//用于记录本轮是否有交换</div><div class="line">        for (int j = 0; j &lt; k; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = j;//本轮交换了，更新交换位置</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总结一下冒泡排序的关键点就是相邻元素两两比较交换，执行N轮，如果有某一轮没有发生交换说明已经有序，停止；记录下每一轮交换停止的位置，这之后的数据时有序的，下一轮无需考察。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;依次比较相邻的两个数据，如果前面的比后面的大，就将其交换&lt;/li&gt;
&lt;li&gt;这样交换一轮之后，整个序列中最大的就“沉”到了最后面
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2017/07/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/17/快速排序/</id>
    <published>2017-07-17T06:21:23.000Z</published>
    <updated>2017-07-18T07:17:26.877Z</updated>
    
    <content type="html"><![CDATA[<p>感谢@MoreWindows的白话经典算法系列，浅显易懂，让我终于看懂了快速排序，总结一下</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>从数列中选择一个作为<strong>基准数</strong></li><li><strong>分区</strong>操作：把比基准数小的都排在基准数的左边，比基准数大的都排在基准数的右边</li><li>对基准数的左边和右边<strong>分治</strong>排序</li></ol><h3 id="具体实现：挖坑填数-分治法"><a href="#具体实现：挖坑填数-分治法" class="headerlink" title="具体实现：挖坑填数+分治法"></a>具体实现：挖坑填数+分治法</h3><p>这里结合个实际例子说明</p><p><img src="https://i.loli.net/2017/07/18/596da83e7801a.png" alt=""> </p><p>根据上面的步骤，选取第一个作为<strong>基准数</strong>，接下来我们需要把比它小的数字放到它的左边，比它大的数字放到它的右边，这里就需要重点注意<strong>挖坑填数</strong>的方法了，划重点！！！</p><p><img src="https://i.loli.net/2017/07/18/596da86bf0f53.png" alt="">  temp=72</p><p>我们先把基准数72保存到变量temp中，这时候就相当于在数组的第一个位置上挖了一个“坑”，如果我们在后边发现有比temp小的数字，就可以把那个比较小的数字填到这个空缺的“坑”里了。</p><p><img src="https://i.loli.net/2017/07/18/596dada8c0f65.png" alt=""> </p><p>我们定义一个从后向前遍历的指针j，发现a[8]位置上的48比72小，所以我们要把48放到前面去，填补之前72留下的空缺.</p><p><img src="https://i.loli.net/2017/07/18/596da9ed5c6da.png" alt=""> </p><p>这时候原来存放48的这个位置就空了出来，有了一个新的“坑”，此时指针i向后遍历，如果找到比temp大的数字，便可以填补之前的48留下的坑了。恩，我们找到了a[3]位置上的88，将他填补到之前48留下来的“坑”里。</p><p><img src="https://i.loli.net/2017/07/18/596dabf678c11.png" alt=""> </p><p>接下来继续重复上面的过程，先从后向前找到比基准值小的，填补在前面的“坑”里，然后再从前向后找比基准值大的，填补刚才空出来的“坑”。直到最终两个指着相遇。</p><p><img src="https://i.loli.net/2017/07/18/596dacb08d160.png" alt=""> </p><p>而此时空缺的位置，恰好就是基准值temp的位置。将基准值填入空缺位置，至此就完成了一次分区的操作，此时基准数前面的数字都比基准数小，后面的都比基准数大。</p><p>接下来就是对基准数前后两段数组分而治之，采用递归调用的思想，将整个数组调整至有序状态。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void quiksort(vector&lt;int&gt; &amp;vec, int i, int j) &#123;</div><div class="line">    if (i &lt; j) &#123;</div><div class="line">        int temp = vec[i];//存储基准值</div><div class="line">        int left = i;</div><div class="line">        int right = j;</div><div class="line">        while (left &lt; right) &#123;</div><div class="line">            //后指针向前遍历，寻找比基准值小的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[right] &gt;= temp) &#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[left] = vec[right];</div><div class="line">            //前指针向后遍历，寻找比基准值大的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[left] &lt;= temp) &#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[right] = vec[left];</div><div class="line">        &#125;</div><div class="line">        vec[right] = temp;</div><div class="line">        //递归调用</div><div class="line">        quiksort(vec, i, right - 1);</div><div class="line">        quiksort(vec, right + 1, j);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec = &#123;&#125;;</div><div class="line">    scanf_s(&quot;%d&quot;, &amp;n);</div><div class="line">    while (n &gt; 0) &#123;</div><div class="line">        scanf_s(&quot;%d&quot;, &amp;temp);</div><div class="line">        vec.push_back(temp);</div><div class="line">        n--;</div><div class="line">    &#125;</div><div class="line">    quiksort(vec, 0, vec.size() - 1);</div><div class="line">    for (int i = 0; i &lt; vec.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; vec[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最坏时间复杂度：$O(n^2)$</li><li>期望时间复杂度：$O(n\log(n))$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感谢@MoreWindows的白话经典算法系列，浅显易懂，让我终于看懂了快速排序，总结一下&lt;/p&gt;
&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;h3 id=&quot;步骤：&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>今日头条-算法岗</title>
    <link href="http://yoursite.com/2017/07/17/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E7%AE%97%E6%B3%95%E5%B2%97/"/>
    <id>http://yoursite.com/2017/07/17/今日头条-算法岗/</id>
    <published>2017-07-17T06:06:32.000Z</published>
    <updated>2017-07-18T03:39:02.725Z</updated>
    
    <content type="html"><![CDATA[<p>昨天去头条面试了，意料之中的挂了23333</p><p>没怎么考察算法，就做了个自我介绍，简单介绍了一下项目，问了问ffm的原理，跟fm比起来有哪些优势</p><p>紧接着上了两道算法题，两道题都很基础，但自己真心不扎实，难怪人家看不上==</p><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><p>给一个句子，把句子翻转但单词不翻转<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:&quot;I am a coder&quot;</div><div class="line">output:&quot;coder a am I&quot;</div></pre></td></tr></table></figure></p><p>对字符串、字符数组这里一直都很懵逼，看到题就知道自己写不出来了，挣扎了一会投降了==<br>而且我的重点都放在了要怎么读进来啊！不会读进来啊！怎么读啊！要好好看c++了啊喂！</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>先翻转整个句子，再把每一个单词翻转过来。翻转字符串的时候前后对换，能减少一半的时间复杂度</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//反转字符串</div><div class="line">void ReverseString(char *begin, char *end) &#123;</div><div class="line">    while (begin &lt; end) &#123;</div><div class="line">        char temp = *begin;</div><div class="line">        *begin = *end;</div><div class="line">        *end = temp;</div><div class="line">        begin++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//反转句子</div><div class="line">char* ReverseSentance(char *ch) &#123;</div><div class="line">    char *begin = ch;</div><div class="line">    char *end = ch;</div><div class="line"></div><div class="line">    while (*end != &apos;\0&apos;)</div><div class="line">        end++;</div><div class="line">    end--;</div><div class="line">    //反转整个句子</div><div class="line">    ReverseString(begin, end);</div><div class="line"></div><div class="line">    //逐个反转单词</div><div class="line">    begin = ch;</div><div class="line">    end = ch;</div><div class="line">    while ((*begin != &apos;\0&apos;)) &#123;</div><div class="line">        while ((*end != &apos; &apos;) &amp;&amp; (*end != &apos;\0&apos;)) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        ReverseString(begin, end - 1);</div><div class="line">        if (*end != &apos;\0&apos;) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        begin = end;</div><div class="line">    &#125;</div><div class="line">    return ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    /*fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    char str[1024];</div><div class="line">    int i = 0;</div><div class="line">    while ((str[i] = getchar()) != &apos;\n&apos;) &#123;</div><div class="line">        i++;</div><div class="line">    &#125; </div><div class="line">    int length = sizeof(str)/sizeof(str[0]);</div><div class="line">    char *array = str;*/</div><div class="line">    char a[] = &quot;I am a coder&quot;;</div><div class="line">    char *array = a;</div><div class="line">    int length = sizeof(a) / sizeof(a[0]);</div><div class="line">    cout &lt;&lt; length;</div><div class="line">    array = ReverseSentance(array);</div><div class="line">    for (int i = 0; i &lt; length-1; i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *array;</div><div class="line">        array++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个有序数组和一个数字，统计该数字在数组中出现的次数</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:3</div><div class="line">1 2 3 3 4 5 6</div><div class="line">output:2</div></pre></td></tr></table></figure><p>我想到了用二分查找来解决，然后我竟然找到了这个数字时候左右分别递归再找==</p><p>其实找到了之后就向左向右遍历就可以了，因为数组本身已经是有序的了嘛。。。。</p><h3 id="关键思路"><a href="#关键思路" class="headerlink" title="关键思路"></a>关键思路</h3><p><strong>二分查找该数字是否在数组中出现，如果找到了就分别向左侧和右侧探测连续出现了几次</strong></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//二分查找</div><div class="line">int midfind(vector&lt;int&gt; &amp;vec,int head,int tail,int n) &#123;</div><div class="line">    if (head &gt; tail)</div><div class="line">        return -1;</div><div class="line">    else &#123;</div><div class="line">        int mid = (head + tail) / 2;</div><div class="line">        if (vec[mid] == n)</div><div class="line">            return mid;</div><div class="line">        else if (vec[mid] &lt; n) &#123;</div><div class="line">            return midfind(vec, mid + 1, tail, n);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return midfind(vec, head, mid - 1, n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec;</div><div class="line">    fscanf(fin,&quot;%d&quot;,&amp;n);</div><div class="line">    while (fscanf(fin, &quot;%d&quot;,&amp;temp)!=EOF) &#123;</div><div class="line">        vec.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    int len = vec.size();</div><div class="line">    int pos = midfind(vec, 0, len - 1, n);</div><div class="line">    if (pos == -1)</div><div class="line">        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</div><div class="line">    else &#123;</div><div class="line">        int pos1 = pos - 1;</div><div class="line">        int pos2 = pos + 1;</div><div class="line">        int sum = 1;</div><div class="line">        while ((pos1&gt;=0) &amp;&amp; (vec[pos1]==n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos1--;</div><div class="line">        &#125;</div><div class="line">        while ((pos2&lt;len) &amp;&amp; (vec[pos2] == n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos2++;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>立flag 好好刷算法了要！！！！！基础很重要！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天去头条面试了，意料之中的挂了23333&lt;/p&gt;
&lt;p&gt;没怎么考察算法，就做了个自我介绍，简单介绍了一下项目，问了问ffm的原理，跟fm比起来有哪些优势&lt;/p&gt;
&lt;p&gt;紧接着上了两道算法题，两道题都很基础，但自己真心不扎实，难怪人家看不上==&lt;/p&gt;
&lt;h2 id=&quot;字符
      
    
    </summary>
    
      <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimal Real-Time Bidding for Display Advertising论文笔记</title>
    <link href="http://yoursite.com/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising论文笔记/</id>
    <published>2017-07-17T06:04:26.000Z</published>
    <updated>2017-07-17T06:05:09.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014"><a href="#Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014" class="headerlink" title="Optimal Real-Time Bidding for Display Advertising——KDD2014"></a>Optimal Real-Time Bidding for Display Advertising——KDD2014</h2><p>参考着师兄的博客<a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a>，仔细读完了这篇paper，总结一下，方便日后回顾</p><p>ps:十分感谢师兄@<a href="http://blog.csdn.net/breada" target="_blank" rel="external">面包包包包包包</a>，看了师兄的三篇博客可算是入了门，不然真是一头雾水hold不住啊</p><p>这篇文章的核心就是提出了一个<strong>非线性的竞价函数</strong>，相比于KDD2012的<a href="http://cwds.uw.edu/sites/default/files/p804.pdf" target="_blank" rel="external">《Bid Optimizing and Inventory Scoring in Targeted Online Advertising》</a>中提出的线性竞价函数，本文认为出价应该与点击率、转化率等指标具有<strong>非线性关系</strong></p><p>首先，文章将现实问题用数学方法建模为限制条件下的优化问题，并通过拉格朗日乘子法，求得出价策略的数学表达式（非线性竞价函数）；然后利用iPinYou数据拟合出价策略中的参数；最后，做实验验证结果，发现了一个有意思的结论：相比少量高品质的展示机会，那些大量低品质的展示机会同样可以具有较好的广告效果，值得出价。这个发现对于那些预算不够，同时又想做广告的小广告主来说，简直就是福音。</p><h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><h3 id="选择合适的出价策略，在预算的限制下实现广告效果最大化"><a href="#选择合适的出价策略，在预算的限制下实现广告效果最大化" class="headerlink" title="选择合适的出价策略，在预算的限制下实现广告效果最大化"></a>选择合适的出价策略，在预算的限制下实现广告效果最大化</h3><p>把这句话用数学的形式表达出来就是下面的样子：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p><p>看起来来有点复杂，其实很简单，两个式子，第一行是优化目标：寻找似的收益最大化的出价函数b()</p><p>第二行就是预算约束，就是花的钱不能超过预算约束B</p><p>模型中涉及的具体符号定义如下：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e0b0486d.png" alt=""> </p><h3 id="结合着具体的符号定义，可以解释一下之前建立的数学模型了"><a href="#结合着具体的符号定义，可以解释一下之前建立的数学模型了" class="headerlink" title="结合着具体的符号定义，可以解释一下之前建立的数学模型了"></a>结合着具体的符号定义，可以解释一下之前建立的数学模型了</h3><p>$dx$：x代表一次bid request，也就是一次竞价请求的特征向量，是ADX发给DSP的竞价请求“标识XXX,男性，20-25岁，跑鞋爱好者，广告位为首页”，即一次广告展示机会。之所以是dx而不是x，是因为我们关注的是整个广告推广计划中所有的竞价过程，而非某一次竞价。</p><p>$p_x(x)$：广告展示机会的概率密度分布，我的理解是在全网所有的竞价中，满足我DSP要求的、或者是我能收到的bid request所占的比例。因此，$p_x(x)*dx$的物理意义是我能收到的展示机会。</p><p>$\theta(x)$：θ是赢得此次竞价所能带来的收益(KPI)，本文用CTR来衡量，CTR越高，收益就越高。</p><p>$b(\theta(x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我所出的价格bid。</p><p>$\omega(b(\theta(x),x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我的出价bid能获胜的概率是多少。因此，$\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$表示对于本次我所收到的这个展示机会来说，在该机会能带来收益（如CTR,CVR等）为θ(x)，我出价为bid的情况下，我能打败对手获得此次展示机会的概率。</p><p>以$\theta(x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会后，所能获得的收益。</p><p>以$b(\theta(x),x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会所花费的钱。</p><p>$N_T$：生存时间T内广告推广活动中所有的bid request数量</p><p>总之还是那句话：<strong>选择合适的出价策略，在预算的限制下实现广告效果最大化</strong></p><h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p><p>经过一系列的化简，我们可以把模型的函数表达式简化成下面的样子，具体过程参考原文</p><p><img src="https://ooo.0o0.ooo/2017/05/11/591426f75561b.png" alt=""> </p><p>现在参数就只有$\theta$了，也就是CTR，接下来要怎么求解最大值呢？这是要一个带约束条件的最优化问题，作者是用了拉格朗日乘子法来解决的</p><p>通过拉格朗日乘子法，我们可以将不等式乘一个参数$\lambda$后和等式写进一个公式里(化简过程已省略)，得到如下结果:</p><p><img src="https://ooo.0o0.ooo/2017/05/11/591427c023edb.png" alt=""> </p><p>然后对其求导，令导数为0得到：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142a08a7855.png" alt=""> </p><p>进而求得出价函数$b(\theta)$与赢得竞价概率之间的函数关系为：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142a857ef5e.png" alt=""> </p><p>也就是说，我们想要的出价函数b()与胜率函数w()有关，那我们就来看看他们之间到底有什么关系。作者利用数据集绘制出二者之间的关系如图：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142bedeeacb.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/05/11/59142c7551aaa.png" alt=""> </p><p>我们发现这个函数走势很像$y=\frac{x}{c+x}$啊！！！对，作者也发现了，于是乎就有了下面的非线性竞价函数：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142c9e5260d.png" alt=""> </p><p>然后把（9）带回到（8）中就求得了我们梦寐以求的非线性出价函数：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142ce77aa66.png" alt=""> </p><p>画个图看看上面的两个函数走势吧：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142d47bf56d.png" alt=""> </p><p>还是很符合实际情况的，点击率越高，出价也就越高，出价越高，赢得竞价的可能行也就越高</p><p>到此，我们就已经把问题的数学转化和模型求解弄完了，那剩下的关键问题就是要<strong>求解两个参数：$\lambda$和$c$了</strong></p><p>可以看出来$c$是可以直接根据历史数据拟合出来的，利用最小二乘法使得均方误差最小即可</p><p>难点在于$\lambda$的求解，文章采用的方法是：<strong>通过不断调整以获得在测试数据中得到最大收益（点击量）来获得</strong></p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><ol><li>利用iPinYou实时竞价数据，每一条数据是一个竞价请求，包含其特征、赢得竞价的价格、用户反馈（点击or转化）</li><li>将数据集按2:1分割分别作为训练和测试集</li><li>流程：用训练数据训练出点击率预估模型和出价函数，根据测试数据特征，计算出一个出价，如果超过数据集中的真实出价，则认为竞价成功</li><li>根据真是数据集中的情况进行模型评估</li><li>为了对比，将预算分别设置为原始预算的1/64,1/32,1/16,1/8,1/4,1/2进行实验</li><li>对比策略：按固定值出价，随机出价，按最大eCPC出价，线性出价</li></ol><p>经过一系列的实验，文章得出了下面的结论：</p><ol><li><strong>非线性出价策略赢得的总点击量大，而且单次点击所产生的费用低</strong></li><li><strong>预算约束越严格的情况下，相比于线性出价策略，非线性出价策略对于点击量的提升越大</strong></li><li>预算越低，$\lambda$的最优解的值越大，出价相对也越低，但是对于低价值的展示机会，非线性出价策略的出价比线性出价策略的出价略高。如下图所示</li></ol><p><img src="https://ooo.0o0.ooo/2017/05/11/59145d12c4aea.png" alt=""> </p><p>我们可以很直观的看出，我们所得到的出价策略是一个非线性的。横坐标θ代表了广告展示计划的品质，ORTB会对低价值的展示机会出高价，这样的结果能为我们带来什么，谁会去要那些低价值的展示机会呢？我们来看下面这张图</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59145cfc4d8d4.png" alt=""> </p><p>在此图中，我们盯着一条曲线看，比如蓝色的(1/32)。随着λ增加，收获的点击量是增加的，意味着λ越高，我们的收益越高。对于我们获得的出价策略而言，λ越高，我们的出价是越低的，也就意味着这次展示机会的价值是很低的。这样的结果值得我们深思，我们以为低价值的展示机会是不值钱的，但数据说明，这些看似不值钱的展示所能带来的回报还算不错。特别地，在λ=1e-05时三条曲线的几乎重合，而红色代表有钱的广告主，蓝色代表穷广告主，虽然预算差了16倍，但是获得的收益是相同的，这个结论对于预算有限的小广告主而言，是个天大的好消息：虽然我们钱不多，但只要我们出价合适，依然可以收获很好的广告效果，四两拨千斤，极大的调动了小广告主参加程序化交易的积极性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014&quot;&gt;&lt;a href=&quot;#Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014&quot; cl
      
    
    </summary>
    
      <category term="RTB" scheme="http://yoursite.com/categories/RTB/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】169. Majority Element</title>
    <link href="http://yoursite.com/2017/04/10/%E3%80%90leetcode%E3%80%91169-Majority-Element/"/>
    <id>http://yoursite.com/2017/04/10/【leetcode】169-Majority-Element/</id>
    <published>2017-04-10T09:29:01.000Z</published>
    <updated>2017-04-10T09:35:27.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code>times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个数组长度为n，其中有一个元素出现的次数大于<code>⌊ n/2 ⌋</code>，现在我们要找出这个元素</p><h2 id="moore-voting算法"><a href="#moore-voting算法" class="headerlink" title="moore-voting算法"></a>moore-voting算法</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>找出一对不同的元素就去掉它们，最后剩下的一定是所找的元素。</p><p>需要<strong>两个指针</strong>和<strong>一个计数器</strong>，其中一个指针指向当前出现次数最大的元素，另一个向后遍历，count存储当前出现次数最大的元素出现的次数</p><ol><li>当用于遍历的指针2指向元素和指针1指向的元素相等时，count加1，否则减1</li><li>当count减至0的时候，指针1需要向后移动到指针2的位置，指针2继续向后遍历</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    int len = nums.size();</div><div class="line">    int result = 0;</div><div class="line">    int count = 1;</div><div class="line">    int temp = 0;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        if (count != 0) &#123;</div><div class="line">            if (nums[i] == nums[temp])</div><div class="line">                count++;</div><div class="line">            else</div><div class="line">                count--;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            temp = i;</div><div class="line">            count = 1;</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">    return nums[temp];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb46e839db1.png" alt=""> </p><h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h3><p>把数字都转化为二进制处理。如果majority element第i位上的数字是1，那么所有数字第i位上为1的总个数一定会大于<code>⌊ n/2 ⌋</code>,反之，如果majority element第i位上的数字是0，那么所有数字第i位上为0的总个数一定会大于<code>⌊ n/2 ⌋</code></p><p>所以，如果我们统计所有的n个数字的第i位上1(或者0)的个数，看是否大于<code>⌊ n/2 ⌋</code>，就可以确定majority element第i位到底是0还是1了</p><p>int型数据一共有32bit，所有需要计算32个二进制位。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i,j,count,major=0;</div><div class="line">        for(i=0;i&lt;32;i++)</div><div class="line">        &#123;</div><div class="line">            for(j=0,count=0;j&lt;nums.size();j++)</div><div class="line">            &#123;</div><div class="line">                if((nums[j]&gt;&gt;i&amp;1)==1)</div><div class="line">                    count++;</div><div class="line">            &#125;</div><div class="line">            if(count&gt;nums.size()/2)</div><div class="line">                major+=(1&lt;&lt;i);</div><div class="line">        &#125;</div><div class="line">        return major;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb4bc45530f.png" alt=""> </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在用bit manipulation方法时，在已经确定了定majority element第i位到底是0还是1之后恢复majority element的时候，遇到了一个问题，查了很久，在这里总结一下</p><p>一开始我用了下面这样的方法恢复majority element</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (int i = 0; i &lt; 32; i++) &#123;</div><div class="line">    if (countones[i] &gt; len / 2)</div><div class="line">        result += pow(2, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是我们平时手算二进制转化成10进制的方法，但是发现遇到负数的时候就不能正确恢复了==</p><p>然后就查啊查，发现：</p><p><strong>int类型默认是signed的</strong>，也就是说带符号的，32bit中<strong>最高的那一位是用来表示符号的，最高位是0表示非负数，最高位是1表示负数</strong>，所以能够表示的整数的范围是$-2^{31}-1$~$2^{31}-1$。关于负数的二进制表示，之前写过一篇博客 <a href="https://siyaozhang.github.io/2017/04/04/c-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9C-%E2%80%9D/" target="_blank" rel="external">负数的二进制表示</a>，可以看出来确实负数的二进制表示最高位是1</p><p>所以用上面的方法<strong>不断叠加</strong>$2^i$（<strong>正数</strong>）是<strong>永远都不会恢复到原来的负数</strong>的，因为最高位永远都不会由0变为1，而且$2^{31}$已经超过int型的表示范围了。</p><p>因此，还是要<strong>用bit运算根据各个位是0还是1来恢复出原来的majority element</strong>，这样无论是正是负就都不会出错了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority elem
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="bit manipulation" scheme="http://yoursite.com/tags/bit-manipulation/"/>
    
  </entry>
  
</feed>
