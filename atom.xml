<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-10T09:08:29.658Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【九章系统设计】爬虫系统与搜索建议系统</title>
    <link href="http://yoursite.com/2018/03/10/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/03/10/【九章系统设计】爬虫系统与搜索建议系统/</id>
    <published>2018-03-10T09:08:29.000Z</published>
    <updated>2018-03-10T09:08:29.658Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法终极大总结</title>
    <link href="http://yoursite.com/2018/03/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/10/排序算法终极大总结/</id>
    <published>2018-03-10T08:47:53.000Z</published>
    <updated>2018-03-10T13:26:08.105Z</updated>
    
    <content type="html"><![CDATA[<p>常见的排序算法有以下几种：</p><ul><li>递归性排序<ul><li><a href="/2017/07/23/归并排序/" title="归并排序">归并排序</a>：归并排序的主要思想是分治，也就是先把数组分成两部分，当两部分都有序时，然后再将两部分进行二路归并。需要注意的是归并排序的时间复杂度分析方法，就是画出$T(n) = 2T(n/2) + cn$ 的递归树，并计算最终时间复杂度。但是要注意的是，归并排序在进行二路归并时，可能会产生额外的空间复杂度。</li><li><a href="/2017/07/17/快速排序/" title="快速排序">快速排序</a>：快速排序的思路也是分治，但分治之前需要选择一个主元作为基准，将主元放在应该在的位置，并且数组左边比主元小，右边比主元大。这样如果当左边有序和右边有序时，整个数组就有序了。假设主元位置为i，快速排序复杂度为$T(n) = T(i) + T(n - i - 1) + cn$ 。由于i的不确定性导致快速排序的最坏情况下时间复杂度为$T(n) = T(n-1) + T(0) +  cn = O(n^2)$ ，而平均情况下是$T(n) = 2T(\frac{n-1}{2}) +cn = nlogn$。 快速排序不需要额外的空间。</li></ul></li><li>非递归型排序<ul><li><a href="/2017/07/20/插入排序/" title="插入排序">插入排序</a>：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</li><li><a href="/2017/07/22/选择排序/" title="选择排序">选择排序</a>：每次从无序区选择一个最小的放大有序区的最后</li><li><a href="/2017/07/20/冒泡排序/" title="冒泡排序">冒泡排序</a>：依次比较相邻的两个数据，如果前面的比后面的大，就将其交换；这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置；重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li><li><a href="/2017/07/22/希尔排序/" title="希尔排序">希尔排序</a>：分组插入排序</li></ul></li><li>非比较排序：非比较排序的时间复杂度可以达到$O(n)$ 。<ul><li><a href="/2018/02/08/计数排序、基数排序、桶排序/" title="计数排序、基数排序、桶排序">计数排序、基数排序、桶排序</a><ul><li>计数排序：已知最大值K。利用数组<code>int[K]</code> 统计每个数字的小于等于它的个数，将这个个数作为这个数字的idx</li><li>基数排序：分别对数字的个位、十位、…、d位依次进行计数排序</li><li>桶排序：将数字分别放入桶里。</li></ul></li></ul></li></ul><p>因此我们做出如下总结：</p><div class="table-container"><table><thead><tr><th>排序方法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>其它要点</th></tr></thead><tbody><tr><td>归并</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>递归树</td></tr><tr><td>快排</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>快速选择  <br>快排优化算法<br></td></tr><tr><td>插入、<br>选择、<br>冒泡、<br>希尔</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td></td></tr><tr><td>计数排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(K)$</td><td>已知数组最大值K</td></tr><tr><td>基数排序</td><td>$O(d(n+10))$</td><td>$O(d(n+10))$</td><td>$O(10)$</td><td></td></tr><tr><td>桶排序</td><td>$O(n)$</td><td></td><td>$O(n)$</td><td>大数排序<br></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见的排序算法有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归性排序&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2017/07/23/归并排序/&quot; title=&quot;归并排序&quot;&gt;归并排序&lt;/a&gt;：归并排序的主要思想是分治，也就是先把数组分成两部分，当两部分都有序时，然后再将两部分进行二路
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【面经】开发相关基础知识</title>
    <link href="http://yoursite.com/2018/03/09/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/09/【面经】开发相关基础知识/</id>
    <published>2018-03-09T15:46:50.000Z</published>
    <updated>2018-03-09T15:46:50.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="亚马逊"><a href="#亚马逊" class="headerlink" title="亚马逊"></a>亚马逊</h2><h3 id="1-JDK和JRE、JVM的区别是什么"><a href="#1-JDK和JRE、JVM的区别是什么" class="headerlink" title="1. JDK和JRE、JVM的区别是什么"></a>1. JDK和JRE、JVM的区别是什么</h3><p><strong>JRE（Java运行时环境）： Java Runtime Environment</strong></p><p>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</p><p><strong>JDK（Java 开发工具包）：Java Development Kit</strong></p><p>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。</p><p><strong>JVM（Java 虚拟机）：Java Virtual Machine</strong></p><p>JVM是Java编程语言的核心。当我们运行一个程序时，JVM负责将字节码转换为特定机器代码。JVM也是<strong>平台特定</strong>的，并提供核心的Java方法，例如内存管理、垃圾回收和安全机制等。JVM 是可定制化的，我们可以通过Java 选项(java options)定制它，比如配置JVM 内存的上下界。JVM之所以被称为虚拟的是因为它提供了一个不依赖于底层操作系统和机器硬件的接口。这种独立于硬件和操作系统的特性正是Java程序可以一次编写多处执行的原因。</p><p><strong>JDK, JRE 和JVM的区别</strong></p><ul><li>JDK是用于开发的而JRE是用于运行Java程序的。</li><li>JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。</li><li>JVM是Java编程语言的核心并且具有平台独立性。</li></ul><h3 id="2-常见设计原则和设计模式"><a href="#2-常见设计原则和设计模式" class="headerlink" title="2. 常见设计原则和设计模式"></a>2. 常见设计原则和设计模式</h3><p>6大设计原则：</p><ol><li><strong>单一职责原则</strong>：就是开发人员经常说的”高内聚，低耦合”。也就是说，每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则。</li><li><strong>开闭原则</strong>：一个对象对扩展开放，对修改关闭。也就是说，对类的改动是通过增加代码进行的，而不是修改现有代码。软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。</li><li><strong>里氏替换原则</strong>：在任何父类出现的地方都可以用它的子类来替代。也就是说，同一个继承体系中的对象应该有共同的行为特征。</li><li><strong>依赖注入原则</strong>：要依赖于抽象，不要依赖于具体实现。也就是说，在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。</li><li><strong>接口分离原则</strong>：不应该强迫程序依赖它们不需要使用的方法。也就是说，一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。</li><li><strong>迪米特原则：</strong>一个对象应当对其他对象尽可能少的了解。也就是说，降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用</li></ol><p>常见设计模式:</p><ol><li><p>简单工厂模式</p><p> · 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</p><p>​        · 优点：客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性。</p><p>​        · 缺点：需要额外的编写代码，增加了工作量。</p></li><li><p>单例设计模式</p><p> 单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。</p><p>​        · 优点：在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</p><p>​        · 缺点：没有抽象层，因此扩展很难。职责过重，在一定程序上违背了单一职责</p></li><li><p>模板设计模式</p><p>· 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现</p><p>​        · 优点：使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</p><p>​        · 缺点：如果算法骨架有修改的话，则需要修改抽象类</p></li></ol><h3 id="2-volatile关键字作用是什么"><a href="#2-volatile关键字作用是什么" class="headerlink" title="2. volatile关键字作用是什么"></a>2. volatile关键字作用是什么</h3><p>英文翻译：不稳定的</p><p>弱同步机制</p><p>在多线程的化境下，Volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>进程线程</p><p>垃圾回收</p><p>hashmap原理、HashMap为什么不是线程安全的</p><p>tcp udp 区别</p><p>如何预防死锁</p><p>描述下tcp三次握手</p><p>函数的参数存在哪里 为什么存在栈里</p><p>数据量过大内存存不下了怎么办</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;亚马逊&quot;&gt;&lt;a href=&quot;#亚马逊&quot; class=&quot;headerlink&quot; title=&quot;亚马逊&quot;&gt;&lt;/a&gt;亚马逊&lt;/h2&gt;&lt;h3 id=&quot;1-JDK和JRE、JVM的区别是什么&quot;&gt;&lt;a href=&quot;#1-JDK和JRE、JVM的区别是什么&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【本科毕设】pub/sub框架</title>
    <link href="http://yoursite.com/2018/03/09/%E3%80%90%E6%9C%AC%E7%A7%91%E6%AF%95%E8%AE%BE%E3%80%91pub-sub%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/03/09/【本科毕设】pub-sub框架/</id>
    <published>2018-03-09T13:58:01.000Z</published>
    <updated>2018-03-09T13:58:01.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-21-59-34.png" alt=""> </p><p>本文中研究的问题为位置感知的发布/订阅框架设计与实现。订阅者以订阅（subscription）的形式向发布/订阅系统注册，表达对特定事件的兴趣；发布者发布消息到发布/订阅系统；发布/订阅系统充当订阅者和发布者的中介，负责订阅的管理，并以通知的形式发送消息到感兴趣的订阅者。</p><p>与传统的基于文本的发布订阅问题不同，在我们所研究的问题中，发布者发布的消息和订阅者的订阅都是同时包含了空间位置和文本描述两种信息。</p><p>​    订阅者对于空间位置和文本描述的相似性有着不同的偏好，比如一些订阅者更希望得到与自己的订阅文本相似程度更高的消息，而另一些订阅者则更关注获得的消息与自己所在的空间位置的相近程度，因此我们允许用户进行参数化订阅，研究基于参数化的空间文本订阅的位置感知发布/订阅框架，力求实现高效、有针对性的发布/订阅过程。</p><h2 id="2-前缀过滤技术"><a href="#2-前缀过滤技术" class="headerlink" title="2. 前缀过滤技术"></a>2. 前缀过滤技术</h2><p>​    文本过滤即为利用数据的文本信息进行剪枝。旨在通过执行较快捷的基于文本的算法来减少记录点之间文本相似度的直接计算，从而提高计算效率。常用的文本过滤有长度过滤，前缀过滤，索引前缀过滤，位置过滤和后缀过滤五种过滤机，我们采用其中的前缀过滤机制，结合空间文本订阅的文本信息对不符合条件的订阅进行剪枝。</p><p>​    前缀过滤技术中，我们需要结合倒排文件列表构建前缀索引，前缀索引即根据计算出的前缀长度，只在倒排文件中存储前缀词。当且仅当两个记录点的文件中前缀有一个以上相同时，两个记录点才有可能成为匹配对</p><h2 id="3-方案"><a href="#3-方案" class="headerlink" title="3. 方案"></a>3. 方案</h2><h3 id="3-1-baseline"><a href="#3-1-baseline" class="headerlink" title="3.1 baseline"></a>3.1 baseline</h3><p>通过计算订阅和消息的相似度，如果超过阈值则可以推送。</p><p>问题：计算量大，效率低。</p><h3 id="3-2-空间感知前缀"><a href="#3-2-空间感知前缀" class="headerlink" title="3.2 空间感知前缀"></a>3.2 空间感知前缀</h3><p>根据阈值和文本权重，可以计算出每个subscription的前缀长度，因此倒排索引简化为只对前缀词做倒排</p><p>根据每个subscription中所有词的权重，可以估算出其文本相似度下界，从而可以得到空间相似度下界。</p><p>接下来利用过滤-验证机制，对m中的关键词访问倒排表，找到包含关键词的subscription，计算这些subscription和m的距离，根据之前存储的空间相似度下界进行过滤，得到候选集。最后再用相似度公式验证得到最终结果。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-23-02-13.png" alt=""> </p><h3 id="3-3-区域感知前缀"><a href="#3-3-区域感知前缀" class="headerlink" title="3.3 区域感知前缀"></a>3.3 区域感知前缀</h3><p> 利用R树对subscriptions做空间索引，在R树的节点中存储倒排索引，空间相似度下界等，当消息过来时，可以一次性过滤掉不符合条件的整个区域。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-09-23-03-19.png" alt=""> </p><h3 id="3-4-进一步优化"><a href="#3-4-进一步优化" class="headerlink" title="3. 4 进一步优化"></a>3. 4 进一步优化</h3><p>对消息流按时间段进行R树空间索引，匹配消息和订阅两个R树，进行过滤</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-03-09-21-59-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生成模型vs判别模型、有监督vs无监督</title>
    <link href="http://yoursite.com/2018/03/09/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8Bvs%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E3%80%81%E6%9C%89%E7%9B%91%E7%9D%A3vs%E6%97%A0%E7%9B%91%E7%9D%A3/"/>
    <id>http://yoursite.com/2018/03/09/生成模型vs判别模型、有监督vs无监督/</id>
    <published>2018-03-09T11:40:12.000Z</published>
    <updated>2018-03-09T13:41:46.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-监督学习-vs-无监督学习"><a href="#1-监督学习-vs-无监督学习" class="headerlink" title="1. 监督学习 vs 无监督学习"></a>1. 监督学习 vs 无监督学习</h2><ol><li>有监督学习：输入数据有标签，比如分类回归</li><li>无监督学习：输入数据没有标签，比如聚类</li><li>半监督学习：输入数据部分有标签，部分没有，或者有标签的部分不确定是否正确，让学习器不依赖外界交互、自动地利用未标记样本来提升学习性能，就是半监督学习</li></ol><h2 id="2-生成模型-vs-判别模型"><a href="#2-生成模型-vs-判别模型" class="headerlink" title="2. 生成模型 vs 判别模型"></a>2. 生成模型 vs 判别模型</h2><p>监督学习方法又可以分为<strong>生成方法</strong>(generative approach)和<strong>判别方法</strong>(discriminative approach)。所学到的模型分别为生成模型(generative model)和判别模型(discriminative model)。</p><h3 id="2-1-生成方法和生成模型"><a href="#2-1-生成方法和生成模型" class="headerlink" title="2.1 生成方法和生成模型"></a>2.1 生成方法和生成模型</h3><p>生成模型：无穷样本==》概率密度模型 = 产生模型==》预测</p><p>生成方法<strong>由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)=P(X,Y)/P(X)作为预测的模型</strong>。这样的方法之所以成为生成方法，是因为<strong>模型表示了给定输入X产生输出Y的生成关系</strong>。用于随机生成的观察值建模，特别是在给定某些隐藏参数情况下。典型的生成模型有：朴素贝叶斯法、马尔科夫模型、高斯混合模型。这种方法一般建立在统计学和Bayes理论的基础之上。</p><p><strong>生成方法的特点：</strong></p><ul><li>从统计的角度表示数据的分布情况，能够<strong>反映同类数据本身的相似度</strong>;</li><li>生成方法还原出联合概率分布，而判别方法不能；</li><li>生成方法的学习<strong>收敛速度更快</strong>、即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型；</li><li>当存在隐变量时，仍然可以用生成方法学习，此时判别方法不能用</li></ul><h3 id="2-2-判别方法和判别模型"><a href="#2-2-判别方法和判别模型" class="headerlink" title="2.2 判别方法和判别模型"></a>2.2 判别方法和判别模型</h3><p>判别模型：有限样本==》判别函数 = 预测模型==》预测</p><p>判别方法由数据<strong>直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型</strong>，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、boosting方法和条件随机场等。判别模型利用正负例和分类标签，关注在判别模型的边缘分布。</p><p><strong>判别方法的特点：</strong></p><blockquote><ul><li>判别方法寻找不同类别之间的最优分类面，<strong>反映的是异类数据之间的差异</strong>;</li><li>判别方法利用了训练数据的类别标识信息，直接学习的是条件概率P(Y|X)或者决策函数f(X)，直接面对预测，<strong>往往学习的准确率更高</strong>；</li><li>由于直接学习条件概率P(Y|X)或者决策函数f(X)，<strong>可以对数据进行各种程度上的抽象、定义特征并使用特征</strong>，因此可以简化学习问题。</li><li><strong>缺点是不能反映训练数据本身的特性</strong></li></ul></blockquote><h3 id="2-3-生成模型和判别模型对比"><a href="#2-3-生成模型和判别模型对比" class="headerlink" title="2.3 生成模型和判别模型对比"></a>2.3 生成模型和判别模型对比</h3><ul><li><p>训练时，二者优化准则不同</p><p>生成模型优化训练数据的联合分布概率；</p><p>判别模型优化训练数据的条件分布概率，判别模型与序列标记问题有较好的对应性。</p></li><li><p>对于观察序列的处理不同</p><p>生成模型中，观察序列作为模型的一部分；</p><p><strong>判别模型中，观察序列只作为条件，因此可以针对观察序列设计灵活的特征。</strong></p><p>训练复杂度不同</p><p><strong>判别模型训练复杂度较高</strong>。</p></li><li><p>是否支持无指导训练</p><p>生成模型支持无指导训练。</p></li><li><p>本质区别</p><p>判别估计的是条件概率分布(conditional distribution)p(Y|X)</p><p>生成模型估计的是联合概率分布（joint probability distribution）p(X,Y)</p></li></ul><p>另外，由生成模型可以得到判别模型，但由判别模型得不到生成模型。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/d195b887a32e" target="_blank" rel="external">【机器学习基础】生成模型和判别模型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-监督学习-vs-无监督学习&quot;&gt;&lt;a href=&quot;#1-监督学习-vs-无监督学习&quot; class=&quot;headerlink&quot; title=&quot;1. 监督学习 vs 无监督学习&quot;&gt;&lt;/a&gt;1. 监督学习 vs 无监督学习&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;有监督学习：输入数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B树、B+树、AVL树、Trie树及其应用场景</title>
    <link href="http://yoursite.com/2018/03/09/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81Trie%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/03/09/B树、B-树、AVL树、Trie树及其应用场景/</id>
    <published>2018-03-09T03:10:57.000Z</published>
    <updated>2018-03-09T07:21:46.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><p>AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL</p><p>红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap</p><p>B和B+树：主要用在文件系统以及数据库中做索引等</p><p>Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路，也是前缀匹配</p><p>R树：空间数据库索引</p><h2 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2. 二叉搜索树"></a>2. 二叉搜索树</h2><p>不必多说了，可以参考 <a href="https://siyaozhang.github.io/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二叉树与分治法</a></p><p><strong>时间复杂度</strong>最好情况是<script type="math/tex">O(logn)</script> ，最坏情况下时间复杂度<script type="math/tex">O(n)</script>，恰好选择了最小或者最大的节点做root，节点排在了一条直线上。</p><h2 id="3-AVL树"><a href="#3-AVL树" class="headerlink" title="3. AVL树"></a>3. AVL树</h2><p>AVL树是二叉搜索树的改进</p><p><strong>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡</strong>，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而<strong>旋转是非常耗时</strong>的，由此我们可以知道<strong>AVL树适合用于插入删除次数比较少，但查找多的情况。</strong></p><p><strong><img src="http://img.blog.csdn.net/20180307121339361" alt="img"></strong></p><p>上图是一个普通的平衡二叉树，这张图我们可以看出，<strong>任意节点的左右子树的平衡因子差值都不会大于1</strong>。</p><p>局限性：</p><p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。</p><h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p><strong>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black（非红即黑）</strong>。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树</strong>(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索、插入、删除操作较多的情况下，我们就用红黑树。</p><h3 id="4-2-性质"><a href="#4-2-性质" class="headerlink" title="4.2 性质"></a>4.2 性质</h3><p>1、每个节点非红即黑；</p><p>2、根节点是黑的；</p><p>3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；</p><p>4、如果一个节点是红的,那么它的两儿子都是黑的；</p><p>5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；</p><p>6、高度始终保持在h = logn</p><p>7、<strong>红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</strong></p><p>如下图所示，即是一颗红黑树(下图引自wikipedia：<a href="http://t.cn/hgvH1l" target="_blank" rel="external">http://t.cn/hgvH1l</a>)：</p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/images/rbtree/1.png" target="_blank" rel="external"><img src="https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png" alt="img"></a></p><p>上文中我们所说的 “叶结点” 或”NULL结点”，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。</p><h3 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h3><p>1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；</p><p>2、著名的<strong>Linux进程调度Completely Fair Scheduler</strong>，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；</p><p>3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；</p><p>4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；</p><p>5、<strong>Java中TreeMap的实现</strong>；</p><p>详细的插入、删除、旋转等操作可以参考：</p><p><a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="external">面试旧敌之红黑树（直白介绍深入理解）</a></p><h2 id="5-B树"><a href="#5-B树" class="headerlink" title="5. B树"></a>5. B树</h2><h3 id="5-1-B-树简介"><a href="#5-1-B-树简介" class="headerlink" title="5.1 B-树简介"></a>5.1 B-树简介</h3><p>B树是为实现<strong>高效的磁盘存取</strong>而设计的多叉平衡搜索树。这个概念在文件系统，数据库系统中非常重要。</p><p>​    B树是一种查找树，我们知道，这一类树（比如二叉查找树，红黑树等等）最初生成的目的都是为了解决某种系统中，查找效率低的问题。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率。</p><p>​    这里有一个基本的概念，就是说我们从外存储器中读取信息的步骤，简单来分，大致有两步：</p><ol><li>找到存储这个数据所对应的磁盘页面，这个过程是机械化的过程，需要依靠磁臂的转动，找到对应磁道，所以耗时长。</li><li>读取数据进内存，并实施运算，这是电子化的过程，相当快。</li></ol><p>总的来说，<strong>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树</strong>(相对于二叉，B树每个内节点有多个分支)，<strong>与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度</strong>(在下面B/B+树的性能分析中会提到)。<strong>B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成</strong>，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，<strong>在关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少</strong>。而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p><h3 id="5-2-B-树结构"><a href="#5-2-B-树结构" class="headerlink" title="5.2 B-树结构"></a>5.2 B-树结构</h3><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><p>B树的结构要求：<br><strong>1）根节点至少有两个子节点</strong><br><strong>2）每个节点有M-1个key，并且以升序排列</strong><br><strong>3）位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</strong><br><strong>4）其它节点至少有M/2个子节点</strong> [M/2,M-1]<br><strong>5）所有叶子节点都在同一层</strong><br><img src="http://img.blog.csdn.net/20161117122843822" alt="这里写图片描述"> </p><p><strong>B树高度</strong></p><p>对于一个包含n个关键字，最小度数t≥2t≥2 的B树，其高度hh 一定满足：</p><script type="math/tex; mode=display">h \leq \log_{t}{\frac{n + 1}{2}}</script><p>在搜索B树时，很明显，访问节点（即读取磁盘）的次数与树的高度呈正比，而B树与红黑树和普通的二叉查找树相比，虽然高度都是对数数量级，但是显然B树中log函数的底可以比2更大，因此，和二叉树相比，极大地减少了磁盘读取的次数。</p><h3 id="5-3-B-树操作"><a href="#5-3-B-树操作" class="headerlink" title="5.3 B-树操作"></a>5.3 B-树操作</h3><ol><li><p><strong>查找</strong></p><p>一棵已经建立好的B树如下图所示，我们的目的是查找关键字为29的文件：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-14-53-26.png" alt="img"></a></p><p>先简单说明一下上图：</p><ul><li>图中小红方块表示对应关键字锁代表的文件存储位置。实际上可以看做一个地址。比如根节点17旁边的小红块表示关键字17所对应的文件在硬盘中的存储地址。</li><li>P是指针。需要注意的是：指针 + 关键字 + 小红块 这三个东西合起来构成了一个B树的节点。这个节点存储在一个磁盘块上。</li></ul><p>下面看看搜索关键字29的文件的过程：</p><ol><li>从根节点开始，读取根节点信息，根节点有2个关键字：17和35。因为17 &lt; 29 &lt; 35，所以找到指针P2指向的子树，也就是磁盘块3（1次I/0操作）</li><li>读取当前节点信息，当前节点有2个关键字：26和30。26 &lt; 29 &lt; 30，找到指针P2指向的子树，也就是磁盘块8（2次I/0操作）</li><li>读取当前节点信息，当前节点有2个关键字：28和29。找到了！（3次I/0操作）</li></ol><p>由上面的过程可见，同样的操作，如果使用平衡二叉树，那么需要至少4次I/O操作，B树比之二叉树的这种优势，还会随着节点数的增加而增加。另外，因为B树节点中的关键字都是排序好的，所以，在节点中的信息被读入内存之后，可以采用二分查找这种快速的查找方式，更进一步减少了读入内存之后的计算时间，由此更能说明对于外存数据结构来说，I/O次数是其查找信息中最大的时间消耗，而我们要做的所有努力就是尽量在搜索过程中减少I/O操作的次数。</p></li><li><p><strong>插入</strong></p><p>​    向B树种插入关键字的过程与向二叉查找树中插入关键字的过程类似，但是要稍微复杂一点，因为根据上面B树的定义，我们可以看出，B树每个节点中关键字的个数是有范围要求的，同时，B树是平衡的，所以，如果像二叉查找树那样，直接找到相关的叶子，插入关键字，有可能会导致B树的结构发生变化而这种变化会使得B树不再是B树。</p><p>​    所以，我们这样来设计B树种对新关键字的插入：首先找到要插入的关键字应该插入的叶子节点（为方便描述，设这个叶子节点为u），如果u是满的（恰好有2t−1个关键字），那么由于不能将一个关键字插入满的节点，我们需要对u按其当前<strong>排在中间关键字</strong><script type="math/tex">u.key_t</script>进行分裂，<strong>分裂</strong>成两个节点u1,u2；同时，作为分裂标准的关键字<script type="math/tex">u.key_t</script>被<strong>上移到u的父节点中</strong>，在<script type="math/tex">u.key_t</script>插入前，如果u的父节点未满，则直接插入即可；如果u的父节点已满，则按照上面的方法对u的父节点分裂，这个过程如果一直不停止的话，最终会导致B树的根节点分裂，B树的高度增加一层。</p><p>​    下面用《算法导论》中的一个题目展示一下这种插入关键字的过程。</p><p>现在我们要将关键字序列：F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y依次插入一棵最小度为2的B树中。也就是说，这棵树的节点中，最多有3个关键字，最少有1个关键字。</p><p><strong>第1步</strong>，F, S, Q可以被插入一个节点（也就是根节点）</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-28.png" alt="img"></a></p><p><strong>第2步</strong>，插入关键字K，因为节点已满，所以在插入前，发生分裂，中间关键字Q上移，建立了一个新的根节点：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-42.png" alt="img"></a></p><p><strong>第3步</strong>，插入关键字C:</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-00-55.png" alt="img"></a></p><p><strong>第4步</strong>，插入关键字L，L应该被插入到根节点的左侧的孩子中，因为此时该节点已满，所以在插入前，发生分裂：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-12.png" alt="img"></a></p><p><strong>第5步</strong>，插入关键字H, T, V，这个过程没有发生节点的分裂：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-01-26.png" alt="img"></a></p><p><strong>第6步</strong>，插入关键字W，W应该被插入到根节点的最右侧的孩子中，因为此时该节点已满，所以在插入前，关键字T上移，最右端的叶子节点发生分裂：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-03-33.png" alt="img"></a></p><p><strong>第7步</strong>，插入关键字M，M应该被插入到根节点的左起第2个孩子中，因为此时该节点已满，所以在插入前，发生分裂，分裂之后，中间关键字K上移，导致根节点发生分裂，树高增加1：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-27.png" alt="img"></a></p><p>第8步，同样的道理，插入关键字R, N, P, A, B, X, Y：最终得到的B树如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-04-41.png" alt="img"></a></p></li><li><p><strong>删除</strong></p><p>​    删除操作的基本思想和插入操作是一样的，都是不能因为关键字的改变而改变B树的结构。<strong>插入操作主要防止的是某个节点中关键字的个数太多，所以采用了分裂；删除则是要防止某个节点中，因删除了关键字而导致这个节点的关键字个数太少，所以采用了合并操作。</strong></p><p>下面分三种情况来讨论下删除操作是如何工作的，这个过程的顺序是自根节点起向下遍历B树</p><p><strong>Case - 1：</strong>如果要删除的关键字k在节点u中，而且u是<strong>叶子节点</strong>，那么直接删除k</p><p><strong>Case - 2：</strong>如果要删除的关键字k在节点u中，而且u是<strong>内部节点</strong>。由于关键字影响着子树的范围，因此不能随意删除。必须<strong>从子树中找到一个合适的数字来替代k</strong>才可以。需要分以下3种情况讨论：</p><p>(1) 如果u中前于k的子节点u1中至少含有t个关键字，则找出k在以u1为根的子树中的前驱k′（前驱的意思是u1中比k小的关键字中最大的），然后在以u1为根的子树中删除k′，并在u中以k′替代k</p><p>(2) 如果上面的条件(1)不成立，也就是说，前于k的子节点中关键字的个数小于t了，那么就去找后于k的子节点，记为u2。若u2中至少含有t个关键字，则找出k在以u2为根的子树中的后继k′(大于k的关键字中最小的)，然后在以u2为根的子树中删除k′，并在u中以k′替代k。可以看出（2）是（1）的一个对称过程</p><p>(3) 如果u1,u2中的关键字个数都是t−1，则将k和u2合并后并入u1，这样u就失去了k和指向u2的指针，最后递归地从u1中删除k</p><p><strong>Case - 3：</strong>如果要删除的关键字k不在当前节点u中，而且u是内部节点（如果自上而下扫描到叶子都没有这个关键字的话，那就说明要删除的关键字根本就不存在，所以此处只考虑u是内部节点的情况），则首先确定包含k的u的子树，我们这里设为u.pi。如果u.pi中至少含有t个关键字，那么继续扫描，寻找下一个要被扫描的子树；如果u.pi中只含有t−1个关键字，则需要分下面两种情况进行操作：</p><p>(1) 如果u.pi至少有一个相邻的兄弟比较“丰满”（即这个兄弟至少有t个关键字）。则将u中的一个关键字降至u.pi，同时令u.pi的最“丰满”的兄弟中升一个关键至u。然后继续扫描B树，寻找k</p><p>(2) 如果u.pi的两个相邻的兄弟都不“丰满”（都只有t−1个关键字）。则令u.pi和其一个兄弟合并，再将u的一个关键字降至新合并的节点。使之成为该节点的中间关键字。</p><p>举个例子</p><p>1、初始状态<br><img src="http://img.blog.csdn.net/20160915145726227" alt="这里写图片描述"></p><p>2、删除元素H<br>首先查找H，H在一个叶子结点中，且该叶子结点元素数目3 &gt; 2<br>移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="http://img.blog.csdn.net/20160915150104895" alt="这里写图片描述"></p><p>3、删除T<br>在中间结点中找到T，此时删了T后该节点关键字个数 1 &lt; 2<br>将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该叶子结点中元素个数 &gt; 2，无需进行合并操作<br><img src="http://img.blog.csdn.net/20160915150446557" alt="这里写图片描述"></p><p>4、删除R<br>R所在叶子结点中元素数目为2，删除导致只有1个元素</p><blockquote><p>如果其某个相邻兄弟结点中比较丰满（元素个数 &gt; [M/2] - 1），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中</p></blockquote><p>在这个实例中，右相邻兄弟结点中比较丰满（3 &gt; 2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="http://img.blog.csdn.net/20160915150946108" alt="这里写图片描述"></p><p>5、删除E<br>删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（[M/2] - 1），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件<br>所以需要该节点与某相邻兄弟结点进行合并操作：</p><blockquote><p>首先，移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中；<br>然后将这两个结点进行合并成一个结点。</p></blockquote><p>即，将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="http://img.blog.csdn.net/20160915152043269" alt="这里写图片描述"><br>此时G所在节点只有一个元素，不行。<br>此时该结点的相邻兄弟又不丰满，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="http://img.blog.csdn.net/20160915152349100" alt="这里写图片描述"></p></li></ol><h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6. B+树"></a>6. B+树</h2><p>​    B+树是B树的一种变形，<strong>它更适合实际应用中操作系统的文件索引和数据库索引</strong>。定义如下：（为和大多资料保持一致，这里使用阶数m来定义B+树，而不像之前的B树中，使用的是最小度t来定义）</p><ol><li>每个内部节点的关键字个数为[m/2,m] 个。其中每个关键字对应一个子树；</li><li>根节点要么没有子树，要么至少有2颗子树</li><li>叶子节点包含了全部的关键字以及关键字指向文件的指针，且：<ol><li>所有叶子节点中的关键字按大小顺序排列</li><li>相邻的叶子节点顺序链接（相当于是构成了一个顺序链表）</li><li>所有叶子节点在同一层</li></ol></li><li>所有分支节点的关键字都是对应子树中关键字的最大值</li></ol><p>比如，下图就是一个非常典型的B+树的例子。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-15-31-31.png" alt="img"></a></p><p>B+树和B树相比，主要的不同点在以下3项：</p><ul><li>内部节点中，关键字的个数与其子树的个数相同，不像B树中，子树的个数总比关键字个数多1个</li><li>所有指向文件的关键字及其指针都在叶子节点中，不像B树，有的指向文件的关键字是在内部节点中。换句话说，B+树中，内部节点仅仅起到索引的作用</li><li>在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支</li></ul><h2 id="6-R树"><a href="#6-R树" class="headerlink" title="6. R树"></a>6. R树</h2><h3 id="6-1-R树的结构"><a href="#6-1-R树的结构" class="headerlink" title="6.1 R树的结构"></a>6.1 R树的结构</h3><p>​    R树是B树在<strong>高维</strong>空间的扩展，是一棵<strong>平衡树</strong>。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。下图1是R树的一个简单实例：</p><p><img src="https://images2015.cnblogs.com/blog/1051369/201704/1051369-20170404131434878-399064987.jpg" alt="img"></p><p>在R树中存放的数据并不是原始数据，而是这些数据的<strong>最小边界矩形（MBR</strong>），空间对象的MBR被包含于R树的叶结点中。</p><p>R树满足如下的性质：</p><p>1)       根结点至少有两个子结点，除非它同时是叶子结点</p><p>2)       每一个叶子结点包含 m至M个索引项记录，通常， m=M/2。</p><p>3)       每一个非叶子节点拥有m至M个子节点，除非它是跟节点。</p><p>4)       所有叶子节点都位于同一层。</p><p>支持搜索、增加、删除等操作，可以自定义矩形的最大子节点数。</p><p>更详细的内容可以参考<a href="http://www.cnblogs.com/cmi-sh-love/p/kong-jian-shud-ju-suo-yinRTree-wan-quan-jie-xi-jiJa.html" target="_blank" rel="external">空间数据索引RTree（R树）完全解析及Java实现</a></p><h2 id="7-对比"><a href="#7-对比" class="headerlink" title="7. 对比"></a>7. 对比</h2><h3 id="7-1-B树和B-树的区别"><a href="#7-1-B树和B-树的区别" class="headerlink" title="7.1 B树和B+树的区别"></a>7.1 B树和B+树的区别</h3><p>​    B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：<br><strong>1、B+树的磁盘读写代价更低</strong><br>B+树的内部结点并没有指向关键字具体信息的指针。因此其<strong>内部结点</strong>相对B 树<strong>更小</strong>。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><blockquote><p>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p></blockquote><p><strong>2、B+-tree的查询效率更加稳定</strong><br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的<strong>路径长度相同</strong>，导致每一个数据的查询效率相当。</p><p>3、<strong>B树在元素遍历的时候效率较低</strong> </p><p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库<strong>，只需要扫一遍叶子结点即可</strong>，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。</p><h3 id="7-2-红黑树与B树区别"><a href="#7-2-红黑树与B树区别" class="headerlink" title="7.2 红黑树与B树区别"></a>7.2 红黑树与B树区别</h3><p>  一言而知就是树的深度较高，在磁盘I/O方面的表现不如B树。<br>  要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。<br>  所以，在大规模数据存储的时候，<strong>红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁</strong>，进而导致效率低下。在这方面，B树表现相对优异，B树可以有多个子女，从几十到上千，可以降低树的高度。</p><h3 id="7-3-AVL树和红黑树"><a href="#7-3-AVL树和红黑树" class="headerlink" title="7.3 AVL树和红黑树"></a>7.3 AVL树和红黑树</h3><p>红黑树的算法时间复杂度和AVL相同，但<strong>统计性能</strong>比AVL树更高。</p><blockquote><p>1、红黑树和AVL树都能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。<br>2、由于设计，红黑树的任何不平衡都会在三次旋转之内解决。AVL树增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p></blockquote><p>在<strong>查找</strong>方面：<br>  红黑树的性质(最长路径长度不超过最短路径长度的2倍)，其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。<br>  AVL是严格平衡的二叉查找树（平衡因子不超过1）。查找过程中不会出现最差情况的单支树。因此查找效率最好，最坏情况都是O(logN)数量级的。</p><p>所以，综上：<br>  AVL比RBtree更加平衡，但是AVL的插入和删除会带来大量的旋转。 所以如果<strong>插入和删除比较多</strong>的情况，应该使用<strong>RBtree</strong>, 如果<strong>查询操作比较多</strong>，应该使用<strong>AVL</strong>。</p><blockquote><p>AVL是一种高度平衡的二叉树，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/u010899985/article/details/79468080" target="_blank" rel="external">为什么MySQL数据库索引选择使用B+树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-应用场景&quot;&gt;&lt;a href=&quot;#1-应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. 应用场景&quot;&gt;&lt;/a&gt;1. 应用场景&lt;/h2&gt;&lt;p&gt;AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>过拟合、欠拟合及其解决办法</title>
    <link href="http://yoursite.com/2018/03/08/%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/08/过拟合、欠拟合及其解决办法/</id>
    <published>2018-03-08T13:27:34.000Z</published>
    <updated>2018-03-08T15:11:46.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-过拟合与欠拟合"><a href="#1-过拟合与欠拟合" class="headerlink" title="1. 过拟合与欠拟合"></a>1. 过拟合与欠拟合</h2><p>​    <strong>机器学习中一个重要的话题便是模型的泛化能力，泛化能力强的模型才是好模型</strong>.</p><p>​    对于训练好的模型，若在训练集表现差，不必说在测试集表现同样会很差，这可能是欠拟合导致；若模型在训练集表现非常好，却在测试集上差强人意，则这便是过拟合导致的.</p><p>​    过拟合与欠拟合也可以用 Bias 与 Variance （偏差和方差）的角度来解释，<strong>欠拟合会导致高 Bias ，过拟合会导致高 Variance ，所以模型需要在 Bias 与 Variance 之间做出一个权衡。</strong></p><p>​    使用简单的模型去拟合复杂数据时，会导致模型很难拟合数据的真实分布，这时模型便欠拟合了，或者说有很大的 Bias，<strong>Bias 即为模型的期望输出与其真实输出之间的差异</strong>；有时为了得到比较精确的模型而过度拟合训练数据，或者模型复杂度过高时，可能连训练数据的噪音也拟合了，导致模型在训练集上效果非常好，但泛化性能却很差，这时模型便过拟合了，或者说有很大的 Variance，这时模型在不同训练集上得到的模型波动比较大，<strong>Variance 刻画了不同训练集得到的模型的输出与这些模型期望输出的差异</strong>。</p><p><img src="https://pic3.zhimg.com/80/v2-7b5523e2f3ef416698cfecaebc73df36_hd.jpg" alt="img"></p><h2 id="2-常用解决办法"><a href="#2-常用解决办法" class="headerlink" title="2. 常用解决办法"></a>2. 常用解决办法</h2><p><strong>(1)解决欠拟合的方法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;</div><div class="line">2、尝试非线性模型，比如核SVM 、决策树、DNN等模型;</div><div class="line">3、如果有正则项可以较小正则项参数 $\lambda$;</div><div class="line">4、Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</div></pre></td></tr></table></figure><p><strong>(2)解决过拟合的方法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、交叉检验，通过交叉检验得到较优的模型参数;</div><div class="line">2、early stop</div><div class="line">3、特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间;</div><div class="line">4、正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择;</div><div class="line">5、如果有正则项则可以考虑增大正则项参数 lambda;</div><div class="line">6、增加训练数据可以有限的避免过拟合;</div><div class="line">7、Bagging,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等.</div></pre></td></tr></table></figure><p><strong>（3）DNN中常见的方法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、早停策略。本质上是交叉验证策略，选择合适的训练次数，避免训练的网络过度拟合训练数据。</div><div class="line">2、集成学习策略。而DNN可以用Bagging的思路来正则化。首先我们要对原始的m个训练样本进行有放回随机采样，构建N组m个样本的数据集，然后分别用这N组数据集去训练我们的DNN。即采用我们的前向传播算法和反向传播算法得到N个DNN模型的W,b参数组合，最后对N个DNN模型的输出用加权平均法或者投票法决定最终输出。不过用集成学习Bagging的方法有一个问题，就是我们的DNN模型本来就比较复杂，参数很多。现在又变成了N个DNN模型，这样参数又增加了N倍，从而导致训练这样的网络要花更加多的时间和空间。因此一般N的个数不能太多，比如5-10个就可以了。</div><div class="line">3、DropOut策略。所谓的Dropout指的是在用前向传播算法和反向传播算法训练DNN模型时，一批数据迭代时，随机的从全连接DNN网络中去掉一部分隐藏层的神经元。　在对训练集中的一批数据进行训练时，我们随机去掉一部分隐藏层的神经元，并用去掉隐藏层的神经元的网络来拟合我们的一批训练数据。使用基于dropout的正则化比基于bagging的正则化简单，这显而易见，当然天下没有免费的午餐，由于dropout会将原始数据分批迭代，因此原始数据集最好较大，否则模型可能会欠拟合。</div></pre></td></tr></table></figure><h2 id="3-L1和L2正则化方法"><a href="#3-L1和L2正则化方法" class="headerlink" title="3. L1和L2正则化方法"></a>3. L1和L2正则化方法</h2><p><strong>目的：防止过拟合，提高泛化能力</strong></p><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>给定数据集<script type="math/tex">D={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}</script>,其中<script type="math/tex">x\in R^d,y\in R</script>.</p><p>考虑最简单的线性回归，以平方误差为损失函数，则优化目标为：</p><script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2</script><p>当样本特征很多，而样本数较少时，上式很容易陷入过拟合。解决方案，正则化项。</p><p><strong><script type="math/tex">L2</script>范数正则化（“岭回归”(redge regression)）：</strong></p><script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_2^2</script><p><strong><script type="math/tex">L1</script>范数正则化：</strong></p><script type="math/tex; mode=display">min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_1</script><h3 id="3-2-L1和L2的异同"><a href="#3-2-L1和L2的异同" class="headerlink" title="3.2 L1和L2的异同"></a>3.2 L1和L2的异同</h3><p>相同点：都用于避免过拟合</p><p>不同点：</p><ol><li>L1可以让一部分特征的系数缩小到0，从而间接实现<strong>特征选择</strong>。所以L1适用于特征之间有关联的情况。</li><li>L2让所有特征的系数都缩小，但是不会减为0，它会使<strong>优化求解稳定快速</strong>。所以L2适用于特征之间没有关联的情况</li></ol><p>总结一下就是 <strong>L1正则化产生稀疏的权值, L2正则化产生平滑的权值</strong>。为什么会这样？这里面的本质原因是什么呢？下面我们从两个角度来解释这个问题。</p><h4 id="角度1：数学公式"><a href="#角度1：数学公式" class="headerlink" title="角度1：数学公式"></a>角度1：数学公式</h4><p><strong>L1 regularization:</strong></p><p>在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n（这里不像L2正则化项那样，需要再乘以1/2，具体原因上面已经说过。）</p><p><img src="http://i.imgur.com/6jbxq15.jpg" alt="img"></p><p>同样先计算导数：</p><p><img src="http://i.imgur.com/kju5RTZ.jpg" alt="img"></p><p>上式中sgn(w)表示w的符号。那么权重w的更新规则为：</p><p><img src="http://i.imgur.com/HCkJZYl.jpg" alt="img"></p><p>比原始的更新规则多出了η <em> λ </em> sgn(w)/n这一项。当w为正时，更新后的w变小。当w为负时，更新后的w变大——因此它的效果就是让w往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p><p>另外，上面没有提到一个问题，当w为0时怎么办？当w等于0时，|W|是不可导的，所以我们只能按照原始的未经正则化的方法去更新w，这就相当于去掉η<em>λ</em>sgn(w)/n这一项，所以我们可以规定sgn(0)=0，这样就把w=0的情况也统一进来了。（在编程的时候，令sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1）</p><p><strong>L2 regularization（权重衰减）</strong>:</p><p>L2正则化就是在代价函数后面再加上一个正则化项：</p><p><img src="http://i.imgur.com/9WnBBu1.jpg" alt="img"></p><p>C0代表原始的代价函数，后面那一项就是L2正则化项，它是这样来的：所有参数w的平方的和，除以训练集的样本大小n。λ就是正则项系数，权衡正则项与C0项的比重。另外还有一个系数1/2，1/2经常会看到，主要是为了后面求导的结果方便，后面那一项求导会产生一个2，与1/2相乘刚好凑整。</p><p>L2正则化项是怎么避免overfitting的呢？我们推导一下看看，先求导：</p><p><img src="http://i.imgur.com/mebEC90.jpg" alt="img"></p><p>可以发现L2正则化项对b的更新没有影响，但是对于w的更新有影响:</p><p><img src="http://i.imgur.com/qM83geg.jpg" alt="img"></p><p>在不使用L2正则化时，求导结果中w前系数为1，现在w前面系数为 1−ηλ/n ，因为η、λ、n都是正的，所以 1−ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来。当然考虑到后面的导数项，w最终的值可能增大也可能减小。</p><p>另外，需要提一下，对于基于mini-batch的随机梯度下降，w和b更新的公式跟上面给出的有点不同：</p><p><img src="http://i.imgur.com/Xs2p2EN.jpg" alt="img"></p><p><img src="http://i.imgur.com/yDETU7x.jpg" alt="img"></p><p>对比上面w的更新公式，可以发现后面那一项变了，变成所有导数加和，乘以η再除以m，m是一个mini-batch中样本的个数。</p><p>到目前为止，我们只是解释了L2正则化项有让w“变小”的效果，但是还没解释为什么w“变小”可以防止overfitting？一个所谓“显而易见”的解释就是：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。</p><h4 id="角度2：几何空间"><a href="#角度2：几何空间" class="headerlink" title="角度2：几何空间"></a>角度2：几何空间</h4><p>（西瓜书-253页的解释） </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-23-02-04.png" alt=""></p><p>​    简化到2维的情形，如上图所示。其中，左边是L1图示，右边是L2图示，左边的方形线上是L1中w1/w2取值区间，右边得圆形线上是L2中w1/w2的取值区间，绿色的圆圈表示w1/w2取不同值时整个正则化项的值的等高线（凸函数），从等高线和w1/w2取值区间的交点可以看到，L1中两个权值倾向于一个较大另一个为0，L2中两个权值倾向于均为非零的较小数。这也就是L1稀疏，L2平滑的效果。</p><h2 id="4-bagging-and-boosting"><a href="#4-bagging-and-boosting" class="headerlink" title="4. bagging  and boosting"></a>4. bagging  and boosting</h2><h3 id="4-1-bootstrap采样"><a href="#4-1-bootstrap采样" class="headerlink" title="4.1 bootstrap采样"></a>4.1 bootstrap采样</h3><p>​    名字来自成语“pull up by your own bootstraps”，意思是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：<br>　　（1） 采用重抽样技术从原始样本中抽取一定数量（自己给定）的样本，此过程允许重复抽样。<br>　　（2） 根据抽出的样本计算给定的统计量T。<br>　　（3） 重复上述N次（一般大于1000），得到N个统计量T。<br>　　（4） 计算上述N个统计量T的样本方差，得到统计量的方差。<br>　　应该说Bootstrap是现代统计学较为流行的一种统计方法，在小样本时效果很好。通过方差的估计可以构造置信区间等，其运用范围得到进一步延伸。</p><h3 id="4-2-bagging-bootstrap-aggregating"><a href="#4-2-bagging-bootstrap-aggregating" class="headerlink" title="4.2 bagging (bootstrap aggregating)"></a>4.2 bagging (bootstrap aggregating)</h3><p>Bagging即套袋法，其算法过程如下：</p><p>A）从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</p><p>B）每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</p><p>C）对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</p><h3 id="4-3-boosting"><a href="#4-3-boosting" class="headerlink" title="4.3 boosting"></a>4.3 boosting</h3><p>其主要思想是将弱分类器组装成一个强分类器。在PAC（概率近似正确）学习框架下，则一定可以将弱分类器组装成一个强分类器。</p><p>关于Boosting的两个核心问题：</p><p>1）在每一轮如何改变训练数据的权值或概率分布？</p><p>通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</p><p>2）通过什么方式来组合弱分类器？</p><p>通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</p><p>而提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。</p><h3 id="4-4-Bagging，Boosting二者之间的区别"><a href="#4-4-Bagging，Boosting二者之间的区别" class="headerlink" title="4.4 Bagging，Boosting二者之间的区别"></a>4.4 Bagging，Boosting二者之间的区别</h3><p>Bagging和Boosting的区别：</p><p>1）样本选择上：</p><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><p>2）样例权重：</p><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><p>3）预测函数：</p><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><p>4）并行计算：</p><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><p>3)方差和偏差：</p><p>Bagging：偏差不变，方差变小，解决过拟合</p><p>Boosting：偏差变小，解决欠拟合</p><p>这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。</p><p>下面是将决策树与这些算法框架进行结合所得到的新的算法：</p><p>1）Bagging + 决策树 = 随机森林</p><p>2）AdaBoost + 决策树 = 提升树</p><p>3）Gradient Boosting + 决策树 = GBDT</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/29707029" target="_blank" rel="external">机器学习防止欠拟合、过拟合方法</a></p><p><a href="http://blog.csdn.net/u012162613/article/details/44261657" target="_blank" rel="external">正则化方法：L1和L2 regularization、数据集扩增、dropout</a></p><p><a href="https://vimsky.com/article/969.html" target="_blank" rel="external">为什么L1稀疏，L2平滑？</a></p><p><a href="https://www.jianshu.com/p/cb0ad5939629" target="_blank" rel="external">Bagging和Boosting 概念及区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-过拟合与欠拟合&quot;&gt;&lt;a href=&quot;#1-过拟合与欠拟合&quot; class=&quot;headerlink&quot; title=&quot;1. 过拟合与欠拟合&quot;&gt;&lt;/a&gt;1. 过拟合与欠拟合&lt;/h2&gt;&lt;p&gt;​    &lt;strong&gt;机器学习中一个重要的话题便是模型的泛化能力，泛化能力强
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【本站目录】</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%90%E6%9C%AC%E7%AB%99%E7%9B%AE%E5%BD%95%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/08/【本站目录】/</id>
    <published>2018-03-08T11:57:57.000Z</published>
    <updated>2018-03-10T09:06:09.521Z</updated>
    
    <content type="html"><![CDATA[<p>文章渐渐多了起来，为了方面复习和查找，对本站文章做个目录~</p><h1 id="1-算法与数据结构"><a href="#1-算法与数据结构" class="headerlink" title="1. 算法与数据结构"></a>1. 算法与数据结构</h1><h3 id="1-1-排序算法"><a href="#1-1-排序算法" class="headerlink" title="1.1 排序算法"></a>1.1 排序算法</h3><ul><li><a href="https://siyaozhang.github.io/2018/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">计数排序、计数排序、桶排序</a> ，三种非比较排序，理想情况下时间复杂度可以降到<script type="math/tex">O(n)</script></li><li><a href="https://siyaozhang.github.io/2017/07/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">归并排序</a></li><li><a href="https://siyaozhang.github.io/2017/07/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">选择排序</a></li><li><a href="https://siyaozhang.github.io/2017/07/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">插入排序</a></li><li><a href="https://siyaozhang.github.io/2017/07/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">冒泡排序</a></li><li><a href="https://siyaozhang.github.io/2017/07/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">快速排序</a></li><li>堆排序</li><li><a href="/2018/03/10/排序算法终极大总结/" title="排序算法终极大总结">排序算法终极大总结</a> </li></ul><h3 id="1-3-数与数组"><a href="#1-3-数与数组" class="headerlink" title="1.3 数与数组"></a>1.3 数与数组</h3><ul><li><a href="https://siyaozhang.github.io/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二分法</a></li><li><a href="https://siyaozhang.github.io/2017/12/24/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/" target="_blank" rel="external">【九章算法基础班】数与数组</a></li><li><a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> 包含<strong>partition、quickSelect</strong></li><li><a href="https://siyaozhang.github.io/2017/11/17/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E6%89%AB%E6%8F%8F%E7%BA%BF/" target="_blank" rel="external">【九章算法强化班】扫描线</a></li></ul><h3 id="1-2-动态规划"><a href="#1-2-动态规划" class="headerlink" title="1.2 动态规划"></a>1.2 动态规划</h3><ul><li> 动态规划四要素，两类常见的动态规划：坐标型动态规划、序列型动态规划</li><li><a href="https://siyaozhang.github.io/2018/03/08/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="external">【九章算法强化】动态规划</a> 包括DP的滚动数组优化、记忆化搜索、博弈类DP、区间型DP、背包DP</li><li><a href="https://siyaozhang.github.io/2017/10/31/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/" target="_blank" rel="external">【算法导论】钢条切割问题</a></li><li><a href="https://siyaozhang.github.io/2017/11/01/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/" target="_blank" rel="external">【算法导论】矩阵链乘法</a></li></ul><h3 id="1-3-链表"><a href="#1-3-链表" class="headerlink" title="1.3 链表"></a>1.3 链表</h3><ul><li><a href="https://siyaozhang.github.io/2017/12/11/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E9%93%BE%E8%A1%A8/" target="_blank" rel="external">【九章算法基础班】链表</a></li></ul><h3 id="1-4-树模块"><a href="#1-4-树模块" class="headerlink" title="1.4 树模块"></a>1.4 树模块</h3><ul><li><a href="https://siyaozhang.github.io/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二叉树与分治法</a></li></ul><ul><li><a href="https://siyaozhang.github.io/2018/02/08/%E3%80%90leetcode%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="external">线段树</a></li><li><a href="https://siyaozhang.github.io/2017/11/14/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91Trie%E6%A0%91/" target="_blank" rel="external">Trie树</a></li><li><a href="https://siyaozhang.github.io/2018/03/09/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81Trie%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/#more" target="_blank" rel="external">B/B+树、红黑树、AVL树、Trie树应用场景</a></li><li>​</li></ul><h3 id="1-5-图模块"><a href="#1-5-图模块" class="headerlink" title="1.5 图模块"></a>1.5 图模块</h3><ul><li><a href="https://siyaozhang.github.io/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/" target="_blank" rel="external">【九章算法基础班】图与搜索</a> 主要是BFS、DFS</li><li><a href="https://siyaozhang.github.io/2017/11/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E3%80%90leetcode%E3%80%9151-52-N-Queens/" target="_blank" rel="external">回溯法、8皇后</a></li><li><a href="https://siyaozhang.github.io/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/" target="_blank" rel="external">【九章算法强化班】并查集</a></li><li>​</li></ul><h3 id="1-6-hash表、堆、栈、队列、Trie树、并查集"><a href="#1-6-hash表、堆、栈、队列、Trie树、并查集" class="headerlink" title="1.6 hash表、堆、栈、队列、Trie树、并查集"></a>1.6 hash表、堆、栈、队列、Trie树、并查集</h3><ul><li><a href="https://siyaozhang.github.io/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="external">【九章算法基础班】数据结构</a> 主要是hash表、堆、栈</li><li><a href="https://siyaozhang.github.io/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%A0%86Heap/" target="_blank" rel="external">【九章算法强化班】堆Heap&amp;双端队列Deque</a> </li><li><a href="https://siyaozhang.github.io/2017/11/04/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E7%AC%ACk%E5%A4%A7/" target="_blank" rel="external">第K大问题——堆</a></li></ul><h1 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2. 系统设计"></a>2. 系统设计</h1><ul><li><a href="https://siyaozhang.github.io/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/" target="_blank" rel="external">【九章系统设计】新鲜事系统</a></li><li><a href="https://siyaozhang.github.io/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/" target="_blank" rel="external">【九章系统设计】从用户系统理解数据库和缓存</a></li><li><a href="https://siyaozhang.github.io/2018/03/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C-%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="external">【九章系统设计】一致性哈希&amp;短网址系统设计</a></li></ul><h1 id="3-机器学习"><a href="#3-机器学习" class="headerlink" title="3. 机器学习"></a>3. 机器学习</h1><h3 id="3-1-线性模型"><a href="#3-1-线性模型" class="headerlink" title="3.1 线性模型"></a>3.1 线性模型</h3><ul><li>LR</li><li>svm</li><li>PCA</li></ul><h3 id="3-2-树模型"><a href="#3-2-树模型" class="headerlink" title="3.2 树模型"></a>3.2 树模型</h3><ul><li><a href="https://siyaozhang.github.io/2017/03/04/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">决策树（一）：基础</a></li><li><a href="https://siyaozhang.github.io/2017/03/05/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%92%8C%E7%BC%BA%E5%A4%B1%E5%A4%84%E7%90%86/" target="_blank" rel="external">决策树（二）：连续值和缺失处理</a></li><li><a href="https://siyaozhang.github.io/2017/03/05/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%9A%E5%8F%98%E9%87%8F%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="external">决策树（三）：多变量决策树</a></li></ul><h3 id="3-3-评价指标等"><a href="#3-3-评价指标等" class="headerlink" title="3.3 评价指标等"></a>3.3 评价指标等</h3><ul><li><a href="https://siyaozhang.github.io/2017/04/04/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81F1%E3%80%81ROC%E3%80%81AUC/" target="_blank" rel="external">准确率、召回率、F1、ROC、AUC</a></li><li><a href="https://siyaozhang.github.io/2017/03/16/%E4%BA%A4%E5%8F%89%E7%86%B5/" target="_blank" rel="external">熵、交叉熵</a></li><li><a href="https://siyaozhang.github.io/2018/03/08/%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/#more" target="_blank" rel="external">过拟合欠拟合，L1\L2正则化项，bagging vs boosting</a></li><li></li></ul><h3 id="3-4-机器学习实践"><a href="#3-4-机器学习实践" class="headerlink" title="3.4 机器学习实践"></a>3.4 机器学习实践</h3><ul><li><a href="https://jiayi797.github.io/2017/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/" target="_blank" rel="external">机器学习实践-不平衡类的处理</a></li><li><a href="https://jiayi797.github.io/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E4%B9%8B%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/" target="_blank" rel="external">机器学习实践-转化率预估之贝叶斯平滑</a></li><li><a href="https://jiayi797.github.io/2017/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6-xgboost%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82%E6%8C%87%E5%8D%97%EF%BC%88Python%E7%89%88%EF%BC%89/" target="_blank" rel="external">机器学习框架-xgboost参数调节指南（Python版</a></li></ul><h1 id="4-项目-amp-竞赛总结"><a href="#4-项目-amp-竞赛总结" class="headerlink" title="4. 项目&amp;竞赛总结"></a>4. 项目&amp;竞赛总结</h1><h3 id="4-1-腾讯社交广告算法大赛"><a href="#4-1-腾讯社交广告算法大赛" class="headerlink" title="4.1 腾讯社交广告算法大赛"></a>4.1 腾讯社交广告算法大赛</h3><ul><li><a href="https://siyaozhang.github.io/2018/03/06/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/" target="_blank" rel="external">【腾讯转化率预估竞赛】总结</a></li><li><a href="https://siyaozhang.github.io/2017/03/14/Factorization-Machine%EF%BC%88FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%89/" target="_blank" rel="external">FM</a> <a href="https://siyaozhang.github.io/2017/03/22/FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/" target="_blank" rel="external">FFM</a></li></ul><h3 id="4-2-编程之美"><a href="#4-2-编程之美" class="headerlink" title="4.2 编程之美"></a>4.2 编程之美</h3><ul><li><a href="https://siyaozhang.github.io/2018/03/08/%E3%80%902017%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%80%BB%E7%BB%93/" target="_blank" rel="external">【2017编程之美】搜索引擎总结</a></li></ul><h3 id="4-3-实习"><a href="#4-3-实习" class="headerlink" title="4.3 实习"></a>4.3 实习</h3><ul><li><a href="https://siyaozhang.github.io/2018/03/07/%E3%80%90%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91/" target="_blank" rel="external">协同过滤实习项目总结</a></li></ul><h1 id="5-语言相关"><a href="#5-语言相关" class="headerlink" title="5. 语言相关"></a>5. 语言相关</h1><ul><li><a href="https://siyaozhang.github.io/2018/01/27/Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">Java常用笔记</a> 写代码的时候总忘记的小东西</li><li><a href="https://siyaozhang.github.io/2018/01/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Java垃圾回收机制</a></li></ul><h1 id="6-面试必备"><a href="#6-面试必备" class="headerlink" title="6. 面试必备"></a>6. 面试必备</h1><ul><li><a href="/2018/03/09/【面经】开发相关基础知识/" title="【面经】开发相关基础知识">【面经】开发相关基础知识</a> </li><li><a href="/2018/03/07/【面经】算法相关/" title="【面经】算法相关">【面经】算法相关</a> </li></ul><h1 id="7-计算广告相关"><a href="#7-计算广告相关" class="headerlink" title="7. 计算广告相关"></a>7. 计算广告相关</h1><h3 id="6-1-系统相关"><a href="#6-1-系统相关" class="headerlink" title="6.1 系统相关"></a>6.1 系统相关</h3><ul><li><a href="https://siyaozhang.github.io/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/" target="_blank" rel="external">【DSP系统】Java UDP通信模拟监听模块</a></li><li><a href="https://siyaozhang.github.io/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/" target="_blank" rel="external">DSP系统mysql数据库搭建</a></li></ul><h3 id="6-2-论文相关"><a href="#6-2-论文相关" class="headerlink" title="6.2 论文相关"></a>6.2 论文相关</h3><ul><li><a href="https://siyaozhang.github.io/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">DeepFM论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/12/07/WAND%E7%AE%97%E6%B3%95/" target="_blank" rel="external">WAND检索算法</a></li><li><a href="https://siyaozhang.github.io/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">Bid Optimizing and Inventory Scoring in Targeted Online论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">ptimal Real-Time Bidding for Display Advertising论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/" target="_blank" rel="external">搜索引擎Top-k快速检索问题</a></li><li><a href="https://siyaozhang.github.io/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/" target="_blank" rel="external">RTB论文笔记</a></li><li><a href="https://siyaozhang.github.io/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/" target="_blank" rel="external">DSP国内硕士论文总结</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章渐渐多了起来，为了方面复习和查找，对本站文章做个目录~&lt;/p&gt;
&lt;h1 id=&quot;1-算法与数据结构&quot;&gt;&lt;a href=&quot;#1-算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 算法与数据结构&quot;&gt;&lt;/a&gt;1. 算法与数据结构&lt;/h1&gt;&lt;h3 id=&quot;1-1-排序算法&quot;&gt;&lt;a href=&quot;#1-1-排序算法&quot; class=&quot;headerlink&quot; title=&quot;1.1 排序算法&quot;&gt;&lt;/a&gt;1.1 排序算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计数排序、计数排序、桶排序&lt;/a&gt; ，三种非比较排序，理想情况下时间复杂度可以降到&lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/10/排序算法终极大总结/&quot; title=&quot;排序算法终极大总结&quot;&gt;排序算法终极大总结&lt;/a&gt; 
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-数与数组&quot;&gt;&lt;a href=&quot;#1-3-数与数组&quot; class=&quot;headerlink&quot; title=&quot;1.3 数与数组&quot;&gt;&lt;/a&gt;1.3 数与数组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法基础班】二分法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/24/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法基础班】数与数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/02/02/【九章算法强化班】两指针/&quot; title=&quot;【九章算法强化班】两指针&quot;&gt;【九章算法强化班】两指针&lt;/a&gt; 包含&lt;strong&gt;partition、quickSelect&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/17/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E6%89%AB%E6%8F%8F%E7%BA%BF/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法强化班】扫描线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-动态规划&quot;&gt;&lt;a href=&quot;#1-2-动态规划&quot; class=&quot;headerlink&quot; title=&quot;1.2 动态规划&quot;&gt;&lt;/a&gt;1.2 动态规划&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt; 动态规划四要素，两类常见的动态规划：坐标型动态规划、序列型动态规划&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/08/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法强化】动态规划&lt;/a&gt; 包括DP的滚动数组优化、记忆化搜索、博弈类DP、区间型DP、背包DP&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/10/31/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【算法导论】钢条切割问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/01/%E3%80%90%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【算法导论】矩阵链乘法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-链表&quot;&gt;&lt;a href=&quot;#1-3-链表&quot; class=&quot;headerlink&quot; title=&quot;1.3 链表&quot;&gt;&lt;/a&gt;1.3 链表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/11/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E9%93%BE%E8%A1%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法基础班】链表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-4-树模块&quot;&gt;&lt;a href=&quot;#1-4-树模块&quot; class=&quot;headerlink&quot; title=&quot;1.4 树模块&quot;&gt;&lt;/a&gt;1.4 树模块&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/29/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法基础班】二叉树与分治法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/02/08/%E3%80%90leetcode%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;线段树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/14/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91Trie%E6%A0%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Trie树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/09/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81Trie%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;B/B+树、红黑树、AVL树、Trie树应用场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-5-图模块&quot;&gt;&lt;a href=&quot;#1-5-图模块&quot; class=&quot;headerlink&quot; title=&quot;1.5 图模块&quot;&gt;&lt;/a&gt;1.5 图模块&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法基础班】图与搜索&lt;/a&gt; 主要是BFS、DFS&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E3%80%90leetcode%E3%80%9151-52-N-Queens/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;回溯法、8皇后&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法强化班】并查集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-6-hash表、堆、栈、队列、Trie树、并查集&quot;&gt;&lt;a href=&quot;#1-6-hash表、堆、栈、队列、Trie树、并查集&quot; class=&quot;headerlink&quot; title=&quot;1.6 hash表、堆、栈、队列、Trie树、并查集&quot;&gt;&lt;/a&gt;1.6 hash表、堆、栈、队列、Trie树、并查集&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法基础班】数据结构&lt;/a&gt; 主要是hash表、堆、栈&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%A0%86Heap/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章算法强化班】堆Heap&amp;amp;双端队列Deque&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/04/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E7%AC%ACk%E5%A4%A7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第K大问题——堆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-系统设计&quot;&gt;&lt;a href=&quot;#2-系统设计&quot; class=&quot;headerlink&quot; title=&quot;2. 系统设计&quot;&gt;&lt;/a&gt;2. 系统设计&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章系统设计】新鲜事系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章系统设计】从用户系统理解数据库和缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C-%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【九章系统设计】一致性哈希&amp;amp;短网址系统设计&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-机器学习&quot;&gt;&lt;a href=&quot;#3-机器学习&quot; class=&quot;headerlink&quot; title=&quot;3. 机器学习&quot;&gt;&lt;/a&gt;3. 机器学习&lt;/h1&gt;&lt;h3 id=&quot;3-1-线性模型&quot;&gt;&lt;a href=&quot;#3-1-线性模型&quot; class=&quot;headerlink&quot; title=&quot;3.1 线性模型&quot;&gt;&lt;/a&gt;3.1 线性模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;LR&lt;/li&gt;
&lt;li&gt;svm&lt;/li&gt;
&lt;li&gt;PCA&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-2-树模型&quot;&gt;&lt;a href=&quot;#3-2-树模型&quot; class=&quot;headerlink&quot; title=&quot;3.2 树模型&quot;&gt;&lt;/a&gt;3.2 树模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/03/04/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;决策树（一）：基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/03/05/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%92%8C%E7%BC%BA%E5%A4%B1%E5%A4%84%E7%90%86/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;决策树（二）：连续值和缺失处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/03/05/%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%9A%E5%8F%98%E9%87%8F%E5%86%B3%E7%AD%96%E6%A0%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;决策树（三）：多变量决策树&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-3-评价指标等&quot;&gt;&lt;a href=&quot;#3-3-评价指标等&quot; class=&quot;headerlink&quot; title=&quot;3.3 评价指标等&quot;&gt;&lt;/a&gt;3.3 评价指标等&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/04/04/%E5%87%86%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81F1%E3%80%81ROC%E3%80%81AUC/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;准确率、召回率、F1、ROC、AUC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/03/16/%E4%BA%A4%E5%8F%89%E7%86%B5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;熵、交叉熵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/08/%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;过拟合欠拟合，L1\L2正则化项，bagging vs boosting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-4-机器学习实践&quot;&gt;&lt;a href=&quot;#3-4-机器学习实践&quot; class=&quot;headerlink&quot; title=&quot;3.4 机器学习实践&quot;&gt;&lt;/a&gt;3.4 机器学习实践&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jiayi797.github.io/2017/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习实践-不平衡类的处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jiayi797.github.io/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E4%B9%8B%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习实践-转化率预估之贝叶斯平滑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jiayi797.github.io/2017/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6-xgboost%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82%E6%8C%87%E5%8D%97%EF%BC%88Python%E7%89%88%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习框架-xgboost参数调节指南（Python版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-项目-amp-竞赛总结&quot;&gt;&lt;a href=&quot;#4-项目-amp-竞赛总结&quot; class=&quot;headerlink&quot; title=&quot;4. 项目&amp;amp;竞赛总结&quot;&gt;&lt;/a&gt;4. 项目&amp;amp;竞赛总结&lt;/h1&gt;&lt;h3 id=&quot;4-1-腾讯社交广告算法大赛&quot;&gt;&lt;a href=&quot;#4-1-腾讯社交广告算法大赛&quot; class=&quot;headerlink&quot; title=&quot;4.1 腾讯社交广告算法大赛&quot;&gt;&lt;/a&gt;4.1 腾讯社交广告算法大赛&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/06/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【腾讯转化率预估竞赛】总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/03/14/Factorization-Machine%EF%BC%88FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FM&lt;/a&gt; &lt;a href=&quot;https://siyaozhang.github.io/2017/03/22/FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FFM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-2-编程之美&quot;&gt;&lt;a href=&quot;#4-2-编程之美&quot; class=&quot;headerlink&quot; title=&quot;4.2 编程之美&quot;&gt;&lt;/a&gt;4.2 编程之美&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/08/%E3%80%902017%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【2017编程之美】搜索引擎总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-3-实习&quot;&gt;&lt;a href=&quot;#4-3-实习&quot; class=&quot;headerlink&quot; title=&quot;4.3 实习&quot;&gt;&lt;/a&gt;4.3 实习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/03/07/%E3%80%90%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;协同过滤实习项目总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;5-语言相关&quot;&gt;&lt;a href=&quot;#5-语言相关&quot; class=&quot;headerlink&quot; title=&quot;5. 语言相关&quot;&gt;&lt;/a&gt;5. 语言相关&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/27/Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java常用笔记&lt;/a&gt; 写代码的时候总忘记的小东西&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java垃圾回收机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;6-面试必备&quot;&gt;&lt;a href=&quot;#6-面试必备&quot; class=&quot;headerlink&quot; title=&quot;6. 面试必备&quot;&gt;&lt;/a&gt;6. 面试必备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/09/【面经】开发相关基础知识/&quot; title=&quot;【面经】开发相关基础知识&quot;&gt;【面经】开发相关基础知识&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/03/07/【面经】算法相关/&quot; title=&quot;【面经】算法相关&quot;&gt;【面经】算法相关&lt;/a&gt; 
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;7-计算广告相关&quot;&gt;&lt;a href=&quot;#7-计算广告相关&quot; class=&quot;headerlink&quot; title=&quot;7. 计算广告相关&quot;&gt;&lt;/a&gt;7. 计算广告相关&lt;/h1&gt;&lt;h3 id=&quot;6-1-系统相关&quot;&gt;&lt;a href=&quot;#6-1-系统相关&quot; class=&quot;headerlink&quot; title=&quot;6.1 系统相关&quot;&gt;&lt;/a&gt;6.1 系统相关&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【DSP系统】Java UDP通信模拟监听模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSP系统mysql数据库搭建&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;6-2-论文相关&quot;&gt;&lt;a href=&quot;#6-2-论文相关&quot; class=&quot;headerlink&quot; title=&quot;6.2 论文相关&quot;&gt;&lt;/a&gt;6.2 论文相关&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/10/DeepFM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DeepFM论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/12/07/WAND%E7%AE%97%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WAND检索算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/27/Bid-Optimizing-and-Inventory-Scoring-in-Targeted-Online%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bid Optimizing and Inventory Scoring in Targeted Online论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ptimal Real-Time Bidding for Display Advertising论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搜索引擎Top-k快速检索问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RTB论文笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://siyaozhang.github.io/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSP国内硕士论文总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【2017编程之美】搜索引擎总结</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%902017%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/08/【2017编程之美】搜索引擎总结/</id>
    <published>2018-03-08T03:24:00.000Z</published>
    <updated>2018-03-09T02:46:46.385Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要回顾和总结2017编程之美决赛中校园聊天机器人后端搜索引擎的实现。</p><h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>校园聊天机器人，针对用户的问题进行回答，当然，问题都是跟校园相关的一些问题。</p><p>收集校主页和论坛上的信息，招聘信息、征友信息、失物招领等信息，根据用户的需求返回合适的答案。</p><h2 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2. 爬虫"></a>2. 爬虫</h2><p>北邮人论坛格式相对工整，并不需要进行DFS爬取。论坛某个页面如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-19-39-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-19-39-36.png" alt="img"></a></p><p>论坛格式基本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1  [标题，最新回复时刻]</div><div class="line">2  [标题，最新回复时刻]</div><div class="line">...</div><div class="line">10 [标题，最新回复时刻]</div><div class="line"></div><div class="line"></div><div class="line">              第k页</div></pre></td></tr></table></figure><p>因此只需要按页遍历即可。</p><h3 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h3><p>爬取的内容建立一张表放入MySQL。由于每个帖子都有自己的唯一性ID，因此可以将这个ID作为主键。</p><div class="table-container"><table><thead><tr><th>文章ID（主键）</th><th>标题（已分词）</th><th>最后更新时刻</th><th>内容（已分词）</th><th>链接</th><th>已索引</th></tr></thead><tbody><tr><td>758943</td><td>社招/神马/搜索/北京/资深/广告/算法/研发/工程师</td><td>20180302 165751</td><td>基于/大规模/用户/行为/效果/目标/建立/优化/推荐/系统/基础/算法/策略 ….</td><td><a href="https://bbs.byr.cn/#!article/JobInfo/758943" target="_blank" rel="external">https://bbs.byr.cn/#!article/JobInfo/758943</a></td><td>是/否</td></tr><tr><td></td><td>…</td><td>…</td><td>…</td><td></td></tr></tbody></table></div><h3 id="2-2-实时爬虫"><a href="#2-2-实时爬虫" class="headerlink" title="2.2 实时爬虫"></a>2.2 实时爬虫</h3><p>由于北邮人论坛的【缘分天空】、【毕业生找工作】、【兼职实习信息】等板块很热火，几乎每小时都有新帖。因此可以不考虑资源浪费问题，直接采用定时爬虫进行信息更新和维护。</p><p>实时爬虫的流程如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-20-13-35.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-20-13-35.png" alt="img"></a></p><p>对于每个页面，我们可以从页面目录快速获取【文章ID、标题、发帖时刻、回复量、最新回复时刻、文章链接】信息。因此当获取到本页面的10篇文章的ID和最新回复时刻TimeStamp后：</p><ol><li><p>看库中是否存在此ID</p><ol><li><p>如果存在：</p><ol><li><p>此帖在近期有回复，更新最新回复时刻TimeStamp</p></li><li><p>此帖在近期无回复，有两种可能：</p><ol><li>后面的帖子不再有新的回复，因此可以直接停止本版面的爬虫；</li><li>爬取第1页时，本帖在第1页；爬取第2页时，本帖被顶到第2页；</li></ol><p>为了不让情况2误认为是近期无更新的贴，因此我们设置50次阈值。当连续50篇文章都没有新的更新时，停止爬虫。</p></li></ol></li><li><p>如果不存在，则爬取本页面并添加进数据库</p></li></ol></li></ol><p>对于每个版块的每个页面，执行以上循环操作。每个页面包含10篇左右文章。由于每篇文章打开需要约1秒，因此一页需要10多秒。北邮人论坛设置反爬虫机制，每连续访问10次后就要休息10秒才可以继续爬。而【毕业生找工作】等热门版面每日的更新量达300+条。那么完成一次此版面的爬取需要10分钟。三个版面的爬取大约需要20分钟。这个时间太长了，不利于后续的实施构建索引。</p><p>为了加速爬取速度，我们采用了多线程爬取技术。为了避免重复写入，因此每个线程只负责一个页面。当爬取完毕时，将数据扔到“待写入队列”里排队写入MySQL。</p><h3 id="2-3-分词"><a href="#2-3-分词" class="headerlink" title="2.3 分词"></a>2.3 分词</h3><p>利用jieba分词模块，对爬取的文档进行分词，首先按是否为汉字、数字、英文字符及标点符号对新闻内容进行梳理，去除掉信息缺失的数据，然后用jieba分词对标题及内容进行分词，并去掉停用词、生僻字等，得到文章的分词内容【这一步骤在爬虫模块已完成】。另外对于北邮人常用的找工作模块，需自定义计算机类技术栈关键词，如Python、Java、计算广告、推荐系统等。</p><p>分好词之后就可以存入数据库了。</p><h2 id="3-索引构建-amp-检索"><a href="#3-索引构建-amp-检索" class="headerlink" title="3. 索引构建&amp;检索"></a>3. 索引构建&amp;检索</h2><h3 id="3-1-向量空间模型"><a href="#3-1-向量空间模型" class="headerlink" title="3.1 向量空间模型"></a>3.1 向量空间模型</h3><p><strong>检索结果排序是搜索引擎最核心的部分，</strong>很大程度度上决定了搜索引擎的质量好坏及用户满意度。实际搜索结果排序的因子有很多，但最主要的两个因素是用户查询和网页内容的相关度，以及网页链接情况。这里我们主要总结网页内容和用户查询相关的内容。</p><p>​       判断网页内容是否与用户査询相关，这依赖于搜索引擎所来用的检索模型。检索模型是搜索引擎的理论基础，为量化相关性提供了一种数学模型，是对查询词和文档之间进行相似度计算的框架和方法。其本质就是相关度建模。</p><p><strong>常见检索模型：布尔模型，向量空间模型，概率模型，语言模型，机器学习排序算法</strong></p><ol><li><p>布尔模型</p><p>苹果 AND 公司：表示搜索既包含“苹果”，又包含“公司”这两个词的文档。<br>苹果 OR 公司：表示搜索包含“苹果”，或包含“公司”这两个词中任意一个的文档。<br>特点：简单粗暴</p></li><li><p><strong>向量空间模型</strong></p><p>苹果 AND 公司：表示搜索既包含“苹果”，又包含“公司”这两个词的文档。<br>苹果 OR 公司：表示搜索包含“苹果”，或包含“公司”这两个词中任意一个的文档。<br>特点：简单粗暴</p><p>本文就是采用这样的方式</p></li><li><p>概率检索模型</p><p>概率检索模型基于概率排序原理，是目前效果最好的模型之一，okapi BM25这一经典概率模型计算公式已经在商业搜索引擎的网页排序中广泛应用。</p><p>I. 概率排序原理</p><p>基本思想：给定一个用户查询，若搜索系统能在搜索结果排序时按照文档和用户查询的相关性由高到低排序，那么这个搜索系统的准确性是最优的。</p><p>II. 实际实现</p><ol><li>根据用户的查询将文档集合划分为两个集合：相关文档子集和不相关文档子集。</li><li>将相关性衡量转换为分类问题，对某个文档D来说，若其属于相关文档子集的概率大于属于不相关文档的概率，就认为它与查询相关。</li></ol><p>另P(R|D)代表给定一个文档D对应的相关性概率，而P(NR|D)代表该文档的不相关概率，若P(R|D)&gt;P(NR|D)我们就认为此文档与查询相关。</p><p>根据贝叶斯定理（详见<a href="http://blog.csdn.net/zealfory/article/details/77853128" target="_blank" rel="external">贝叶斯公式推导及意义</a>）,最终等价于计算:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(R|D)/P(NR|D)</div></pre></td></tr></table></figure><p>搜索系统无需分类，只需将文档按照上式大小降序排列即可。</p><p>III. 估值公式<br>基于二元独立模型（BIM）的二元假设和词汇独立性假设，得到最终的相关性估算公式：</p><p><img src="http://img.blog.csdn.net/20170923100608912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="估算公式"><br>其中pi代表第i个单词在相关文档集合中出现的概率，si代表第i个单词在不相关文档集合中出现的概率。</p><p>取log便于计算：<br><img src="http://img.blog.csdn.net/20170923100720285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>统计语言模型</p><p>基本思想：<br>​    其他的检索模型的思考路径是从<strong>查询</strong>到文档，即给定用户<strong>查询</strong>，如何找出相关的文档，该模型的思路正好想法，是由文档到<strong>查询</strong>这个方向，即为每个文档建立不同的语言模型，判断由文档生成用户<strong>查询</strong>的可能性有多大，然后按照这种生成概率由高到低排序，作为搜索结果。语言模型代表了单词或者单词序列在文档中的分布情况；</p><p>举个例子：</p><p>先引入一个概念：抽取概率<br>把一篇文档进行分词，统计其中每个词的出现频率进行计数，则一个词Word在文档Doc中的抽取概率为“Word词的计数/Doc中所有词的计数之和”。所谓抽取概率，就是在Doc中随机抽取一个词的话，Word被抽取到的概率。<br>假设用户搜索“野鸟装备 跑步”，野鸟装备在文档Doc1中的抽取概率1%，跑步的抽取概率为2%，则该次搜索中，Doc1的相关性得分为1%*2%。依此可以计算出所有文档的相关性得分，并按相关性得分对搜索结果进行排序。 </p></li><li><p>机器学习模型</p><p>机器学习与前面的模型相比，有几个显著的不同：<br>1、这里一般使用有监督的机器学习，因此需要对训练结果有监督反馈，用户对搜索结果的隐性评价（即点击）可以看作是一种监督反馈。<br>2、传统搜索计算搜索结果相关性一般也就考虑关键词匹配、词频等少数几个维度的数据，使用前面提到的模型已经足够，只有当考察的数据维度比较多时，机器学习的优势才会体现出来。比如像百度、Google这种大型的商业搜索引擎，考察的数据维度要多很多，比如链入链出链接数、网站类型、网站权威度、用户地理位置、历史搜索习惯、设备类型等等，据说Google考察的数据维度多达几百个。<br>特点：复杂度高，适合大型商业搜索引擎。</p><p><a href="http://blog.csdn.net/starzhou/article/details/51438140" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></p></li></ol><h3 id="3-2-TF-IDF"><a href="#3-2-TF-IDF" class="headerlink" title="3.2 TF-IDF"></a>3.2 TF-IDF</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-13-40-07.png" alt=""></p><h3 id="3-3-倒排索引构建"><a href="#3-3-倒排索引构建" class="headerlink" title="3.3 倒排索引构建"></a>3.3 倒排索引构建</h3><p>对每个词来说更新“词-文章序号”的倒排列表。倒排列表的结构如下：</p><div class="table-container"><table><thead><tr><th>ID</th><th>词</th><th>文档频率</th><th>倒排记录表</th></tr></thead><tbody><tr><td>0</td><td>中国</td><td>3</td><td>1,3,4</td></tr><tr><td>1</td><td>招聘</td><td>1</td><td>4，</td></tr><tr><td>2</td><td>蜜蜂</td><td>2</td><td>1,2</td></tr></tbody></table></div><h3 id="3-4-计算各文档的向量"><a href="#3-4-计算各文档的向量" class="headerlink" title="3.4 计算各文档的向量"></a>3.4 计算各文档的向量</h3><p>假如文档1包含的词有【中国，蜜蜂】，按照上字典序号对应的关系，词向量应该为[1,0,1][1,0,1] 。而用01表示词其实并不科学，这里每个词可以用TF-IDF来优化。那么词向量可能会变成[0.2,0,0.1][0.2,0,0.1]</p><p>计算每个文档的词向量（下表不必存储）：</p><div class="table-container"><table><thead><tr><th>文档</th><th>词</th><th>词向量</th></tr></thead><tbody><tr><td>1</td><td>中国，蜜蜂</td><td>[0.2,0,1][0.2,0,1]</td></tr><tr><td>2</td><td>蜜蜂</td><td>[0,0,0.8][0,0,0.8]</td></tr><tr><td>3</td><td>中国</td><td>[0.7,0,0][0.7,0,0]</td></tr><tr><td>4</td><td>中国，招聘</td><td>[0.4,0.6,0][0.4,0.6,0]</td></tr></tbody></table></div><p>将词向量模型更新添加进倒排索引：</p><div class="table-container"><table><thead><tr><th>词</th><th>文档频率</th><th>倒排记录表[文章ID，权重]</th></tr></thead><tbody><tr><td>中国</td><td>3</td><td>[1,0.2] , [3,0.7] , [4,0.4]</td></tr><tr><td>招聘</td><td>1</td><td>[4,0.6]</td></tr><tr><td>蜜蜂</td><td>2</td><td>[1,0.1], [2,0.8]</td></tr></tbody></table></div><p>其中每个文档中某个词的TF值只与该文档有关，但是IDF是与当前倒排表相关的，计算的时候这里需要主要 </p><h3 id="3-5-检索"><a href="#3-5-检索" class="headerlink" title="3.5 检索"></a>3.5 检索</h3><p>当用户输入查询词时，例如查询【中国，招聘】这两个关键字时，由于关键字无权重，因此可以直接设查询向量qq为[1,1,0][1,1,0] 。按理来说应该直接对着【文档dd-词向量】表格直接依次计算余弦相似度q×dq×d，然后取相似度最高的前K个作为返回结果。但是这样太暴力了，也太慢了。</p><p>机智的人类发现，q是一个01向量， q×dq×d 也就是对于q中那些为1的词项，计算在文档d中这些词的权重值和。</p><p>因此我们利用倒排索引优化查询。步骤为：</p><ol><li>在词典中定位【中国，招聘】这两个词，返回其倒排记录表。【中国 –&gt; [1,0.2] , [3,0.7] , [4,0.4]】，【招聘 –&gt; [4,0.6]】</li><li>文档4中，中国和招聘两个词的权重值和为1；而文档1的权重为0.2；文档3的权重为0.7</li></ol><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><ol><li><strong>索引构建/更新流程图</strong></li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-02-23-00-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-02-23-00-07.png" alt="img"></a></p><ol><li><strong>倒排索引数据库设计</strong></li></ol><p>将爬好的数据进行实时权重向量计算，填入下表，即是倒排表</p><div class="table-container"><table><thead><tr><th>词</th><th>文档频率</th><th>倒排记录表</th></tr></thead><tbody><tr><td>中国</td><td>3</td><td>[1,0.2] , [3,0.7] , [4,0.4]</td></tr><tr><td>招聘</td><td>1</td><td>[4,0.6]</td></tr><tr><td>蜜蜂</td><td>2</td><td>[1,0.1], [2,0.8]</td></tr></tbody></table></div><p>当时这个结构直接存储在了内存当中。但讲道理应该存储在MongoDB这一类KV数据库中。</p><h2 id="4-旧数据删除"><a href="#4-旧数据删除" class="headerlink" title="4. 旧数据删除"></a>4. 旧数据删除</h2><p>​    后续如果数据量不断增大，可以考虑将一些陈旧的帖子删除，比如保留最近半年有过更新的帖子，不过这还要考虑机器的容量。</p><p>本系统定义每天的凌晨4点进行旧数据清除工作。</p><p>​    每个帖子是有有效期的。当某个帖子过了某个时间后信息量就会变得很少，不再有检索需求。因此需要将旧帖子删掉。由于机器硬盘限制，本系统设定当帖子的最后更新时刻与当前时刻超过10天时，此贴应该被从数据库与索引中删除。</p><p>​    本系统定义每天的凌晨4点进行旧数据清除工作。</p><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><p>回头重新看这个问题时，我们发现如果有高并发等类似的请求时，系统还有很多地方需要优化：</p><h3 id="5-1-检索模型角度"><a href="#5-1-检索模型角度" class="headerlink" title="5.1 检索模型角度"></a>5.1 检索模型角度</h3><p>可以结合其他模型，比如概率模型、语言模型等，如果有一定的用户量之后可以结合learn to rank模型</p><h3 id="5-2-字典优化角度"><a href="#5-2-字典优化角度" class="headerlink" title="5.2 字典优化角度"></a>5.2 字典优化角度</h3><p>在实现字典时，通常会使用哈希表、树（二查查找树、字典树）等数据结构。</p><p><strong>用二查查找树实现字典</strong></p><p>使用二叉查找树实现词典时， 要先将数据对（的列表） <strong>按照单词词典顺序排列</strong>。</p><p>数据对 = [单词 + 该单词的倒排列表的引用（地址）]</p><p>若用内存上的二叉查找树实现之前例子中的词典， 就会得到如下图所示的树形结构。 树中的各个结点是通过地址引用（指针） 连接起来的</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-12-27.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-12-27.png" alt="img"></a></p><p>一般倒排列表都会很长，字典很大。因此会考虑将倒排列表存储到二级存储的连续区域中。</p><p>在二级存储上实现词典时，也要先将数据对按照单词的词典顺序排列， 然后一个接一个地存储到存储器上。 但是， 如果只是单纯地一个接一个地存储， 就无法知道各数据对应该在哪里结束了， 因此在此之上还要维护一个列表， 用于存储从开头算起每个数据对的偏移量。 对应的数据结构如图所示。 在进行检索时， 可以对该偏移量的列表进行二分查找。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-14-28.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-14-28.png" alt="img"></a></p><p>如果词典能够完整地加载到内存， 那么所形成的二叉树的搜索效率将会非常高。 特别是当二叉树处于平衡状态时， 平均进行log2Nlog2N 次查找就能找到单词。<br>但是， 如果词典无法完整地加载到内存， 而必须存储到二级存储器上时， 二叉树就未必是高效的数据结构了。 HDD 或 SSD 等二级存储器一般被称作“块设备”， 由于它们是以块为单位进行输入输出的 ， 所以即使只是读取块中 1 个字节的数据， 也不得不对整个块进行输入输出操作。 例如， 假设我们用二叉查找树实现了含有 100 万个单词的词典， 那么进行二分查找的话， 平均需要 20 次查找， 因此在最坏的情况下就需要加载 20 个块。 也就是说， 假设二级存储的加载性能为 5ms/ 块， 那么在 1 次检索中， 仅花费在二级存储输入输出上的时间就高达100ms。<br>因此， 当要存储大型词典时， 往往要使用适合块设备的 B+ 树等树形数据结构。</p><p><strong>用B+树实现字典</strong></p><p>B+ 树是一种平衡的多叉树， 属于从 B 树派生出来的树形结构。 在 B+ 树中， 所有的记录都存储在树中的叶结点（Leaf Node） 上， 内部结点（Internal Node） 上只以关键字的顺序存储关键字</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-43-00.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-03-03-13-43-00.png" alt="img"></a></p><p><strong>B+树通常以文件系统中页尺寸的常数倍为单位管理各节点。这样有助于减少检索时对二级存储的输入输出次数。</strong></p><h3 id="5-2-倒排索引构建-更新角度"><a href="#5-2-倒排索引构建-更新角度" class="headerlink" title="5.2 倒排索引构建/更新角度"></a>5.2 倒排索引构建/更新角度</h3><p>简单的文档列表直接存储在内存中。比如我们的项目搜索引擎的倒排索引就是放在内存中的，但是大多数情况倒排索引都是非常稀疏的表，因此用链表实现倒排索引非常好。</p><p>而<strong>文档链表一般都很大，因此很多都存储在二级存储中</strong>。这样就有两种构建方法：基于排序的构建方法和基于合并的构建方法。</p><p><strong>基于排序的索引构建法</strong></p><ol><li>对各文档中构成该文档的每个单词都建立一条【单词、文档编号、TF】的记录。然后将该记录写入二级存储上的文件末尾</li><li>将文件各条记录按照字典顺序排列；单词字段相同的再按照文档编号顺序排列</li><li>逐行读取排序后的文件，取出每个单词的文档编号列表；并用这些列表构建每个单词的倒排索引（这一步可以压缩倒排列表，此处省略）</li></ol><p><strong>基于合并的索引构建法</strong></p><p>基于合并的索引构建法是一种先在内存上构建出倒排索引的片段，然后将这些片段导出到二级存储，最后将导出的多个倒排索引合并在一起。</p><ol><li>在内存上构建【单词-倒排】的kv映射表Map。</li><li>如果某单词不在Map里，就要将该单词加入到Map中</li><li>当Map过大，就将Map导入文件里</li><li>重复1-3步骤，直到处理完所有文档。最后利用多路归并将将导出的各文件合并在一起。（这一步也可以压缩倒排，此处省略）</li></ol><p><strong>动态索引构建</strong></p><p>之前说的索引构建方法都是只有构建完成后才可用于检索。这叫静态构建方法（Offline Index Construction）。</p><p>还有一种动态构建方法（Online Index Construction / Dynamic Indexing）。这种方法可以<strong>一边更新索引，一边检索</strong>。其基本策略如下所示：</p><ul><li>将索引分成内存上的索引和磁盘上的索引分别管理</li><li>添加文档后，优先更新内存上的索引</li><li>当内存索引满时，将其整合到磁盘上的索引中</li></ul><h3 id="5-3-倒排索引压缩"><a href="#5-3-倒排索引压缩" class="headerlink" title="5.3 倒排索引压缩"></a>5.3 倒排索引压缩</h3><p>为什么要进行压缩？</p><p>如果数据量很大，倒排索引庞大，在使用倒排索引进行检索的过程中，总检索时间中的大部分时间往往花费在了<strong>从二级存储读取倒排索引</strong>上。于是，就经常可以看到在存储倒排索引前，对其进行压缩以减少从二级存储读取的时间，进而使检索处理得以高速运转的对策。</p><p>也就是说，我们可以根据如下原理，通过压缩倒排索引来加快检索处理的速度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">从二级存储中读取（部分）经过压缩的倒排索引的时间＋还原倒排索引的时间</div><div class="line">＜从二级存储中读取（部分）尚未经过压缩的倒排索引的时间</div></pre></td></tr></table></figure><p>倒排索引的压缩分为针对词典的压缩和针对倒排文件的压缩两种。<br>我们可以通过使用更少的信息量表示单词的集合来实现词典的压缩。例如，对于按照词典顺序排列的单词列表而言，通过避免重复存储相同的前缀，就可以减少存储词典时所需的必要存储空间。但是，在大多数情况下，由于词典的大小远远小于倒排文件的大小，所以一般认为压缩词典对于加快检索处理的速度并没有太大的贡献。</p><p>而倒排文件的压缩，可以通过使用更少的信息量表示其构成要素来实现。构成要素就是指文档编号、单词在文档内的出现次数（TF，Term Frequency，词频）以及由单词在文档内的偏移量构成的整数数组。</p><p><strong>使用可变长度的编码确实可以带来大幅度的压缩</strong>。</p><p>待填坑==</p><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ol><li><a href="https://jiayi797.github.io/2018/03/02/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9B%9E%E9%A1%BE/" target="_blank" rel="external">自制搜索引擎</a></li><li><a href="http://blog.csdn.net/guoziqing506/article/details/64122287" target="_blank" rel="external">B树与B+树</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="external">TF-IDF与余弦相似性的应用（一）：自动提取关键词</a></li><li><a href="http://blog.csdn.net/starzhou/article/details/51438140" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7981145" target="_blank" rel="external"> 搜索引擎的检索模型-查询与文档的相关度计算</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要回顾和总结2017编程之美决赛中校园聊天机器人后端搜索引擎的实现。&lt;/p&gt;
&lt;h2 id=&quot;1-项目简介&quot;&gt;&lt;a href=&quot;#1-项目简介&quot; class=&quot;headerlink&quot; title=&quot;1. 项目简介&quot;&gt;&lt;/a&gt;1. 项目简介&lt;/h2&gt;&lt;p&gt;校园聊天机器人
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】动态规划</title>
    <link href="http://yoursite.com/2018/03/08/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2018/03/08/【九章算法强化班】动态规划/</id>
    <published>2018-03-08T01:37:45.000Z</published>
    <updated>2018-03-08T01:37:45.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p>滚动数组</p><ul><li>house robber I/II</li><li>Maximal Square</li></ul><p>记忆化搜索</p><ul><li>longest increasing subsequence</li><li>coins in a line</li></ul><h2 id="动态规划四要素"><a href="#动态规划四要素" class="headerlink" title="动态规划四要素"></a>动态规划四要素</h2><ol><li>状态</li><li>转移方程</li><li>初始化</li><li>答案</li></ol><h2 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h2><p>f[i] = max(f[i-1],f[i-2]+A[i]);</p><p>转化为：</p><p>f[i%2] = max(f[(i-1)%2],f[(i-2)%2])</p><p>滚动数组优化不会对时间复杂度进行优化，而只是对空间进行优化</p><h3 id="例题1-House-Robber"><a href="#例题1-House-Robber" class="headerlink" title="例题1. House Robber"></a>例题1. <a href="https://leetcode.com/problems/house-robber" target="_blank" rel="external">House Robber</a></h3><p>给定一个数组，代表抢劫商店可以获得的价值，不可以抢劫相邻的商店，计算能够获得的最大价值</p><p>思路：</p><p><strong>序列型dp</strong></p><p><code>f[i]</code>代表抢劫前i个商店能够获得的最大值</p><p>对于店铺i可以有抢和不抢两种情况：</p><ol><li>如果抢，则不能抢f[i-1]，则前i个商店的最大值为前i-2个商店的最大值加上第i个商店的价值</li><li>如果不抢，则前i个商店的最大值=前i-1个商店的最大值</li></ol><p>取两种情况的最大值</p><p>转移方程:f[i] = max(f[i-1],f[i-2]+nums[i])</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>] + nums[i]);</div><div class="line">        System.out.println(dp[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>用滚动数组优化</strong></p><p>转移方程：<code>f[i] = max(f[i-1],f[i-2]+nums[i])</code></p><p>根据前面的分析，对于每一个商店i，我们只需要考虑商店i-1和i-2，也就是状态i只与它的前两个状态有关，所以我们只需要维护一个长度为2的数组来记录状态即可。</p><p>状态转移方程转化为<code>f[i%2] = max(f[(i-1)%2],f[(i-2)%2]+nums[i])</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        dp[i%<span class="number">2</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>],dp[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[(nums.length-<span class="number">1</span>)%<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这道题是状态只与前两个状态有关，如果推广到一般，如果状态i与前k个状态有关，则有：</p><p><code>f[i%k] = max(f[(i-1)%k],f[(i-2)%k]+nums[i])</code></p><h3 id="例题2-House-Robber-II"><a href="#例题2-House-Robber-II" class="headerlink" title="例题2. House Robber II"></a>例题2. <a href="https://leetcode.com/problems/house-robber-ii" target="_blank" rel="external">House Robber II</a></h3><p>首尾商店算相邻的商店，也就是商店是一个环。</p><p>思路：</p><p>对于成环的问题有两个小技巧：</p><ol><li>拆分数组的方式，将计算一个数组的问题转化成计算两个数组：<ol><li>去掉最后一个元素</li><li>去掉第一个元素</li></ol></li><li>将原数组copy一份，首尾相接，本题不适用</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span> [len-<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span> [len-<span class="number">1</span>];</div><div class="line">    dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    dp2[<span class="number">0</span>] = nums[<span class="number">1</span>];</div><div class="line">    dp2[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</div><div class="line">        dp1[i] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>] + nums[i]);</div><div class="line">        dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(dp1[nums.length-<span class="number">2</span>],dp2[nums.length-<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>滚动数组优化：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums.length;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">    dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    dp2[<span class="number">0</span>] = nums[<span class="number">1</span>];</div><div class="line">    dp2[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</div><div class="line">        dp1[i%<span class="number">2</span>] = Math.max(dp1[(i-<span class="number">1</span>)%<span class="number">2</span>],dp1[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i]);</div><div class="line">        dp2[i%<span class="number">2</span>] = Math.max(dp2[(i-<span class="number">1</span>)%<span class="number">2</span>],dp2[(i-<span class="number">2</span>)%<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Math.max(dp1[(nums.length-<span class="number">2</span>)%<span class="number">2</span>],dp2[(nums.length-<span class="number">2</span>)%<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Maximal-Square"><a href="#例题3-Maximal-Square" class="headerlink" title="例题3. Maximal Square"></a>例题3. <a href="https://leetcode.com/problems/maximal-square" target="_blank" rel="external">Maximal Square</a></h3><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return 4.</p></blockquote><p>找到全为1的正方形的最大面积</p><p>思路：</p><p>定位正方形，需要一个三维数组[x,y,a]</p><p>其中xy为正方形顶点坐标，a为边长</p><p><strong>baseline：</strong></p><p>x,y,a三层循环从0到n，然后x，y从1到a一共5层循环，复杂度<script type="math/tex">O(n^5)</script></p><p><strong>dp</strong></p><p>对于一个点<code>(i,j)</code> (nums[i,j] = 1)，如要计算以其为右下角的最大正方形边长，需要考虑三个点：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-21-14-20-12.png" alt=""> </p><ol><li>以(i-1,j-1)为右下角的最大正方形边长</li><li>以(i,j-1)为最右点的矩形长度</li><li>以(i-1,j)为最下点的矩形长度</li></ol><p>取三个值中最小的+1就是以(i,j)为右下角的矩形最大边长</p><p>因此：</p><ol><li><p>状态：</p><p><code>f[i][j]</code>表示以以(i,j)为右下角的矩形最大边长</p></li><li><p>转移方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i][j] = max(f[i-1],[j-1],up[i-1][j],left[i][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i][j] = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改进：</p><p>上面的方法除了维护f之外，还需要维护up和left数组，其实可以直接用f来代替up和left。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</div><div class="line">  f[i][j] = max(f[i-<span class="number">1</span>],[j-<span class="number">1</span>],f[i-<span class="number">1</span>][j],f[i][j-<span class="number">1</span>])+<span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">  f[i][j] = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f[i][0] = matrix[i][0]</div><div class="line">f[0][j] = matrix[0][j]</div></pre></td></tr></table></figure></li><li><p>答案</p><p><code>max(f[i][j])</code></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;rows;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;cols;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; cols;j++) &#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</div><div class="line">                    maxSquare = Math.max(maxSquare, dp[i][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxSquare*maxSquare;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>滚动数组优化：</strong></p><p>对于每一个元素(i,j)，只与它前一行和前一列的元素有关，与其前两行的元素无关，因此可以对其行进行滚动数组优化</p><p>转移方程变为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i%2][j] = max(f[(i-1)%2],[j-1],f[(i-1)%2][j],f[i%2][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i%2][j] = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;cols;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                maxSquare = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++) &#123;</div><div class="line">                <span class="comment">//每行第一个元素</span></div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                        dp[i%<span class="number">2</span>][j] = <span class="number">1</span>;</div><div class="line">                        maxSquare = Math.max(maxSquare, dp[i%<span class="number">2</span>][j]);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        dp[i%<span class="number">2</span>][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i%<span class="number">2</span>][j] = Math.min(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j-<span class="number">1</span>],Math.min(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j],dp[i%<span class="number">2</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</div><div class="line">                    maxSquare = Math.max(maxSquare, dp[i%<span class="number">2</span>][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i%<span class="number">2</span>][j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxSquare*maxSquare;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>follow up：</strong></p><p>01矩阵里面找一个，对角线全为1， 其他为0的正方形</p><p>转移方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(matrix[i][j] == 1)&#123;</div><div class="line">  f[i][j] = max(f[i-1],[j-1],up[i-1][j],left[i][j-1])+1</div><div class="line">&#125;</div><div class="line">if(matrix[i][j] == 0)&#123;</div><div class="line">  f[i][j] = 0;</div><div class="line">&#125;</div><div class="line">其中up和left表示前面连续0的个数</div></pre></td></tr></table></figure><h3 id="二维动态规划空间优化（二维滚动数组）总结"><a href="#二维动态规划空间优化（二维滚动数组）总结" class="headerlink" title="二维动态规划空间优化（二维滚动数组）总结"></a>二维动态规划空间优化（二维滚动数组）总结</h3><p>这类题目特点：</p><p><code>f[i][j]</code> = 由f[i-1]行 来决定状态， 第i行跟 i-1行之前毫无关系， 所以状态转变为：</p><p><code>f[i%2][j]</code> = 由f[(i-1)%2]行来决定状态</p><p>还有一些题目可以用滚动数组进行优化：</p><h3 id="习题1-Unique-Paths"><a href="#习题1-Unique-Paths" class="headerlink" title="习题1. Unique Paths"></a>习题1. <a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="external">Unique Paths</a></h3><h3 id="习题2-Minimum-Path-Sum"><a href="#习题2-Minimum-Path-Sum" class="headerlink" title="习题2. Minimum Path Sum"></a>习题2. <a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">Minimum Path Sum</a></h3><h3 id="习题3-Edit-Distance"><a href="#习题3-Edit-Distance" class="headerlink" title="习题3. Edit Distance"></a>习题3. <a href="https://leetcode.com/problems/edit-distance" target="_blank" rel="external">Edit Distance</a></h3><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><ul><li>本质上是动态规划</li><li>动态规划就是解决了重复计算的搜索</li><li>动态规划的实现方式：<ul><li>循环（从小到大递推）</li><li>记忆化搜索（从大到小）<ul><li>画搜索树</li><li>滚动数组优化，万金油</li></ul></li></ul></li></ul><h3 id="例题1-Longest-Increasing-Subsequence"><a href="#例题1-Longest-Increasing-Subsequence" class="headerlink" title="例题1. Longest Increasing Subsequence"></a>例题1. <a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="external">Longest Increasing Subsequence</a></h3><p>见<a href="https://siyaozhang.github.io/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%B8%8A" target="_blank" rel="external">【九章算法基础班】动态规划</a>/)</p><h3 id="例题2-Longest-Increasing-Path-in-a-Matrix"><a href="#例题2-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="例题2. Longest Increasing Path in a Matrix"></a>例题2. <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="external">Longest Increasing Path in a Matrix</a></h3><blockquote><p>Given an integer matrix, find the length of the longest increasing path.</p><p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums = [</div><div class="line">&gt;   [9,9,4],</div><div class="line">&gt;   [6,6,8],</div><div class="line">&gt;   [2,1,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums = [</div><div class="line">&gt;   [3,4,5],</div><div class="line">&gt;   [3,2,6],</div><div class="line">&gt;   [2,2,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return <code>4</code><br>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p></blockquote><p>分析：</p><p>用for循环解决这道题不知道起点在哪，即初始状态找不到</p><p>用搜索：</p><p>用搜索的方式，<code>f[i][j]</code> 为以点(i,j)为结尾的最长递增子序列长度，则需要看其上下左右四个点中没有被访问过的点，计算以这些点为结尾的最长递增子序列长度，这样就会有很多重复计算的点，因此可以用记忆化搜索，把计算过的点的信息存储下来，后面用到的时候直接查找即可。</p><p>记忆化搜索：</p><ul><li>状态： <code>f[i][j]</code> 为以点(i,j)为结尾的最长递增子序列长度</li><li>转移方程：<ul><li>a = +-1;b = 0;</li><li>b = +-1;a = 0;</li><li><code>f[i][j] =f[x+a][x+b]+1,if(a[x][y]&gt;a[x+a][x+b])</code></li></ul></li><li>初始化<ul><li><code>f[i][j] = 1</code> </li></ul></li><li>答案<ul><li><code>max f[i][j]</code> </li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingPathinaMatrix</span> </span>&#123;</div><div class="line">    <span class="comment">//计算矩阵中ij点的最长递增子序列的长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows= matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta =&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta =&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>;k++)&#123;</div><div class="line">            <span class="keyword">int</span> x = i + x_delta[k];</div><div class="line">            <span class="keyword">int</span> y = j + y_delta[k];</div><div class="line">            <span class="comment">//如果上下左右的节点都没有越界,而且当前点的值大于其相邻点的值</span></div><div class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; matrix[i][j] &gt; matrix[x][y])&#123;</div><div class="line">                maxlen = Math.max(maxlen,search(matrix,x,y,dp)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = maxlen;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line"><span class="comment">//        //初始化每个点最长递增子序列长度为1</span></div><div class="line"><span class="comment">//        for(int i = 0;i &lt; dp.length;i++)&#123;</span></div><div class="line"><span class="comment">//            for(int j = 0 ; j &lt; dp[0].length;j++)&#123;</span></div><div class="line"><span class="comment">//                dp[i][j] = 1;</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dp.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dp[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                res = Math.max(res,search(matrix,i,j,dp));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        LongestIncreasingPathinaMatrix test = <span class="keyword">new</span> LongestIncreasingPathinaMatrix();</div><div class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> res = test.longestIncreasingPath(matrix);</div><div class="line">        System.out.print(res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结：什么时候用记忆化搜索"><a href="#总结：什么时候用记忆化搜索" class="headerlink" title="总结：什么时候用记忆化搜索"></a>总结：什么时候用记忆化搜索</h3><ol><li>状态转移特别麻烦，不是顺序性。</li><li>初始化状态不是很容易找到。</li><li>从大到小</li></ol><h2 id="博弈类DP"><a href="#博弈类DP" class="headerlink" title="博弈类DP"></a>博弈类DP</h2><p>连两个人做游戏</p><p>解决博弈类DP通常用记忆化搜索的方法</p><h3 id="例题1-coins-in-a-line"><a href="#例题1-coins-in-a-line" class="headerlink" title="例题1.coins in a line"></a>例题1.<a href="http://www.lintcode.com/en/problem/coins-in-a-line/" target="_blank" rel="external">coins in a line</a></h3><blockquote><p>There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.</p><p>Could you please decide the <strong>first</strong> play will win or lose?</p><p>Example</p><p>n = <code>1</code>, return <code>true</code>.</p><p>n = <code>2</code>, return <code>true</code>.</p><p>n = <code>3</code>, return <code>false</code>.</p><p>n = <code>4</code>, return <code>true</code>.</p><p>n = <code>5</code>, return <code>true</code>.</p></blockquote><p>两个人轮流选取硬币，每次只能选1个或者2个，取到最后一个石子的人获胜，给定石子数量，返回第一个选的人（先手）能否获胜。</p><p>分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">画搜索树，以<span class="number">4</span>个coin为例</div><div class="line">先手层： <span class="number">4</span>T</div><div class="line">   <span class="number">1</span>↙      ↘<span class="number">2</span></div><div class="line">后手层：<span class="number">3F</span>    <span class="number">2</span>T</div><div class="line"> <span class="number">1</span>↙   ↘<span class="number">2</span>     <span class="number">1</span>↙   ↘<span class="number">2</span></div><div class="line">先手层：     <span class="number">2</span>T     <span class="number">1</span>T   <span class="number">1</span>T      <span class="number">0F</span></div><div class="line">  </div><div class="line">搜索树中的TorF表示当前选择coin的选手的输赢</div><div class="line">因为两个选手都会选择对自己最为有利的方式选取硬币，因此假设两个选手在开始的时候就已经绘制了这样的搜索树，以<span class="number">4</span>枚硬币的情况为例，先手可以选择<span class="number">1</span>个或者<span class="number">2</span>个:</div><div class="line"><span class="number">1</span>. 选<span class="number">1</span>个，还剩<span class="number">3</span>个，此时后手无论选择<span class="number">1</span>个还是<span class="number">2</span>个，先手都可以赢</div><div class="line"><span class="number">2</span>. 选<span class="number">2</span>个，还剩<span class="number">2</span>个，此时后手选<span class="number">2</span>个先手就会输掉比赛</div><div class="line">所以先手选择对自己最为有利的方式，选择<span class="number">1</span>个，赢得比赛。</div><div class="line">由此可见，当前有n个coin的情况下， 该选手是否能够赢得比赛与在剩余n-<span class="number">1</span>和n-<span class="number">2</span>枚硬币的情况下对手是否能够赢得比赛有关。</div><div class="line">以f(i)表示在剩余i枚硬币情况下当前选手是否能够获胜，</div><div class="line">则当下层节点中至少有一个为<span class="keyword">false</span>时，本层即可获胜</div><div class="line">状态转移方程为: f(i) = !f(i-<span class="number">1</span>)||!f(i-<span class="number">2</span>)</div><div class="line">初始化：f(<span class="number">1</span>)=f(<span class="number">2</span>)=<span class="keyword">true</span></div><div class="line">答案：f(i)</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    dp[<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</div><div class="line">        dp[i] = !dp[i-<span class="number">1</span>] || !dp[i-<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题2-coins-in-a-line-II"><a href="#例题2-coins-in-a-line-II" class="headerlink" title="例题2. coins in a line II"></a>例题2. <a href="http://www.lintcode.com/en/problem/coins-in-a-line-ii/" target="_blank" rel="external">coins in a line II</a></h3><blockquote><p>There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.</p><p>Could you please decide the <strong>first</strong> player will win or lose?</p><p>Example</p><p>Given values array A = <code>[1,2,2]</code>, return <code>true</code>.</p><p>Given A = <code>[1,2,4]</code>, return <code>false</code>.</p></blockquote><p>给定硬币序列，硬币具有价值，两个人轮流选取硬币，每次可以选1个或者2个获得相应的价值，最终获得价值多的人获胜，问先手能够获胜</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f[i]:表示还剩i个硬币，当前取硬币的人最后最多取硬币的价值</div><div class="line">如果f[i]&gt;所有硬币价值的一半则可以获胜</div><div class="line"></div><div class="line">以[5,1,2,10]为例</div><div class="line">先手层：     [5,1,2,10]</div><div class="line">       1↙    ↘2</div><div class="line">后手层：     [1,2,10]     [2,10]</div><div class="line">   1↙ ↘2     1↙   ↘2</div><div class="line">先手层：  [2,10]   [10] [10]    []</div><div class="line"></div><div class="line">两个人在选取硬币的时候，会选择给对方留下尽可能少的价值</div><div class="line">转移方程为：f[i] = sum[i]- min(f[i-1],f[i-2])</div><div class="line">初始化：</div><div class="line">f[1] = coins[i-1]</div><div class="line">f[2] = coins[i-1]+coins[i-2]</div><div class="line">答案：</div><div class="line">if dp[n] &gt; sum[coins]/2</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(values.length &lt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = values.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">        sum += values[i];</div><div class="line">        sums[i] = sum;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</div><div class="line">    dp[<span class="number">0</span>] = sums[sums.length-<span class="number">1</span>];</div><div class="line">    dp[<span class="number">1</span>] = sums[sums.length-<span class="number">2</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; values.length;i++)&#123;</div><div class="line">        dp[i] = sums[values.length-i-<span class="number">1</span>] - Math.min(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[values.length-<span class="number">1</span>] &gt; sums[<span class="number">0</span>]/<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Coins-in-a-Line-III"><a href="#例题3-Coins-in-a-Line-III" class="headerlink" title="例题3. Coins in a Line III"></a>例题3. Coins in a Line III</h3><blockquote><p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.</p><p>Could you please decide the first player will win or lose?</p><p><strong>Example</strong></p><p>Given array A = [3,2,2], return true.</p><p>Given array A = [1,2,4], return true.</p><p>Given array A = [1,20,4], return false.</p></blockquote><p>和II一样coin带有价值，选取时可以从头部或者尾部选取一个coin。</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">初始：[3, 2, 2]</div><div class="line"></div><div class="line">                  [3, 2, 2]</div><div class="line">                   dp[0][2]</div><div class="line">                /           \</div><div class="line">        取左3  /              \ 取右2</div><div class="line">             /                 \</div><div class="line">         [2, 2]                [3, 2]</div><div class="line">        dp[1][2]              dp[0][1]</div><div class="line">          /    \                  /  \</div><div class="line">   取左2 /       \ 取右2    取左3 /    \ 取右2</div><div class="line">        /         \             /      \</div><div class="line">    [2]            [2]        [2]      [3]</div><div class="line">  dp[2][2]     dp[1][1]     dp[1][1]   dp[0][0]</div><div class="line"> </div><div class="line">这道题目属于区间型dp</div><div class="line">dp[i][j] 现在还第i到第j的硬币，现在当前取硬币的人（先手）最后最多取硬币价值；这里是区间型DP，下标表示区间范围</div><div class="line">转移方程：</div><div class="line">sum[i][j]第i到第j的硬币价值总和</div><div class="line">dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);</div><div class="line">初始化：</div><div class="line">dp[i][i] = coin[i]</div><div class="line">答案：</div><div class="line">dp[0][n-1] &gt; sum[coins]/2</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] values,<span class="keyword">int</span>[][] sums,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line">    dp[i][j] = sums[i][j] - Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[values.length][values.length];</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length][values.length];</div><div class="line">    <span class="comment">//sums[i][j]为从i到j的coins价值和</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length;i++)&#123;</div><div class="line">        sums[i][i] = values[i];</div><div class="line">        dp[i][i] = values[i];</div><div class="line">        <span class="keyword">int</span> sum = sums[i][i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; values.length;j++)&#123;</div><div class="line">            sum += values[j];</div><div class="line">            sums[i][j] = sum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> search(values,sums,dp,<span class="number">0</span>,values.length-<span class="number">1</span>) &gt; sums[<span class="number">0</span>][values.length-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="区间型DP"><a href="#区间型DP" class="headerlink" title="区间型DP"></a>区间型DP</h2><p>特点：</p><ol><li>求一段区间的解max/min/count</li><li>转移方程通过区间更新</li><li>从大到小更新，用记忆化搜索</li></ol><h3 id="例题1-Stone-Game"><a href="#例题1-Stone-Game" class="headerlink" title="例题1. Stone Game"></a>例题1. Stone Game</h3><blockquote><p>There is a stone game.At the beginning of the game the player picks <code>n</code> piles of stones in a line.</p><p>The goal is to merge the stones in one pile observing the following rules:</p><ol><li>At each step of the game, the player can merge two adjacent piles to a new pile.</li><li>The score is the number of stones in the new pile.</li></ol><p>You are to determine the <strong>minimum</strong> of the total score.</p><p><strong>Example</strong></p><p>For <code>[4, 1, 1, 4]</code>, in the best solution, the total score is <code>18</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1. Merge second and third piles =&gt; [4, 2, 4], score +2</div><div class="line">&gt; 2. Merge the first two piles =&gt; [6, 4]，score +6</div><div class="line">&gt; 3. Merge the last two piles =&gt; [10], score +10</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Other two examples:</p><p><code>[1, 1, 1, 1]</code> return <code>8</code> <code>[4, 4, 5, 9]</code> return <code>43</code></p></blockquote><p>给定数组，每次合并相邻元素直至全部合并，每次合并需要花费两个元素价值之和，返回最小的花费</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以[3,4,5,6]为例：</div><div class="line">死胡同:容易想到的一个思路从小往大，枚举第一次合并是在哪? 转而用记忆化搜索的思路，从大到小，先考虑最后的0 ~ n-1合并的总花费。</div><div class="line">正确的打开方式：</div><div class="line"></div><div class="line">将区间拆分，看成是两个区间的合并</div><div class="line">                        [3,4,5,6]</div><div class="line">                          (0,3)</div><div class="line">               ↙   ↓    ↘</div><div class="line">      [3]+[4,5,6]   [3,4]+[5,6]   [3,4,5]+[6]   </div><div class="line">      (0,0)+(1,3)   (0,1)+(2,3)   (0,2)+(3,3)</div><div class="line">            ↙   ↘</div><div class="line">   (1,1)+(2,3) (1,2)+(3,3) .....</div></pre></td></tr></table></figure><ul><li>State:<ul><li><code>dp[i][j]</code>表示把第i到第j个石子合并到一起的最小花费</li></ul></li><li>Function:<ul><li>预处理<code>sum[i,j]</code>表示i到j所有石子价值和</li><li><code>dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i,j])</code> 对于所有<code>k</code>属于<code>{i,j}</code></li></ul></li><li>Intialize:<ul><li>for each i<ul><li><code>dp[i][i] = 0</code></li></ul></li></ul></li><li>Answer:<ul><li><code>dp[0][n-1]</code></li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] stones,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt; j)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(dp[i][j]!= <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> dp[i][j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = i;idx &lt;= j;idx++)&#123;</div><div class="line">        minCost = Math.min(minCost,Math.min(search(stones,dp,i,idx),search(stones,dp,idx+<span class="number">1</span>,j)));</div><div class="line">    &#125;</div><div class="line">    dp[i][j] = minCost;</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StoneGame</span><span class="params">(<span class="keyword">int</span>[] stones)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length][stones.length];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; stones.length;i++)&#123;</div><div class="line">        dp[i][i] = stones[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> search(stones,dp,<span class="number">0</span>,stones.length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题2-Burst-Balloons"><a href="#例题2-Burst-Balloons" class="headerlink" title="例题2. Burst Balloons"></a>例题2. <a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="external">Burst Balloons</a></h3><blockquote><p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p><p>Find the maximum coins you can collect by bursting the balloons wisely.</p><p><strong>Note:</strong><br>(1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>(2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</p><p><strong>Example:</strong></p><p>Given <code>[3, 1, 5, 8]</code></p><p>Return <code>167</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</div><div class="line">&gt;    coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>戳气球，每次戳破气球i可以获得价值nums[i-1]*nums[i]&amp;nums[i+1]，返回可以获得的最大利润。</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[3, 1, 5, 8]</div><div class="line">↙↙↘   ↘</div><div class="line">最后一次打爆的气球:3  15      8</div><div class="line">获得价值：                               1*5*1</div><div class="line">[1,5,8]   [3,5,8]    [3,1](5)[8]   [3,1,5]</div><div class="line">  ↙    ↘    ↓    </div><div class="line">最后一次打爆的气球:           3   1   8</div><div class="line">获得价值1*3*5  1*1*5  5*8*1</div><div class="line">    (3)[1](5) [3](1)(5)</div><div class="line">    ↓         ↓ </div><div class="line">最后一次打爆的气球:          1          3</div><div class="line">获得价值      3*1*5       1*3*1</div></pre></td></tr></table></figure><ul><li><p>State:</p><ul><li><code>dp[i][j]</code>表示把第i到第j个气球打爆获得的最大价值</li></ul></li><li><p>Function:</p><p>计算<code>dp[i][j]</code> 需要遍历ij区间内所有的点，看做最后一个从ij区间中删除的点，删除该点时获得的价值为<code>nums[i-1]*nums[k]*nums[j+1]</code>，然后再删除该点之前，其左边和右边的节点已经全部被删除，所以转移方程为：</p><ul><li><code>dp[i][j] = max(nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j])</code> 对于所有<code>k</code>属于<code>{i,j}</code></li></ul></li><li><p>Intialize:</p><ul><li>for each i<ul><li><code>dp[i][i] = 0</code></li></ul></li></ul></li><li><p>Answer:</p><ul><li><code>dp[0][n-1]</code></li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算戳破从i到j所有气球获得的coins</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[][] max,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i &gt; j)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果已经计算过了</span></div><div class="line">        <span class="keyword">if</span>(max[i][j] != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> max[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</div><div class="line">        <span class="comment">//假设idx是ij区间中最后一个被戳破的气球</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = i;idx &lt;= j;idx++)&#123;</div><div class="line">            <span class="keyword">int</span> left = i-<span class="number">1</span> &lt; <span class="number">0</span>?<span class="number">1</span>:nums[i-<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> right = j+<span class="number">1</span> &gt;= nums.length ?<span class="number">1</span>:nums[j+<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> temp = left * right * nums[idx];</div><div class="line">            maxVal = Math.max(maxVal,temp + solve(nums,max,i,idx-<span class="number">1</span>) + solve(nums,max,idx+<span class="number">1</span>,j));</div><div class="line">        &#125;</div><div class="line">        max[i][j] = maxVal;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];<span class="comment">//打爆ij所有气球的最大值</span></div><div class="line">        <span class="comment">//Arrays.fill(max,-1);</span></div><div class="line">        <span class="keyword">return</span> solve(nums,max,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Scramble-String"><a href="#例题3-Scramble-String" class="headerlink" title="例题3. Scramble String"></a>例题3. <a href="https://leetcode.com/problems/scramble-string" target="_blank" rel="external">Scramble String</a></h3><blockquote><p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p><p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     great</div><div class="line">&gt;    /    \</div><div class="line">&gt;   gr    eat</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; g   r  e   at</div><div class="line">&gt;            / \</div><div class="line">&gt;           a   t</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     rgeat</div><div class="line">&gt;    /    \</div><div class="line">&gt;   rg    eat</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; r   g  e   at</div><div class="line">&gt;            / \</div><div class="line">&gt;           a   t</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     rgtae</div><div class="line">&gt;    /    \</div><div class="line">&gt;   rg    tae</div><div class="line">&gt;  / \    /  \</div><div class="line">&gt; r   g  ta  e</div><div class="line">&gt;        / \</div><div class="line">&gt;       t   a</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em></p></blockquote><p>分析：</p><p>对于s1和s2，找不同的分割点k，将其分别分为两个子数组。若s1的两个子数组和对应的s2的两个子数组都是scramble的，则s1和s2就是scramble的。例如，s1[0…i]被分为0…k，k+1…i，其对应的s2子数组为0…k，k+1…i或者0…i-k-1, i-k…i（即s2的前k个元素或者后k个元素对应于s1的前k个元素，比如s1=abc，s2=acb，第一层递归时比较的是s1左边的子数组和s2左边的子数组以及s1右边的子数组和s2右边的子数组，第二层递归比较右边两个子数组时，就要比较s1右边子数组的左边子数组”b”和s2右边子数组的右边子数组”b”），只要两种情况里面有一种满足，则s1和s2就是scramble的。</p><p>( isScramble(s2[0…k], s1[0…k]) &amp;&amp; isScramble(s2[k+1…j], s1[k+1…i]) ) || ( isScramble(s2[0…k], s1[i-k…i]) &amp;&amp; isScramble(s2[k+1…j], s1[0…i-k-1]) )，（k = 0,1,2 … i-1，k相当于字符串的分割点)</p><p>因此可以用记忆化搜索来保存子问题，设dp[i][j][k]表示s2从j开始长度为k的子串是否可以由s1从i开始长度为k的子串转换而成:</p><p>状态：</p><p><code>dp[i][j][k]</code> 表示s1从第i个开始s2从第j个开始的k个字母是否是scramble string</p><p>因此状态转移方程为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">对于所有的i属于[1,k]:</div><div class="line">s11 = s1.substring(0, i);  </div><div class="line">s12 = s1.substring(i, i+k-1); </div><div class="line">s21 = s2.substring(0, i);  </div><div class="line">s22 = s2.substring(i, i+k-1)</div><div class="line">s23 = s2.substring(j, j+k-i-1);  </div><div class="line">s24 = s2.substring(j+k-i, j+k-1); </div><div class="line">for i = x -&gt; x+k ：</div><div class="line">  dpx[k] = (dpx[i] &amp;&amp; dpx+i[k-i]) || dpx[i] &amp;&amp; dpx+i[k-i])</div></pre></td></tr></table></figure><p>初始化：</p><p><code>dp[i][j][1] = s1[i]==s[j].</code></p><p>答案：</p><p><code>dp[0][0][len]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[][][] dp,<span class="keyword">boolean</span>[][][] visited,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="comment">//如果计算过了，直接返回</span></div><div class="line">        <span class="keyword">if</span>(visited[i][j][k])&#123;</div><div class="line">            <span class="keyword">return</span> dp[i][j][k];</div><div class="line">        &#125;</div><div class="line">        dp[i][j][k] = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>;idx &lt; k;idx++)&#123;</div><div class="line">            <span class="keyword">if</span>((search(dp,visited,i,j,idx) &amp;&amp; search(dp,visited,i+idx,j+idx,k-idx) )||</div><div class="line">                    (search(dp,visited,i,j+k-idx,idx) &amp;&amp; search(dp,visited,i+idx,j,k-idx)))&#123;</div><div class="line">                dp[i][j][k] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[i][j][k] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> dp[i][j][k];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1.length() != s2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len = s1.length();</div><div class="line">        <span class="keyword">boolean</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];</div><div class="line">        <span class="keyword">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</div><div class="line">                dp[i][j][<span class="number">1</span>] = s1.charAt(i)== s2.charAt(j);</div><div class="line">                visited[i][j][<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> search(dp,visited,<span class="number">0</span>,<span class="number">0</span>,len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>递归也可以做</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1.equals(s2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s1.length();i++) &#123;</div><div class="line">            count[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count.length;i++) &#123;</div><div class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(<span class="number">0</span>, i)) </div><div class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(s2.length()-i)) </div><div class="line">               &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>, s2.length()-i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="背包类DP"><a href="#背包类DP" class="headerlink" title="背包类DP"></a>背包类DP</h2><p>特点：</p><ol><li>用值作为DP维度</li><li>DP过程就是填写矩阵</li><li>可以用滚动数组优化</li></ol><h3 id="例题1-Backpack"><a href="#例题1-Backpack" class="headerlink" title="例题1. Backpack"></a>例题1. <a href="http://www.lintcode.com/en/problem/backpack/" target="_blank" rel="external">Backpack</a></h3><blockquote><p>Given <em>n</em> items with size Ai, an integer <em>m</em> denotes the size of a backpack. How full you can fill this backpack?</p><p>Example</p><p>If we have <code>4</code> items with size <code>[2, 3, 5, 7]</code>, the backpack size is 11, we can select <code>[2, 3, 5]</code>, so that the max size we can fill this backpack is <code>10</code>. If the backpack size is <code>12</code>. we can select <code>[2, 3, 7]</code> so that we can fulfill the backpack.</p><p>You function should return the max size we can fill in the given backpack.</p></blockquote><p>给定背包容量和物品数组，返回最大的</p><p>分析：</p><p>不可以用贪心，比如[8,7,5]，容量为12</p><p>如果用贪心法放了8就放不下其他的了，但是放7和5得到的总容量更大，所以不能用贪心法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以items = [2,3,4,5]，size=11为例分析：</div><div class="line"></div><div class="line">定以一个矩阵，行数为items.length，列数为size</div><div class="line"></div><div class="line">idx 01234567...</div><div class="line"> 0TFFFFFFF...</div><div class="line"> 1TFTFFFFF...</div><div class="line"> 2TFTTFTFF...</div><div class="line"> 3T...</div><div class="line"> 4T...</div><div class="line"></div><div class="line">state:</div><div class="line">f[i][S]表示在前i个物品中取出一些能否组成和为S</div><div class="line"></div><div class="line">function：</div><div class="line">在前i个物品中是否有选择方式使得取出的物品和为S，可以分两种情况讨论：</div><div class="line">1. 选择第i个物品：需要考虑在前i-1和物品中是否可以选取一些物品组成s-a[i]</div><div class="line">2. 不选第i个物品：需要考虑在前i-1和物品中是否可以选取一些物品组成s</div><div class="line">因此状态转移方程为:</div><div class="line">f[i][S] = f[i-1][s-a[i]] or f[i-1][s]</div><div class="line"></div><div class="line">initial:</div><div class="line">f[i][0] = true;</div><div class="line">f[0][j] = false;j!=0</div><div class="line"></div><div class="line">answer:</div><div class="line">max j,f[i][j] = true;</div><div class="line"></div><div class="line">滚动数组优化：</div><div class="line">可以看出来f[i][S]只与前一行有关，所以可以进行二位滚动数组优化</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; A.length+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i-A[j-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</div><div class="line">                dp[j][i] = dp[j-<span class="number">1</span>][i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                dp[j][i] = dp[j-<span class="number">1</span>][i-A[j-<span class="number">1</span>]] || dp[j-<span class="number">1</span>][i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(dp[j][i])&#123;</div><div class="line">                res =i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题2-BackPack马甲变换1，硬币凑整"><a href="#例题2-BackPack马甲变换1，硬币凑整" class="headerlink" title="例题2. BackPack马甲变换1，硬币凑整"></a>例题2. BackPack马甲变换1，硬币凑整</h3><p>给定面值1,2,5,10的硬币无穷多个，请问能够凑成80元的方案总数。</p><p>分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">states：</div><div class="line">dp[i][j]表示用前i种硬币凑成j元钱的方案总数</div><div class="line"></div><div class="line">以[1,2,5,10] total = 80 为例：</div><div class="line">依然采用填写矩阵的方式</div><div class="line">idx012345678910...</div><div class="line">010000000000...</div><div class="line">111111111111...</div><div class="line">2112233...</div><div class="line">31...</div><div class="line">41</div><div class="line"></div><div class="line">动态转移方程：</div><div class="line">用前i种硬币凑成j元，考虑第i种硬币取的个数k</div><div class="line">dp[i][j] = dp[i-1][j-val[i]] +....+dp[i-1][j-val[i]*k]</div><div class="line"></div><div class="line">初始化：</div><div class="line">dp[i][0] = 1;</div><div class="line">dp[0][j] = 0;(j!=0)</div><div class="line"></div><div class="line">答案：</div><div class="line">dp[val.length][total]</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m+<span class="number">1</span>;i++)&#123;</div><div class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(k * A[i-<span class="number">1</span>] &lt;= m)&#123;</div><div class="line">                dp[i][j] += dp[i-<span class="number">1</span>][j-k*A[i-<span class="number">1</span>]];</div><div class="line">                k++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题3-Coin-Change"><a href="#例题3-Coin-Change" class="headerlink" title="例题3. Coin Change"></a>例题3. <a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="external">Coin Change</a></h3><blockquote><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p><strong>Example 1:</strong><br>coins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>return <code>3</code> (11 = 5 + 5 + 1)</p><p><strong>Example 2:</strong><br>coins = <code>[2]</code>, amount = <code>3</code><br>return <code>-1</code>.</p></blockquote><p>给定硬币面值，和总价值，返回能凑成总价值所用硬币数的最小值</p><p>思路：</p><p>和上一题思路类似</p><p>state:</p><p><code>dp[i][j]</code> 表示用i种硬币凑成j元所需要的最少硬币数量</p><p>function：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][j] = min&#123;dp[i-1][j-k*A[i-1]]+k&#125;</div><div class="line">for each k*A[i-1]] &lt;= amout &amp;&amp; dp[i-1][j-k*A[i-1]] != 0</div></pre></td></tr></table></figure><p>initial：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][0] = 1;</div><div class="line">dp[0][j] = 0;(j!=0)</div></pre></td></tr></table></figure><p>answer：</p><p><code>dp[coins.length][amount]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;coins.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; amount+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; coins.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; amount+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">                <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">while</span>(k * coins[i-<span class="number">1</span>] &lt;= j)&#123;</div><div class="line">                    <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j-k*coins[i-<span class="number">1</span>]] != -<span class="number">1</span>)&#123;</div><div class="line">                        minCount = Math.min(minCount,dp[i-<span class="number">1</span>][j-k*coins[i-<span class="number">1</span>]]+k);</div><div class="line">                    &#125;</div><div class="line">                    k++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(minCount != Integer.MAX_VALUE)&#123;</div><div class="line">                    dp[i][j] = minCount;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(dp[coins.length][amount] == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> dp[coins.length][amount];</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>优化：</p><h3 id="例题4-BackPack-马甲变换2"><a href="#例题4-BackPack-马甲变换2" class="headerlink" title="例题4. BackPack 马甲变换2"></a>例题4. BackPack 马甲变换2</h3><p>把一个数组[1,24,5,6]尽量平分</p><p>可以转化为背包问题：</p><p>数组总和为36，一半为18</p><p>背包容量为18，用数组中的数字尽量将背包装满</p><h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="external">Partition Equal Subset Sum</a></h3><blockquote><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong></p><ol><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 5, 11, 5]</div><div class="line">&gt;</div><div class="line">&gt; Output: true</div><div class="line">&gt;</div><div class="line">&gt; Explanation: The array can be partitioned as [1, 5, 5] and [11].</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 3, 5]</div><div class="line">&gt;</div><div class="line">&gt; Output: false</div><div class="line">&gt;</div><div class="line">&gt; Explanation: The array cannot be partitioned into equal sum subsets.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>返回是否能够取到整个数组的一半。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionEqualSubsetSum</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span> != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        sum = sum/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length+<span class="number">1</span>][sum+<span class="number">1</span>];</div><div class="line">        <span class="comment">//chushihua</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; sum+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(j &lt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[nums.length][sum];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题5-Backpack-II"><a href="#例题5-Backpack-II" class="headerlink" title="例题5.  Backpack II"></a>例题5.  <a href="http://www.lintcode.com/en/problem/backpack-ii/" target="_blank" rel="external">Backpack II</a></h3><p>给定物品占空间和物品价值数组，背包容量，如何装能够使得背物品价值最高</p><p>不可以用贪心算法</p><p>分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">依然采用补全矩阵的方法</div><div class="line">体积数组为A，价值数组为val,容量为S</div><div class="line">state：</div><div class="line">f[i][j]表示在前i个物品中选取一些物品，构成总体积为j，所获得的最高价值是多少</div><div class="line">function：</div><div class="line">考虑第i个物品，有选和不选两种情况：</div><div class="line"><span class="number">1</span>. 选：总价值为f[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>]</div><div class="line"><span class="number">2</span>. 不选：总价值为f[i-<span class="number">1</span>][j]</div><div class="line">取两者之中较大的，因此状态转移方程为：</div><div class="line">f[i][j] = max(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>])</div><div class="line">initial:</div><div class="line">f[<span class="number">0</span>][i] = <span class="number">0</span></div><div class="line">f[i][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">answer：</div><div class="line">f[A.length][S]</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(j &gt;= A[i-<span class="number">1</span>])&#123;</div><div class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="例题6-K-Sum"><a href="#例题6-K-Sum" class="headerlink" title="例题6. K Sum"></a>例题6. K Sum</h3><p>给定数组A=[1,2,3,4],k=2,target=5</p><p>在A中选2个元素，和为5，返回方案个数</p><p>思路：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">state:</div><div class="line">f[i][j][k]表示在前i个元素中选取j个出来和为t个方案个数</div><div class="line">function:</div><div class="line">考虑第i个元素，有选和不选两种方案，两种方案数求和</div><div class="line">f[i][j][k] = f[i-<span class="number">1</span>][j-<span class="number">1</span>][t-A[i-<span class="number">1</span>]] + f[i-<span class="number">1</span>][j][t]</div><div class="line">initial:</div><div class="line">f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">answer:</div><div class="line">f[A.length][k][target]</div></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> A: An integer array</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> k: A positive integer (k &lt;= length(A))</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target: An integer</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kSum</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][k+<span class="number">1</span>][target+<span class="number">1</span>];</div><div class="line">        <span class="comment">//Chushihua</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; A.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; k+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; target+<span class="number">1</span>;l++)&#123;</div><div class="line">                    <span class="keyword">if</span>(l &gt;= A[i-<span class="number">1</span>])&#123;</div><div class="line">                        dp[i][j][l] = dp[i-<span class="number">1</span>][j][l] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>][l-A[i-<span class="number">1</span>]];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        dp[i][j][l] = dp[i-<span class="number">1</span>][j][l];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[A.length][k][target];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优化：</p><h3 id="例题7-Minnimum-Adjus"><a href="#例题7-Minnimum-Adjus" class="headerlink" title="例题7. Minnimum Adjus"></a>例题7. Minnimum Adjus</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>区间类DP<ul><li>从大到小去思考，将区间划分成小区间</li><li>主要通过记忆化搜索来解决</li></ul></li><li>背包类DP<ul><li>用值座位DP维度</li><li>用for循环填写矩阵数值</li><li>可以用滚动数组做优化</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;p&gt;滚动数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;house robber I/II&lt;/li&gt;
&lt;li&gt;Maxim
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【面经】算法相关</title>
    <link href="http://yoursite.com/2018/03/07/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/03/07/【面经】算法相关/</id>
    <published>2018-03-07T11:33:12.000Z</published>
    <updated>2018-03-10T09:31:43.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-海量数据选取TOPK"><a href="#1-海量数据选取TOPK" class="headerlink" title="1. 海量数据选取TOPK"></a>1. 海量数据选取TOPK</h3><p>baseline：</p><p>用堆，如果取最大的K个，就用最小堆，遍历数组，遇到比堆顶元素大的元素就入堆，同时堆中元素超过k个需要poll操作，保证堆中只有K个元素，最终的topk元素在堆中。</p><p>时间复杂度分析:</p><script type="math/tex; mode=display">O(n*logk)$$ ，元素入堆复杂度$$O(logk)</script><script type="math/tex; mode=display">O(n)$$算法：先用quick select方法找到第K大的元素，复杂度$$O(n)</script><p>然后再遍历一遍，将大于K的元素取出，复杂度<script type="math/tex">O(n)</script></p><p>总复杂度<script type="math/tex">O(n)</script></p><p>！！！！！卧槽！神奇！！！！</p><p><strong>follow up：海量数据选取第K大</strong></p><p>Quick Select，详见<a href="/2018/02/02/【九章算法强化班】两指针/" title="【九章算法强化班】两指针">【九章算法强化班】两指针</a> </p><p>时间复杂度<script type="math/tex">O(n)</script></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-海量数据选取TOPK&quot;&gt;&lt;a href=&quot;#1-海量数据选取TOPK&quot; class=&quot;headerlink&quot; title=&quot;1. 海量数据选取TOPK&quot;&gt;&lt;/a&gt;1. 海量数据选取TOPK&lt;/h3&gt;&lt;p&gt;baseline：&lt;/p&gt;
&lt;p&gt;用堆，如果取最大的K个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【实习项目总结】</title>
    <link href="http://yoursite.com/2018/03/07/%E3%80%90%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/07/【实习项目总结】/</id>
    <published>2018-03-07T10:35:03.000Z</published>
    <updated>2018-03-07T10:35:03.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>无线短视频推荐项目，负责无线端用户的短视频推荐，也就是给手机端用户推荐短视频。主要用到了item-based协同过滤的思想，为用户提供候选短视频推荐集合，然后再利用预训练的LR模型返回候选推荐集合的最终排序，推给用户。</p><h2 id="2-推荐系统分类"><a href="#2-推荐系统分类" class="headerlink" title="2. 推荐系统分类"></a>2. 推荐系统分类</h2><p>感谢@<a href="https://www.zhihu.com/question/20326697/answer/58148605" target="_blank" rel="external">奔波的梦想</a> 的总结。推荐算法大致可以分为三类：基于内容的推荐算法、协同过滤推荐算法和基于知识的推荐算法。<br>​         <strong>基于内容的推荐算法</strong>，原理是用户喜欢和自己关注过的Item在内容上类似的Item，比如你看了哈利波特I，基于内容的推荐算法发现哈利波特II-VI，与你以前观看的在内容上面（共有很多关键词）有很大关联性，就把后者推荐给你，这种方法可以避免Item的冷启动问题（冷启动：如果一个Item从没有被关注过，其他推荐算法则很少会去推荐，但是基于内容的推荐算法可以分析Item之间的关系，实现推荐），弊端在于推荐的Item可能会重复，典型的就是新闻推荐，如果你看了一则关于MH370的新闻，很可能推荐的新闻和你浏览过的，内容一致；另外一个弊端则是对于一些多媒体的推荐（比如音乐、电影、图片等)由于很难提内容特征，则很难进行推荐，一种解决方式则是人工给这些Item打标签。<br>​        <strong>协同过滤算法</strong>，原理是用户喜欢那些具有相似兴趣的用户喜欢过的商品，比如你的朋友喜欢电影哈利波特I，那么就会推荐给你，这是最简单的基于用户的协同过滤算法（user-based collaboratIve filtering），还有一种是基于Item的协同过滤算法（item-based collaborative filtering），这两种方法都是将用户的所有数据读入到内存中进行运算的，因此成为Memory-based Collaborative Filtering，另一种则是Model-based collaborative filtering，包括Aspect Model，pLSA，LDA，聚类，SVD，Matrix Factorization等，这种方法训练过程比较长，但是训练完成后，推荐过程比较快。<br>​       最后一种方法是基于知识的推荐算法，也有人将这种方法归为基于内容的推荐，这种方法比较典型的是构建领域本体，或者是建立一定的规则，进行推荐。</p><p><strong>item-based 和 user-based 协同过滤的比较：</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-08-09-51-55.png" alt=""> </p><p>我们再来回顾一下<strong>item-base CF算法的特点</strong>：</p><ul><li>物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大</li><li>适合长尾物品丰富，用户个性化需求强的领域</li><li>对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性</li><li>利用用户历史行为做推荐解释，比较令用户信服</li></ul><p>所以item-base挺适合做电影的推荐。当用户浏览某个电影的时候，我们可以推荐给他类似的电影，或者根据用户以前的观影记录，推荐他感兴趣的电影。</p><h2 id="3-项目流程"><a href="#3-项目流程" class="headerlink" title="3. 项目流程"></a>3. 项目流程</h2><ol><li>根据集群中7天用户-视频score数据，计算视频两两之间的余弦相似度</li><li>为每个视频选取与之相似度&gt;0.5且最接近的top40个视频</li><li>根据用户7天之内看过的视频，将相似视频merge进来，根据看过视频的score和相似视频的余弦相似度乘积，对看过的所有视频的所有相似视频打分，取top50作为用户的推荐视频候选集（去掉已经看过的视频）</li><li>根据线上抽取的特征和用户、视频15天线下特征输入预训练的LR得到候选集合的点击率排序，作为最终的推荐顺序。</li></ol><h2 id="4-CF核心思路"><a href="#4-CF核心思路" class="headerlink" title="4. CF核心思路"></a>4. CF核心思路</h2><pre><code>* user1     user2* item1  score11   score21 (X)* item2  score12   score22 (Y)* --------------------------------* sim(item1,item2) = XY / math.sqrt(XX) * math.sqrt(YY)* XY= score11 * score12 + score21 * score22* XX = score11 * score11 + score21 * score21* YY = score12 * score12 + score22 * score22</code></pre><p>已知一周内，用户观看视频的数据，形式为RDD[(uid,(aid,score))]</p><p>按照uid做一次join操作，就可以得到RDD[((aid1,aid2),(score11,score22))]，即用户对以及同时看过两者的用户对其的score</p><p>接下来就可以计算出aid对的余弦相似度了</p><p>然后根据余弦相似度为每个aid选出最相近的top40相似ad</p><h2 id="5-优化方向"><a href="#5-优化方向" class="headerlink" title="5. 优化方向"></a>5. 优化方向</h2><p>暂时就想到了一个：</p><p>将用户对电影的score做时间衰减</p><p>之后继续补充</p><h2 id="6-核心代码"><a href="#6-核心代码" class="headerlink" title="6. 核心代码"></a>6. 核心代码</h2><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> model</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.hive.<span class="type">HiveContext</span></div><div class="line"><span class="keyword">import</span> util.<span class="type">MqManager</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Created by dengxing on 2017/7/18.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">CF</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/** 基于dt时间获取原始数据源</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param sc    SparkContext</span></div><div class="line"><span class="comment">    * @param table 转换的hive表</span></div><div class="line"><span class="comment">    * @param day   获取当前日期的数据</span></div><div class="line"><span class="comment">    * @return 原始数据的dataFrame</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResource</span></span>(sc: <span class="type">SparkContext</span>, table: <span class="type">String</span>, day: <span class="type">String</span>) = &#123;</div><div class="line">    <span class="keyword">val</span> hiveContext = <span class="keyword">new</span> <span class="type">HiveContext</span>(sc)</div><div class="line">    <span class="keyword">import</span> hiveContext.sql</div><div class="line">    <span class="keyword">val</span> resource = sql(<span class="string">"select "</span></div><div class="line">      + <span class="string">"uid,"</span></div><div class="line">      + <span class="string">"aid,"</span></div><div class="line">      + <span class="string">"cnt"</span></div><div class="line">      + <span class="string">" from "</span> + table + <span class="string">" where dt ='"</span> + day + <span class="string">"'"</span>)</div><div class="line">    resource</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * 分布式计算余弦相似度</span></div><div class="line"><span class="comment">    * --------------------------------</span></div><div class="line"><span class="comment">    * user1     user2</span></div><div class="line"><span class="comment">    * item1  score11   score21 (X)</span></div><div class="line"><span class="comment">    * item2  score12   score22 (Y)</span></div><div class="line"><span class="comment">    * --------------------------------</span></div><div class="line"><span class="comment">    * sim(item1,item2) = XY / math.sqrt(XX) * math.sqrt(YY)</span></div><div class="line"><span class="comment">    * XY= score11 * score12 + score21 * score22</span></div><div class="line"><span class="comment">    * XX = score11 * score11 + score21 * score21</span></div><div class="line"><span class="comment">    * YY = score12 * score12 + score22 * score22</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param resource</span></div><div class="line"><span class="comment">    * @return RDD[(item1,item2,sim)]</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getCosineSimilarity</span></span>(resource: <span class="type">DataFrame</span>): <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Double</span>))] = &#123;</div><div class="line">    <span class="keyword">val</span> rating = resource.map &#123;</div><div class="line">      row =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> uid = row.getString(<span class="number">0</span>)</div><div class="line">        <span class="keyword">val</span> aid = row.getString(<span class="number">1</span>)</div><div class="line">        <span class="keyword">val</span> score = row.getString(<span class="number">2</span>).toDouble</div><div class="line">        (uid, aid, score)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//RDD[(uid,(aid,score))]</span></div><div class="line">    <span class="keyword">val</span> user_item_score = rating.map(f =&gt; (f._1, (f._2, f._3)))</div><div class="line">    </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个用户有过行为的item键值对,即</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),(score11,score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_score_pair = user_item_score.join(user_item_score)</div><div class="line">      .map(f =&gt; ((f._2._1._1, f._2._2._1), (f._2._1._2, f._2._2._2)))</div><div class="line">    </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取同一对item，所有的用户评分向量的点积，即XY 及 XX 及 YY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),score11 * score12 + score21 * score22)]</span></div><div class="line"><span class="comment">     * 及 RDD[((aid1,aid1),score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 及 RDD[((aid2,aid2),score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_ALL = item_score_pair.map(f =&gt; (f._1, f._2._1 * f._2._2)).reduceByKey(_ + _)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个item，所有用户的自向量的点积，即XX或YY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid1),score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 或 RDD[((aid2,aid2),score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XX_YY = item_pair_ALL.filter(f =&gt; f._1._1 == f._1._2)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取每个item，所有用户的非自向量的点积，即XY</span></div><div class="line"><span class="comment">     * RDD[((aid1,aid2),score11 * score12 + score21 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XY = item_pair_ALL.filter(f =&gt; f._1._1 != f._1._2)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取item_pair_XX_YY中的item及XX或YY</span></div><div class="line"><span class="comment">     * RDD[(aid1,score11 * score11 + score21 * score21)]</span></div><div class="line"><span class="comment">     * 或 RDD[(aid2,score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_XX_YY = item_pair_XX_YY.map(f =&gt; (f._1._1, f._2))</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转化item_pair_XY为(aid1,((aid1,aid2,XY),XX)))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,((aid1,aid2,score11 * score12 + score21 * score22),score11 * score11 + score21 * score21)))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> item_XY_XX = item_pair_XY.map(f =&gt; (f._1._1, (f._1._1, f._1._2, f._2))).join(item_XX_YY)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转为item_XY_XX为(aid2,((aid1,aid2,XY,XX),YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid2,((aid1,aid2,score11 * score12 + score21 * score22,score11 * score11 + score21 * score21),score12 * score12 + score22 * score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_XY_XX_YY = item_XY_XX.map(f =&gt; (f._2._1._2, (f._2._1._1, f._2._1._2, f._2._1._3, f._2._2))).join(item_XX_YY)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  提取item_XY_XX_YY中的(aid1,aid2,XY,XX,YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,aid2,score11 * score12 + score21 * score22,score11 * score11 + score21 * score21,score12 * score12 + score22 * score22)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_XY_XX_YY = item_XY_XX_YY.map(f =&gt; (f._2._1._1, f._2._1._2, f._2._1._3, f._2._1._4, f._2._2))</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     *  转化item_pair_XY_XX_YY为(aid1,aid2,XY / math.sqrt(XX * YY))</span></div><div class="line"><span class="comment">     *  RDD[(aid1,aid2,score11 * score12 + score21 * score22 / math.sqrt((score11 * score11 + score21 * score21)*(score12 * score12 + score22 * score22))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> item_pair_sim = item_pair_XY_XX_YY.map(f =&gt; (f._1, (f._2, f._3 / math.sqrt(f._4 * f._5))))</div><div class="line">    item_pair_sim</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * 基于item相似度矩阵为user生成topN推荐列表</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param resource</span></div><div class="line"><span class="comment">    * @param item_sim_bd</span></div><div class="line"><span class="comment">    * @param topN</span></div><div class="line"><span class="comment">    * @return RDD[(user,List[(item,score)])]</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">recommend</span></span>(resource: <span class="type">DataFrame</span>, item_sim_bd: <span class="type">Broadcast</span>[scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]], topN: <span class="type">Int</span> = <span class="number">50</span>) = &#123;</div><div class="line">    <span class="keyword">val</span> user_item_score = resource.map(</div><div class="line">      row =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> uid = row.getString(<span class="number">0</span>)</div><div class="line">        <span class="keyword">val</span> aid = row.getString(<span class="number">1</span>)</div><div class="line">        <span class="keyword">val</span> score = row.getString(<span class="number">2</span>).toDouble</div><div class="line">        ((uid, aid), score)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 提取item_sim_user_score为((user,item2),sim * score)</span></div><div class="line"><span class="comment">     * RDD[(user,item2),sim * score]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_item_simscore = user_item_score.flatMap(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> items_sim = item_sim_bd.value.getOrElse(f._1._2, <span class="type">List</span>((<span class="string">"0"</span>, <span class="number">0.0</span>)))</div><div class="line">        <span class="keyword">for</span> (w &lt;- items_sim) <span class="keyword">yield</span> ((f._1._1, w._1), w._2 * f._2)</div><div class="line">      &#125;).filter(_._2 &gt; <span class="number">0.03</span>)</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 聚合user_item_simscore为 (user,（item2,sim1 * score1 + sim2 * score2）)</span></div><div class="line"><span class="comment">     * 假设user观看过两个item,评分分别为score1和score2，item2是与user观看过的两个item相似的item,相似度分别为sim1，sim2</span></div><div class="line"><span class="comment">     * RDD[(user,item2),sim1 * score1 + sim2 * score2）)]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_item_rank = user_item_simscore.reduceByKey(_ + _, <span class="number">1000</span>)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 过滤用户已看过的item,并对user_item_rank基于user聚合</span></div><div class="line"><span class="comment">     * RDD[(user,CompactBuffer((item2,rank2）,(item3,rank3)...))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_items_ranks = user_item_rank.subtractByKey(user_item_score).map(f =&gt; (f._1._1, (f._1._2, f._2))).groupByKey(<span class="number">1000</span>)</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 对user_items_ranks基于rank降序排序，并提取topN,其中包括用户已观看过的item</span></div><div class="line"><span class="comment">     * RDD[(user,ArrayBuffer((item2,rank2）,...,(itemN,rankN)))]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">val</span> user_items_ranks_desc = user_items_ranks.map(f =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> item_rank_list = f._2.toList</div><div class="line">      <span class="keyword">val</span> item_rank_desc = item_rank_list.sortWith((x, y) =&gt; x._2 &gt; y._2)</div><div class="line">      (f._1, item_rank_desc.take(topN))</div><div class="line">    &#125;)</div><div class="line">    user_items_ranks_desc</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * json 编码格式1：用于CF离线推荐结果</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param recTopN 离线推荐结果</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encodeToJson1</span></span>(recTopN: (<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)])) = &#123;</div><div class="line">    <span class="keyword">val</span> mtype = <span class="string">"lxfs"</span></div><div class="line">    <span class="keyword">val</span> mtype_ = <span class="string">"\""</span> + <span class="string">"mtype"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + mtype + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> uid = recTopN._1</div><div class="line">    <span class="keyword">val</span> uid_ = <span class="string">"\""</span> + <span class="string">"uid"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + uid + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid_score = recTopN._2</div><div class="line">    <span class="keyword">val</span> aids_ = <span class="keyword">new</span> <span class="type">StringBuilder</span>().append(<span class="string">"\""</span> + <span class="string">"list"</span> + <span class="string">"\""</span> + <span class="string">":["</span>)</div><div class="line">    <span class="keyword">for</span> (v &lt;- aid_score) &#123;</div><div class="line">      <span class="keyword">val</span> aid = v._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">      <span class="keyword">val</span> type_ = v._1.split(<span class="string">"_"</span>)(<span class="number">1</span>)</div><div class="line">      <span class="keyword">val</span> score = v._2</div><div class="line">      aids_.append(<span class="string">"&#123;"</span> + <span class="string">"\"aid\""</span> + <span class="string">":"</span> + aid + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"type\""</span> + <span class="string">":"</span> + type_ + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"score\""</span> + <span class="string">":"</span> + score + <span class="string">"&#125;,"</span>)</div><div class="line">    &#125;</div><div class="line">    aids_.deleteCharAt(aids_.length - <span class="number">1</span>).append(<span class="string">"]"</span>)</div><div class="line">    <span class="keyword">val</span> result = <span class="string">"&#123;"</span> + mtype_ + <span class="string">","</span> + uid_ + <span class="string">","</span> + aids_.toString() + <span class="string">"&#125;"</span></div><div class="line">    result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    * json 编码格式2：用于CF相似度矩阵</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * @param cf_sim CF截断的相似度矩阵</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encodeToJson2</span></span>(cf_sim: (<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)])) = &#123;</div><div class="line">    <span class="keyword">val</span> mtype = <span class="string">"cf"</span></div><div class="line">    <span class="keyword">val</span> mtype_ = <span class="string">"\""</span> + <span class="string">"mtype"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + mtype + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid1 = cf_sim._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">    <span class="keyword">val</span> aid_ = <span class="string">"\""</span> + <span class="string">"aid"</span> + <span class="string">"\""</span> + <span class="string">":"</span> + <span class="string">"\""</span> + aid1 + <span class="string">"\""</span></div><div class="line">    <span class="keyword">val</span> aid_score = cf_sim._2</div><div class="line">    <span class="keyword">val</span> aids_ = <span class="keyword">new</span> <span class="type">StringBuilder</span>().append(<span class="string">"\""</span> + <span class="string">"similar"</span> + <span class="string">"\""</span> + <span class="string">":["</span>)</div><div class="line">    <span class="keyword">for</span> (v &lt;- aid_score) &#123;</div><div class="line">      <span class="keyword">val</span> aid2 = v._1.split(<span class="string">"_"</span>)(<span class="number">0</span>)</div><div class="line">      <span class="keyword">val</span> type_ = v._1.split(<span class="string">"_"</span>)(<span class="number">1</span>)</div><div class="line">      <span class="keyword">val</span> score = v._2</div><div class="line">      aids_.append(<span class="string">"&#123;"</span> + <span class="string">"\"aid\""</span> + <span class="string">":"</span> + aid2 + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"type\""</span> + <span class="string">":"</span> + type_ + <span class="string">","</span>)</div><div class="line">      aids_.append(<span class="string">"\"score\""</span> + <span class="string">":"</span> + score + <span class="string">"&#125;,"</span>)</div><div class="line">    &#125;</div><div class="line">    aids_.deleteCharAt(aids_.length - <span class="number">1</span>).append(<span class="string">"]"</span>)</div><div class="line">    <span class="keyword">val</span> result = <span class="string">"&#123;"</span> + mtype_ + <span class="string">","</span> + aid_ + <span class="string">","</span> + aids_.toString() + <span class="string">"&#125;"</span></div><div class="line">    result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> table = args(<span class="number">0</span>) <span class="comment">//要处理的表</span></div><div class="line">    <span class="keyword">val</span> day = args(<span class="number">1</span>) <span class="comment">//当前日期</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Wireless ItemBased Collaborative Filtering"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> resource = getResource(sc, table, day).repartition(<span class="number">1000</span>)</div><div class="line">    resource.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 1.计算item相似度矩阵</span></div><div class="line">    <span class="keyword">val</span> item_sim: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Double</span>))] = getCosineSimilarity(resource)</div><div class="line">    item_sim.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 2.每个item提取最相近的40个item</span></div><div class="line">    <span class="keyword">val</span> item_sim_rdd = item_sim.filter(f =&gt; f._2._2 &gt; <span class="number">0.05</span>).groupByKey().map(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> item = f._1</div><div class="line">        <span class="keyword">val</span> items_score = f._2.toList</div><div class="line">        <span class="keyword">val</span> items_score_desc = items_score.sortWith((x, y) =&gt; x._2 &gt; y._2)</div><div class="line">        (item, items_score_desc.take(<span class="number">40</span>))</div><div class="line">      &#125;).cache()</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存cf相似度矩阵到HDFS</span></div><div class="line">    item_sim_rdd.map(encodeToJson2(_)).foreachPartition(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">for</span> (m &lt;- f) <span class="type">MqManager</span>.sendMessage(m)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="comment">// 4.广播相似度矩阵</span></div><div class="line">    <span class="keyword">val</span> item_sim_map = item_sim_rdd.collectAsMap()</div><div class="line">    <span class="keyword">val</span> item_sim_bd: <span class="type">Broadcast</span>[scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]] = sc.broadcast(item_sim_map)</div><div class="line"></div><div class="line">    <span class="comment">// 5.为用户生成推荐列表</span></div><div class="line">    <span class="keyword">val</span> recTopN = recommend(resource, item_sim_bd, <span class="number">50</span>)</div><div class="line"></div><div class="line">    <span class="comment">/* 6.发送RabbitMQ</span></div><div class="line"><span class="comment">     * 1&gt; CF相似度矩阵Json 编码并发送</span></div><div class="line"><span class="comment">     * 2&gt; 用户推荐列表Json 编码并发送</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    recTopN.map(encodeToJson1(_)).foreachPartition(</div><div class="line">      f =&gt; &#123;</div><div class="line">        <span class="keyword">for</span> (m &lt;- f) <span class="type">MqManager</span>.sendMessage(m)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-项目简介&quot;&gt;&lt;a href=&quot;#1-项目简介&quot; class=&quot;headerlink&quot; title=&quot;1. 项目简介&quot;&gt;&lt;/a&gt;1. 项目简介&lt;/h2&gt;&lt;p&gt;无线短视频推荐项目，负责无线端用户的短视频推荐，也就是给手机端用户推荐短视频。主要用到了item-bas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【腾讯社交广告算法大赛】贝叶斯平滑</title>
    <link href="http://yoursite.com/2018/03/07/%E3%80%90%E8%85%BE%E8%AE%AF%E7%A4%BE%E4%BA%A4%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/"/>
    <id>http://yoursite.com/2018/03/07/【腾讯社交广告算法大赛】贝叶斯平滑/</id>
    <published>2018-03-07T05:46:12.000Z</published>
    <updated>2018-03-07T06:46:46.375Z</updated>
    
    <content type="html"><![CDATA[<p>等周末邓邓给讲了在写</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>电商领域中经常需要计算或预测一些转化率指标，如最典型的CTR（点击率，Click-Through Rate）。这些转化率可以是模型的预测值，也可以作为模型的特征（feature）使用。以商品点击率预测为例，CTR的值等于点击量（Click）除以曝光量（Impression或Exposure）。以r表示点击率，</p><script type="math/tex; mode=display">r = C/I</script><p>但在实际应用过程中会碰到两个问题：</p><ul><li><strong>新商品点击率的预测与计算</strong><br>对于新上线的商品，其曝光为0，点击量也为0，此时这件商品的CTR应该设为0还是赋一个初始值？</li><li><strong>不同商品点击率之间的比较</strong><br>有两件商品A和B，其点击率分别为<script type="math/tex">r_A=5/10</script>和<script type="math/tex">r_B=50/100</script>，<script type="math/tex">r_A=r_B</script>，但商品A的曝光只有10次，商品B的曝光有100次，这样比较是否合理？</li></ul><p>第一个问题，初始值设0是可以的，但不太合理。当CTR作为特征使用时，表示这个商品完全没有点击，不太符合日常推断，通常是赋一个大于0的初始值。第二个问题，不合理。</p><p>解决以上两个问题可以使用平滑的技术解决。最简单的方法是在计算CTR的公式中分子分母同时加上一个数，加上之后可避免这两个问题。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-07-14-47-28.png" alt=""> </p><p>但(2)式中a和b的值如何确定？若设置得不合理会出现数据被放大的情况。本文介绍如何使用贝叶斯平滑来确定a和b的值。</p><h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><p>为了估计两个参数<script type="math/tex">\alpha</script>和<script type="math/tex">\beta</script></p><p>可以采用二阶矩估计的方法，计算样本的均值（一阶矩）和方差（二阶矩），然后让总体的矩和样本矩相等，可以求出参数。</p><p>beta分布的期望是：</p><script type="math/tex; mode=display">E(x) = \frac{\alpha}{\alpha+\beta}</script><p>beta分布的方差是：</p><script type="math/tex; mode=display">D(x) = \frac{\alpha\beta}{(\alpha+\beta)^2+(\alpha+\beta+1)}</script><p>带入求解即可</p><p>代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HyperParam</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, beta)</span>:</span></div><div class="line">        self.alpha = alpha</div><div class="line">        self.beta = beta</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample_from_beta</span><span class="params">(self, alpha, beta, num, imp_upperbound)</span>:</span></div><div class="line">        sample = numpy.random.beta(alpha, beta, num)</div><div class="line">        I = []</div><div class="line">        C = []</div><div class="line">        <span class="keyword">for</span> click_ratio <span class="keyword">in</span> sample:</div><div class="line">            imp = random.random() * imp_upperbound</div><div class="line">            <span class="comment">#imp = imp_upperbound</span></div><div class="line">            click = imp * click_ratio</div><div class="line">            I.append(imp)</div><div class="line">            C.append(click)</div><div class="line">        <span class="keyword">return</span> I, C</div><div class="line"></div><div class="line">    <span class="comment"># 矩估计，根据均值和方差</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_from_data_by_moment</span><span class="params">(self, tries, success)</span>:</span></div><div class="line">        <span class="string">'''estimate alpha, beta using moment estimation'''</span></div><div class="line">        mean, var = self.__compute_moment(tries, success)</div><div class="line">        <span class="comment">#print 'mean and variance: ', mean, var</span></div><div class="line">        <span class="comment">#self.alpha = mean*(mean*(1-mean)/(var+0.000001)-1)</span></div><div class="line">        self.alpha = (mean+<span class="number">0.000001</span>) * ((mean+<span class="number">0.000001</span>) * (<span class="number">1.000001</span> - mean) / (var+<span class="number">0.000001</span>) - <span class="number">1</span>)</div><div class="line">        <span class="comment">#self.beta = (1-mean)*(mean*(1-mean)/(var+0.000001)-1)</span></div><div class="line">        self.beta = (<span class="number">1.000001</span> - mean) * ((mean+<span class="number">0.000001</span>) * (<span class="number">1.000001</span> - mean) / (var+<span class="number">0.000001</span>) - <span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 计算均值和方差，也就是一阶和二阶矩</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__compute_moment</span><span class="params">(self, tries, success)</span>:</span></div><div class="line">        <span class="string">'''moment estimation'''</span></div><div class="line">        ctr_list = []</div><div class="line">        <span class="comment"># var = 0.0</span></div><div class="line">        mean = (success/tries).mean()</div><div class="line">        <span class="keyword">if</span> len(tries)==<span class="number">1</span>:</div><div class="line">            var = <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            var = (success/tries).var()</div><div class="line">      <span class="keyword">return</span> mean, var</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;等周末邓邓给讲了在写&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;电商领域中经常需要计算或预测一些转化率指标，如最典型的CTR（点击率，Click-Through Rat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【腾讯转化率预估比赛】总结</title>
    <link href="http://yoursite.com/2018/03/06/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/06/【腾讯转化率预估】比赛总结/</id>
    <published>2018-03-06T05:50:10.000Z</published>
    <updated>2018-03-07T07:41:46.397Z</updated>
    
    <content type="html"><![CDATA[<p>第一届腾讯社交广告算法大赛复赛成绩0.101941，排名26名，在此总结一下。</p><p><a href="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" alt="img"></a></p><h1 id="1-题目简介"><a href="#1-题目简介" class="headerlink" title="1. 题目简介"></a>1. 题目简介</h1><h2 id="1-1-移动App广告转化率预估"><a href="#1-1-移动App广告转化率预估" class="headerlink" title="1.1 移动App广告转化率预估"></a>1.1 移动App广告转化率预估</h2><p>详细赛题见<a href="http://algo.tpai.qq.com/home/information/index.html" target="_blank" rel="external">官方网站</a></p><blockquote><p>计算广告是互联网最重要的商业模式之一，广告投放效果通常通过曝光、点击和转化各环节来衡量，大多数广告系统受广告效果数据回流的限制只能通过曝光或点击作为投放效果的衡量标准开展优化。腾讯社交广告(<a href="http://ads.tencent.com/" target="_blank" rel="external">http://ads.tencent.com</a>)发挥特有的用户识别和转化跟踪数据能力，帮助广告主跟踪广告投放后的转化效果，基于广告转化数据训练转化率预估模型(pCVR，Predicted Conversion Rate)，在广告排序中引入pCVR因子优化广告投放效果，提升ROI。</p><p>本题目以移动App广告为研究对象，预测App广告点击后被激活的概率：pCVR=P(conversion=1 | Ad,User,Context)，即给定广告、用户和上下文情况下广告被点击后发生激活的概率。</p></blockquote><p>总结起来就是说，在业界，大多数广告系统是通过点击率来投放广告的，因为转化追踪起来是比较困难的，然而腾讯凭借平台优势很好地追踪了广告投放之后的转化情况，以此训练<strong>转化率预估模型</strong>，用转化率来指导广告投放，进而提升ROI。</p><p><strong>因此赛题就是给我们17-30号两周（15天）的移动APP广告（投放在移动端的APP广告）数据，让我们训练转化率模型做转化率预估，即预测第31号App广告点击后被激活的概率。</strong></p><h2 id="1-2-评估方式："><a href="#1-2-评估方式：" class="headerlink" title="1.2 评估方式："></a>1.2 评估方式：</h2><p>通过Logarithmic Loss评估(越小越好)，公式如下：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-36-51.png" alt=""> </p><p>其中，</p><ul><li>N是测试样本总数</li><li><script type="math/tex">y_i</script>是二值变量，取值为0或1，表示第i个样本的label</li><li><script type="math/tex">p_i</script>是模型预测第i个样本label为1的概率</li></ul><h1 id="2-数据"><a href="#2-数据" class="headerlink" title="2. 数据"></a>2. 数据</h1><h2 id="2-1-数据量"><a href="#2-1-数据量" class="headerlink" title="2.1 数据量"></a>2.1 数据量</h2><p><strong>数据量：初赛30w/天；决赛300w/天</strong></p><h2 id="2-2-数据表"><a href="#2-2-数据表" class="headerlink" title="2.2 数据表"></a>2.2 数据表</h2><p>接下来看看给的数据长啥样。</p><p>一共给了8张表：</p><p>test+train+下面这些：</p><div class="table-container"><table><thead><tr><th>文件类型</th><th>描述</th></tr></thead><tbody><tr><td>用户基础特征文件(<em>user.csv</em>)</td><td>每行代表一个用户，各字段之间由逗号分隔，顺序依次为：“userID，age，gender，education，marriageStatus，haveBaby，hometown，residence”。</td></tr><tr><td>用户App安装列表文件(<em>user_installedapps.csv</em>)</td><td>每行代表一个用户安装的单个App，各字段之间由逗号分隔，顺序依次为：“userID，appID”。特别的，我们提供了截止到第1天0点用户全部的App安装列表。</td></tr><tr><td>用户App安装流水文件(<em>user_app_actions.csv</em>)</td><td>每行代表一个用户的单个App操作流水，各字段之间由逗号分隔，顺序依次为：“userID，installTime，appID”。特别的，我们提供了训练数据开始时间之前16天开始连续30天的操作流水，即第1天0点到第31天0点。</td></tr><tr><td>App特征文件(<em>app_categories.csv</em>)</td><td>每行代表一个App，各字段之间由逗号分隔，顺序依次为：“appID，appCategory”。</td></tr><tr><td>广告特征文件(<em>ad.csv</em>)</td><td>每行描述一条广告素材，各字段之间由逗号分隔，顺序依次为“creativeID，adID，camgaignID，advertiserID，appID，appPlatform”。</td></tr><tr><td>广告位特征文件(<em>position.csv</em>)</td><td>每行描述一个广告位，各字段之间由逗号分隔，顺序依次为：“positionID，sitesetID，positionType”。</td></tr></tbody></table></div><p><code>train.csv</code> 训练数据集 ：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-30-00.png" alt=""> </p><p>17到30号共14天点击数据。</p><p>每一条训练样本即为一条广告<strong>点击日志</strong>(点击时间用clickTime表示)，样本label取值0或1，其中0表示点击后没有发生转化，1表示点击后有发生转化，如果label为1，还会提供转化回流时间。</p><p>每一条数据其中label表示是否转化，经统计<strong>转化率大概1/40</strong></p><p>数据量：初赛30w/天；决赛300w/天</p><p><code>test.csv</code> 线上测试数据</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-30-28.png" alt=""> </p><p>31号一天数据，字段和test一致，需要预测lable</p><p><code>ad.csv</code> 广告基本特征</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-30-44.png" alt="">     <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-26-24.png" alt=""> </p><p>这里广告结构分为四级：广告主——推广计划——广告——素材。<strong>之后会用到这个层级结构做贝叶斯平滑。</strong></p><p><code>user.csv</code> 用户信息表</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-31-49.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-05.png" alt=""> </p><p>就是用户的一些基本特征啦，性别年龄blabla</p><p><code>app_category.csv</code> appID对应的类别信息</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-32-49.png" alt="">                      <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-21.png" alt=""> </p><p>就是appID和对应的categoryID，其中类目标签有两层，使用3位数字编码，百位数表示一级类目，十位个位数表示二级类目，如“210”表示一级类目编号为2，二级类目编号为10，类目未知或者无法获取时，标记为0。</p><p><code>position.csv</code> 广告位信息</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-33-15.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-46.png" alt=""> </p><p>没啥说的，就是广告位信息，直接merge就行</p><p><code>user_app_actions.csv</code> 用户安装app流水，1——30天的，包含安装时间</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-34-00.png" alt="">        <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-29-01.png" alt=""> </p><p>用户近期的app安装行为，这里可以挖掘出用户的偏好类别，时间等等。。。</p><p><code>user_installedapps.csv</code>用户历史安装过的app，第一天0点之前的</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-34-31.png" alt="">         <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-30-00.png" alt=""> </p><p>用户自注册以来安装过的appID，有待挖掘。。。</p><h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>总结一下，一共有三类特征，用户特征、广告特征、上下文特征，官网也给了个很好的总结表：</p><div class="table-container"><table><thead><tr><th>特征</th><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>广告特征</td><td>账户ID(<em>advertiserID</em>)</td><td>腾讯社交广告的账户结构分为四级：账户——推广计划——广告——素材，账户对应一家特定的广告主。</td></tr><tr><td></td><td>推广计划ID(<em>campaignID</em>)</td><td>推广计划是广告的集合，类似电脑文件夹功能。广告主可以将推广平台、预算限额、是否匀速投放等条件相同的广告放在同一个推广计划中，方便管理。</td></tr><tr><td></td><td>广告ID(<em>adID</em>)</td><td>腾讯社交广告管理平台中的广告是指广告主创建的广告创意(或称广告素材)及广告展示相关设置，包含广告的基本信息(广告名称，投放时间等)，广告的推广目标，投放平台，投放的广告规格，所投放的广告创意，广告的受众(即广告的定向设置)，广告出价等信息。单个推广计划下的广告数不设上限。</td></tr><tr><td></td><td>素材ID(<em>creativeID</em>)</td><td>展示给用户直接看到的广告内容，一条广告下可以有多组素材。</td></tr><tr><td></td><td>AppID(<em>appID</em>)</td><td>广告推广的目标页面链接地址，即点击后想要展示给用户的页面，此处页面特指具体的App。多个推广计划或广告可以同时推广同一个App。</td></tr><tr><td></td><td>App分类(<em>appCategory</em>)</td><td>App开发者设定的App类目标签，类目标签有两层，使用3位数字编码，百位数表示一级类目，十位个位数表示二级类目，如“210”表示一级类目编号为2，二级类目编号为10，类目未知或者无法获取时，标记为0。</td></tr><tr><td></td><td>App平台(<em>appPlatform</em>)</td><td>App所属操作系统平台，取值为Android，iOS，未知。同一个appID只会属于一个平台。</td></tr><tr><td>用户特征</td><td>用户ID(<em>userID</em>)</td><td>唯一标识一个用户</td></tr><tr><td></td><td>年龄(<em>age</em>)</td><td>取值范围[0, 80]，其中0表示未知。</td></tr><tr><td></td><td>性别(<em>gender</em>)</td><td>取值包括男，女，未知。</td></tr><tr><td></td><td>学历(<em>education</em>)</td><td>用户当前最高学历，不区分在读生和毕业生，取值包括小学，初中，高中，专科，本科，硕士，博士，未知</td></tr><tr><td></td><td>婚恋状态(<em>marriageStatus</em>)</td><td>用户当前感情状况，取值包括单身，新婚，已婚，未知。</td></tr><tr><td></td><td>育儿状态(<em>haveBaby</em>)</td><td>用户当前孕育宝宝状态，取值包括孕育中，宝宝0~6个月，宝宝6~12个月，宝宝1~2岁，宝宝2~3岁，育儿但宝宝年龄未知，未知。</td></tr><tr><td></td><td>家乡/籍贯(<em>hometown</em>)</td><td>用户出生地，取值具体到市级城市，使用二级编码，千位百位数表示省份，十位个位数表示省内城市，如1806表示省份编号为18，城市编号是省内的6号，编号0表示未知。</td></tr><tr><td></td><td>常住地(<em>residence</em>)</td><td>最近一段时间用户长期居住的地方，取值具体到市级城市，编码方式与家乡相同。</td></tr><tr><td></td><td>App安装列表(<em>appInstallList</em>)</td><td>截止到某一时间点用户全部的App安装列表(appID)，已过滤高频和低频App。</td></tr><tr><td></td><td>App安装流水</td><td>最近一段时间内用户安装App行为流水，包括appID，行为发生时间(installTime)和app类别(appCategory)，已过滤高频和低频App。</td></tr><tr><td></td><td>注：2~8基于用户个人注册资料和算法自动修正得到，9~10基于用户行为日志统计得到。</td><td></td></tr><tr><td>上下文特征</td><td>广告位ID(<em>positionID</em>)</td><td>广告曝光的具体位置，如QQ空间Feeds广告位。</td></tr><tr><td></td><td>站点集合ID(<em>sitesetID</em>)</td><td>多个广告位的聚合，如QQ空间</td></tr><tr><td></td><td>广告位类型(<em>positionType</em>)</td><td>对于某些站点，人工定义的一套广告位规格分类，如Banner广告位。</td></tr><tr><td></td><td>联网方式(<em>connectionType</em>)</td><td>移动设备当前使用的联网方式，取值包括2G，3G，4G，WIFI，未知</td></tr><tr><td></td><td>运营商(<em>telecomsOperator</em>)</td><td>移动设备当前使用的运营商，取值包括中国移动，中国联通，中国电信，未知</td></tr></tbody></table></div><p>接下来的任务就是从这些给的数据里面挖掘有用的信息去训练模型预测转化率啦。</p><h1 id="3-主要流程"><a href="#3-主要流程" class="headerlink" title="3. 主要流程"></a>3. 主要流程</h1><p>这是Kaggle上数据挖掘比赛的黄金流程图：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" alt="img"></a></p><p>我们也是采用这个流程来做的~</p><h1 id="4-数据分析-amp-清洗"><a href="#4-数据分析-amp-清洗" class="headerlink" title="4. 数据分析&amp;清洗"></a>4. 数据分析&amp;清洗</h1><h2 id="4-1-数据分析"><a href="#4-1-数据分析" class="headerlink" title="4.1 数据分析"></a>4.1 数据分析</h2><p>拿到数据第一件事就是要好好分析数据！！！不仅一开始要分析，训练完也要根据结果分析，所以数据分析是要贯穿整个流程的，只有通过不断的分析统计，才能挖掘到数据背后的价值啊~</p><p>上面介绍数据表的时候已经有了一部分简单粗暴的分析了，实际上拿到赛题的时候进行的数据统计和分析远比上面的多，比如还统计了广告主上传回流时间的分布，上传回流时间在5,4,3,2,1天内的百分比，用户转化时间段分布各维度转化率情况（比如各广告主、广告计划、性别、年龄、app的转化率等等)…….</p><p>这些都是数据清洗和特征工程的依据。</p><h2 id="4-2-数据清洗"><a href="#4-2-数据清洗" class="headerlink" title="4.2 数据清洗"></a>4.2 数据清洗</h2><p>按天对训练集<code>train.csv</code>转化率进行了统计</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-16-37-49.png" alt=""> </p><p>其中19号可能由于节日等原因导致转化率有点高，但是考虑到如果去掉这一天的数据就会丢失大一部分信息所以最终没有去掉。</p><p>而由于回流时间的存在，最后四天的数据会不准确，也就是说后五天的数据中有一部分实际上是转化了的，但广告主还没有来得及将这条转化汇报给广告系统，导致数据集中的label被误标记为了0（实际上是1）</p><p>这里我们尝试了两种方法：</p><ol><li>根据经验猜测回流数据是广告主网站反馈回来的，所以我们计算了各广告主在最后五天内的最后一次回流反馈时间，将各广告主最后一次回流返回时间之后的数据删除掉这样就在一定程度上减少了不准确的负样本。这样筛去了大概有3万条。这样的做法带来的问题是有一些真正的负样本也被去除掉了。</li><li>由于最后两天数据的问题比较大，所以干脆直接把最后两天的数据删掉，不用这两天的数据训练模型，这样带来的问题是有一些在这两天新上线的广告就没有得到充分的训练。</li></ol><h1 id="5-特征工程"><a href="#5-特征工程" class="headerlink" title="5. 特征工程"></a>5. 特征工程</h1><p>一开始的时候我们采用了很多基本特征，即各种基础的category型特征（AppID, UserID, creativeID, pisitionID等）的onehot编码，又对单特征进行了一定的统计，比如某广告的转化率，某种联网方式的转化率等。后来看了大神“为情所困的少年”的分享，才反应过来其实无论是onehot还是对ID单维度的统计特征，其实都是对于一个特征的一种表达，从一定意义上是重复的。我个人感觉onehot之后的稀疏特征更适合于线性模型，如LR；而统计量的连续特征更适合于树模型，如GBDT。</p><p>回头来看，其实特征工程需要根据模型预先选择方向。李沐说过，模型是使用离散特征还是连续特征，其实是一个“海量离散特征+简单模型” 同 “少量连续特征+复杂模型”的权衡。既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是折腾模型了。通常来说，前者容易，而且可以n个人一起并行做，有成功经验；后者目前看很赞，能走多远还须拭目以待。</p><p>后来这两种思路在初赛和决赛中我们的都尝试了：</p><h2 id="5-1-海量离散特征-简单模型"><a href="#5-1-海量离散特征-简单模型" class="headerlink" title="5.1 海量离散特征+简单模型"></a>5.1 海量离散特征+简单模型</h2><p>在初赛的开始阶段，我们将各种基础的category型特征进行onehot编码，然后构造了一些单维度的统计特征，比如某广告的转化率，某种联网方式的转化率等，然后构造了一些组合特征，将这些特征onehot之后输入了LR模型就开始训练和预测了。</p><p>对于LR这种线性模型来说，它更适合于onehot类型的特征，首先它对于稀疏高维特征处理是无压力的，其次离散化后的特征对异常数据有很强的鲁棒性，这些在参考文献2<a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a>中可以看到。</p><p>对于一些onehot之后维度很大的特征，我们通过统计，取高频的一部分，舍弃低频的一部分，进行onehot。但随着构造特征的增多，onehot之后的向量维度剧增，这时就会带来维度灾难问题，见参考文献4<a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a>。不仅如此，这时基本上也就被设备问题限制死了。</p><p>这很烦。于是我们就换模型了。</p><h2 id="5-2-少量连续特征-复杂模型"><a href="#5-2-少量连续特征-复杂模型" class="headerlink" title="5.2 少量连续特征+复杂模型"></a>5.2 少量连续特征+复杂模型</h2><p>既然要预测的是转化率，我们不如把特征转化为<strong>转化率特征</strong>，这样特征就变成了连续值，同时我们还抽取了一些<strong>统计特征</strong>，比如某广告在一天之内、n天之内的<strong>点击量，转化量</strong>，某用户历史安装次数、APP历史被安装次数，等等，然后输入树模型中训练。感谢“为情所困”大神的分享，树模型比LR快了不少。</p><h2 id="5-3-组合特征构造"><a href="#5-3-组合特征构造" class="headerlink" title="5.3 组合特征构造"></a>5.3 组合特征构造</h2><p>说到特征组合，从统计的角度解释，基本特征仅仅是真实特征分布在低维空间的映射，不足以描述真实分布，加入组合特征是为了在更高维空间拟合真实分布，使得预测更准确。<br>在初赛和决赛阶段，我们共使用过两种组合特征的表达：</p><p><strong>1. 对离散ID进行hash生成新特征</strong></p><p>在初期用LR的时候，我们采用的方式是hash。即对两个ID做hash运算，得到一个新特征。这是一个很巧妙的方法。例如下面这个表，我们做哈希：</p><p>age×10+gendarage×10+gendar</p><p>得到第三列：</p><div class="table-container"><table><thead><tr><th>age</th><th>gendar</th><th>hash</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>10</td></tr><tr><td>2</td><td>1</td><td>21</td></tr><tr><td>3</td><td>2</td><td>32</td></tr></tbody></table></div><p>第三列的的特征的取值有两位，十位是age,个位是gendar。新特征是一种新的交叉特征的体现。</p><p><strong>2. 对组合进行统计生成新特征</strong></p><p>像之前“为情所困”大神说过的那样，其实无论onehot还是统计特征，其实都是对于一个特征的一种表达。因为后期我们采用了GBDT，因此我们弃用了之前的hash组合方式，而选用统计量（即点击量、转化量和转化率）。这样就在一个维度上表达了这两个特征的组合，而且非常便于计算。</p><p>实现：按字段groupby，获取统计量和转化率特征</p><h2 id="5-4-特征选择"><a href="#5-4-特征选择" class="headerlink" title="5.4 特征选择"></a>5.4 特征选择</h2><p>我们用到了两种特征选择的方法：</p><ol><li>根据方差：方差很小的属性，意味着该属性的识别能力很差。极端情况下，方差为0，意味着该属性在所有样本上都是一个值，所以我们尽量选那些方差比较大，区分度比较好的特征。</li><li>根据模型评分+相关系数矩阵：用GBDT训练会得到一个特征打分，可以作为筛选特征的依据，与此同时，我们发现，有一些特征之间有很强的相互作用，比如加入了某个特征之后会使之前排名很靠前的特征下降，因此我们还计算了特征之间的相关系数，对于相关系数较大的特征，我们就多次试验，反复选择</li></ol><p>特征之间的相关系数：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-21-58-07.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-21-49-00.png" alt=""> </p><p>另外，“酱紫”学长对特征筛选还有一种建议就是直接对所有基本特征进行遍历两两组合，然后用卡方检验筛出来一些比较好的特征。这种方式很简单，大多数工作只需要交给模型来完成。<strong>日后学习一下</strong></p><h2 id="5-5-用户-APP特征挖掘"><a href="#5-5-用户-APP特征挖掘" class="headerlink" title="5.5 用户-APP特征挖掘"></a>5.5 用户-APP特征挖掘</h2><p>特征说到这里，还有两个表没有充分利用上，<code>user_app_actions.csv</code> 和</p><p><code>user_installedapps.csv</code> </p><p><code>user_app_actions.csv</code> ：用户安装app流水，1——30天的，包含安装时间，既然包含安装时间，就可以提取出用户的偏好安装时间、类别、app的偏好安装时间、安装量等特征</p><p><code>user_installedapps.csv</code> 用户历史安装app</p><p>两个表都有用户和APP的安装信息，所以是否可以提取出用户和app之间的一些联系呢。思考一个问题，如果用户已经点击了某个APP的广告，那么是否会转化（下载）取决于什么呢？除了一些客观的因素，比如广告位（是否误点），联网方式等，当然是用户到底感不感兴趣！需不需要！</p><p>想到这里就感觉是个推荐系统方面的问题了，所以我们查了一些资料，尝试了用三种方式表达用户和app之间的联系：</p><ol><li><p>tf-idf向量特征</p><ol><li>把用户看成文档，app、app所属的类别看成词</li><li>把app、app所属的类别看成文档，用户看成词</li></ol><p>没什么提高</p></li><li><p>word-embedding特征</p><p><code>user_app_actions.csv</code> 中包含用户的近期下载的app，根据时间可以得到app下载的顺序。</p><p>把word2vec应用在用户app下载序列上，根据用户下载app的顺序，把app看做单词，也是可以形成这样的序列数据，进而训练处每个app对应的向量，看作是app的一个特征。</p></li><li><p>SVD分解</p><p><code>user_installedapps.csv</code> 表中没有时间信息，也就不合适用word2vec来提取特征了，我们想到了用推荐系统中的常用套路：SVD分解</p><p>关于SVD知识的补充日后可以看下面两篇文章：</p><p><a href="http://blog.csdn.net/zhongkejingwang/article/details/43053513" target="_blank" rel="external">奇异值分解SVD原理详解及推导</a></p><p><a href="http://blog.csdn.net/zhongkejingwang/article/details/43083603" target="_blank" rel="external">SVD在推荐系统中的应用详解以及算法推导</a></p></li></ol><h2 id="5-6-贝叶斯平滑"><a href="#5-6-贝叶斯平滑" class="headerlink" title="5.6 贝叶斯平滑"></a>5.6 贝叶斯平滑</h2><p>这里我们参考了@<a href="https://cloud.tencent.com/developer/user/598572" target="_blank" rel="external">王照彬</a> 大神的平滑方式</p><p> 例如对我们数据中存在的 root -&gt; advertiser -&gt; campaign -&gt; ad -&gt; creative 层级关系(root为训练集中全部样本), 这样的层级关系隐喻了在同一个父节点下的子节点, 其来自于同一个Beta分布, 所以我逐层进行了贝叶斯平滑, 且建立层级关系还有一个好处, 即对预测集出现的数据, 若该creativeID 在训练集从未出现过, 则在pandas.merge时该值为空, 则向上寻找其父节点的统计值, 最高一层为root, 是基与全部训练数据的统计, root的值不进行贝叶斯平滑, 且一定存在, 这就保证了当在预测集中遇到了未出现的样本时, 使用最合理的缺省值进行补全.</p><p><img src="https://blog-10039692.file.myqcloud.com/1496913643639_4485_1496913644532.png" alt="img"></p><p>关于贝叶斯平滑，其核心思想就是说，当某些广告投放量比较少时，或者还未投放时，根据历史数据所统计的转化率特征是不准确的，比如有广告A和B，<script type="math/tex">r_A = 5/10</script>,<script type="math/tex">r_B = 50/100</script>,由于广告A的投放量还比较少，通过历史数据计算而得的<script type="math/tex">r_B</script> 就很有可能不准确，在比如如果某一个广告还未投放过，那么根据历史数据计算其转化率为0，放入模型中训练，也是非常不合理的，所以我们该如何解决呢？</p><p>假设</p><p>我们假设广告的转化率是服从伯努利分布的，也就是只有转化和不转化两种情况，伯努利的共轭显先验分布是贝塔分布，因此可以采用</p><p>对于贝叶斯平滑参数的估计方法，可以采用矩估计、极大似然估计和EM算法，这里由于速度的限制，我们采用的是矩估计的方式，代码<a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a></p><p>关于贝叶斯平滑，有待补习，参考文章：</p><p><a href="http://blog.csdn.net/jinping_shi/article/details/53444100" target="_blank" rel="external">贝叶斯参数估计的理解</a></p><p><a href="https://www.bbsmax.com/A/A7zgmjRk54/" target="_blank" rel="external">CTR预估中的贝叶斯平滑方法（二）参数估计和代码实现</a></p><p><a href="http://blog.csdn.net/jinping_shi/article/details/78334362" target="_blank" rel="external">转化率（CTR）预测的贝叶斯平滑</a></p><p><a href="https://zhuanlan.zhihu.com/p/21724759" target="_blank" rel="external">计算广告的训练与平滑思想（下）</a></p><h2 id="5-7-多线程抽取特征"><a href="#5-7-多线程抽取特征" class="headerlink" title="5.7 多线程抽取特征"></a>5.7 多线程抽取特征</h2><p>决赛数据集太大，而我们组合特征非常多。因此我们采用了多线程抽特征的方式。</p><p>每个特征一个进程，同时对多个特征进行抽取。</p><p>代码见<a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a>，extra_rate_thread_0623.py</p><h2 id="5-8-总结"><a href="#5-8-总结" class="headerlink" title="5.8 总结"></a>5.8 总结</h2><p><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a>总结得非常好，我们的特征主要分为以下几类：</p><ul><li><p>Trick特征：</p><ol><li><p><strong>重复点击的数据条目</strong>：通过观察原始数据是不难发现的,有很多只有clickTime和label不一样的重复数据，按时间排序发现重复数据如果转化，label一般标在头或尾，少部分在中间，在训练集上出现的情况在测试集上也会出现，所以把重复点击数据中的第一条和最后一条标记出来，让模型去学习。后来进一步标注，非重复数据0，重复但不是第一条和最后一条1，重复且是第一条2，最后一条3。这里面包含用户的重复点击、creativeID的重复点击等</p></li><li><p>时间差特征：与重复第一条的时间差和重复最后一条的时间差特征，与前一条和后一条的时间差，甚至包括了重复组合特征的时间差特征</p></li><li><p>rank特征：重复数据的rank特征，同样包括重复的用户、广告等</p><p>这里实现方面用到了pandas的 <code>shift()</code>操作，非常酷炫</p></li></ol></li></ul><ul><li><p>统计特征（单维+组合）：<br>原始特征主要三大类：广告特征、用户特征、位置特征，通过交叉组合算统计构造特征，由于机器限制，统计特征主要使用了转化率，部分特征还统计了点击次数和转化次数。前面已经说过，就不详细列举。</p></li><li><p>用户app行为挖掘特征：</p><p>word-embedding特征、SVD特征</p></li></ul><h1 id="6-训练集-测试集构造"><a href="#6-训练集-测试集构造" class="headerlink" title="6. 训练集/测试集构造"></a>6. 训练集/测试集构造</h1><p>尝试过两种方法：</p><ol><li><p><strong>滑动窗口</strong></p><p>用每天的前七天的统计（统计指统计转化量、点击量、转化率，下同）来作为本天的特征。</p><p>这样就得到了24-30号7天的特征数据，再加上31号的特征，然后用24-29做训练，得到模型，30号作为线下验证集合，验证模型的线下loss，然后将31号的特征输入到该模型，得到最终的线上预测结果，提交。</p><p>​<br>如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" alt="img"></a><br>经测试我们发现，即使我们去掉了30号的部分负样本，还是有一些问题的，30号的数据还是不够好，线上线下会不一致，因此我们改用28号做验证：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" alt="img"></a><br>这样做出于两种目的：一是尽量做到了线上线下统一，二是不让模型学习30号的样本数据，防止一些错误样本被模型学到。</p></li><li><p>用第一周统计，第二周做交叉验证并训练模型。如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" alt="img"></a></p></li></ol><p>相信很多人都用的是这两种其中的一种。我是一个对自己极度不自信的人，来来回回换了好几次。最终觉得第2种方式很稳定，线上线下较统一。第1种方式特征更新较快，模型更准确，但带来的问题就是线上线下不太统一。</p><h1 id="7-模型训练和验证"><a href="#7-模型训练和验证" class="headerlink" title="7. 模型训练和验证"></a>7. 模型训练和验证</h1><p>操作系统：ubuntu14.04</p><p>机器内存：256G</p><p>语言：python</p><p>用到的模型：</p><ul><li><p>LR：L1\L2</p></li><li><p>gbdt：xgboost,lightGBM</p></li><li><p>gbdt+lr：Facebook论文中提出的一种方法</p></li><li><p>特征离散化+ffm：</p><p>​    可以参考我的两篇文章</p><p>​    <a href="https://siyaozhang.github.io/2017/03/14/Factorization-Machine%EF%BC%88FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%89/" target="_blank" rel="external">Factorization Machine（<strong>FM</strong>，因子分解机）</a></p><p>​    <a href="https://siyaozhang.github.io/2017/03/22/FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/" target="_blank" rel="external">F<strong>FM</strong>（field-aware Factorization Machine）——升级版<strong>FM</strong></a></p></li></ul><h1 id="8-项目代码"><a href="#8-项目代码" class="headerlink" title="8. 项目代码"></a>8. 项目代码</h1><p><a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a></p><h1 id="9-参考资料"><a href="#9-参考资料" class="headerlink" title="9. 参考资料"></a>9. 参考资料</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/26820998" target="_blank" rel="external">Kaggle 数据挖掘比赛经验分享</a></li><li><a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a></li><li><a href="http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html" target="_blank" rel="external">特征哈希（Feature Hashing）</a></li><li><a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a></li><li><a href="http://blog.jasonding.top/2015/11/12/Feature%20Engineering/%E3%80%90%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E3%80%91%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">【特征工程】特征选择与特征学习</a></li><li><a href="http://202.197.191.206:8080/30/text/chapter04/4_8.htm" target="_blank" rel="external">描述量选择及特征的组合优化</a></li><li><a href="http://www.jianshu.com/p/8f6f94f1d275" target="_blank" rel="external">scikit-learn系列之特征选择</a></li><li><a href="http://blog.csdn.net/shine19930820/article/details/71713680" target="_blank" rel="external">GBDT原理及利用GBDT构造新的特征-Python实现</a></li><li><a href="http://www.bigbear2017.com/blog/2016/11/02/facebook-ctr-paper/" target="_blank" rel="external">很好的文献资料Facebook CTR Paper</a></li><li><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a></li><li><a href="https://www.qcloud.com/community/article/895055" target="_blank" rel="external">【SPA大赛】腾讯广告点击大赛：对stacking的一些基本介绍</a></li><li><a href="http://blog.csdn.net/ben3ben/article/details/74838338" target="_blank" rel="external">第七名</a></li></ol><h1 id="10-top3方案"><a href="#10-top3方案" class="headerlink" title="10. top3方案"></a>10. top3方案</h1><h3 id="10-1-top1"><a href="#10-1-top1" class="headerlink" title="10.1 top1"></a>10.1 top1</h3><p>特征工程非常细致，而且有理有据，都是经过仔细的分析统计抽取的特征，效果必然好，而且还做了模型创新，用</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-07-17-03-21.png" alt=""> </p><h3 id="10-2-top2"><a href="#10-2-top2" class="headerlink" title="10.2 top2"></a>10.2 top2</h3><p>也是用了17-30号交叉验证，和我们相同的就不说了，说说不同的：</p><p>回流数据不准处理方法：删掉30号平均回流时间较长的数据</p><p>应该是这里回流的处理方式比较好，特征也比较细致，最后模型也做了stacking，模型大概跟我们差不多，但是我们ffm一直没训练好，最后也没有融合</p><h3 id="10-3-top4"><a href="#10-3-top4" class="headerlink" title="10.3 top4"></a>10.3 top4</h3><p>deepFM</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一届腾讯社交广告算法大赛复赛成绩0.101941，排名26名，在此总结一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】一致性哈希&amp;短网址系统设计</title>
    <link href="http://yoursite.com/2018/03/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C-%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/03/05/【九章系统设计】一致性哈希-短网址系统设计/</id>
    <published>2018-03-05T07:20:56.000Z</published>
    <updated>2018-03-06T02:41:49.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-16-18-40.png" alt=""> </p><h1 id="consistent-hashing-一致性哈性"><a href="#consistent-hashing-一致性哈性" class="headerlink" title="consistent hashing 一致性哈性"></a>consistent hashing 一致性哈性</h1><h2 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h2><p>数据量过大，需要将数据拆分，有两种拆分方式：</p><ol><li>纵向：不同表存在不同机器，按常用字段和不常用字段将表拆分存在不同机器</li><li>横向：将数据横向切分，存在不同的机器上</li></ol><h2 id="为什么要做一致性hash？"><a href="#为什么要做一致性hash？" class="headerlink" title="为什么要做一致性hash？"></a>为什么要做一致性hash？</h2><ul><li>一种简单的hash算法：将数据存在第%n个机器上</li><li>当增加一台机器时（n -&gt; n+1），需要迁移的数据量非常大</li><li>因此这个hash算法称为<strong>不一致hash</strong></li></ul><h2 id="一个简单的一致性hash算法："><a href="#一个简单的一致性hash算法：" class="headerlink" title="一个简单的一致性hash算法："></a>一个简单的一致性hash算法：</h2><ul><li><p>将key模一个很大的数，比如360</p></li><li><p>将360分配给n台机器，每个机器负责一段区间</p></li><li><p>区间分配信息记录在一张表上，存在web server上</p></li><li><p>新加一台机器的时候，在表中选择一个位置插入，匀走<strong>相邻</strong>两台机器的一部分数据</p></li><li><p>比如n从3变化到4：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-17-24-32.png" alt=""> </p></li></ul><p>缺陷：</p><ol><li>数据分布不均匀：分摊数据后，各机器数据分布不均匀</li><li>迁移压力大：新机器只能从与之相邻的两台机器上迁移数据，导致这两台老机器负载过大</li></ol><h2 id="一个更实用的一致性hashing"><a href="#一个更实用的一致性hashing" class="headerlink" title="一个更实用的一致性hashing"></a>一个更实用的一致性hashing</h2><p>将机器（IP或者名字）与数据，都看做环上的一个点！！</p><ol><li>将机器映射到环上，如下图所示的ABCD是四个机器<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-39-02.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-39-02.png" alt="img"></a></li><li>比如有个数据，蓝色的点，散在了蓝色点出。那么就顺时针去找一个机器，把这个数据放在这个机器上，即B<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-40-32.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-40-32.png" alt="img"></a></li><li>那么如何让点更均匀呢？<br>四个点可能不会均匀，但是4000个点相对来说一定会更均匀。那就引入Micro shards / Virtual nodes 的概念——一台机器对应了1000个代表。例如将A机器撒在环上（下图红色），将B机器撒在环上（下图蓝色）<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-42-51.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-42-51.png" alt="img"></a><br>来了一个数据时， 例如图中的黑色点Data，那么就找到了机器B<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-44-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-44-31.png" alt="img"></a></li><li>也就是意味着，每个机器负责了很多个离散的区间。</li><li>当需要加入一台新机器时？加入我们现在机器分布是这样：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-51-51.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-51-51.png" alt="img"></a><br>新来了一个E的机器，丢到环里之后<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-52-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-52-19.png" alt="img"></a><br>[D,E]之间的数据必须从A迁移到E上！！！！[A,E]之间的数据必须从B迁移到E上</li></ol><p>总结：</p><ul><li><p>将整个hash区间看成一个环，大小从359变成<script type="math/tex">2^{64}-1</script></p></li><li><p>将机器和数据都看成是环上的点</p></li><li><p>引入Micro shards/Virtual nodes的概念，每台机器对应1000个Micro shards/Virtual nodes</p></li><li><p>把每台机器看成1000台机器均匀撒在环上</p></li><li><p>每加入一条数据</p><ul><li>计算其id对应的hash值，得到0~<script type="math/tex">2^{64}-1</script> 区间上的一个点，找到环上对应的点</li><li>从这个点出发顺时针找到第一个机器的virtual node</li><li>该virtual node对应的机器就是本条数据应该存储的数据库服务器</li></ul></li><li><p>每加入一台新机器</p><ul><li>在环上随机撒1000个点</li><li>这1000个virtual node 各自想顺时针相邻的第一个virtual node 索要数据</li><li>例子：<a href="http://www.jiuzhang.com/qa/2067/" target="_blank" rel="external">http://www.jiuzhang.com/qa/2067/</a></li></ul></li><li><p>实现用TreeMap 红黑树</p><p>​</p></li></ul><p>问题：</p><p>问题1：需要存储数据在环的哪里吗？<br>不需要。因为这个数据在哪里与其它数据在哪里没有关系。只需要在环上计算数据所在的点的下一个位置的机器是哪个即可。</p><p>问题：那这个1000能变成100万吗？<br>太多也不行。查询效率会变低。就是在比较均匀的情况下选一个比较快的就行。</p><p>思考：哪种数据结构能够支持这种“顺时针”寻找下一个机器的功能呢？——链表是不行的，因为链表长度太大，查找很慢。用TreeMap!! 就是一个红黑树，能在LogN的时间内寻找比n大的最小值。</p><h1 id="数据备份-Replica"><a href="#数据备份-Replica" class="headerlink" title="数据备份 Replica"></a>数据备份 Replica</h1><h2 id="问题：Backup和Replica有什么区别？"><a href="#问题：Backup和Replica有什么区别？" class="headerlink" title="问题：Backup和Replica有什么区别？"></a>问题：Backup和Replica有什么区别？</h2><p>Backup</p><ul><li>一般是周期性的，比如每天晚上进行一次备份</li><li>当数据丢失的时候，通常只能恢复到之前的某个时间点</li><li>Backup 的数据是死数据，是离线的。不用作在线的数据服务，不分摊读</li></ul><p>Replica</p><ul><li>是实时的， 在数据写入的时候，就会以复制品的形式存为多份</li><li>当数据丢失的时候，可以马上通过其他的复制品恢复</li><li>Replica是实时的。 用作在线的数据服务，分摊读</li></ul><p>思考：既然 Replica 更牛，那么还需要 Backup么？</p><p>backup便宜哇~</p><h2 id="MySQL类型数据库的Replica"><a href="#MySQL类型数据库的Replica" class="headerlink" title="MySQL类型数据库的Replica"></a>MySQL类型数据库的Replica</h2><p>以MySQL为代表的的SQL型数据库，通常自带Master Slave模式的Replica方法。Master负责写，Slave负责读。Slave从Master中同步对数据的操作。</p><p><strong>Master - slave原理</strong>：Write Ahead Log</p><p>SQL数据库的任何操作，都会以Log的形式做一份记录。</p><p>比如Master上的数据A在B时刻从C改成了D，那么Master会通知Slave来读Log（不是同步值，而是同步操作！）。Slave被激活后，告诉master我可以更新了，之后Master有任何操作就会通知slave来读log然后slave会同步操作</p><p>因此Slave上的数据是有延迟的。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-24-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-24-44.png" alt="img"></a></p><p>问题：万一Master挂了怎么办？</p><ul><li>将一台slave升级为master, 接受读 + 写</li><li>可能会造成一定程度的数据丢失和不一致</li></ul><h2 id="NoSQL类型数据库的Replica"><a href="#NoSQL类型数据库的Replica" class="headerlink" title="NoSQL类型数据库的Replica"></a>NoSQL类型数据库的Replica</h2><p>以Cassandra为代表的的NoSQL数据库，通常将数据“顺时针”存储在Consistent hashing环上的三个vitual nodes中。</p><h2 id="MySQL和NoSQL型数据库的Replica比较"><a href="#MySQL和NoSQL型数据库的Replica比较" class="headerlink" title="MySQL和NoSQL型数据库的Replica比较"></a>MySQL和NoSQL型数据库的Replica比较</h2><p><strong>SQL</strong></p><ul><li>“自带” 的 Replica 方式是 Master Slave</li><li>“手动” 的 Replica 方式也可以在 Consistent Hashing 环上顺时针存三份</li></ul><p><strong>NoSQL</strong></p><ul><li>“自带” 的 Replica 方式就是 Consistent Hashing 环上顺时针存三份</li><li>“手动” 的 Replica 方式：就不需要手动了，NoSQL就是在 Sharding 和 Replica 上帮你偷懒用的！</li></ul><h1 id="设计短网址系统-Design-Tiny-URL"><a href="#设计短网址系统-Design-Tiny-URL" class="headerlink" title="设计短网址系统 Design Tiny URL"></a>设计短网址系统 Design Tiny URL</h1><p>短网址生成网站：</p><p><a href="https://bitly.com/" target="_blank" rel="external">https://bitly.com/</a><br><a href="https://goo.gl/" target="_blank" rel="external">https://goo.gl/</a></p><h2 id="系统设计的常见误区："><a href="#系统设计的常见误区：" class="headerlink" title="系统设计的常见误区："></a>系统设计的常见误区：</h2><p><strong>以下几个是误区</strong></p><ul><li>系统一定巨大无比 —— ×</li><li>必须用NoSQL —— ×</li><li>必须是分布式 —— ×</li></ul><p>不可以扔关键词，必须一步步分析。</p><p><strong>正确打开方式——4S分析法</strong></p><ol><li>提问：分析功能/需求/QPS/存储容量——Scenario</li><li>画图：根据分析结果设计“可行解”—— Service+Storage</li><li>进化：研究可能遇到的问题，优化系统 —— Scale</li></ol><h2 id="1-Scenario-场景-需求分析"><a href="#1-Scenario-场景-需求分析" class="headerlink" title="1. Scenario 场景 需求分析"></a>1. Scenario 场景 需求分析</h2><h4 id="我要设计啥"><a href="#我要设计啥" class="headerlink" title="我要设计啥"></a>我要设计啥</h4><ul><li>根据长URL生成短URL<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-35-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-35-36.png" alt="img"></a></li><li>根据短URL还原长URL<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-36-01.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-36-01.png" alt="img"></a></li></ul><h4 id="QPS-Storage"><a href="#QPS-Storage" class="headerlink" title="QPS + Storage"></a>QPS + Storage</h4><p>假设这个是用来给微博做短网址的跳转。那么QPS能有多少？</p><ol><li>询问微博日活用户 —— 约100M</li><li>推算产生一条Tiny URL的QPS<ul><li>假设每个用户平均每天发0.1条微博，</li><li>平均写QPS = 100M * 0.1 / 86400 ~ 100</li><li>峰值QPS = 100 * 2 = 200</li></ul></li><li>推算点击一条Tiny URL的QPS<ul><li>假设每个用户平均点1个Tiny URL</li><li>平均读QPS = 100M * 1 / 86400 ~ 1k</li><li>峰值QPS = 2k</li></ul></li><li>推算每天产生的新的 URL 所占存储<ul><li>100M * 0.1 ~ 10M 条</li><li>每一条 URL 长度平均 100 算，一共1G</li><li>1T 的硬盘可以用 3 年</li></ul></li></ol><p>前3点：2k QPS ，一台SSD支持的MySQL完全可以搞定！</p><h2 id="2-Service-服务"><a href="#2-Service-服务" class="headerlink" title="2. Service 服务"></a>2. Service 服务</h2><h4 id="逻辑块聚类与接口设计"><a href="#逻辑块聚类与接口设计" class="headerlink" title="逻辑块聚类与接口设计"></a>逻辑块聚类与接口设计</h4><ol><li><p>TinyUrl只有一个UrlService</p><ul><li>本身就是一个小Application</li><li>无需关心其他的</li></ul></li><li><p>函数设计</p><ul><li><code>UrlService.encode(long_url)</code></li><li><code>`UrlService.decode(short_url)</code></li></ul></li><li><p>访问端口设计</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">GET /&lt;short_url&gt;</div><div class="line"><span class="keyword">return</span> a Http redirect response</div><div class="line"></div><div class="line">POST /data/shorten/</div><div class="line">Data = &#123;url: http:<span class="comment">//xxxx &#125;</span></div><div class="line">Return <span class="keyword">short</span> url</div></pre></td></tr></table></figure></li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-49-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-49-19.png" alt="img"></a></p><h2 id="3-Storage-数据存储"><a href="#3-Storage-数据存储" class="headerlink" title="3. Storage 数据存储"></a>3. Storage 数据存储</h2><p>两个步骤：</p><ol><li>选择存储结构</li><li>细化数据表</li></ol><h4 id="选择存储结构-SQL-vs-NoSQL"><a href="#选择存储结构-SQL-vs-NoSQL" class="headerlink" title="选择存储结构 SQL vs NoSQL"></a>选择存储结构 SQL vs NoSQL</h4><ul><li>是否需要支持 Transaction（事务）？<ul><li>NoSQL不支持Transaction</li><li>是否需要丰富的 SQL Query？</li></ul></li><li>NoSQL的SQL Query不是太丰富<ul><li>也有一些NoSQL的数据库提供简单的SQL Query支持</li></ul></li><li>是否想偷懒？<ul><li>大多数 Web Framework 与 SQL 数据库兼容得很好</li><li>用SQL比用NoSQL少写很多代码</li></ul></li><li>是否需要Sequential ID？<ul><li>SQL 为你提供了 auto-increment 的 Sequential ID。也就是1,2,3,4,5 …</li><li>NoSQL的ID并不是 Sequential 的</li></ul></li><li>对QPS的要求有多高？<ul><li>NoSQL 的性能更高</li></ul></li><li>对Scalability的要求有多高？<ul><li>SQL 需要码农自己写代码来 Scale</li><li>还记得Db那节课中怎么做 Sharding，Replica 的么？</li></ul></li><li>NoSQL 这些都帮你做了</li></ul><p><strong>选择</strong></p><ul><li>是否需要支持 Transaction？——不需要。NoSQL +1</li><li>是否需要丰富的 SQL Query？——不需要。NoSQL +1</li><li>是否想偷懒？——Tiny URL 需要写的代码并不复杂。NoSQL+1</li><li>对QPS的要求有多高？—— 经计算，2k QPS并不高，而且2k读可以用Cache，写很少。SQL +1</li><li>对Scalability的要求有多高？—— 存储和QPS要求都不高，单机都可以搞定。SQL+1</li><li>是否需要Sequential ID？—— 取决于你的算法是什么 : 如何将Long URL 转化为 Short URL</li></ul><h2 id="4-算法：-如何将Long-URL-转化为-Short-URL"><a href="#4-算法：-如何将Long-URL-转化为-Short-URL" class="headerlink" title="4. 算法： 如何将Long URL 转化为 Short URL"></a>4. 算法： 如何将Long URL 转化为 Short URL</h2><h3 id="4-1-算法1-使用哈希函数-Hash-Function（不可行）"><a href="#4-1-算法1-使用哈希函数-Hash-Function（不可行）" class="headerlink" title="4.1 算法1 使用哈希函数 Hash Function（不可行）"></a>4.1 算法1 使用哈希函数 Hash Function（不可行）</h3><p>比如取 Long Url 的 MD5 的最后 6 位——这个方法肯定是有问题的</p><ul><li>优点：快</li><li>缺点：难以设计一个没有冲突的哈希算法</li></ul><h3 id="4-2-算法2：随机生成-数据库去重"><a href="#4-2-算法2：随机生成-数据库去重" class="headerlink" title="4.2 算法2：随机生成 + 数据库去重"></a>4.2 算法2：随机生成 + 数据库去重</h3><p>随机一个 6 位的 ShortURL，如果没有被用过，就绑定到该 LongURL</p><p>伪代码如下：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-23-00-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-23-00-12.png" alt="img"></a></p><ul><li>优点：实现简单</li><li>缺点：生成短网址的长度随着短网址越来越多变得越来越慢</li><li>可行性：其实能凑合用。在生活中有很多随机编码的，例如机票码、酒店码，是不可重复的，就是用这种方法弄的。</li></ul><h3 id="4-3-算法3：进制转换-Base62"><a href="#4-3-算法3：进制转换-Base62" class="headerlink" title="4.3 算法3：进制转换 Base62"></a>4.3 算法3：进制转换 Base62</h3><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-55-32.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-55-32.png" alt="img"></a></p><ul><li>Base62<ul><li>将6位的short url看成一个62进制的数（0-9,a-z,A-Z）</li><li>每个short url对应到一个整数</li><li>该整数对应数据库表的主键——Sequential ID</li></ul></li><li>6位可以表示不同的URL有多少？<ul><li>5位 = 625625 = 9亿</li><li>6位 = 626626 = 570亿</li><li>7位 = 627627 = 35000亿</li></ul></li><li>优缺点<ul><li>优点：效率高</li><li>缺点：依赖于全局的自增ID</li></ul></li></ul><h3 id="4-4-算法2与3的比较"><a href="#4-4-算法2与3的比较" class="headerlink" title="4.4 算法2与3的比较"></a>4.4 算法2与3的比较</h3><ul><li><p><strong>基于随机生成的方法</strong><br>需要根据 Long 查询 Short，也需要根据 Short 查询 Long。基本上work solution如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-00-54.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-00-54.png" alt="img"></a><br>如果选择用 SQL 型数据库，表结构如下：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-58-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-58-03.png" alt="img"></a><br>并且需要对shortKey和longURL分别建索引<br>• <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95" target="_blank" rel="external">什么是索引？</a><br>• <a href="http://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html" target="_blank" rel="external">索引的原理？</a><br>也可以选用 NoSQL 数据库，但是需要建立两张表（大多数NoSQL数据库不支持二级索引）。以 Cassandra 为例子<br>第一张表：根据 Long 查询 Short<br>row_key=longURL, column_key=ShortURL, value=null or timestamp<br>第二张表：根据 Short 查询 Long<br>row_key=shortURL, column_key=LongURL, value=null or timestamp</p></li><li><p><strong>基于进制转换的方法</strong><br>因为需要用到自增ID（Sequential ID），因此只能选择使用 SQL 型数据库。表单结构如下，shortURL 可以不存储在表单里，因为可以根据 id 来进行换算</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-21-36-40.png" alt=""> </p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-02-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-02-19.png" alt="img"></a></p></li></ul><h2 id="5-Scale-优化"><a href="#5-Scale-优化" class="headerlink" title="5. Scale 优化"></a>5. Scale 优化</h2><h3 id="5-1-如何提高响应速度？"><a href="#5-1-如何提高响应速度？" class="headerlink" title="5.1 如何提高响应速度？"></a>5.1 如何提高响应速度？</h3><p><strong>读操作的优化</strong></p><p>既然读操作比较多，那么可以用cache的方式去提速。</p><ul><li>cache里存什么？<ul><li>long to short(生成新short url时需要)</li><li>short to long(查询short url时需要)</li></ul></li><li>查询的流程图：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-22-22.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-22-22.png" alt="img"></a></li></ul><h3 id="5-2-如何提速？"><a href="#5-2-如何提速？" class="headerlink" title="5.2 如何提速？"></a>5.2 如何提速？</h3><ul><li><p>利用地理位置信息加速</p></li><li><p>优化服务器速度</p><ul><li>不同地区，使用不同Web服务器</li><li>通过DNS解析不同地区的用户到不同的服务器</li></ul></li><li><p>优化数据访问速度</p><ul><li><p>使用Centralized MySQL + Distributed Memcached</p></li><li><p>数据库共享一个，不同地区设置多个缓存</p></li><li><p>一个MySQL配多个Memcached, Memcached跨地区分布</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-31-37.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-31-37.png" alt="img"></a></p></li></ul></li></ul><h3 id="5-3-数据量扩展"><a href="#5-3-数据量扩展" class="headerlink" title="5.3 数据量扩展"></a>5.3 数据量扩展</h3><p>如果数据量很大，一台MySQL搞不定了</p><ul><li>什么时候需要扩展多台服务器？<ul><li>Cache资源不够</li><li>写操作越来越多</li><li>请求太多，无法通过Cache满足</li></ul></li><li>增加多台数据库可以优化什么？<ul><li>解决存不下的问题——Storage角度（TinyURL一般遇不到这种问题）</li><li>解决忙不过来的问题——QPS角度</li><li>TinyURL主要是什么问题？？——忙不过来的问题</li></ul></li></ul><ul><li><p>如何解决忙不过来的问题？拆分 </p><ul><li><p>纵向切分？不同列放不同数据库？不可行！</p></li><li><p>横向拆分？</p><ul><li><p>用什么做sharding key?</p></li><li><p>如果用longURL做为sharding key，如何查询ID(short URL) ?</p><ul><li>已知shortURL查询longURL时，只能广播给N台数据库查询</li><li>不能降低每台机器QPS</li></ul></li><li><p>如果用ID(short URL)做为sharding key，如何查询 longURL?</p><ul><li><p>假设按照ID%N来分配存储</p></li><li><p>short2long</p><ul><li>将shortURL转化为ID</li><li>根据ID计算找到数据库</li><li>在该数据库中查询longURL即可</li></ul></li><li><p>long2short</p><ul><li>先查询：广播给N台数据库，查询是否存在，似乎有点耗时，但是也是可行的，因为数据库服务器不会太多</li><li>再插入如果不存在的话，获得下一个自增ID值，插入对应数据库</li><li><strong>其实也不可以不查询直接插入</strong>，因为long2short没有必要意义对应，<strong>一个long可以对应多个short</strong>，也就是说可以把长网址转成多个短网址，但是一旦用户获得一个短网址，相同的短网址只能对应一个长网址。</li></ul></li><li><p>这种方法还有一个问题，如何在多台数据库服务器上获取全局递增的ID？（因为每台机器上都有一个数据表，需要获取所有数据的递增ID就是个问题），解决办法：</p><ol><li>专门用一台服务器负责自增ID服务，不存储数据，也不负责查询</li><li>用Zookeeper</li></ol><p>但用全局递增ID不是解决TinyURL的好办法</p></li></ul></li></ul><p><strong>下面是一种更好的sharding办法，不需要全局递增ID：</strong></p></li><li><p>如果最开始shortkey为6位，那就增加一位前置位：</p><ul><li>AB1234 –&gt; 0AB1234（该前置位由hash(long_url)%62得到（可以用consistent hash算法），因此是唯一的。这个前置位可以作为机器的ID等）</li><li>另一种做法，把第一位单独留出来做sharding key，总共还是6位</li></ul></li><li><p>该前置位为sharding key</p></li><li><p>这样我们就可以同时通过shortURL和longURL得到sharding key</p><ul><li>无需广播</li><li>无论short2long还是long2short都可直接定位数据所在服务器</li></ul></li><li><p>当新加入一个longURL时，先通过hash(long_url)%62得到机器ID，然后在该机器上，通过该台机器的自增ID通过进制转换得到6位shortkey</p></li><li><p>用户已知shortURL时，先按第一位获取到机器ID，然后在此机器上查询longURL</p><p>那么当前的架构就变成了：</p></li></ul></li></ul><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-22-18-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-22-18-36.png" alt="img"></a></p><h3 id="5-4-Multi-region-的进一步优化"><a href="#5-4-Multi-region-的进一步优化" class="headerlink" title="5.4 Multi region 的进一步优化"></a>5.4 Multi region 的进一步优化</h3><p>上面的架构图还有优化的空间：</p><ul><li>网站服务器与数据库服务器之间的通信</li><li>中心化服务器集群与跨地域的web server之间的通信较慢，比如如果中心数据库放在美国，那么中国的服务器需要访问美国的数据库，通信较慢</li></ul><p>解决方法1：重写数据库到中国，中国用户访问中国数据库</p><p>问题：重写数据库，一致性问题如何解决？很难解决</p><p>正确打开方式：</p><p>想一想用户习惯：</p><ol><li>中国的用户一般访问的网站是中国的，美国的用户一般访问的网站是美国的</li><li>中国用户访问时，会被DNS分配中国的服务器</li></ol><p>因此我们可以用<strong>地域信息</strong>进行sharding，也就是说按照网站的地域信息将其数据分开存储在不同地方的数据库中</p><p>​    如何获得网站的地域信息？做一张用户经常访问的网站数据表</p><p>这样中国用户要访问的网站大多在位于中国的数据库中，响应速度就会比较快，当然也有少量中国用户需要访问美国网站的情况，就直接去访问美国数据库就好，反正不会慢对少，毕竟中国访问中国是主流需求，优化系统就是要优化主要需求。</p><p>最终架构图</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-11-17-32.png" alt=""> </p><h3 id="5-5-自定义短链接"><a href="#5-5-自定义短链接" class="headerlink" title="5.5 自定义短链接"></a>5.5 自定义短链接</h3><p>用户自定义短网址 -&gt; 长网址映射</p><p><a href="http://tiny.url/google/" target="_blank" rel="external">http://tiny.url/google/</a> =&gt; <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a><br><a href="http://tiny.url/systemdesign/" target="_blank" rel="external">http://tiny.url/systemdesign/</a> =&gt; <a href="http://www.jiuzhang.com/course/2/" target="_blank" rel="external">http://www.jiuzhang.com/course/2/</a></p><p><strong>一个错误的想法是：</strong></p><p>在URLtable中增加一个column，存放自定义的URL，因为这一列大部分会是空的，浪费空间。</p><p>正确打开方式：</p><ul><li>新建一张表存储自定义URL<ul><li>CustomURL Table</li></ul></li></ul><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-12-05-53.png" alt=""> </p><ul><li>已知长链接查询短链接的时候：<ul><li>先查询customURL table</li><li>再查询URL table</li></ul></li><li>用户想要由长链接自定一个新的短链接的时候<ul><li>查询是否已经在URLtable中存在了</li><li>再在CustomURL table 中查询和插入</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-03
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】follow up</title>
    <link href="http://yoursite.com/2018/02/26/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91follow-up/"/>
    <id>http://yoursite.com/2018/02/26/【九章算法强化班】follow-up/</id>
    <published>2018-02-26T07:07:15.000Z</published>
    <updated>2018-02-28T07:35:25.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-26-20-43-25.png" alt=""> </p><h2 id="例题1-Find-Peak-Element"><a href="#例题1-Find-Peak-Element" class="headerlink" title="例题1.Find Peak Element"></a>例题1.<a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h2><blockquote><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p><p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p></blockquote><p>找局部最大值。</p><p>思路：</p><ol><li><p>baseline：</p><p>遍历，找到i：nums[i-1]&lt;num[i]&lt;num[i+1]</p><p>复杂度<script type="math/tex">O(n)</script></p></li></ol><ol><li><p>优化：二分法</p><p>首先我们找到中间节点mid，如果大于两边返回当前index就可以了，如果左边的节点比mid大，那么我们可以继续在左半区间查找，这里面一定存在一个peak，为什么这么说呢？假设此时的区间范围为[0, mid - 1]， 因为num[mid - 1]一定大于num[mid]了，如果num[mid - 2] &lt;= num[mid - 1]，那么num[mid - 1]就是一个peak。如果num[mid - 2] &gt; num[mid - 1]，那么我们就继续在[0, mid - 2]区间查找，因为num[-1]为负无穷，所以最终我们绝对能在左半区间找到一个peak。同理右半区间一样。</p><p>复杂度<script type="math/tex">O(logn)</script></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &gt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((nums[mid] &lt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[end])&#123;</div><div class="line">            <span class="keyword">return</span>  end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-Find-Peak-Element-II"><a href="#follow-up-Find-Peak-Element-II" class="headerlink" title="follow up: Find Peak Element II"></a>follow up: Find Peak Element II</h3><p> 由一维拓展到二维，在矩阵上找peak element</p><p>peak element：<code>matrix[i][j]</code> 比其上下左右相邻元素大</p><p>思路：</p><ol><li><p>baseline：</p><p>遍历</p><p>复杂度复杂度<script type="math/tex">O(n^2)</script></p></li><li><p>优化：二分法</p><ul><li>找到中间行的最大值<code>matrix[i][j]</code></li><li>跟相邻上下元素比较，决定向上/向下走</li><li>如果上面的元素比较大，向上走，否则向下走</li></ul><p>复杂度<script type="math/tex">O(nlogn)</script></p></li><li><p>优化：行列交替二分</p><ul><li>找到中间行的最大值<code>matrix[i][j]</code> <script type="math/tex">O(n)</script></li><li>跟相邻上下元素比较，决定向上/向下走 剩下一半矩阵</li><li>找中间列的最大值<code>matrix[i][j]</code><script type="math/tex">O(n/2)</script></li><li>跟相邻左右元素比较，决定向左/向右走 剩下n/4矩阵</li></ul><p>复杂度<script type="math/tex">O(n)</script></p></li></ol><h2 id="例题2-Subarray-Sum"><a href="#例题2-Subarray-Sum" class="headerlink" title="例题2. Subarray Sum"></a>例题2. <a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">Subarray Sum</a></h2><blockquote><p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p><p>Example</p><p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p></blockquote><p>找子数组，和为0</p><p>思路：</p><ol><li><p>baseline:</p><p>两指针遍历</p><p>复杂度复杂度<script type="math/tex">O(n^2)</script></p></li><li><p>prefix sum:</p><p>用hash表记录前缀和的取值</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                result.add(<span class="number">0</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="follow-up-1-Submatrix-Sum"><a href="#follow-up-1-Submatrix-Sum" class="headerlink" title="follow up 1: Submatrix Sum"></a>follow up 1: <a href="http://www.lintcode.com/en/problem/submatrix-sum/" target="_blank" rel="external">Submatrix Sum</a></h3><blockquote><p>Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.</p><p>Example</p><p>Given matrix</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1 ,5 ,7],</div><div class="line">&gt;   [3 ,7 ,-8],</div><div class="line">&gt;   [4 ,-8 ,9],</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[(1,1), (2,2)]</code></p></blockquote><p>求元素和为0的子矩阵，返回矩阵的左上角和右下角元素位置</p><p>思路：</p><ol><li><p>先定位子矩阵的首行和尾行（外层循环）</p></li><li><p>把首行和尾行之间的元素压成一行，变成一个数组</p></li><li><p>对上面的数组做subarray sum，找到和为0的子数组就可以定位子矩阵的首列和尾列。</p><p>​</p></li></ol><p>预计算presum矩阵：</p><p><code>presum[i][j] = matrix[0][0]到matrix[i][j]的所有元素和</code></p><p>当外层循环固定为l和h时，内层循环j从0开始遍历，矩阵的前缀和为<code>presum[h][j]-presum[l][j]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] submatrixSum(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> rows = matrix.length;</div><div class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[][] presum = <span class="keyword">new</span> <span class="keyword">int</span>[rows+<span class="number">1</span>][cols+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</div><div class="line">                presum[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                presum[i][j] = matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] + presum[i-<span class="number">1</span>][j] + presum[i][j-<span class="number">1</span>] - presum[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; rows + <span class="number">1</span>; j++) &#123;</div><div class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cols + <span class="number">1</span>; k++) &#123;</div><div class="line">                <span class="keyword">int</span> diff = presum[j][k] - presum[i][k];</div><div class="line">                <span class="keyword">if</span> (map.containsKey(diff)) &#123;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">0</span>] = i;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">1</span>] = map.get(diff);</div><div class="line">                    result[<span class="number">1</span>][<span class="number">0</span>] = j-<span class="number">1</span>;</div><div class="line">                    result[<span class="number">1</span>][<span class="number">1</span>] = k-<span class="number">1</span>;</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    map.put(diff, k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-2-Subarray-Sum-II"><a href="#follow-up-2-Subarray-Sum-II" class="headerlink" title="follow up 2: Subarray Sum II"></a>follow up 2: Subarray Sum II</h3><p>给定一个数组nums和一个区间interval，返回nums数组中和在区间interval中的子数组个数，如nums = [1,2,3,4]，interval = [1,3],return 4,the possible answers are:[0,0],[0,1],[1,1],[2,2]</p><p>思路：</p><p>low &lt; prefix[j] - prefix[i] &lt; high</p><p>low + prefix[i] &lt; prefix[j] &lt; high + prefix[i]</p><p>prefix[i]  &lt;  prefix[j] - low</p><p>prefix[i]  &gt; prefix[j] - high</p><p>所以本题就是要找到在[prefix[j] - high , prefix[j] - low]范围内的prefix[i] </p><p>由于prefix[i]是递增的，所以可以存在数组中，用二分法查找</p><h2 id="例题3-Maximum-Subarray"><a href="#例题3-Maximum-Subarray" class="headerlink" title="例题3. Maximum Subarray"></a>例题3. <a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p></blockquote><p>找和最大的子数组</p><p>思路：</p><p>方法1：prefixsum</p><p>维护最小的prefixsum和当前最大的子数组和</p><p>方法2：dp</p><p>dp[i] = max(dp[i-1] + num[i],num[i])</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</div><div class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</div><div class="line">            maxVal = Math.max(maxVal,dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="follow-up-循环连续子数组"><a href="#follow-up-循环连续子数组" class="headerlink" title="follow up 循环连续子数组"></a>follow up 循环连续子数组</h2><p>上题的数组变成循环数组。</p><p>处理循环数组三种方法：</p><ol><li>拆开</li><li>扩展</li><li>取反</li></ol><p>分别看对于这道题是否可行：</p><ol><li><p>拆开</p><p>house robber用到了这个方法，抢第一个就不能抢最后一个，抢最后一个就不能抢第一个</p></li><li><p>扩展</p><p>将数组翻一倍，[-3, 1, 3, -3, 4]变成[-3, 1, 3, -3, 4,-3,1,3,-3]，然后找最大子数组，但是长度不能超过nums的长度。</p></li><li><p>取反</p><p>找循环数组中的最大子数组，有两种情况：</p><ol><li>在数组的中部，正常找就行了</li><li>一半在数组后面，一半在数组头部，因为数组的总和是一定的，因此这种情况可以转化成在数组中部找最小的子数组</li></ol><p>然后取上面两种情况的最大值。</p><p>​</p></li></ol><h2 id="例题4-Wiggle-Sort"><a href="#例题4-Wiggle-Sort" class="headerlink" title="例题4.  Wiggle Sort"></a>例题4.  <a href="https://leetcode.com/problems/wiggle-sort" target="_blank" rel="external">Wiggle Sort</a></h2><blockquote><p>Given an unsorted array <code>nums</code>, reorder it <strong>in-place</strong> such that <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...</code>.</p><p>For example, given <code>nums = [3, 5, 2, 1, 6, 4]</code>, one possible answer is <code>[1, 6, 2, 5, 3, 4]</code>.</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[start];</div><div class="line">                start++;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-Wiggle-Sort-II"><a href="#follow-up-Wiggle-Sort-II" class="headerlink" title="follow up Wiggle Sort II"></a>follow up <a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p><p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>对数组排序，排序之后将数组分成大小两堆，然后依次选取排序</p></li><li><p>quick sort思想</p><p>利用quick sort 找到中点，然后对左右两边元素一次选取排序</p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="例题5-Building-Post-Office-Best-Meeting-Point"><a href="#例题5-Building-Post-Office-Best-Meeting-Point" class="headerlink" title="例题5. Building Post Office Best Meeting Point"></a>例题5. Building Post Office <a href="https://leetcode.com/problems/best-meeting-point" target="_blank" rel="external">Best Meeting Point</a></h2><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>遍历所有位置，计算每个位置到所有人的距离，取最小的</p></li><li><p>优化：</p><p>看成一维，对于所有人来说，meeting point选在所有人的中位数的位置距离和最近，因此对行和列坐标分别选取中位数，得到meeting point</p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//int  num = 0;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                    <span class="comment">//num++;</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up1-Shortest-Distance-from-All-Buildings"><a href="#follow-up1-Shortest-Distance-from-All-Buildings" class="headerlink" title="follow up1. Shortest Distance from All Buildings"></a>follow up1. <a href="https://leetcode.com/problems/shortest-distance-from-all-buildings" target="_blank" rel="external">Shortest Distance from All Buildings</a></h3><blockquote><p>You want to build a house on an <em>empty</em> land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values <strong>0</strong>, <strong>1</strong> or <strong>2</strong>, where:</p><ul><li>Each <strong>0</strong> marks an empty land which you can pass by freely.</li><li>Each <strong>1</strong> marks a building which you cannot pass through.</li><li>Each <strong>2</strong> marks an obstacle which you cannot pass through.</li></ul><p>For example, given three buildings at <code>(0,0)</code>, <code>(0,4)</code>, <code>(2,2)</code>, and an obstacle at <code>(0,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 2 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(1,2)</code> is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>bfs，计算每个点到所有人的距离，取距离和最小的</p><p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层bfs<script type="math/tex">O(n^2)</script>，因此时间复杂度<script type="math/tex">O(n^4)</script></p></li><li><p>反向bfs</p><p>计算每个人到所有位置的距离<code>dis[k][i][j]</code> ，复杂度<script type="math/tex">O(n^2)</script></p><p>然后再遍历矩阵中每一个点，查询距离，取最小值，复杂度<script type="math/tex">O(n^2)</script></p><p>因此时间复杂度<script type="math/tex">O(n^2)</script></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算到所有空地的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> idx,<span class="keyword">int</span>[][][] distance,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">int</span>[][] grid)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(i*cols+j);</div><div class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">int</span> val = queue.poll();</div><div class="line">                <span class="keyword">int</span> x = val/cols;</div><div class="line">                <span class="keyword">int</span> y = val % cols;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                    <span class="keyword">int</span> x_new = x + x_delta[ii];</div><div class="line">                    <span class="keyword">int</span> y_new = y + y_delta[ii];</div><div class="line">                    <span class="keyword">if</span>(x_new &gt;= <span class="number">0</span> &amp;&amp; x_new &lt; rows &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt;cols) &#123;</div><div class="line">                        <span class="keyword">if</span>(grid[x_new][y_new] == <span class="number">0</span> &amp;&amp; distance[idx][x_new][y_new] == <span class="number">0</span>)&#123;</div><div class="line">                            distance[idx][x_new][y_new] = dis;</div><div class="line">                            queue.add(x_new * cols + y_new);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">            dis++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="comment">//计算有多少个1</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[count][rows][cols];</div><div class="line">        <span class="comment">//计算（i,j）到所有0点的距离</span></div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    bfs(i,j,idx,distance,rows,cols,grid);</div><div class="line">                    idx++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</div><div class="line">        <span class="comment">//找距离和最短的</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; distance.length;k++)&#123;</div><div class="line">                        <span class="keyword">if</span>(distance[k][i][j] == <span class="number">0</span>)&#123;</div><div class="line">                            flag = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span>&#123;</div><div class="line">                            sum += distance[k][i][j];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(flag)&#123;</div><div class="line">                        minDist = Math.min(minDist,sum);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minDist == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minDist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-2-Bomb-Enemy"><a href="#follow-up-2-Bomb-Enemy" class="headerlink" title="follow up 2. Bomb Enemy"></a>follow up 2. <a href="https://leetcode.com/problems/bomb-enemy" target="_blank" rel="external">Bomb Enemy</a></h3><blockquote><p>Given a 2D grid, each cell is either a wall <code>&#39;W&#39;</code>, an enemy <code>&#39;E&#39;</code> or empty <code>&#39;0&#39;</code> (the number zero), return the maximum enemies you can kill using one bomb.<br>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br>Note that you can only put the bomb at an empty cell.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For the given grid</div><div class="line">&gt;</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt; E 0 W E</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt;</div><div class="line">&gt; return 3. (Placing a bomb at (1,1) kills 3 enemies)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>bfs，计算每个点能够炸到的到所有人</p><p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层<script type="math/tex">O(n)</script>，因此时间复杂度<script type="math/tex">O(n^3)</script></p></li><li><p>反向bfs</p><p>申请四个数组：</p><p><code>left[i][j]:在(i,j)放炸弹，向左最多炸人数</code></p><p><code>right[i][j]:在(i,j)放炸弹，向右最多炸人数</code></p><p><code>up[i][j]:在(i,j)放炸弹，向上最多炸人数</code></p><p><code>dowm[i][j]:在(i,j)放炸弹，向下最多炸人数</code></p><p>将四个数组相加就得到在(i,j)放炸弹，总共炸人数</p><p>因此时间复杂度<script type="math/tex">O(n^2)</script> </p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombEnemy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxKilledEnemies</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] left = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] up = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">int</span> leftsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> rightsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span>)&#123; left[i][j] = leftsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'W'</span>)&#123; leftsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'E'</span>)&#123; leftsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'0'</span>)&#123; right[i][cols-<span class="number">1</span>-j] = rightsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'W'</span>)&#123; rightsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'E'</span>)&#123; rightsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cols;i++)&#123;</div><div class="line">            <span class="keyword">int</span> upsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> downsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; rows;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'0'</span>)&#123; up[j][i] = upsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'W'</span>)&#123; upsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'E'</span>)&#123; upsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'0'</span>)&#123; down[rows-<span class="number">1</span>-j][i] = downsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'W'</span>)&#123; downsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'E'</span>)&#123; downsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                maxnum = Math.max(maxnum,left[i][j] + right[i][j] + up[i][j] + down[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxnum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="例题6-N个数组的第K大问题"><a href="#例题6-N个数组的第K大问题" class="headerlink" title="例题6. N个数组的第K大问题"></a>例题6. N个数组的第K大问题</h2><p>在N个数组中找到第K大的元素</p><p>排序+heap</p><p>类似merge K sorted list</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-02
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】线段树</title>
    <link href="http://yoursite.com/2018/02/08/%E3%80%90leetcode%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2018/02/08/【leetcode】线段树/</id>
    <published>2018-02-08T14:27:03.000Z</published>
    <updated>2018-02-11T13:34:17.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线段树入门"><a href="#1-线段树入门" class="headerlink" title="1. 线段树入门"></a>1. 线段树入门</h1><p>本文主要参考自<a href="https://jiayi797.github.io/2018/01/23/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="external">jiayi797的专栏</a> 、 <a href="http://www.cnblogs.com/TenosDoIt/" target="_blank" rel="external">JustDoIT</a> 和 <a href="https://www.jiuzhang.com/article/kSiBNt/" target="_blank" rel="external">线段树知识点总结</a></p><p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。</p><p>线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]。线段树形如：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" alt="img"></a></p><p>下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0…n-1]中查找某个数组某个区间内的最大值，其中数组大小固定，但是数组中的元素的值可以随时更新。从这题可以看出：区间(a,b)的最大值和区间(b,c)的最大值中，取较大的就是区间(a,c)的最大值。很明显这个操作具有区间的性质。</p><p>我们可以用线段树来解决这个区间最大值问题。根据这个问题我们构造如下的二叉线段树。区间的第三维就是区间的最大值。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" alt="img"></a></p><p>加入第三维的时候，只需要在构建完左右区间后，根据左右区间的最大值更新当前区间最大值即可。</p><p>因为每次将区间长度一分为二，所有构造的节点个数为：</p><p>n + 1/2 <em>n + 1/4 </em>n + 1/8 * n + …</p><p>= (1 + 1/2 + 1/4 + 1/8 + …) * n</p><p>= 2n</p><p>所以构造线段树的时空复杂度都为O(n)。</p><h2 id="1-1-线段树常见题型"><a href="#1-1-线段树常见题型" class="headerlink" title="1.1. 线段树常见题型"></a>1.1. 线段树常见题型</h2><p>一道题可不可以用线段树来做，基本是看这道题的操作有没有<strong>区间的性质</strong>。也就是在一个区间上的操作是否可以转化为两个子区间上的操作。</p><ul><li>求区间和，积，最小值，gcd等</li><li>以当前节点的值作为节点处理。例如给出N个数字，再给一个数，问比这个数大的有多少个。</li><li>区间加减同一个值，或者区间同时赋一个值。</li></ul><h2 id="1-2-链式线段树"><a href="#1-2-链式线段树" class="headerlink" title="1.2. 链式线段树"></a>1.2. 链式线段树</h2><p>我们常见的二叉树都是链式结构。因此我们先完成链式的线段树。</p><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>复杂度O(n)</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</div><div class="line">    <span class="comment">//线段树节点定义</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        <span class="keyword">int</span> max;</div><div class="line">        SegmentTreeNode left = <span class="keyword">null</span>;<span class="comment">//定义左右节点</span></div><div class="line">        SegmentTreeNode right = <span class="keyword">null</span>;</div><div class="line">        SegmentTreeNode(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">builder</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,A.length-<span class="number">1</span>,A);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (low &gt; high)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        SegmentTreeNode root = <span class="keyword">new</span> SegmentTreeNode(low,high,A[low]);</div><div class="line">        <span class="keyword">if</span>(low == high)&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.left = helper(low,high/<span class="number">2</span>,A);</div><div class="line">            root.left = helper(high/<span class="number">2</span>+<span class="number">1</span>,high,A);</div><div class="line">            root.max = Math.max(root.left.max,root.right.max);<span class="comment">//更新当前节点max值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>复杂度 O(log(n))O(log(n))</p><p>构造线段树目的是为了更快地查询。例如给定区间，要求区间中的最大值。而线段树的区间查询操作就是将当前区间分解为较小的子区间，然后由子区间的最大值就可以快速得到需要查询区间的最大值。例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">query(1,3) = max(query(1,1), query(2,3)) = max(4,3) = 4</div></pre></td></tr></table></figure><p>查询实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在线段树中查找[low,high]区间的最大值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.start == low &amp;&amp; root.end == high)&#123;</div><div class="line">        <span class="keyword">return</span> root.max;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">if</span>(mid &gt;= low)&#123;<span class="comment">//查询区间与左半区间有交集，最大值有可能在左半区间</span></div><div class="line">        result = Math.max(result,query(root.left,low,mid));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= high)&#123; <span class="comment">//查询区间与右半区间有交集，最大值有可能在右半区间</span></div><div class="line">        result = Math.max(result,query(root.right,mid+<span class="number">1</span>,high));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><p>复杂度 O(log(n))O(log(n))</p><p>更新序列中的一个节点，那么如何把这种变化体现到线段树中呢？</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" alt="img"></a></p><p>例如要将第4个点更新为5.就要变动3个区间的值，分别为[3,3], [2,3], [0,3]</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" alt="img"></a></p><p>改动一个节点，与这个节点对应的叶子结点都要变动。并且，这个节点变动后，这个节点的属性值也有可能会变动，那么就有可能影响到这个节点的父亲节点的属性值（例如可能影响到最大值）。所以需要从叶子节点一路走到根节点。</p><p>单点更新实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="comment">////如果找到相应叶子节点了</span></div><div class="line">    <span class="keyword">if</span>(root.start == root.end &amp;&amp; root.start == idx)&#123;</div><div class="line">        root.max = val;<span class="comment">//修改max值</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(idx &lt;= mid)&#123;<span class="comment">//要修改的在左边</span></div><div class="line">        modify(root.left,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        modify(root.right,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//跟新root的max</span></div><div class="line">    root.max = Math.max(root.left.max,root.right.max);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-线段树入门&quot;&gt;&lt;a href=&quot;#1-线段树入门&quot; class=&quot;headerlink&quot; title=&quot;1. 线段树入门&quot;&gt;&lt;/a&gt;1. 线段树入门&lt;/h1&gt;&lt;p&gt;本文主要参考自&lt;a href=&quot;https://jiayi797.github.io/2018/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计数排序、基数排序、桶排序</title>
    <link href="http://yoursite.com/2018/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/02/08/计数排序、基数排序、桶排序/</id>
    <published>2018-02-08T07:03:21.000Z</published>
    <updated>2018-02-11T13:34:17.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为比较排序。</p><p>可以证明，基于比较的排序算法在最坏情况下的时间下界是Ω(nlgn)。堆排序和归并排序的运行时间上界为O(nlgn)，因此这两种排序算法都是渐进最优的比较排序算法。</p><p>而<strong>非基于比较的排序</strong>，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限，达到线性时间复杂度<script type="math/tex">O(n)</script>。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p><p>基数排序：O(dn) (d次调用桶排序)，空间复杂度 O(k) </p><p>桶排序：O(n)时间复杂度，O(n)空间复杂度</p><p>计数排序：O(n)时间复杂度，O(k)空间复杂度，每一个元素都是整数，并且位于0到k - 1之间</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)。</p><p>计数排序的思想是，对每一个输入元素，计算小于它的元素个数，如果有10个元素小于它，那么它就应该放在11的位置上，如果有17个元素小于它，它就应该放在18的位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。下图展示了实际的运行过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1186132-945c959a74a71c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/597" alt="img"></p><p>计数排序</p><p>构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，得到图(a)的结果。然后把C中每个元素变成前面所有元素的累加和，得到图(b)的结果。接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到B中的位置，即是该元素排序后的位置。例如，图中A的最后一个元素是3，找到C[3]是7，再令B[7]=3即可，然后顺便把C[3]减一，这是防止相同的数被放到同一个位置。</p><p>计数排序的时间代价可以这样计算，第一次遍历A并计算C所花时间是Θ(n)，C累加所花时间是Θ(k)，再次遍历A并给B赋值所花时间是Θ(n)，因此，总时间为Θ(k + n)。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>对于一组数据，我们可以按照每一位对它们进行排序。比如，考虑下面一组十进制数</p><blockquote><p>329<br>457<br>839<br>355</p></blockquote><p>先按最后一位从小到大排序，得到</p><blockquote><p>35<strong>5</strong><br>45<strong>7</strong><br>32<strong>9</strong><br>83<strong>9</strong></p></blockquote><p>再按中间一位从小到大排序，得到</p><blockquote><p>3<strong>2</strong>9<br>8<strong>3</strong>9<br>3<strong>5</strong>5<br>4<strong>5</strong>7</p></blockquote><p>最后按第一位从小到大排序，得到</p><blockquote><p><strong>3</strong>29<br><strong>3</strong>55<br><strong>4</strong>57<br><strong>8</strong>39</p></blockquote><p>其中，对任何一位的排序算法必须是稳定的，即相同数字不能改变它们的前后顺序。</p><p>基数排序算法的运行时间很容易计算，对于n个k进制d位数，假如每一位的排序使用计数排序算法，则该位排序用时为Θ(n + k)，总共d位数，总排序用时就是Θ(d(n + k))。当d为常数且k=O(n)时，总排序时间为Θ(n)。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p><p>我们将[0,1)区间划分为n个相同大小的子区间，称为桶。然后将输入数据分别放到各个桶中。如果数据分布得很均匀，每个桶中的数据就不会太多，都会维持在常数量级。我们先对每个桶中的元素排序，然后把所有桶中的元素顺序列出来即可。下图为n=10的一个案例。</p><p><img src="http://upload-images.jianshu.io/upload_images/1186132-1ea2b9a00e9dbeb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675" alt="img"></p><p>桶排序.png</p><p>创建一个长度也为10的数组，将A中的元素按照大小找到B中合适的位置，插入链表。之后，分别对B中每个链表中的元素执行插入排序。最后将B中的所有元素依次取出即可。</p><p>现在分析桶排序的时间代价。将A中元素放入B用时Θ(n)，B中每个链表执行插入排序的用时，可以证明是O(2 - 1/n)，于是总用时就是Θ(n) + n * O(2 - 1/n) = Θ(n)。具体证明过程比较难理解，这里我想给出一个容易理解的解释，虽然不一定对，但还是可以帮助理解为什么总用时是Θ(n)。n个数放入n个桶，平均下来每个桶只有一个数，在实际中，可能有的多有的少，但都不会差得太离谱。因此我们可以认为每个桶中只有常数个数，那么对常数个数执行插入排序所用的时间当然也就是O(1)了。于是n个桶总用时就是O(n)，加上前面的Θ(n)，桶排序总用时就是Θ(n)了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非比较排序&quot;&gt;&lt;a href=&quot;#非比较排序&quot; class=&quot;headerlink&quot; title=&quot;非比较排序&quot;&gt;&lt;/a&gt;非比较排序&lt;/h2&gt;&lt;p&gt;插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/02/08/%E3%80%90leetcode%E3%80%91sort/"/>
    <id>http://yoursite.com/2018/02/08/【leetcode】sort/</id>
    <published>2018-02-08T05:38:35.636Z</published>
    <updated>2018-02-11T13:34:17.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr><p>title: 【leetcode】sort<br>date: 2018-02-08 13:38:35<br>tags:</p><h2 id="categories"><a href="#categories" class="headerlink" title="categories:"></a>categories:</h2></blockquote><p>leetcode 排序相关问题</p><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a><a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="external">Largest Number</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p></blockquote><p>给定数组返回由该数组构成的最大数字，返回string类型</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先把数字转化成字符串，然后按字符串顺序排序，这里有一个小技巧，判断字符串s1和s2谁应该放在前面时，比较s1+s2和s2+s1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Comparator&lt;String&gt; cmp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</div><div class="line">                String s1 = o1+o2;</div><div class="line">                String s2 = o2+o1;</div><div class="line">                <span class="keyword">return</span> s2.compareTo(s1);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            strs[i] = String.valueOf(nums[i]);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(strs,cmp);</div><div class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</div><div class="line">            sb.append(strs[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a><a href="https://leetcode.com/problems/maximum-gap/" target="_blank" rel="external">Maximum Gap</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Try to solve it in linear time/space.</p><p>Return 0 if the array contains less than 2 elements.</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p></blockquote><p>给定一个无序数组，返回数组中相邻元素（排序后）之差的最大值</p><p>复杂度要求：线性时间复杂度</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：排序，计算相邻元素最大值，时间复杂度<script type="math/tex">O(nlogn)</script></p><p>优化：桶排序</p><ol><li>确定数组中最大和最小元素max和min，数组中元素个数N</li><li>这N个数字的平均间隔为：avg = (max-min)/(N-1)，maxGap &gt;= avg，所以我们令桶的大小int <code>bucketSize = Math.max(1,(max - min) / (N-1));</code> 这样每一个桶内，元素的差值不会超过avg了，那么相邻元素之间的最大间隔一定在桶之间。</li><li>根据桶的大小，可以计算出桶的个数为<code>int bucketNum = (max - min)/bucketSize + 1;</code> ,</li><li>遍历数组中的元素，将元素放入对应的桶中，并维护每个桶的最大值和最小值</li><li>计算相邻桶的最小值和最大值的差，遇到桶中没有元素的跳过，取最大的差值即为所求。</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> N = nums.length;</div><div class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(N == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.abs(nums[<span class="number">0</span>] - nums[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//查找nums中最大和最小值</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</div><div class="line">            min = Math.min(min,num);</div><div class="line">            max = Math.max(max,num);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//maxGap &gt; avg = (max-min)/(N-1);bucketSize = floor(max-min)/(N-1);</span></div><div class="line">        <span class="keyword">int</span> bucketSize = Math.max(<span class="number">1</span>,(max - min) / (N-<span class="number">1</span>));<span class="comment">//桶大小</span></div><div class="line">        <span class="comment">//bucketNum = ceil (max-min)/bucketSize</span></div><div class="line">        <span class="keyword">int</span> bucketNum = (max - min)/bucketSize + <span class="number">1</span>;<span class="comment">//桶个数</span></div><div class="line"></div><div class="line">        <span class="comment">//用于记录每个bucket中的最大和最小值</span></div><div class="line">        <span class="keyword">int</span>[] bucketMin = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMin[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] bucketMax = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMax[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[(nums[i]-min)/bucketSize] == -<span class="number">1</span>)&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; bucketMin[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; bucketMax[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lastMax =  bucketMax[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[i] == -<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            maxGap = Math.max(maxGap,bucketMin[i] - lastMax);</div><div class="line">            lastMax = bucketMax[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxGap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="external">Best Meeting Point</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p></blockquote><p>给定二维数组，1代表n个人的出发地，0代表其余地点，找到数组中的一个位置，使得大家到这个地点的曼哈顿距离之和最短，返回最短距离</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只想到了暴力的思路。。。</p><p>看了solution，需要从一维的入手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Case #1: 1-0-0-0-1</div><div class="line">Case #2: 0-1-0-1-0</div><div class="line">Case #3: 1-0-0-0-0-0-0-1-1</div><div class="line">Case #4: 1-1-0-0-1</div></pre></td></tr></table></figure><p>给了这么几个例子，说明到所有点最短的距离就是中位数的点。</p><p>所以扩展到二维，到所有点距离最短的点就是所有点分别在x轴和y轴中位数的点。</p><p>因此可以遍历所有的点，记录是1的点的xy坐标，然后分别对xy坐标排序，取中位数的点，即为要求的点，再计算下距离就好。</p><p>优化：</p><p>可以把横纵坐标分离计算，按需加入list,这样就不需要排序了,直接取中位数位置的点</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestMeetingPoint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="external">Insert Interval</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p><p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p><p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p></blockquote><p>给定区间数组，区间之间没有overlap，又给定一个独立区间，将该独立区间加到数组的区间里，如有overlap将区间merge,返回加入独立区间后的数组</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>遍历数组中的区间，当数组中的区间和独立区间还没有交集（intervals.get(i).end &lt; newInterval.start）的时候，将这些区间原封不动放入result中</li><li>将区间start和end初始化为newInterval的start和end</li><li>继续遍历数组中的区间，直至intervals.get(i).start &gt; newInterval.end,也就是和独立区间不相交了，在此期间，更新数组的上下边界</li><li>将更新好的区间加入结果</li><li>将剩余区间加入结果</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertInterval</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start)&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i == intervals.size())&#123;</div><div class="line">            res.add(newInterval);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = newInterval.start;</div><div class="line">        <span class="keyword">int</span> end = newInterval.end;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end)&#123;</div><div class="line">            start = Math.min(start,intervals.get(i).start);</div><div class="line">            end = Math.max(end,intervals.get(i).end);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        res.add(<span class="keyword">new</span> Interval(start,end));</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size())&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a><a href="https://leetcode.com/problems/h-index/" target="_blank" rel="external">H-Index</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;hr&gt;
&lt;p&gt;title: 【leetcode】sort&lt;br&gt;date: 2018-02-08 13:38:35&lt;br&gt;tags:&lt;/p&gt;
&lt;h2 id=&quot;categories&quot;&gt;&lt;a href=&quot;#categories&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】两指针</title>
    <link href="http://yoursite.com/2018/02/02/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E4%B8%A4%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/02/02/【九章算法强化班】两指针/</id>
    <published>2018-02-02T04:31:57.000Z</published>
    <updated>2018-02-08T07:05:26.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol><li>一个数组，从两边往中间移动（对撞型）</li><li>一个数组，同时向前移动（前向型）</li><li>两个数组两根指针（并行型）</li></ol><h2 id="1-对撞型或相会型"><a href="#1-对撞型或相会型" class="headerlink" title="1.对撞型或相会型"></a>1.对撞型或相会型</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-12-41-27.png" alt=""> </p><h3 id="leetcode-11-Container-With-Most-Water"><a href="#leetcode-11-Container-With-Most-Water" class="headerlink" title="leetcode 11.Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">leetcode 11.Container With Most Water</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>灌水问题，从两边向内灌水，所以初始两个指针ij一头一尾，此时能够容纳的水量是i和j中比较高度的柱子高度*ij两个柱子之间的距离：</p><p>max(height[i] , height[j]) * (j - i)</p><p>然后考虑将柱子向内移动，其实我们只需要移动比较矮的柱子，因为如果移动长的一边的柱子，根据上面的公式，j-i会变短，max(height[i] , height[j])可能变小可能不变，所以总的水量不会增加，所以我们只有移动短的柱子，才有可能会遇到更高的柱子，使得水量增大。</p><p>这样一来，每次选取较短的柱子向内移动，时间复杂度为<script type="math/tex">O(n)</script></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">                max = Math.max(max,(j-i) *height[i]);</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max,(j-i) * height[j]);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Quick-select-—-Kth-Largest-Element-in-an-Array"><a href="#Quick-select-—-Kth-Largest-Element-in-an-Array" class="headerlink" title="Quick select — Kth Largest Element in an Array"></a>Quick select — <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p></blockquote><p>在一组数字中找到第K大的数字</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一：可以用堆，维护一个大小为K的堆，将数字依次加入堆，找到第k大，时间复杂度<script type="math/tex">O(nlogk)</script></p><p>方法二：quick select，基于quick sort的思想</p><ol><li>每次在数组中随机选取一个数组作为pivort，这里面随机选取，经过大量的验证，选取中间位置的数字作为pivot比较稳妥。</li><li>然后和快排一样，将比它小的放在它左边，比它大的放在右边，找到pivot的位置即是pivot的最终位置。<ol><li>如果此时pivot的位置==k-1，找到了</li><li>如果此时pivot的位置 &gt;k-1，只需在pivot左边寻找第k大</li><li>如果此时pivot的位置 &lt;k-1，只需在pivot右边寻找第k-pivot大</li></ol></li></ol><p>这种方法的时间复杂度为<script type="math/tex">O(n)+O(n/2)+O(n/4)+...+O(1) = O(2n) = O(n)</script></p><p>两种方法的比较：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-15-34-03.png" alt=""> </p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> pivotIdx = start+(end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> pivot = nums[pivotIdx];</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        swap(nums,i,pivotIdx);<span class="comment">//把pivot交换至数组头</span></div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= pivot)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            nums[i] = nums[j];</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= pivot)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            nums[j] = nums[i];</div><div class="line">        &#125;</div><div class="line">        nums[j] = pivot;</div><div class="line">        <span class="keyword">if</span>((j - start) == k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> pivot;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((j - start) &gt; k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,start,j-<span class="number">1</span>,k);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,j+<span class="number">1</span>,end,k-j+start-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> partition(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-16-57-31.png" alt=""> </p><h3 id="lintcode-399-Nuts-amp-Bolts-Problem"><a href="#lintcode-399-Nuts-amp-Bolts-Problem" class="headerlink" title="lintcode 399.Nuts &amp; Bolts Problem"></a><a href="https://www.lintcode.com/en/problem/nuts-bolts-problem/" target="_blank" rel="external">lintcode 399.Nuts &amp; Bolts Problem</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts。nuts 和 bolts 一一匹配。 不允许将 nut 之间互相比较，也不允许将 bolt 之间互相比较。也就是说，只许将 nut 与 bolt 进行比较， 或将 bolt 与 nut 进行比较。请比较 nut 与 bolt 的大小</p><p>样例</p><p>给出 nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;GG&#39;, &#39;DD&#39;, &#39;BC&#39;]</code><br>你的程序应该找出bolts和nuts的匹配。<br>一组可能的返回结果是：<br>nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;BC&#39;,&#39;DD&#39;,&#39;GG&#39;]</code></p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>因为nuts和bolts两个数组在各自的内部不能互相比较，只能在两个数组之间的元素进行比较。所以这就需要利用一个array中的元素对另一个array进行partition，并反过来重复这一个过程，最终让两个array都满足comparator所定义的相同顺序。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * public class NBCompare &#123;</span></div><div class="line"><span class="comment"> *     public int cmp(String a, String b);</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> * You can use compare.cmp(a, b) to compare nuts "a" and bolts "b",</span></div><div class="line"><span class="comment"> * if "a" is bigger than "b", it will return 1, else if they are equal,</span></div><div class="line"><span class="comment"> * it will return 0, else if "a" is smaller than "b", it will return -1.</span></div><div class="line"><span class="comment"> * When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> nuts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> bolts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> compare: a instance of Comparator</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: nothing</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(String[] nuts,String[] bolts,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</div><div class="line">         <span class="comment">//选取bolts中的第一个元素作为pivot，计算在nuts中对应的元素的位置</span></div><div class="line">         <span class="keyword">int</span> nuts_pivotidx = partition(nuts,bolts[start],compare,start,end);</div><div class="line">         <span class="comment">//利用nuts中的pivot对bolts中元素排序</span></div><div class="line">         partition(bolts,nuts[nuts_pivotidx],compare,start,end);</div><div class="line">         <span class="comment">//对picot左边右边分别排序</span></div><div class="line">         quicksort(nuts, bolts, compare, start, nuts_pivotidx - <span class="number">1</span>);</div><div class="line">         quicksort(nuts, bolts, compare, nuts_pivotidx + <span class="number">1</span>, end);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//输入nuts和bolts中的pivot,对nuts排序，返回对应元素的位置</span></div><div class="line">     <span class="comment">//输入bolts和nuts中的pivot,对bolts排序，返回对应元素的位置</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String[] str,String pivot,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="comment">//在另一个数组中找到对应的螺丝或者螺母</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">             <span class="keyword">if</span>(compare.cmp(str[i],pivot) == <span class="number">0</span> || </div><div class="line">             compare.cmp(pivot,str[i]) == <span class="number">0</span>)&#123;</div><div class="line">                 swap(str,i,start);</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//快速排序</span></div><div class="line">         String pivotTemp = str[start];</div><div class="line">         <span class="keyword">int</span> left = start;</div><div class="line">         <span class="keyword">int</span> right = end;</div><div class="line">         <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == -<span class="number">1</span> || </div><div class="line">            compare.cmp(pivot,str[right]) == <span class="number">1</span>))&#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            str[left] = str[right];</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == <span class="number">1</span> || </div><div class="line">            compare.cmp(pivot, str[right]) == -<span class="number">1</span>))&#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            str[right] = str[left];</div><div class="line">        &#125;</div><div class="line">        str[left] = pivotTemp;    </div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//交换元素</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] strings,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">         String temp = strings[i];</div><div class="line">         strings[i] = strings[j];</div><div class="line">         strings[j] = temp;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortNutsAndBolts</span><span class="params">(String[] nuts, String[] bolts, NBComparator compare)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">if</span>(nuts == <span class="keyword">null</span> || bolts == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(nuts.length != bolts.length) <span class="keyword">return</span>;</div><div class="line">        quicksort(nuts,bolts,compare,<span class="number">0</span>,nuts.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="2-窗口类"><a href="#2-窗口类" class="headerlink" title="2.窗口类"></a>2.窗口类</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-21-47-48.png" alt=""> </p><h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p></blockquote><p>返回数组中元素和&gt;=s的最长子数组的长度</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两指针控制滑动窗口类问题，当窗口内元素和&lt;s时右指针向右滑动，更新最大长度</p><p>当窗口内元素和&gt;=s时，左指针向右滑动至&lt;s，无需更新最大长度</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++)&#123;</div><div class="line">            sum += nums[j];</div><div class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</div><div class="line">                minLen = Math.min(minLen,j-i+<span class="number">1</span>);</div><div class="line">                sum -= nums[i];</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE?<span class="number">0</span>:minLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p></blockquote><p>查找字符串中没有重复元素的最长子串</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>记录窗口中出现过哪些字母，当遇到重复字母的时候窗口缩小</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//相当于hashmap</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt; s.length())&#123;</div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)] == <span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)] = <span class="number">1</span>;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//map[s.charAt(j)] == 1</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">while</span>(s.charAt(j) != s.charAt(i))&#123;</div><div class="line">                    map[s.charAt(i)] = <span class="number">0</span>;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring" target="_blank" rel="external">Minimum Window Substring</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<br><strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><br><strong>T</strong> = <code>&quot;ABC&quot;</code></p><p>Minimum window is <code>&quot;BANC&quot;</code>.</p></blockquote><p>返回s中能够包含t的最短子串</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>滑动窗口+hashtable的思想</p><p>首先需要两个hash表，一个存储t中的字母，一个存储s中子串的字母，还需要一个能够判别s中的子串是否能够包含t的函数。</p><p>然后两指针滑动窗口，右指针向右滑动，当滑窗中的子串能够包含t时，窗口缩小，左指针右移，更新最短窗口，直到窗口内子串不足以包含t中全部字母，此时右指针继续向后移动，重复上述过程。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//判断s是否包含t</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(<span class="keyword">int</span>[] mapT,<span class="keyword">int</span>[] mapS)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mapT.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(mapS[i] &lt; mapT[i])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] mapT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span>[] mapS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        StringBuilder minWindow = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : t.toCharArray())&#123;</div><div class="line">            mapT[ch]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++) &#123;</div><div class="line">            mapS[s.charAt(j)]++;</div><div class="line">            <span class="keyword">while</span>(isContain(mapT,mapS))&#123;</div><div class="line">                <span class="keyword">if</span>(minlen &gt; j-i+<span class="number">1</span>)&#123;</div><div class="line">                    minlen = j-i+<span class="number">1</span>;</div><div class="line">                    minWindow = <span class="keyword">new</span> StringBuilder(s.substring(i,j+<span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">                mapS[s.charAt(i)]--;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minWindow.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="Longest Substring with At Most K Distinct Characters"></a><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="external">Longest Substring with At Most K Distinct Characters</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the longest substring T that contains at most <em>k</em> distinct characters.</p><p>For example, Given s = <code>“eceba”</code> and k = 2,</p><p>T is “ece” which its length is 3.</p></blockquote><p>在字符串中找到一个子串，最多包含k个不同的字母，返回满足这样条件的子串的最大长度。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>还是滑窗+hash表</p><p>用hash表存储当前子串中字母，用charNum存储子串中的不同字母个数</p><ol><li>当窗口内字母个数&lt;=k时右指针向右滑动，扩大窗口，更新窗口大小</li><li>当窗口内字母个数&gt;k时，左指针右移，缩小窗口，</li></ol><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> charNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++)&#123;</div><div class="line">            <span class="comment">//之前已经出现过这个字母了</span></div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)]&gt;<span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数&lt;k</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (charNum &lt; k)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数==k</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                <span class="keyword">while</span>(charNum &gt; k)&#123;</div><div class="line">                    <span class="keyword">if</span>(map[s.charAt(i)] == <span class="number">1</span>)&#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                        charNum--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                    &#125;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="两个数组两个指针"><a href="#两个数组两个指针" class="headerlink" title="两个数组两个指针"></a>两个数组两个指针</h2><h3 id="最小差"><a href="#最小差" class="headerlink" title="最小差"></a><a href="http://www.lintcode.com/zh-cn/problem/the-smallest-difference/" target="_blank" rel="external">最小差</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定两个整数数组（第一个是数组 <code>A</code>，第二个是数组 <code>B</code>），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。</p><p>样例</p><p>给定数组 A = <code>[3,4,6,7]</code>， B = <code>[2,3,8,9]</code>，返回 <code>0</code>。</p></blockquote><p>给定两个数组，返回两个数组元素之间的最小差</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>baseline:双层for循环，A中循环一遍B中循环一遍，计算每两个元素之间的差值取最小，时间复杂度：<script type="math/tex">O(n^2)</script></p><p>优化：</p><p>先排序，排序之后遍历A中元素，用二分查找的思路在B中寻找与元素A[i]差值最小的元素，时间复杂度：<script type="math/tex">O(nlogn)</script></p><p>骚操作：</p><p>两指针ij分别指向AB，更新A[i]和B[j]的差值</p><p>当A[i]&lt;B[j]时，i后移，反之j后移</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    Arrays.sort(A);</div><div class="line">    Arrays.sort(B);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</div><div class="line">        min = Math.min(min,Math.abs(A[i]-B[j]));</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; B[j])&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Smallest-Range"><a href="#Smallest-Range" class="headerlink" title="Smallest Range"></a><a href="https://leetcode.com/problems/smallest-range/" target="_blank" rel="external">Smallest Range</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You have <code>k</code> lists of sorted integers in ascending order. Find the <strong>smallest</strong> range that includes at least one number from each of the <code>k</code> lists.</p><p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</div><div class="line">&gt; Output: [20,24]</div><div class="line">&gt; Explanation: </div><div class="line">&gt; List 1: [4, 10, 15, 24,26], 24 is in range [20,24].</div><div class="line">&gt; List 2: [0, 9, 12, 20], 20 is in range [20,24].</div><div class="line">&gt; List 3: [5, 18, 22, 30], 22 is in range [20,24].</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定k个数组，找到最短的区间，该区间需满足包含来自每个数组的至少一个元素</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>k个数组k个指针，k个指针中的最大最小即是当前情况下的区间。</p><p>每次将值最小的指针向后移动，更新当前情况下的区间长度。</p><p>这里就需要找到哪个指针所指的值是最小的了，所以我们需要一个最小堆来维护k个指针中的最小值。</p><p>另外，我们还需要计算k个指针中的最大值，这个最大值用一个变量max维护就可以了，每次入堆的元素都跟当前max比较更新一下就好。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallestRange</span> </span>&#123;</div><div class="line">  <span class="comment">//定义结构Node，存储节所在的数组idx和值</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];<span class="comment">//代表指针指向每一个数组</span></div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; minheap= <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);<span class="comment">//最小堆</span></div><div class="line">        <span class="keyword">int</span> max  = Integer.MIN_VALUE;<span class="comment">//存储当前遇到的最大值</span></div><div class="line">        <span class="keyword">int</span> minRangeLen = Integer.MAX_VALUE;<span class="comment">//存储最小区间的长读</span></div><div class="line">        <span class="keyword">int</span>[] minRange = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//存储最小区间</span></div><div class="line">        <span class="comment">//先把所有list第一个元素先入堆，同时记录最大值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; idx.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> val = nums.get(i).get(idx[i]);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(i,val));</div><div class="line">            max = Math.max(max,val);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//出堆</span></div><div class="line">        <span class="keyword">while</span> (!minheap.isEmpty())&#123;</div><div class="line">            <span class="comment">//取堆顶元素</span></div><div class="line">            Node temp = minheap.poll();</div><div class="line">            <span class="comment">//更新当前最小区间的长度</span></div><div class="line">            <span class="keyword">if</span>(max-temp.val &lt; minRangeLen)&#123;</div><div class="line">                minRangeLen = max-temp.val;</div><div class="line">                minRange[<span class="number">0</span>] = temp.val;</div><div class="line">                minRange[<span class="number">1</span>] = max;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//堆顶元素所在的区间指针后移一位</span></div><div class="line">            idx[temp.idx]++;</div><div class="line">            <span class="comment">//如果对顶元素所在的区间指针溢出了，跳出</span></div><div class="line">            <span class="keyword">if</span>(idx[temp.idx] == nums.get(temp.idx).size())&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//找到下一个值，更新max，入堆</span></div><div class="line">            <span class="keyword">int</span> nextval = nums.get(temp.idx).get(idx[temp.idx]);</div><div class="line">            max = Math.max(max,nextval);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(temp.idx,nextval));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minRange;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Partition-Labels"><a href="#Partition-Labels" class="headerlink" title="Partition Labels"></a><a href="https://leetcode.com/problems/partition-labels/" target="_blank" rel="external">Partition Labels</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">&gt; Output: [9,7,8]</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</div><div class="line">&gt; This is a partition so that each letter appears in at most one part.</div><div class="line">&gt; A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个字符串，要求将字符串分割，保证每个字母只出现在一个子串中，最终返回分割的字符串长度</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">由于每个字母只能出现在一个字符串中，比如第一个字母a，其所在的子串至少要从第一个a到最后一个a。</div><div class="line">S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">     ↑       ↑</div><div class="line">     i       maxRight</div><div class="line">但此时并不一定找到第一个合适的分割点了，因为在这两个a中其他字母，有可能出现在后半段中，所以我们还需要遍历这两个指针中间的字母，确定每一个字母在字符串中出现的最后位置，在这个过程中，前后两个指针的距离可能会变得更远，中间的每一个元素都需要遍历到。所以我们用maxRight来存储当前遍历过的字母的最远位置，则i的遍历区间应该是while (i &lt;= maxright)。</div></pre></td></tr></table></figure><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> maxright = i;<span class="comment">//初始化maxright</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= maxright)&#123;</div><div class="line">            <span class="keyword">char</span> ch = s.charAt(i);</div><div class="line">            <span class="keyword">while</span> (s.charAt(j) != ch)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//找到ch出现的最后一个位置</span></div><div class="line">            maxright = Math.max(maxright,j);<span class="comment">//更新最远距离</span></div><div class="line">            <span class="keyword">if</span>(i == maxright)&#123;<span class="comment">//找到了最后一个，跳出</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            j = end;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//更新结果集，继续分割右边</span></div><div class="line">        result.add(maxright-start+<span class="number">1</span>);</div><div class="line">        partition(s,maxright+<span class="number">1</span>,end);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</div><div class="line">        partition(S,<span class="number">0</span>,S.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;一个数组，从两边往中间移动（对撞型）&lt;/li&gt;
&lt;li&gt;一个数组，同时向前移动（前向型）
      
    
    </summary>
    
    
  </entry>
  
</feed>
