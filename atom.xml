<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-07T05:46:12.044Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【腾讯社交广告算法大赛】贝叶斯平滑</title>
    <link href="http://yoursite.com/2018/03/07/%E3%80%90%E8%85%BE%E8%AE%AF%E7%A4%BE%E4%BA%A4%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E3%80%91%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/"/>
    <id>http://yoursite.com/2018/03/07/【腾讯社交广告算法大赛】贝叶斯平滑/</id>
    <published>2018-03-07T05:46:12.000Z</published>
    <updated>2018-03-07T05:46:12.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;矩估计&quot;&gt;&lt;a href=&quot;#矩估计&quot; class=&quot;headerlink&quot; title=&quot;矩估计&quot;&gt;&lt;/a&gt;矩估计&lt;/h3&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【腾讯转化率预估比赛】总结</title>
    <link href="http://yoursite.com/2018/03/06/%E3%80%90%E8%85%BE%E8%AE%AF%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E3%80%91%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/06/【腾讯转化率预估】比赛总结/</id>
    <published>2018-03-06T05:50:10.000Z</published>
    <updated>2018-03-07T04:11:46.395Z</updated>
    
    <content type="html"><![CDATA[<p>第一届腾讯社交广告算法大赛复赛成绩0.101941，排名26名，在此总结一下。</p><p><a href="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" target="_blank" rel="external"><img src="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" alt="img"></a></p><h1 id="1-题目简介"><a href="#1-题目简介" class="headerlink" title="1. 题目简介"></a>1. 题目简介</h1><h2 id="1-1-移动App广告转化率预估"><a href="#1-1-移动App广告转化率预估" class="headerlink" title="1.1 移动App广告转化率预估"></a>1.1 移动App广告转化率预估</h2><p>详细赛题见<a href="http://algo.tpai.qq.com/home/information/index.html" target="_blank" rel="external">官方网站</a></p><blockquote><p>计算广告是互联网最重要的商业模式之一，广告投放效果通常通过曝光、点击和转化各环节来衡量，大多数广告系统受广告效果数据回流的限制只能通过曝光或点击作为投放效果的衡量标准开展优化。腾讯社交广告(<a href="http://ads.tencent.com/" target="_blank" rel="external">http://ads.tencent.com</a>)发挥特有的用户识别和转化跟踪数据能力，帮助广告主跟踪广告投放后的转化效果，基于广告转化数据训练转化率预估模型(pCVR，Predicted Conversion Rate)，在广告排序中引入pCVR因子优化广告投放效果，提升ROI。</p><p>本题目以移动App广告为研究对象，预测App广告点击后被激活的概率：pCVR=P(conversion=1 | Ad,User,Context)，即给定广告、用户和上下文情况下广告被点击后发生激活的概率。</p></blockquote><p>总结起来就是说，在业界，大多数广告系统是通过点击率来投放广告的，因为转化追踪起来是比较困难的，然而腾讯凭借平台优势很好地追踪了广告投放之后的转化情况，以此训练<strong>转化率预估模型</strong>，用转化率来指导广告投放，进而提升ROI。</p><p><strong>因此赛题就是给我们17-30号两周（15天）的移动APP广告（投放在移动端的APP广告）数据，让我们训练转化率模型做转化率预估，即预测第31号App广告点击后被激活的概率。</strong></p><h2 id="1-2-评估方式："><a href="#1-2-评估方式：" class="headerlink" title="1.2 评估方式："></a>1.2 评估方式：</h2><p>通过Logarithmic Loss评估(越小越好)，公式如下：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-36-51.png" alt=""> </p><p>其中，</p><ul><li>N是测试样本总数</li><li><script type="math/tex">y_i</script>是二值变量，取值为0或1，表示第i个样本的label</li><li><script type="math/tex">p_i</script>是模型预测第i个样本label为1的概率</li></ul><h1 id="2-数据"><a href="#2-数据" class="headerlink" title="2. 数据"></a>2. 数据</h1><h2 id="2-1-数据量"><a href="#2-1-数据量" class="headerlink" title="2.1 数据量"></a>2.1 数据量</h2><p><strong>数据量：初赛30w/天；决赛300w/天</strong></p><h2 id="2-2-数据表"><a href="#2-2-数据表" class="headerlink" title="2.2 数据表"></a>2.2 数据表</h2><p>接下来看看给的数据长啥样。</p><p>一共给了8张表：</p><p>test+train+下面这些：</p><div class="table-container"><table><thead><tr><th>文件类型</th><th>描述</th></tr></thead><tbody><tr><td>用户基础特征文件(<em>user.csv</em>)</td><td>每行代表一个用户，各字段之间由逗号分隔，顺序依次为：“userID，age，gender，education，marriageStatus，haveBaby，hometown，residence”。</td></tr><tr><td>用户App安装列表文件(<em>user_installedapps.csv</em>)</td><td>每行代表一个用户安装的单个App，各字段之间由逗号分隔，顺序依次为：“userID，appID”。特别的，我们提供了截止到第1天0点用户全部的App安装列表。</td></tr><tr><td>用户App安装流水文件(<em>user_app_actions.csv</em>)</td><td>每行代表一个用户的单个App操作流水，各字段之间由逗号分隔，顺序依次为：“userID，installTime，appID”。特别的，我们提供了训练数据开始时间之前16天开始连续30天的操作流水，即第1天0点到第31天0点。</td></tr><tr><td>App特征文件(<em>app_categories.csv</em>)</td><td>每行代表一个App，各字段之间由逗号分隔，顺序依次为：“appID，appCategory”。</td></tr><tr><td>广告特征文件(<em>ad.csv</em>)</td><td>每行描述一条广告素材，各字段之间由逗号分隔，顺序依次为“creativeID，adID，camgaignID，advertiserID，appID，appPlatform”。</td></tr><tr><td>广告位特征文件(<em>position.csv</em>)</td><td>每行描述一个广告位，各字段之间由逗号分隔，顺序依次为：“positionID，sitesetID，positionType”。</td></tr></tbody></table></div><p><code>train.csv</code> 训练数据集 ：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-30-00.png" alt=""> </p><p>17到30号共14天点击数据。</p><p>每一条训练样本即为一条广告<strong>点击日志</strong>(点击时间用clickTime表示)，样本label取值0或1，其中0表示点击后没有发生转化，1表示点击后有发生转化，如果label为1，还会提供转化回流时间。</p><p>每一条数据其中label表示是否转化，经统计<strong>转化率大概1/40</strong></p><p>数据量：初赛30w/天；决赛300w/天</p><p><code>test.csv</code> 线上测试数据</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-14-30-28.png" alt=""> </p><p>31号一天数据，字段和test一致，需要预测lable</p><p><code>ad.csv</code> 广告基本特征</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-30-44.png" alt="">     <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-26-24.png" alt=""> </p><p>这里广告结构分为四级：广告主——推广计划——广告——素材。<strong>之后会用到这个层级结构做贝叶斯平滑。</strong></p><p><code>user.csv</code> 用户信息表</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-31-49.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-05.png" alt=""> </p><p>就是用户的一些基本特征啦，性别年龄blabla</p><p><code>app_category.csv</code> appID对应的类别信息</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-32-49.png" alt="">                      <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-21.png" alt=""> </p><p>就是appID和对应的categoryID，其中类目标签有两层，使用3位数字编码，百位数表示一级类目，十位个位数表示二级类目，如“210”表示一级类目编号为2，二级类目编号为10，类目未知或者无法获取时，标记为0。</p><p><code>position.csv</code> 广告位信息</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-33-15.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-28-46.png" alt=""> </p><p>没啥说的，就是广告位信息，直接merge就行</p><p><code>user_app_actions.csv</code> 用户安装app流水，1——30天的，包含安装时间</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-34-00.png" alt="">        <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-29-01.png" alt=""> </p><p>用户近期的app安装行为，这里可以挖掘出用户的偏好类别，时间等等。。。</p><p><code>user_installedapps.csv</code>用户历史安装过的app，第一天0点之前的</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-34-31.png" alt="">         <img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-15-30-00.png" alt=""> </p><p>用户自注册以来安装过的appID，有待挖掘。。。</p><h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>总结一下，一共有三类特征，用户特征、广告特征、上下文特征，官网也给了个很好的总结表：</p><div class="table-container"><table><thead><tr><th>特征</th><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>广告特征</td><td>账户ID(<em>advertiserID</em>)</td><td>腾讯社交广告的账户结构分为四级：账户——推广计划——广告——素材，账户对应一家特定的广告主。</td></tr><tr><td></td><td>推广计划ID(<em>campaignID</em>)</td><td>推广计划是广告的集合，类似电脑文件夹功能。广告主可以将推广平台、预算限额、是否匀速投放等条件相同的广告放在同一个推广计划中，方便管理。</td></tr><tr><td></td><td>广告ID(<em>adID</em>)</td><td>腾讯社交广告管理平台中的广告是指广告主创建的广告创意(或称广告素材)及广告展示相关设置，包含广告的基本信息(广告名称，投放时间等)，广告的推广目标，投放平台，投放的广告规格，所投放的广告创意，广告的受众(即广告的定向设置)，广告出价等信息。单个推广计划下的广告数不设上限。</td></tr><tr><td></td><td>素材ID(<em>creativeID</em>)</td><td>展示给用户直接看到的广告内容，一条广告下可以有多组素材。</td></tr><tr><td></td><td>AppID(<em>appID</em>)</td><td>广告推广的目标页面链接地址，即点击后想要展示给用户的页面，此处页面特指具体的App。多个推广计划或广告可以同时推广同一个App。</td></tr><tr><td></td><td>App分类(<em>appCategory</em>)</td><td>App开发者设定的App类目标签，类目标签有两层，使用3位数字编码，百位数表示一级类目，十位个位数表示二级类目，如“210”表示一级类目编号为2，二级类目编号为10，类目未知或者无法获取时，标记为0。</td></tr><tr><td></td><td>App平台(<em>appPlatform</em>)</td><td>App所属操作系统平台，取值为Android，iOS，未知。同一个appID只会属于一个平台。</td></tr><tr><td>用户特征</td><td>用户ID(<em>userID</em>)</td><td>唯一标识一个用户</td></tr><tr><td></td><td>年龄(<em>age</em>)</td><td>取值范围[0, 80]，其中0表示未知。</td></tr><tr><td></td><td>性别(<em>gender</em>)</td><td>取值包括男，女，未知。</td></tr><tr><td></td><td>学历(<em>education</em>)</td><td>用户当前最高学历，不区分在读生和毕业生，取值包括小学，初中，高中，专科，本科，硕士，博士，未知</td></tr><tr><td></td><td>婚恋状态(<em>marriageStatus</em>)</td><td>用户当前感情状况，取值包括单身，新婚，已婚，未知。</td></tr><tr><td></td><td>育儿状态(<em>haveBaby</em>)</td><td>用户当前孕育宝宝状态，取值包括孕育中，宝宝0~6个月，宝宝6~12个月，宝宝1~2岁，宝宝2~3岁，育儿但宝宝年龄未知，未知。</td></tr><tr><td></td><td>家乡/籍贯(<em>hometown</em>)</td><td>用户出生地，取值具体到市级城市，使用二级编码，千位百位数表示省份，十位个位数表示省内城市，如1806表示省份编号为18，城市编号是省内的6号，编号0表示未知。</td></tr><tr><td></td><td>常住地(<em>residence</em>)</td><td>最近一段时间用户长期居住的地方，取值具体到市级城市，编码方式与家乡相同。</td></tr><tr><td></td><td>App安装列表(<em>appInstallList</em>)</td><td>截止到某一时间点用户全部的App安装列表(appID)，已过滤高频和低频App。</td></tr><tr><td></td><td>App安装流水</td><td>最近一段时间内用户安装App行为流水，包括appID，行为发生时间(installTime)和app类别(appCategory)，已过滤高频和低频App。</td></tr><tr><td></td><td>注：2~8基于用户个人注册资料和算法自动修正得到，9~10基于用户行为日志统计得到。</td><td></td></tr><tr><td>上下文特征</td><td>广告位ID(<em>positionID</em>)</td><td>广告曝光的具体位置，如QQ空间Feeds广告位。</td></tr><tr><td></td><td>站点集合ID(<em>sitesetID</em>)</td><td>多个广告位的聚合，如QQ空间</td></tr><tr><td></td><td>广告位类型(<em>positionType</em>)</td><td>对于某些站点，人工定义的一套广告位规格分类，如Banner广告位。</td></tr><tr><td></td><td>联网方式(<em>connectionType</em>)</td><td>移动设备当前使用的联网方式，取值包括2G，3G，4G，WIFI，未知</td></tr><tr><td></td><td>运营商(<em>telecomsOperator</em>)</td><td>移动设备当前使用的运营商，取值包括中国移动，中国联通，中国电信，未知</td></tr></tbody></table></div><p>接下来的任务就是从这些给的数据里面挖掘有用的信息去训练模型预测转化率啦。</p><h1 id="3-主要流程"><a href="#3-主要流程" class="headerlink" title="3. 主要流程"></a>3. 主要流程</h1><p>这是Kaggle上数据挖掘比赛的黄金流程图：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" alt="img"></a></p><p>我们也是采用这个流程来做的~</p><h1 id="4-数据分析-amp-清洗"><a href="#4-数据分析-amp-清洗" class="headerlink" title="4. 数据分析&amp;清洗"></a>4. 数据分析&amp;清洗</h1><h2 id="4-1-数据分析"><a href="#4-1-数据分析" class="headerlink" title="4.1 数据分析"></a>4.1 数据分析</h2><p>拿到数据第一件事就是要好好分析数据！！！不仅一开始要分析，训练完也要根据结果分析，所以数据分析是要贯穿整个流程的，只有通过不断的分析统计，才能挖掘到数据背后的价值啊~</p><p>上面介绍数据表的时候已经有了一部分简单粗暴的分析了，实际上拿到赛题的时候进行的数据统计和分析远比上面的多，比如还统计了广告主上传回流时间的分布，上传回流时间在5,4,3,2,1天内的百分比，用户转化时间段分布各维度转化率情况（比如各广告主、广告计划、性别、年龄、app的转化率等等)…….</p><p>这些都是数据清洗和特征工程的依据。</p><h2 id="4-2-数据清洗"><a href="#4-2-数据清洗" class="headerlink" title="4.2 数据清洗"></a>4.2 数据清洗</h2><p>按天对训练集<code>train.csv</code>转化率进行了统计</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-16-37-49.png" alt=""> </p><p>其中19号可能由于节日等原因导致转化率有点高，但是考虑到如果去掉这一天的数据就会丢失大一部分信息所以最终没有去掉。</p><p>而由于回流时间的存在，最后四天的数据会不准确，也就是说后五天的数据中有一部分实际上是转化了的，但广告主还没有来得及将这条转化汇报给广告系统，导致数据集中的label被误标记为了0（实际上是1）</p><p>这里我们尝试了两种方法：</p><ol><li>根据经验猜测回流数据是广告主网站反馈回来的，所以我们计算了各广告主在最后五天内的最后一次回流反馈时间，将各广告主最后一次回流返回时间之后的数据删除掉这样就在一定程度上减少了不准确的负样本。这样筛去了大概有3万条。这样的做法带来的问题是有一些真正的负样本也被去除掉了。</li><li>由于最后两天数据的问题比较大，所以干脆直接把最后两天的数据删掉，不用这两天的数据训练模型，这样带来的问题是有一些在这两天新上线的广告就没有得到充分的训练。</li></ol><h1 id="5-特征工程"><a href="#5-特征工程" class="headerlink" title="5. 特征工程"></a>5. 特征工程</h1><p>一开始的时候我们采用了很多基本特征，即各种基础的category型特征（AppID, UserID, creativeID, pisitionID等）的onehot编码，又对单特征进行了一定的统计，比如某广告的转化率，某种联网方式的转化率等。后来看了大神“为情所困的少年”的分享，才反应过来其实无论是onehot还是对ID单维度的统计特征，其实都是对于一个特征的一种表达，从一定意义上是重复的。我个人感觉onehot之后的稀疏特征更适合于线性模型，如LR；而统计量的连续特征更适合于树模型，如GBDT。</p><p>回头来看，其实特征工程需要根据模型预先选择方向。李沐说过，模型是使用离散特征还是连续特征，其实是一个“海量离散特征+简单模型” 同 “少量连续特征+复杂模型”的权衡。既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是折腾模型了。通常来说，前者容易，而且可以n个人一起并行做，有成功经验；后者目前看很赞，能走多远还须拭目以待。</p><p>后来这两种思路在初赛和决赛中我们的都尝试了：</p><h2 id="5-1-海量离散特征-简单模型"><a href="#5-1-海量离散特征-简单模型" class="headerlink" title="5.1 海量离散特征+简单模型"></a>5.1 海量离散特征+简单模型</h2><p>在初赛的开始阶段，我们将各种基础的category型特征进行onehot编码，然后构造了一些单维度的统计特征，比如某广告的转化率，某种联网方式的转化率等，然后构造了一些组合特征，将这些特征onehot之后输入了LR模型就开始训练和预测了。</p><p>对于LR这种线性模型来说，它更适合于onehot类型的特征，首先它对于稀疏高维特征处理是无压力的，其次离散化后的特征对异常数据有很强的鲁棒性，这些在参考文献2<a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a>中可以看到。</p><p>对于一些onehot之后维度很大的特征，我们通过统计，取高频的一部分，舍弃低频的一部分，进行onehot。但随着构造特征的增多，onehot之后的向量维度剧增，这时就会带来维度灾难问题，见参考文献4<a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a>。不仅如此，这时基本上也就被设备问题限制死了。</p><p>这很烦。于是我们就换模型了。</p><h2 id="5-2-少量连续特征-复杂模型"><a href="#5-2-少量连续特征-复杂模型" class="headerlink" title="5.2 少量连续特征+复杂模型"></a>5.2 少量连续特征+复杂模型</h2><p>既然要预测的是转化率，我们不如把特征转化为<strong>转化率特征</strong>，这样特征就变成了连续值，同时我们还抽取了一些<strong>统计特征</strong>，比如某广告在一天之内、n天之内的<strong>点击量，转化量</strong>，某用户历史安装次数、APP历史被安装次数，等等，然后输入树模型中训练。感谢“为情所困”大神的分享，树模型比LR快了不少。</p><h2 id="5-3-组合特征构造"><a href="#5-3-组合特征构造" class="headerlink" title="5.3 组合特征构造"></a>5.3 组合特征构造</h2><p>说到特征组合，从统计的角度解释，基本特征仅仅是真实特征分布在低维空间的映射，不足以描述真实分布，加入组合特征是为了在更高维空间拟合真实分布，使得预测更准确。<br>在初赛和决赛阶段，我们共使用过两种组合特征的表达：</p><p><strong>1. 对离散ID进行hash生成新特征</strong></p><p>在初期用LR的时候，我们采用的方式是hash。即对两个ID做hash运算，得到一个新特征。这是一个很巧妙的方法。例如下面这个表，我们做哈希：</p><p>age×10+gendarage×10+gendar</p><p>得到第三列：</p><div class="table-container"><table><thead><tr><th>age</th><th>gendar</th><th>hash</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>10</td></tr><tr><td>2</td><td>1</td><td>21</td></tr><tr><td>3</td><td>2</td><td>32</td></tr></tbody></table></div><p>第三列的的特征的取值有两位，十位是age,个位是gendar。新特征是一种新的交叉特征的体现。</p><p><strong>2. 对组合进行统计生成新特征</strong></p><p>像之前“为情所困”大神说过的那样，其实无论onehot还是统计特征，其实都是对于一个特征的一种表达。因为后期我们采用了GBDT，因此我们弃用了之前的hash组合方式，而选用统计量（即点击量、转化量和转化率）。这样就在一个维度上表达了这两个特征的组合，而且非常便于计算。</p><p>实现：按字段groupby，获取统计量和转化率特征</p><h2 id="5-4-特征选择"><a href="#5-4-特征选择" class="headerlink" title="5.4 特征选择"></a>5.4 特征选择</h2><p>我们用到了两种特征选择的方法：</p><ol><li>根据方差：方差很小的属性，意味着该属性的识别能力很差。极端情况下，方差为0，意味着该属性在所有样本上都是一个值，所以我们尽量选那些方差比较大，区分度比较好的特征。</li><li>根据模型评分+相关系数矩阵：用GBDT训练会得到一个特征打分，可以作为筛选特征的依据，与此同时，我们发现，有一些特征之间有很强的相互作用，比如加入了某个特征之后会使之前排名很靠前的特征下降，因此我们还计算了特征之间的相关系数，对于相关系数较大的特征，我们就多次试验，反复选择</li></ol><p>特征之间的相关系数：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-21-58-07.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-21-49-00.png" alt=""> </p><p>另外，“酱紫”学长对特征筛选还有一种建议就是直接对所有基本特征进行遍历两两组合，然后用卡方检验筛出来一些比较好的特征。这种方式很简单，大多数工作只需要交给模型来完成。<strong>日后学习一下</strong></p><h2 id="5-5-用户-APP特征挖掘"><a href="#5-5-用户-APP特征挖掘" class="headerlink" title="5.5 用户-APP特征挖掘"></a>5.5 用户-APP特征挖掘</h2><p>特征说到这里，还有两个表没有充分利用上，<code>user_app_actions.csv</code> 和</p><p><code>user_installedapps.csv</code> </p><p><code>user_app_actions.csv</code> ：用户安装app流水，1——30天的，包含安装时间，既然包含安装时间，就可以提取出用户的偏好安装时间、类别、app的偏好安装时间、安装量等特征</p><p><code>user_installedapps.csv</code> 用户历史安装app</p><p>两个表都有用户和APP的安装信息，所以是否可以提取出用户和app之间的一些联系呢。思考一个问题，如果用户已经点击了某个APP的广告，那么是否会转化（下载）取决于什么呢？除了一些客观的因素，比如广告位（是否误点），联网方式等，当然是用户到底感不感兴趣！需不需要！</p><p>想到这里就感觉是个推荐系统方面的问题了，所以我们查了一些资料，尝试了用三种方式表达用户和app之间的联系：</p><ol><li><p>tf-idf向量特征</p><ol><li>把用户看成文档，app、app所属的类别看成词</li><li>把app、app所属的类别看成文档，用户看成词</li></ol><p>没什么提高</p></li><li><p>word-embedding特征</p><p><code>user_app_actions.csv</code> 中包含用户的近期下载的app，根据时间可以得到app下载的顺序。</p><p>把word2vec应用在用户app下载序列上，根据用户下载app的顺序，把app看做单词，也是可以形成这样的序列数据，进而训练处每个app对应的向量，看作是app的一个特征。</p></li><li><p>SVD分解</p><p><code>user_installedapps.csv</code> 表中没有时间信息，也就不合适用word2vec来提取特征了，我们想到了用推荐系统中的常用套路：SVD分解</p><p>关于SVD知识的补充日后可以看下面两篇文章：</p><p><a href="http://blog.csdn.net/zhongkejingwang/article/details/43053513" target="_blank" rel="external">奇异值分解SVD原理详解及推导</a></p><p><a href="http://blog.csdn.net/zhongkejingwang/article/details/43083603" target="_blank" rel="external">SVD在推荐系统中的应用详解以及算法推导</a></p></li></ol><h2 id="5-6-贝叶斯平滑"><a href="#5-6-贝叶斯平滑" class="headerlink" title="5.6 贝叶斯平滑"></a>5.6 贝叶斯平滑</h2><p>这里我们参考了@<a href="https://cloud.tencent.com/developer/user/598572" target="_blank" rel="external">王照彬</a> 大神的平滑方式</p><p> 例如对我们数据中存在的 root -&gt; advertiser -&gt; campaign -&gt; ad -&gt; creative 层级关系(root为训练集中全部样本), 这样的层级关系隐喻了在同一个父节点下的子节点, 其来自于同一个Beta分布, 所以我逐层进行了贝叶斯平滑, 且建立层级关系还有一个好处, 即对预测集出现的数据, 若该creativeID 在训练集从未出现过, 则在pandas.merge时该值为空, 则向上寻找其父节点的统计值, 最高一层为root, 是基与全部训练数据的统计, root的值不进行贝叶斯平滑, 且一定存在, 这就保证了当在预测集中遇到了未出现的样本时, 使用最合理的缺省值进行补全.</p><p><img src="https://blog-10039692.file.myqcloud.com/1496913643639_4485_1496913644532.png" alt="img"></p><p>关于贝叶斯平滑，有待补习，参考文章：</p><p><a href="http://blog.csdn.net/jinping_shi/article/details/78334362" target="_blank" rel="external">转化率（CTR）预测的贝叶斯平滑</a></p><p><a href="https://zhuanlan.zhihu.com/p/21724759" target="_blank" rel="external">计算广告的训练与平滑思想（下）</a></p><h2 id="5-7-多线程抽取特征"><a href="#5-7-多线程抽取特征" class="headerlink" title="5.7 多线程抽取特征"></a>5.7 多线程抽取特征</h2><p>决赛数据集太大，而我们组合特征非常多。因此我们采用了多线程抽特征的方式。</p><p>每个特征一个进程，同时对多个特征进行抽取。</p><p>代码见<a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a>，extra_rate_thread_0623.py</p><h2 id="5-8-总结"><a href="#5-8-总结" class="headerlink" title="5.8 总结"></a>5.8 总结</h2><p><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a>总结得非常好，我们的特征主要分为以下几类：</p><ul><li><p>Trick特征：</p><ol><li><p><strong>重复点击的数据条目</strong>：通过观察原始数据是不难发现的,有很多只有clickTime和label不一样的重复数据，按时间排序发现重复数据如果转化，label一般标在头或尾，少部分在中间，在训练集上出现的情况在测试集上也会出现，所以把重复点击数据中的第一条和最后一条标记出来，让模型去学习。后来进一步标注，非重复数据0，重复但不是第一条和最后一条1，重复且是第一条2，最后一条3。这里面包含用户的重复点击、creativeID的重复点击等</p></li><li><p>时间差特征：与重复第一条的时间差和重复最后一条的时间差特征，与前一条和后一条的时间差，甚至包括了重复组合特征的时间差特征</p></li><li><p>rank特征：重复数据的rank特征，同样包括重复的用户、广告等</p><p>这里实现方面用到了pandas的 <code>shift()</code>操作，非常酷炫</p></li></ol></li></ul><ul><li><p>统计特征（单维+组合）：<br>原始特征主要三大类：广告特征、用户特征、位置特征，通过交叉组合算统计构造特征，由于机器限制，统计特征主要使用了转化率，部分特征还统计了点击次数和转化次数。前面已经说过，就不详细列举。</p></li><li><p>用户app行为挖掘特征：</p><p>word-embedding特征、SVD特征</p></li></ul><h1 id="6-训练集-测试集构造"><a href="#6-训练集-测试集构造" class="headerlink" title="6. 训练集/测试集构造"></a>6. 训练集/测试集构造</h1><p>尝试过两种方法：</p><ol><li><p><strong>滑动窗口</strong></p><p>用每天的前七天的统计（统计指统计转化量、点击量、转化率，下同）来作为本天的特征。</p><p>这样就得到了24-30号7天的特征数据，再加上31号的特征，然后用24-29做训练，得到模型，30号作为线下验证集合，验证模型的线下loss，然后将31号的特征输入到该模型，得到最终的线上预测结果，提交。</p><p>​<br>如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" alt="img"></a><br>经测试我们发现，即使我们去掉了30号的部分负样本，还是有一些问题的，30号的数据还是不够好，线上线下会不一致，因此我们改用28号做验证：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" alt="img"></a><br>这样做出于两种目的：一是尽量做到了线上线下统一，二是不让模型学习30号的样本数据，防止一些错误样本被模型学到。</p></li><li><p>用第一周统计，第二周做交叉验证并训练模型。如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" alt="img"></a></p></li></ol><p>相信很多人都用的是这两种其中的一种。我是一个对自己极度不自信的人，来来回回换了好几次。最终觉得第2种方式很稳定，线上线下较统一。第1种方式特征更新较快，模型更准确，但带来的问题就是线上线下不太统一。</p><h1 id="7-模型训练和验证"><a href="#7-模型训练和验证" class="headerlink" title="7. 模型训练和验证"></a>7. 模型训练和验证</h1><p>操作系统：ubuntu14.04</p><p>机器内存：256G</p><p>语言：python</p><p>用到的模型：</p><ul><li><p>LR：L1\L2</p></li><li><p>gbdt：xgboost,lightGBM</p></li><li><p>gbdt+lr</p></li><li><p>特征离散化+ffm：</p><p>​    可以参考我的两篇文章</p><p>​    <a href="https://siyaozhang.github.io/2017/03/14/Factorization-Machine%EF%BC%88FM%EF%BC%8C%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%89/" target="_blank" rel="external">Factorization Machine（<strong>FM</strong>，因子分解机）</a></p><p>​    <a href="https://siyaozhang.github.io/2017/03/22/FFM%EF%BC%88field-aware-Factorization-Machine%EF%BC%89%E2%80%94%E2%80%94%E5%8D%87%E7%BA%A7%E7%89%88FM/" target="_blank" rel="external">F<strong>FM</strong>（field-aware Factorization Machine）——升级版<strong>FM</strong></a></p></li></ul><h1 id="8-改进方向"><a href="#8-改进方向" class="headerlink" title="8. 改进方向"></a>8. 改进方向</h1><p>回流数据方面</p><p>卡方检验</p><h1 id="9-项目代码"><a href="#9-项目代码" class="headerlink" title="9. 项目代码"></a>9. 项目代码</h1><p><a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a></p><h1 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10. 参考资料"></a>10. 参考资料</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/26820998" target="_blank" rel="external">Kaggle 数据挖掘比赛经验分享</a></li><li><a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a></li><li><a href="http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html" target="_blank" rel="external">特征哈希（Feature Hashing）</a></li><li><a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a></li><li><a href="http://blog.jasonding.top/2015/11/12/Feature%20Engineering/%E3%80%90%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E3%80%91%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">【特征工程】特征选择与特征学习</a></li><li><a href="http://202.197.191.206:8080/30/text/chapter04/4_8.htm" target="_blank" rel="external">描述量选择及特征的组合优化</a></li><li><a href="http://www.jianshu.com/p/8f6f94f1d275" target="_blank" rel="external">scikit-learn系列之特征选择</a></li><li><a href="http://blog.csdn.net/shine19930820/article/details/71713680" target="_blank" rel="external">GBDT原理及利用GBDT构造新的特征-Python实现</a></li><li><a href="http://www.bigbear2017.com/blog/2016/11/02/facebook-ctr-paper/" target="_blank" rel="external">很好的文献资料Facebook CTR Paper</a></li><li><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a></li><li><a href="https://www.qcloud.com/community/article/895055" target="_blank" rel="external">【SPA大赛】腾讯广告点击大赛：对stacking的一些基本介绍</a></li><li><a href="http://blog.csdn.net/ben3ben/article/details/74838338" target="_blank" rel="external">第七名</a></li></ol><h1 id="11-top3方案"><a href="#11-top3方案" class="headerlink" title="11. top3方案"></a>11. top3方案</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一届腾讯社交广告算法大赛复赛成绩0.101941，排名26名，在此总结一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】一致性哈希&amp;短网址系统设计</title>
    <link href="http://yoursite.com/2018/03/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C-%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/03/05/【九章系统设计】一致性哈希-短网址系统设计/</id>
    <published>2018-03-05T07:20:56.000Z</published>
    <updated>2018-03-06T02:41:49.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-16-18-40.png" alt=""> </p><h1 id="consistent-hashing-一致性哈性"><a href="#consistent-hashing-一致性哈性" class="headerlink" title="consistent hashing 一致性哈性"></a>consistent hashing 一致性哈性</h1><h2 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h2><p>数据量过大，需要将数据拆分，有两种拆分方式：</p><ol><li>纵向：不同表存在不同机器，按常用字段和不常用字段将表拆分存在不同机器</li><li>横向：将数据横向切分，存在不同的机器上</li></ol><h2 id="为什么要做一致性hash？"><a href="#为什么要做一致性hash？" class="headerlink" title="为什么要做一致性hash？"></a>为什么要做一致性hash？</h2><ul><li>一种简单的hash算法：将数据存在第%n个机器上</li><li>当增加一台机器时（n -&gt; n+1），需要迁移的数据量非常大</li><li>因此这个hash算法称为<strong>不一致hash</strong></li></ul><h2 id="一个简单的一致性hash算法："><a href="#一个简单的一致性hash算法：" class="headerlink" title="一个简单的一致性hash算法："></a>一个简单的一致性hash算法：</h2><ul><li><p>将key模一个很大的数，比如360</p></li><li><p>将360分配给n台机器，每个机器负责一段区间</p></li><li><p>区间分配信息记录在一张表上，存在web server上</p></li><li><p>新加一台机器的时候，在表中选择一个位置插入，匀走<strong>相邻</strong>两台机器的一部分数据</p></li><li><p>比如n从3变化到4：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-17-24-32.png" alt=""> </p></li></ul><p>缺陷：</p><ol><li>数据分布不均匀：分摊数据后，各机器数据分布不均匀</li><li>迁移压力大：新机器只能从与之相邻的两台机器上迁移数据，导致这两台老机器负载过大</li></ol><h2 id="一个更实用的一致性hashing"><a href="#一个更实用的一致性hashing" class="headerlink" title="一个更实用的一致性hashing"></a>一个更实用的一致性hashing</h2><p>将机器（IP或者名字）与数据，都看做环上的一个点！！</p><ol><li>将机器映射到环上，如下图所示的ABCD是四个机器<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-39-02.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-39-02.png" alt="img"></a></li><li>比如有个数据，蓝色的点，散在了蓝色点出。那么就顺时针去找一个机器，把这个数据放在这个机器上，即B<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-40-32.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-40-32.png" alt="img"></a></li><li>那么如何让点更均匀呢？<br>四个点可能不会均匀，但是4000个点相对来说一定会更均匀。那就引入Micro shards / Virtual nodes 的概念——一台机器对应了1000个代表。例如将A机器撒在环上（下图红色），将B机器撒在环上（下图蓝色）<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-42-51.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-42-51.png" alt="img"></a><br>来了一个数据时， 例如图中的黑色点Data，那么就找到了机器B<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-44-31.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-44-31.png" alt="img"></a></li><li>也就是意味着，每个机器负责了很多个离散的区间。</li><li>当需要加入一台新机器时？加入我们现在机器分布是这样：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-51-51.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-51-51.png" alt="img"></a><br>新来了一个E的机器，丢到环里之后<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-52-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-01-22-52-19.png" alt="img"></a><br>[D,E]之间的数据必须从A迁移到E上！！！！[A,E]之间的数据必须从B迁移到E上</li></ol><p>总结：</p><ul><li><p>将整个hash区间看成一个环，大小从359变成<script type="math/tex">2^{64}-1</script></p></li><li><p>将机器和数据都看成是环上的点</p></li><li><p>引入Micro shards/Virtual nodes的概念，每台机器对应1000个Micro shards/Virtual nodes</p></li><li><p>把每台机器看成1000台机器均匀撒在环上</p></li><li><p>每加入一条数据</p><ul><li>计算其id对应的hash值，得到0~<script type="math/tex">2^{64}-1</script> 区间上的一个点，找到环上对应的点</li><li>从这个点出发顺时针找到第一个机器的virtual node</li><li>该virtual node对应的机器就是本条数据应该存储的数据库服务器</li></ul></li><li><p>每加入一台新机器</p><ul><li>在环上随机撒1000个点</li><li>这1000个virtual node 各自想顺时针相邻的第一个virtual node 索要数据</li><li>例子：<a href="http://www.jiuzhang.com/qa/2067/" target="_blank" rel="external">http://www.jiuzhang.com/qa/2067/</a></li></ul></li><li><p>实现用TreeMap 红黑树</p><p>​</p></li></ul><p>问题：</p><p>问题1：需要存储数据在环的哪里吗？<br>不需要。因为这个数据在哪里与其它数据在哪里没有关系。只需要在环上计算数据所在的点的下一个位置的机器是哪个即可。</p><p>问题：那这个1000能变成100万吗？<br>太多也不行。查询效率会变低。就是在比较均匀的情况下选一个比较快的就行。</p><p>思考：哪种数据结构能够支持这种“顺时针”寻找下一个机器的功能呢？——链表是不行的，因为链表长度太大，查找很慢。用TreeMap!! 就是一个红黑树，能在LogN的时间内寻找比n大的最小值。</p><h1 id="数据备份-Replica"><a href="#数据备份-Replica" class="headerlink" title="数据备份 Replica"></a>数据备份 Replica</h1><h2 id="问题：Backup和Replica有什么区别？"><a href="#问题：Backup和Replica有什么区别？" class="headerlink" title="问题：Backup和Replica有什么区别？"></a>问题：Backup和Replica有什么区别？</h2><p>Backup</p><ul><li>一般是周期性的，比如每天晚上进行一次备份</li><li>当数据丢失的时候，通常只能恢复到之前的某个时间点</li><li>Backup 的数据是死数据，是离线的。不用作在线的数据服务，不分摊读</li></ul><p>Replica</p><ul><li>是实时的， 在数据写入的时候，就会以复制品的形式存为多份</li><li>当数据丢失的时候，可以马上通过其他的复制品恢复</li><li>Replica是实时的。 用作在线的数据服务，分摊读</li></ul><p>思考：既然 Replica 更牛，那么还需要 Backup么？</p><p>backup便宜哇~</p><h2 id="MySQL类型数据库的Replica"><a href="#MySQL类型数据库的Replica" class="headerlink" title="MySQL类型数据库的Replica"></a>MySQL类型数据库的Replica</h2><p>以MySQL为代表的的SQL型数据库，通常自带Master Slave模式的Replica方法。Master负责写，Slave负责读。Slave从Master中同步对数据的操作。</p><p><strong>Master - slave原理</strong>：Write Ahead Log</p><p>SQL数据库的任何操作，都会以Log的形式做一份记录。</p><p>比如Master上的数据A在B时刻从C改成了D，那么Master会通知Slave来读Log（不是同步值，而是同步操作！）。Slave被激活后，告诉master我可以更新了，之后Master有任何操作就会通知slave来读log然后slave会同步操作</p><p>因此Slave上的数据是有延迟的。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-24-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-24-44.png" alt="img"></a></p><p>问题：万一Master挂了怎么办？</p><ul><li>将一台slave升级为master, 接受读 + 写</li><li>可能会造成一定程度的数据丢失和不一致</li></ul><h2 id="NoSQL类型数据库的Replica"><a href="#NoSQL类型数据库的Replica" class="headerlink" title="NoSQL类型数据库的Replica"></a>NoSQL类型数据库的Replica</h2><p>以Cassandra为代表的的NoSQL数据库，通常将数据“顺时针”存储在Consistent hashing环上的三个vitual nodes中。</p><h2 id="MySQL和NoSQL型数据库的Replica比较"><a href="#MySQL和NoSQL型数据库的Replica比较" class="headerlink" title="MySQL和NoSQL型数据库的Replica比较"></a>MySQL和NoSQL型数据库的Replica比较</h2><p><strong>SQL</strong></p><ul><li>“自带” 的 Replica 方式是 Master Slave</li><li>“手动” 的 Replica 方式也可以在 Consistent Hashing 环上顺时针存三份</li></ul><p><strong>NoSQL</strong></p><ul><li>“自带” 的 Replica 方式就是 Consistent Hashing 环上顺时针存三份</li><li>“手动” 的 Replica 方式：就不需要手动了，NoSQL就是在 Sharding 和 Replica 上帮你偷懒用的！</li></ul><h1 id="设计短网址系统-Design-Tiny-URL"><a href="#设计短网址系统-Design-Tiny-URL" class="headerlink" title="设计短网址系统 Design Tiny URL"></a>设计短网址系统 Design Tiny URL</h1><p>短网址生成网站：</p><p><a href="https://bitly.com/" target="_blank" rel="external">https://bitly.com/</a><br><a href="https://goo.gl/" target="_blank" rel="external">https://goo.gl/</a></p><h2 id="系统设计的常见误区："><a href="#系统设计的常见误区：" class="headerlink" title="系统设计的常见误区："></a>系统设计的常见误区：</h2><p><strong>以下几个是误区</strong></p><ul><li>系统一定巨大无比 —— ×</li><li>必须用NoSQL —— ×</li><li>必须是分布式 —— ×</li></ul><p>不可以扔关键词，必须一步步分析。</p><p><strong>正确打开方式——4S分析法</strong></p><ol><li>提问：分析功能/需求/QPS/存储容量——Scenario</li><li>画图：根据分析结果设计“可行解”—— Service+Storage</li><li>进化：研究可能遇到的问题，优化系统 —— Scale</li></ol><h2 id="1-Scenario-场景-需求分析"><a href="#1-Scenario-场景-需求分析" class="headerlink" title="1. Scenario 场景 需求分析"></a>1. Scenario 场景 需求分析</h2><h4 id="我要设计啥"><a href="#我要设计啥" class="headerlink" title="我要设计啥"></a>我要设计啥</h4><ul><li>根据长URL生成短URL<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-35-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-35-36.png" alt="img"></a></li><li>根据短URL还原长URL<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-36-01.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-36-01.png" alt="img"></a></li></ul><h4 id="QPS-Storage"><a href="#QPS-Storage" class="headerlink" title="QPS + Storage"></a>QPS + Storage</h4><p>假设这个是用来给微博做短网址的跳转。那么QPS能有多少？</p><ol><li>询问微博日活用户 —— 约100M</li><li>推算产生一条Tiny URL的QPS<ul><li>假设每个用户平均每天发0.1条微博，</li><li>平均写QPS = 100M * 0.1 / 86400 ~ 100</li><li>峰值QPS = 100 * 2 = 200</li></ul></li><li>推算点击一条Tiny URL的QPS<ul><li>假设每个用户平均点1个Tiny URL</li><li>平均读QPS = 100M * 1 / 86400 ~ 1k</li><li>峰值QPS = 2k</li></ul></li><li>推算每天产生的新的 URL 所占存储<ul><li>100M * 0.1 ~ 10M 条</li><li>每一条 URL 长度平均 100 算，一共1G</li><li>1T 的硬盘可以用 3 年</li></ul></li></ol><p>前3点：2k QPS ，一台SSD支持的MySQL完全可以搞定！</p><h2 id="2-Service-服务"><a href="#2-Service-服务" class="headerlink" title="2. Service 服务"></a>2. Service 服务</h2><h4 id="逻辑块聚类与接口设计"><a href="#逻辑块聚类与接口设计" class="headerlink" title="逻辑块聚类与接口设计"></a>逻辑块聚类与接口设计</h4><ol><li><p>TinyUrl只有一个UrlService</p><ul><li>本身就是一个小Application</li><li>无需关心其他的</li></ul></li><li><p>函数设计</p><ul><li><code>UrlService.encode(long_url)</code></li><li><code>`UrlService.decode(short_url)</code></li></ul></li><li><p>访问端口设计</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">GET /&lt;short_url&gt;</div><div class="line"><span class="keyword">return</span> a Http redirect response</div><div class="line"></div><div class="line">POST /data/shorten/</div><div class="line">Data = &#123;url: http:<span class="comment">//xxxx &#125;</span></div><div class="line">Return <span class="keyword">short</span> url</div></pre></td></tr></table></figure></li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-49-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-22-49-19.png" alt="img"></a></p><h2 id="3-Storage-数据存储"><a href="#3-Storage-数据存储" class="headerlink" title="3. Storage 数据存储"></a>3. Storage 数据存储</h2><p>两个步骤：</p><ol><li>选择存储结构</li><li>细化数据表</li></ol><h4 id="选择存储结构-SQL-vs-NoSQL"><a href="#选择存储结构-SQL-vs-NoSQL" class="headerlink" title="选择存储结构 SQL vs NoSQL"></a>选择存储结构 SQL vs NoSQL</h4><ul><li>是否需要支持 Transaction（事务）？<ul><li>NoSQL不支持Transaction</li><li>是否需要丰富的 SQL Query？</li></ul></li><li>NoSQL的SQL Query不是太丰富<ul><li>也有一些NoSQL的数据库提供简单的SQL Query支持</li></ul></li><li>是否想偷懒？<ul><li>大多数 Web Framework 与 SQL 数据库兼容得很好</li><li>用SQL比用NoSQL少写很多代码</li></ul></li><li>是否需要Sequential ID？<ul><li>SQL 为你提供了 auto-increment 的 Sequential ID。也就是1,2,3,4,5 …</li><li>NoSQL的ID并不是 Sequential 的</li></ul></li><li>对QPS的要求有多高？<ul><li>NoSQL 的性能更高</li></ul></li><li>对Scalability的要求有多高？<ul><li>SQL 需要码农自己写代码来 Scale</li><li>还记得Db那节课中怎么做 Sharding，Replica 的么？</li></ul></li><li>NoSQL 这些都帮你做了</li></ul><p><strong>选择</strong></p><ul><li>是否需要支持 Transaction？——不需要。NoSQL +1</li><li>是否需要丰富的 SQL Query？——不需要。NoSQL +1</li><li>是否想偷懒？——Tiny URL 需要写的代码并不复杂。NoSQL+1</li><li>对QPS的要求有多高？—— 经计算，2k QPS并不高，而且2k读可以用Cache，写很少。SQL +1</li><li>对Scalability的要求有多高？—— 存储和QPS要求都不高，单机都可以搞定。SQL+1</li><li>是否需要Sequential ID？—— 取决于你的算法是什么 : 如何将Long URL 转化为 Short URL</li></ul><h2 id="4-算法：-如何将Long-URL-转化为-Short-URL"><a href="#4-算法：-如何将Long-URL-转化为-Short-URL" class="headerlink" title="4. 算法： 如何将Long URL 转化为 Short URL"></a>4. 算法： 如何将Long URL 转化为 Short URL</h2><h3 id="4-1-算法1-使用哈希函数-Hash-Function（不可行）"><a href="#4-1-算法1-使用哈希函数-Hash-Function（不可行）" class="headerlink" title="4.1 算法1 使用哈希函数 Hash Function（不可行）"></a>4.1 算法1 使用哈希函数 Hash Function（不可行）</h3><p>比如取 Long Url 的 MD5 的最后 6 位——这个方法肯定是有问题的</p><ul><li>优点：快</li><li>缺点：难以设计一个没有冲突的哈希算法</li></ul><h3 id="4-2-算法2：随机生成-数据库去重"><a href="#4-2-算法2：随机生成-数据库去重" class="headerlink" title="4.2 算法2：随机生成 + 数据库去重"></a>4.2 算法2：随机生成 + 数据库去重</h3><p>随机一个 6 位的 ShortURL，如果没有被用过，就绑定到该 LongURL</p><p>伪代码如下：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-03-23-00-12.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-03-23-00-12.png" alt="img"></a></p><ul><li>优点：实现简单</li><li>缺点：生成短网址的长度随着短网址越来越多变得越来越慢</li><li>可行性：其实能凑合用。在生活中有很多随机编码的，例如机票码、酒店码，是不可重复的，就是用这种方法弄的。</li></ul><h3 id="4-3-算法3：进制转换-Base62"><a href="#4-3-算法3：进制转换-Base62" class="headerlink" title="4.3 算法3：进制转换 Base62"></a>4.3 算法3：进制转换 Base62</h3><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-55-32.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-55-32.png" alt="img"></a></p><ul><li>Base62<ul><li>将6位的short url看成一个62进制的数（0-9,a-z,A-Z）</li><li>每个short url对应到一个整数</li><li>该整数对应数据库表的主键——Sequential ID</li></ul></li><li>6位可以表示不同的URL有多少？<ul><li>5位 = 625625 = 9亿</li><li>6位 = 626626 = 570亿</li><li>7位 = 627627 = 35000亿</li></ul></li><li>优缺点<ul><li>优点：效率高</li><li>缺点：依赖于全局的自增ID</li></ul></li></ul><h3 id="4-4-算法2与3的比较"><a href="#4-4-算法2与3的比较" class="headerlink" title="4.4 算法2与3的比较"></a>4.4 算法2与3的比较</h3><ul><li><p><strong>基于随机生成的方法</strong><br>需要根据 Long 查询 Short，也需要根据 Short 查询 Long。基本上work solution如下图所示：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-00-54.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-00-54.png" alt="img"></a><br>如果选择用 SQL 型数据库，表结构如下：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-58-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-20-58-03.png" alt="img"></a><br>并且需要对shortKey和longURL分别建索引<br>• <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95" target="_blank" rel="external">什么是索引？</a><br>• <a href="http://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html" target="_blank" rel="external">索引的原理？</a><br>也可以选用 NoSQL 数据库，但是需要建立两张表（大多数NoSQL数据库不支持二级索引）。以 Cassandra 为例子<br>第一张表：根据 Long 查询 Short<br>row_key=longURL, column_key=ShortURL, value=null or timestamp<br>第二张表：根据 Short 查询 Long<br>row_key=shortURL, column_key=LongURL, value=null or timestamp</p></li><li><p><strong>基于进制转换的方法</strong><br>因为需要用到自增ID（Sequential ID），因此只能选择使用 SQL 型数据库。表单结构如下，shortURL 可以不存储在表单里，因为可以根据 id 来进行换算</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-05-21-36-40.png" alt=""> </p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-02-19.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-02-19.png" alt="img"></a></p></li></ul><h2 id="5-Scale-优化"><a href="#5-Scale-优化" class="headerlink" title="5. Scale 优化"></a>5. Scale 优化</h2><h3 id="5-1-如何提高响应速度？"><a href="#5-1-如何提高响应速度？" class="headerlink" title="5.1 如何提高响应速度？"></a>5.1 如何提高响应速度？</h3><p><strong>读操作的优化</strong></p><p>既然读操作比较多，那么可以用cache的方式去提速。</p><ul><li>cache里存什么？<ul><li>long to short(生成新short url时需要)</li><li>short to long(查询short url时需要)</li></ul></li><li>查询的流程图：<br><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-22-22.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-22-22.png" alt="img"></a></li></ul><h3 id="5-2-如何提速？"><a href="#5-2-如何提速？" class="headerlink" title="5.2 如何提速？"></a>5.2 如何提速？</h3><ul><li><p>利用地理位置信息加速</p></li><li><p>优化服务器速度</p><ul><li>不同地区，使用不同Web服务器</li><li>通过DNS解析不同地区的用户到不同的服务器</li></ul></li><li><p>优化数据访问速度</p><ul><li><p>使用Centralized MySQL + Distributed Memcached</p></li><li><p>数据库共享一个，不同地区设置多个缓存</p></li><li><p>一个MySQL配多个Memcached, Memcached跨地区分布</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-31-37.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-21-31-37.png" alt="img"></a></p></li></ul></li></ul><h3 id="5-3-数据量扩展"><a href="#5-3-数据量扩展" class="headerlink" title="5.3 数据量扩展"></a>5.3 数据量扩展</h3><p>如果数据量很大，一台MySQL搞不定了</p><ul><li>什么时候需要扩展多台服务器？<ul><li>Cache资源不够</li><li>写操作越来越多</li><li>请求太多，无法通过Cache满足</li></ul></li><li>增加多台数据库可以优化什么？<ul><li>解决存不下的问题——Storage角度（TinyURL一般遇不到这种问题）</li><li>解决忙不过来的问题——QPS角度</li><li>TinyURL主要是什么问题？？——忙不过来的问题</li></ul></li></ul><ul><li><p>如何解决忙不过来的问题？拆分 </p><ul><li><p>纵向切分？不同列放不同数据库？不可行！</p></li><li><p>横向拆分？</p><ul><li><p>用什么做sharding key?</p></li><li><p>如果用longURL做为sharding key，如何查询ID(short URL) ?</p><ul><li>已知shortURL查询longURL时，只能广播给N台数据库查询</li><li>不能降低每台机器QPS</li></ul></li><li><p>如果用ID(short URL)做为sharding key，如何查询 longURL?</p><ul><li><p>假设按照ID%N来分配存储</p></li><li><p>short2long</p><ul><li>将shortURL转化为ID</li><li>根据ID计算找到数据库</li><li>在该数据库中查询longURL即可</li></ul></li><li><p>long2short</p><ul><li>先查询：广播给N台数据库，查询是否存在，似乎有点耗时，但是也是可行的，因为数据库服务器不会太多</li><li>再插入如果不存在的话，获得下一个自增ID值，插入对应数据库</li><li><strong>其实也不可以不查询直接插入</strong>，因为long2short没有必要意义对应，<strong>一个long可以对应多个short</strong>，也就是说可以把长网址转成多个短网址，但是一旦用户获得一个短网址，相同的短网址只能对应一个长网址。</li></ul></li><li><p>这种方法还有一个问题，如何在多台数据库服务器上获取全局递增的ID？（因为每台机器上都有一个数据表，需要获取所有数据的递增ID就是个问题），解决办法：</p><ol><li>专门用一台服务器负责自增ID服务，不存储数据，也不负责查询</li><li>用Zookeeper</li></ol><p>但用全局递增ID不是解决TinyURL的好办法</p></li></ul></li></ul><p><strong>下面是一种更好的sharding办法，不需要全局递增ID：</strong></p></li><li><p>如果最开始shortkey为6位，那就增加一位前置位：</p><ul><li>AB1234 –&gt; 0AB1234（该前置位由hash(long_url)%62得到（可以用consistent hash算法），因此是唯一的。这个前置位可以作为机器的ID等）</li><li>另一种做法，把第一位单独留出来做sharding key，总共还是6位</li></ul></li><li><p>该前置位为sharding key</p></li><li><p>这样我们就可以同时通过shortURL和longURL得到sharding key</p><ul><li>无需广播</li><li>无论short2long还是long2short都可直接定位数据所在服务器</li></ul></li><li><p>当新加入一个longURL时，先通过hash(long_url)%62得到机器ID，然后在该机器上，通过该台机器的自增ID通过进制转换得到6位shortkey</p></li><li><p>用户已知shortURL时，先按第一位获取到机器ID，然后在此机器上查询longURL</p><p>那么当前的架构就变成了：</p></li></ul></li></ul><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-02-10-22-18-36.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-02-10-22-18-36.png" alt="img"></a></p><h3 id="5-4-Multi-region-的进一步优化"><a href="#5-4-Multi-region-的进一步优化" class="headerlink" title="5.4 Multi region 的进一步优化"></a>5.4 Multi region 的进一步优化</h3><p>上面的架构图还有优化的空间：</p><ul><li>网站服务器与数据库服务器之间的通信</li><li>中心化服务器集群与跨地域的web server之间的通信较慢，比如如果中心数据库放在美国，那么中国的服务器需要访问美国的数据库，通信较慢</li></ul><p>解决方法1：重写数据库到中国，中国用户访问中国数据库</p><p>问题：重写数据库，一致性问题如何解决？很难解决</p><p>正确打开方式：</p><p>想一想用户习惯：</p><ol><li>中国的用户一般访问的网站是中国的，美国的用户一般访问的网站是美国的</li><li>中国用户访问时，会被DNS分配中国的服务器</li></ol><p>因此我们可以用<strong>地域信息</strong>进行sharding，也就是说按照网站的地域信息将其数据分开存储在不同地方的数据库中</p><p>​    如何获得网站的地域信息？做一张用户经常访问的网站数据表</p><p>这样中国用户要访问的网站大多在位于中国的数据库中，响应速度就会比较快，当然也有少量中国用户需要访问美国网站的情况，就直接去访问美国数据库就好，反正不会慢对少，毕竟中国访问中国是主流需求，优化系统就是要优化主要需求。</p><p>最终架构图</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-11-17-32.png" alt=""> </p><h3 id="5-5-自定义短链接"><a href="#5-5-自定义短链接" class="headerlink" title="5.5 自定义短链接"></a>5.5 自定义短链接</h3><p>用户自定义短网址 -&gt; 长网址映射</p><p><a href="http://tiny.url/google/" target="_blank" rel="external">http://tiny.url/google/</a> =&gt; <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a><br><a href="http://tiny.url/systemdesign/" target="_blank" rel="external">http://tiny.url/systemdesign/</a> =&gt; <a href="http://www.jiuzhang.com/course/2/" target="_blank" rel="external">http://www.jiuzhang.com/course/2/</a></p><p><strong>一个错误的想法是：</strong></p><p>在URLtable中增加一个column，存放自定义的URL，因为这一列大部分会是空的，浪费空间。</p><p>正确打开方式：</p><ul><li>新建一张表存储自定义URL<ul><li>CustomURL Table</li></ul></li></ul><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-03-06-12-05-53.png" alt=""> </p><ul><li>已知长链接查询短链接的时候：<ul><li>先查询customURL table</li><li>再查询URL table</li></ul></li><li>用户想要由长链接自定一个新的短链接的时候<ul><li>查询是否已经在URLtable中存在了</li><li>再在CustomURL table 中查询和插入</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-03
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】follow up</title>
    <link href="http://yoursite.com/2018/02/26/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91follow-up/"/>
    <id>http://yoursite.com/2018/02/26/【九章算法强化班】follow-up/</id>
    <published>2018-02-26T07:07:15.000Z</published>
    <updated>2018-02-28T07:35:25.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-26-20-43-25.png" alt=""> </p><h2 id="例题1-Find-Peak-Element"><a href="#例题1-Find-Peak-Element" class="headerlink" title="例题1.Find Peak Element"></a>例题1.<a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h2><blockquote><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p><p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p></blockquote><p>找局部最大值。</p><p>思路：</p><ol><li><p>baseline：</p><p>遍历，找到i：nums[i-1]&lt;num[i]&lt;num[i+1]</p><p>复杂度<script type="math/tex">O(n)</script></p></li></ol><ol><li><p>优化：二分法</p><p>首先我们找到中间节点mid，如果大于两边返回当前index就可以了，如果左边的节点比mid大，那么我们可以继续在左半区间查找，这里面一定存在一个peak，为什么这么说呢？假设此时的区间范围为[0, mid - 1]， 因为num[mid - 1]一定大于num[mid]了，如果num[mid - 2] &lt;= num[mid - 1]，那么num[mid - 1]就是一个peak。如果num[mid - 2] &gt; num[mid - 1]，那么我们就继续在[0, mid - 2]区间查找，因为num[-1]为负无穷，所以最终我们绝对能在左半区间找到一个peak。同理右半区间一样。</p><p>复杂度<script type="math/tex">O(logn)</script></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &gt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((nums[mid] &lt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[end])&#123;</div><div class="line">            <span class="keyword">return</span>  end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-Find-Peak-Element-II"><a href="#follow-up-Find-Peak-Element-II" class="headerlink" title="follow up: Find Peak Element II"></a>follow up: Find Peak Element II</h3><p> 由一维拓展到二维，在矩阵上找peak element</p><p>peak element：<code>matrix[i][j]</code> 比其上下左右相邻元素大</p><p>思路：</p><ol><li><p>baseline：</p><p>遍历</p><p>复杂度复杂度<script type="math/tex">O(n^2)</script></p></li><li><p>优化：二分法</p><ul><li>找到中间行的最大值<code>matrix[i][j]</code></li><li>跟相邻上下元素比较，决定向上/向下走</li><li>如果上面的元素比较大，向上走，否则向下走</li></ul><p>复杂度<script type="math/tex">O(nlogn)</script></p></li><li><p>优化：行列交替二分</p><ul><li>找到中间行的最大值<code>matrix[i][j]</code> <script type="math/tex">O(n)</script></li><li>跟相邻上下元素比较，决定向上/向下走 剩下一半矩阵</li><li>找中间列的最大值<code>matrix[i][j]</code><script type="math/tex">O(n/2)</script></li><li>跟相邻左右元素比较，决定向左/向右走 剩下n/4矩阵</li></ul><p>复杂度<script type="math/tex">O(n)</script></p></li></ol><h2 id="例题2-Subarray-Sum"><a href="#例题2-Subarray-Sum" class="headerlink" title="例题2. Subarray Sum"></a>例题2. <a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">Subarray Sum</a></h2><blockquote><p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p><p>Example</p><p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p></blockquote><p>找子数组，和为0</p><p>思路：</p><ol><li><p>baseline:</p><p>两指针遍历</p><p>复杂度复杂度<script type="math/tex">O(n^2)</script></p></li><li><p>prefix sum:</p><p>用hash表记录前缀和的取值</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                result.add(<span class="number">0</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="follow-up-1-Submatrix-Sum"><a href="#follow-up-1-Submatrix-Sum" class="headerlink" title="follow up 1: Submatrix Sum"></a>follow up 1: <a href="http://www.lintcode.com/en/problem/submatrix-sum/" target="_blank" rel="external">Submatrix Sum</a></h3><blockquote><p>Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.</p><p>Example</p><p>Given matrix</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1 ,5 ,7],</div><div class="line">&gt;   [3 ,7 ,-8],</div><div class="line">&gt;   [4 ,-8 ,9],</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[(1,1), (2,2)]</code></p></blockquote><p>求元素和为0的子矩阵，返回矩阵的左上角和右下角元素位置</p><p>思路：</p><ol><li><p>先定位子矩阵的首行和尾行（外层循环）</p></li><li><p>把首行和尾行之间的元素压成一行，变成一个数组</p></li><li><p>对上面的数组做subarray sum，找到和为0的子数组就可以定位子矩阵的首列和尾列。</p><p>​</p></li></ol><p>预计算presum矩阵：</p><p><code>presum[i][j] = matrix[0][0]到matrix[i][j]的所有元素和</code></p><p>当外层循环固定为l和h时，内层循环j从0开始遍历，矩阵的前缀和为<code>presum[h][j]-presum[l][j]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] submatrixSum(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> rows = matrix.length;</div><div class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[][] presum = <span class="keyword">new</span> <span class="keyword">int</span>[rows+<span class="number">1</span>][cols+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</div><div class="line">                presum[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                presum[i][j] = matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] + presum[i-<span class="number">1</span>][j] + presum[i][j-<span class="number">1</span>] - presum[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; rows + <span class="number">1</span>; j++) &#123;</div><div class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cols + <span class="number">1</span>; k++) &#123;</div><div class="line">                <span class="keyword">int</span> diff = presum[j][k] - presum[i][k];</div><div class="line">                <span class="keyword">if</span> (map.containsKey(diff)) &#123;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">0</span>] = i;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">1</span>] = map.get(diff);</div><div class="line">                    result[<span class="number">1</span>][<span class="number">0</span>] = j-<span class="number">1</span>;</div><div class="line">                    result[<span class="number">1</span>][<span class="number">1</span>] = k-<span class="number">1</span>;</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    map.put(diff, k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-2-Subarray-Sum-II"><a href="#follow-up-2-Subarray-Sum-II" class="headerlink" title="follow up 2: Subarray Sum II"></a>follow up 2: Subarray Sum II</h3><p>给定一个数组nums和一个区间interval，返回nums数组中和在区间interval中的子数组个数，如nums = [1,2,3,4]，interval = [1,3],return 4,the possible answers are:[0,0],[0,1],[1,1],[2,2]</p><p>思路：</p><p>low &lt; prefix[j] - prefix[i] &lt; high</p><p>low + prefix[i] &lt; prefix[j] &lt; high + prefix[i]</p><p>prefix[i]  &lt;  prefix[j] - low</p><p>prefix[i]  &gt; prefix[j] - high</p><p>所以本题就是要找到在[prefix[j] - high , prefix[j] - low]范围内的prefix[i] </p><p>由于prefix[i]是递增的，所以可以存在数组中，用二分法查找</p><h2 id="例题3-Maximum-Subarray"><a href="#例题3-Maximum-Subarray" class="headerlink" title="例题3. Maximum Subarray"></a>例题3. <a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p></blockquote><p>找和最大的子数组</p><p>思路：</p><p>方法1：prefixsum</p><p>维护最小的prefixsum和当前最大的子数组和</p><p>方法2：dp</p><p>dp[i] = max(dp[i-1] + num[i],num[i])</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</div><div class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</div><div class="line">            maxVal = Math.max(maxVal,dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="follow-up-循环连续子数组"><a href="#follow-up-循环连续子数组" class="headerlink" title="follow up 循环连续子数组"></a>follow up 循环连续子数组</h2><p>上题的数组变成循环数组。</p><p>处理循环数组三种方法：</p><ol><li>拆开</li><li>扩展</li><li>取反</li></ol><p>分别看对于这道题是否可行：</p><ol><li><p>拆开</p><p>house robber用到了这个方法，抢第一个就不能抢最后一个，抢最后一个就不能抢第一个</p></li><li><p>扩展</p><p>将数组翻一倍，[-3, 1, 3, -3, 4]变成[-3, 1, 3, -3, 4,-3,1,3,-3]，然后找最大子数组，但是长度不能超过nums的长度。</p></li><li><p>取反</p><p>找循环数组中的最大子数组，有两种情况：</p><ol><li>在数组的中部，正常找就行了</li><li>一半在数组后面，一半在数组头部，因为数组的总和是一定的，因此这种情况可以转化成在数组中部找最小的子数组</li></ol><p>然后取上面两种情况的最大值。</p><p>​</p></li></ol><h2 id="例题4-Wiggle-Sort"><a href="#例题4-Wiggle-Sort" class="headerlink" title="例题4.  Wiggle Sort"></a>例题4.  <a href="https://leetcode.com/problems/wiggle-sort" target="_blank" rel="external">Wiggle Sort</a></h2><blockquote><p>Given an unsorted array <code>nums</code>, reorder it <strong>in-place</strong> such that <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...</code>.</p><p>For example, given <code>nums = [3, 5, 2, 1, 6, 4]</code>, one possible answer is <code>[1, 6, 2, 5, 3, 4]</code>.</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[start];</div><div class="line">                start++;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-Wiggle-Sort-II"><a href="#follow-up-Wiggle-Sort-II" class="headerlink" title="follow up Wiggle Sort II"></a>follow up <a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p><p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>对数组排序，排序之后将数组分成大小两堆，然后依次选取排序</p></li><li><p>quick sort思想</p><p>利用quick sort 找到中点，然后对左右两边元素一次选取排序</p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="例题5-Building-Post-Office-Best-Meeting-Point"><a href="#例题5-Building-Post-Office-Best-Meeting-Point" class="headerlink" title="例题5. Building Post Office Best Meeting Point"></a>例题5. Building Post Office <a href="https://leetcode.com/problems/best-meeting-point" target="_blank" rel="external">Best Meeting Point</a></h2><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>遍历所有位置，计算每个位置到所有人的距离，取最小的</p></li><li><p>优化：</p><p>看成一维，对于所有人来说，meeting point选在所有人的中位数的位置距离和最近，因此对行和列坐标分别选取中位数，得到meeting point</p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//int  num = 0;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                    <span class="comment">//num++;</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up1-Shortest-Distance-from-All-Buildings"><a href="#follow-up1-Shortest-Distance-from-All-Buildings" class="headerlink" title="follow up1. Shortest Distance from All Buildings"></a>follow up1. <a href="https://leetcode.com/problems/shortest-distance-from-all-buildings" target="_blank" rel="external">Shortest Distance from All Buildings</a></h3><blockquote><p>You want to build a house on an <em>empty</em> land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values <strong>0</strong>, <strong>1</strong> or <strong>2</strong>, where:</p><ul><li>Each <strong>0</strong> marks an empty land which you can pass by freely.</li><li>Each <strong>1</strong> marks a building which you cannot pass through.</li><li>Each <strong>2</strong> marks an obstacle which you cannot pass through.</li></ul><p>For example, given three buildings at <code>(0,0)</code>, <code>(0,4)</code>, <code>(2,2)</code>, and an obstacle at <code>(0,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 2 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(1,2)</code> is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>bfs，计算每个点到所有人的距离，取距离和最小的</p><p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层bfs<script type="math/tex">O(n^2)</script>，因此时间复杂度<script type="math/tex">O(n^4)</script></p></li><li><p>反向bfs</p><p>计算每个人到所有位置的距离<code>dis[k][i][j]</code> ，复杂度<script type="math/tex">O(n^2)</script></p><p>然后再遍历矩阵中每一个点，查询距离，取最小值，复杂度<script type="math/tex">O(n^2)</script></p><p>因此时间复杂度<script type="math/tex">O(n^2)</script></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算到所有空地的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> idx,<span class="keyword">int</span>[][][] distance,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">int</span>[][] grid)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(i*cols+j);</div><div class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">int</span> val = queue.poll();</div><div class="line">                <span class="keyword">int</span> x = val/cols;</div><div class="line">                <span class="keyword">int</span> y = val % cols;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                    <span class="keyword">int</span> x_new = x + x_delta[ii];</div><div class="line">                    <span class="keyword">int</span> y_new = y + y_delta[ii];</div><div class="line">                    <span class="keyword">if</span>(x_new &gt;= <span class="number">0</span> &amp;&amp; x_new &lt; rows &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt;cols) &#123;</div><div class="line">                        <span class="keyword">if</span>(grid[x_new][y_new] == <span class="number">0</span> &amp;&amp; distance[idx][x_new][y_new] == <span class="number">0</span>)&#123;</div><div class="line">                            distance[idx][x_new][y_new] = dis;</div><div class="line">                            queue.add(x_new * cols + y_new);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">            dis++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="comment">//计算有多少个1</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[count][rows][cols];</div><div class="line">        <span class="comment">//计算（i,j）到所有0点的距离</span></div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    bfs(i,j,idx,distance,rows,cols,grid);</div><div class="line">                    idx++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</div><div class="line">        <span class="comment">//找距离和最短的</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; distance.length;k++)&#123;</div><div class="line">                        <span class="keyword">if</span>(distance[k][i][j] == <span class="number">0</span>)&#123;</div><div class="line">                            flag = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span>&#123;</div><div class="line">                            sum += distance[k][i][j];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(flag)&#123;</div><div class="line">                        minDist = Math.min(minDist,sum);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minDist == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minDist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-2-Bomb-Enemy"><a href="#follow-up-2-Bomb-Enemy" class="headerlink" title="follow up 2. Bomb Enemy"></a>follow up 2. <a href="https://leetcode.com/problems/bomb-enemy" target="_blank" rel="external">Bomb Enemy</a></h3><blockquote><p>Given a 2D grid, each cell is either a wall <code>&#39;W&#39;</code>, an enemy <code>&#39;E&#39;</code> or empty <code>&#39;0&#39;</code> (the number zero), return the maximum enemies you can kill using one bomb.<br>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br>Note that you can only put the bomb at an empty cell.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For the given grid</div><div class="line">&gt;</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt; E 0 W E</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt;</div><div class="line">&gt; return 3. (Placing a bomb at (1,1) kills 3 enemies)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>bfs，计算每个点能够炸到的到所有人</p><p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层<script type="math/tex">O(n)</script>，因此时间复杂度<script type="math/tex">O(n^3)</script></p></li><li><p>反向bfs</p><p>申请四个数组：</p><p><code>left[i][j]:在(i,j)放炸弹，向左最多炸人数</code></p><p><code>right[i][j]:在(i,j)放炸弹，向右最多炸人数</code></p><p><code>up[i][j]:在(i,j)放炸弹，向上最多炸人数</code></p><p><code>dowm[i][j]:在(i,j)放炸弹，向下最多炸人数</code></p><p>将四个数组相加就得到在(i,j)放炸弹，总共炸人数</p><p>因此时间复杂度<script type="math/tex">O(n^2)</script> </p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombEnemy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxKilledEnemies</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] left = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] up = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">int</span> leftsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> rightsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span>)&#123; left[i][j] = leftsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'W'</span>)&#123; leftsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'E'</span>)&#123; leftsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'0'</span>)&#123; right[i][cols-<span class="number">1</span>-j] = rightsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'W'</span>)&#123; rightsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'E'</span>)&#123; rightsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cols;i++)&#123;</div><div class="line">            <span class="keyword">int</span> upsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> downsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; rows;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'0'</span>)&#123; up[j][i] = upsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'W'</span>)&#123; upsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'E'</span>)&#123; upsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'0'</span>)&#123; down[rows-<span class="number">1</span>-j][i] = downsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'W'</span>)&#123; downsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'E'</span>)&#123; downsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                maxnum = Math.max(maxnum,left[i][j] + right[i][j] + up[i][j] + down[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxnum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="例题6-N个数组的第K大问题"><a href="#例题6-N个数组的第K大问题" class="headerlink" title="例题6. N个数组的第K大问题"></a>例题6. N个数组的第K大问题</h2><p>在N个数组中找到第K大的元素</p><p>排序+heap</p><p>类似merge K sorted list</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-02
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】线段树</title>
    <link href="http://yoursite.com/2018/02/08/%E3%80%90leetcode%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2018/02/08/【leetcode】线段树/</id>
    <published>2018-02-08T14:27:03.000Z</published>
    <updated>2018-02-11T13:34:17.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线段树入门"><a href="#1-线段树入门" class="headerlink" title="1. 线段树入门"></a>1. 线段树入门</h1><p>本文主要参考自<a href="https://jiayi797.github.io/2018/01/23/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="external">jiayi797的专栏</a> 、 <a href="http://www.cnblogs.com/TenosDoIt/" target="_blank" rel="external">JustDoIT</a> 和 <a href="https://www.jiuzhang.com/article/kSiBNt/" target="_blank" rel="external">线段树知识点总结</a></p><p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。</p><p>线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]。线段树形如：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" alt="img"></a></p><p>下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0…n-1]中查找某个数组某个区间内的最大值，其中数组大小固定，但是数组中的元素的值可以随时更新。从这题可以看出：区间(a,b)的最大值和区间(b,c)的最大值中，取较大的就是区间(a,c)的最大值。很明显这个操作具有区间的性质。</p><p>我们可以用线段树来解决这个区间最大值问题。根据这个问题我们构造如下的二叉线段树。区间的第三维就是区间的最大值。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" alt="img"></a></p><p>加入第三维的时候，只需要在构建完左右区间后，根据左右区间的最大值更新当前区间最大值即可。</p><p>因为每次将区间长度一分为二，所有构造的节点个数为：</p><p>n + 1/2 <em>n + 1/4 </em>n + 1/8 * n + …</p><p>= (1 + 1/2 + 1/4 + 1/8 + …) * n</p><p>= 2n</p><p>所以构造线段树的时空复杂度都为O(n)。</p><h2 id="1-1-线段树常见题型"><a href="#1-1-线段树常见题型" class="headerlink" title="1.1. 线段树常见题型"></a>1.1. 线段树常见题型</h2><p>一道题可不可以用线段树来做，基本是看这道题的操作有没有<strong>区间的性质</strong>。也就是在一个区间上的操作是否可以转化为两个子区间上的操作。</p><ul><li>求区间和，积，最小值，gcd等</li><li>以当前节点的值作为节点处理。例如给出N个数字，再给一个数，问比这个数大的有多少个。</li><li>区间加减同一个值，或者区间同时赋一个值。</li></ul><h2 id="1-2-链式线段树"><a href="#1-2-链式线段树" class="headerlink" title="1.2. 链式线段树"></a>1.2. 链式线段树</h2><p>我们常见的二叉树都是链式结构。因此我们先完成链式的线段树。</p><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>复杂度O(n)</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</div><div class="line">    <span class="comment">//线段树节点定义</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        <span class="keyword">int</span> max;</div><div class="line">        SegmentTreeNode left = <span class="keyword">null</span>;<span class="comment">//定义左右节点</span></div><div class="line">        SegmentTreeNode right = <span class="keyword">null</span>;</div><div class="line">        SegmentTreeNode(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">builder</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,A.length-<span class="number">1</span>,A);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (low &gt; high)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        SegmentTreeNode root = <span class="keyword">new</span> SegmentTreeNode(low,high,A[low]);</div><div class="line">        <span class="keyword">if</span>(low == high)&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.left = helper(low,high/<span class="number">2</span>,A);</div><div class="line">            root.left = helper(high/<span class="number">2</span>+<span class="number">1</span>,high,A);</div><div class="line">            root.max = Math.max(root.left.max,root.right.max);<span class="comment">//更新当前节点max值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>复杂度 O(log(n))O(log(n))</p><p>构造线段树目的是为了更快地查询。例如给定区间，要求区间中的最大值。而线段树的区间查询操作就是将当前区间分解为较小的子区间，然后由子区间的最大值就可以快速得到需要查询区间的最大值。例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">query(1,3) = max(query(1,1), query(2,3)) = max(4,3) = 4</div></pre></td></tr></table></figure><p>查询实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在线段树中查找[low,high]区间的最大值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.start == low &amp;&amp; root.end == high)&#123;</div><div class="line">        <span class="keyword">return</span> root.max;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">if</span>(mid &gt;= low)&#123;<span class="comment">//查询区间与左半区间有交集，最大值有可能在左半区间</span></div><div class="line">        result = Math.max(result,query(root.left,low,mid));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= high)&#123; <span class="comment">//查询区间与右半区间有交集，最大值有可能在右半区间</span></div><div class="line">        result = Math.max(result,query(root.right,mid+<span class="number">1</span>,high));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><p>复杂度 O(log(n))O(log(n))</p><p>更新序列中的一个节点，那么如何把这种变化体现到线段树中呢？</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" alt="img"></a></p><p>例如要将第4个点更新为5.就要变动3个区间的值，分别为[3,3], [2,3], [0,3]</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" alt="img"></a></p><p>改动一个节点，与这个节点对应的叶子结点都要变动。并且，这个节点变动后，这个节点的属性值也有可能会变动，那么就有可能影响到这个节点的父亲节点的属性值（例如可能影响到最大值）。所以需要从叶子节点一路走到根节点。</p><p>单点更新实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="comment">////如果找到相应叶子节点了</span></div><div class="line">    <span class="keyword">if</span>(root.start == root.end &amp;&amp; root.start == idx)&#123;</div><div class="line">        root.max = val;<span class="comment">//修改max值</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(idx &lt;= mid)&#123;<span class="comment">//要修改的在左边</span></div><div class="line">        modify(root.left,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        modify(root.right,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//跟新root的max</span></div><div class="line">    root.max = Math.max(root.left.max,root.right.max);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-线段树入门&quot;&gt;&lt;a href=&quot;#1-线段树入门&quot; class=&quot;headerlink&quot; title=&quot;1. 线段树入门&quot;&gt;&lt;/a&gt;1. 线段树入门&lt;/h1&gt;&lt;p&gt;本文主要参考自&lt;a href=&quot;https://jiayi797.github.io/2018/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计数排序、基数排序、桶排序</title>
    <link href="http://yoursite.com/2018/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/02/08/计数排序、基数排序、桶排序/</id>
    <published>2018-02-08T07:03:21.000Z</published>
    <updated>2018-02-11T13:34:17.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为比较排序。</p><p>可以证明，基于比较的排序算法在最坏情况下的时间下界是Ω(nlgn)。堆排序和归并排序的运行时间上界为O(nlgn)，因此这两种排序算法都是渐进最优的比较排序算法。</p><p>而<strong>非基于比较的排序</strong>，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限，达到线性时间复杂度<script type="math/tex">O(n)</script>。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p><p>基数排序：O(dn) (d次调用桶排序)，空间复杂度 O(k) </p><p>桶排序：O(n)时间复杂度，O(n)空间复杂度</p><p>计数排序：O(n)时间复杂度，O(k)空间复杂度，每一个元素都是整数，并且位于0到k - 1之间</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)。</p><p>计数排序的思想是，对每一个输入元素，计算小于它的元素个数，如果有10个元素小于它，那么它就应该放在11的位置上，如果有17个元素小于它，它就应该放在18的位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。下图展示了实际的运行过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1186132-945c959a74a71c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/597" alt="img"></p><p>计数排序</p><p>构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，得到图(a)的结果。然后把C中每个元素变成前面所有元素的累加和，得到图(b)的结果。接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到B中的位置，即是该元素排序后的位置。例如，图中A的最后一个元素是3，找到C[3]是7，再令B[7]=3即可，然后顺便把C[3]减一，这是防止相同的数被放到同一个位置。</p><p>计数排序的时间代价可以这样计算，第一次遍历A并计算C所花时间是Θ(n)，C累加所花时间是Θ(k)，再次遍历A并给B赋值所花时间是Θ(n)，因此，总时间为Θ(k + n)。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>对于一组数据，我们可以按照每一位对它们进行排序。比如，考虑下面一组十进制数</p><blockquote><p>329<br>457<br>839<br>355</p></blockquote><p>先按最后一位从小到大排序，得到</p><blockquote><p>35<strong>5</strong><br>45<strong>7</strong><br>32<strong>9</strong><br>83<strong>9</strong></p></blockquote><p>再按中间一位从小到大排序，得到</p><blockquote><p>3<strong>2</strong>9<br>8<strong>3</strong>9<br>3<strong>5</strong>5<br>4<strong>5</strong>7</p></blockquote><p>最后按第一位从小到大排序，得到</p><blockquote><p><strong>3</strong>29<br><strong>3</strong>55<br><strong>4</strong>57<br><strong>8</strong>39</p></blockquote><p>其中，对任何一位的排序算法必须是稳定的，即相同数字不能改变它们的前后顺序。</p><p>基数排序算法的运行时间很容易计算，对于n个k进制d位数，假如每一位的排序使用计数排序算法，则该位排序用时为Θ(n + k)，总共d位数，总排序用时就是Θ(d(n + k))。当d为常数且k=O(n)时，总排序时间为Θ(n)。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p><p>我们将[0,1)区间划分为n个相同大小的子区间，称为桶。然后将输入数据分别放到各个桶中。如果数据分布得很均匀，每个桶中的数据就不会太多，都会维持在常数量级。我们先对每个桶中的元素排序，然后把所有桶中的元素顺序列出来即可。下图为n=10的一个案例。</p><p><img src="http://upload-images.jianshu.io/upload_images/1186132-1ea2b9a00e9dbeb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675" alt="img"></p><p>桶排序.png</p><p>创建一个长度也为10的数组，将A中的元素按照大小找到B中合适的位置，插入链表。之后，分别对B中每个链表中的元素执行插入排序。最后将B中的所有元素依次取出即可。</p><p>现在分析桶排序的时间代价。将A中元素放入B用时Θ(n)，B中每个链表执行插入排序的用时，可以证明是O(2 - 1/n)，于是总用时就是Θ(n) + n * O(2 - 1/n) = Θ(n)。具体证明过程比较难理解，这里我想给出一个容易理解的解释，虽然不一定对，但还是可以帮助理解为什么总用时是Θ(n)。n个数放入n个桶，平均下来每个桶只有一个数，在实际中，可能有的多有的少，但都不会差得太离谱。因此我们可以认为每个桶中只有常数个数，那么对常数个数执行插入排序所用的时间当然也就是O(1)了。于是n个桶总用时就是O(n)，加上前面的Θ(n)，桶排序总用时就是Θ(n)了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非比较排序&quot;&gt;&lt;a href=&quot;#非比较排序&quot; class=&quot;headerlink&quot; title=&quot;非比较排序&quot;&gt;&lt;/a&gt;非比较排序&lt;/h2&gt;&lt;p&gt;插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/02/08/%E3%80%90leetcode%E3%80%91sort/"/>
    <id>http://yoursite.com/2018/02/08/【leetcode】sort/</id>
    <published>2018-02-08T05:38:35.636Z</published>
    <updated>2018-02-11T13:34:17.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr><p>title: 【leetcode】sort<br>date: 2018-02-08 13:38:35<br>tags:</p><h2 id="categories"><a href="#categories" class="headerlink" title="categories:"></a>categories:</h2></blockquote><p>leetcode 排序相关问题</p><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a><a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="external">Largest Number</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p></blockquote><p>给定数组返回由该数组构成的最大数字，返回string类型</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先把数字转化成字符串，然后按字符串顺序排序，这里有一个小技巧，判断字符串s1和s2谁应该放在前面时，比较s1+s2和s2+s1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Comparator&lt;String&gt; cmp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</div><div class="line">                String s1 = o1+o2;</div><div class="line">                String s2 = o2+o1;</div><div class="line">                <span class="keyword">return</span> s2.compareTo(s1);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            strs[i] = String.valueOf(nums[i]);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(strs,cmp);</div><div class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</div><div class="line">            sb.append(strs[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a><a href="https://leetcode.com/problems/maximum-gap/" target="_blank" rel="external">Maximum Gap</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Try to solve it in linear time/space.</p><p>Return 0 if the array contains less than 2 elements.</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p></blockquote><p>给定一个无序数组，返回数组中相邻元素（排序后）之差的最大值</p><p>复杂度要求：线性时间复杂度</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：排序，计算相邻元素最大值，时间复杂度<script type="math/tex">O(nlogn)</script></p><p>优化：桶排序</p><ol><li>确定数组中最大和最小元素max和min，数组中元素个数N</li><li>这N个数字的平均间隔为：avg = (max-min)/(N-1)，maxGap &gt;= avg，所以我们令桶的大小int <code>bucketSize = Math.max(1,(max - min) / (N-1));</code> 这样每一个桶内，元素的差值不会超过avg了，那么相邻元素之间的最大间隔一定在桶之间。</li><li>根据桶的大小，可以计算出桶的个数为<code>int bucketNum = (max - min)/bucketSize + 1;</code> ,</li><li>遍历数组中的元素，将元素放入对应的桶中，并维护每个桶的最大值和最小值</li><li>计算相邻桶的最小值和最大值的差，遇到桶中没有元素的跳过，取最大的差值即为所求。</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> N = nums.length;</div><div class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(N == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.abs(nums[<span class="number">0</span>] - nums[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//查找nums中最大和最小值</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</div><div class="line">            min = Math.min(min,num);</div><div class="line">            max = Math.max(max,num);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//maxGap &gt; avg = (max-min)/(N-1);bucketSize = floor(max-min)/(N-1);</span></div><div class="line">        <span class="keyword">int</span> bucketSize = Math.max(<span class="number">1</span>,(max - min) / (N-<span class="number">1</span>));<span class="comment">//桶大小</span></div><div class="line">        <span class="comment">//bucketNum = ceil (max-min)/bucketSize</span></div><div class="line">        <span class="keyword">int</span> bucketNum = (max - min)/bucketSize + <span class="number">1</span>;<span class="comment">//桶个数</span></div><div class="line"></div><div class="line">        <span class="comment">//用于记录每个bucket中的最大和最小值</span></div><div class="line">        <span class="keyword">int</span>[] bucketMin = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMin[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] bucketMax = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMax[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[(nums[i]-min)/bucketSize] == -<span class="number">1</span>)&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; bucketMin[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; bucketMax[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lastMax =  bucketMax[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[i] == -<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            maxGap = Math.max(maxGap,bucketMin[i] - lastMax);</div><div class="line">            lastMax = bucketMax[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxGap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="external">Best Meeting Point</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p></blockquote><p>给定二维数组，1代表n个人的出发地，0代表其余地点，找到数组中的一个位置，使得大家到这个地点的曼哈顿距离之和最短，返回最短距离</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只想到了暴力的思路。。。</p><p>看了solution，需要从一维的入手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Case #1: 1-0-0-0-1</div><div class="line">Case #2: 0-1-0-1-0</div><div class="line">Case #3: 1-0-0-0-0-0-0-1-1</div><div class="line">Case #4: 1-1-0-0-1</div></pre></td></tr></table></figure><p>给了这么几个例子，说明到所有点最短的距离就是中位数的点。</p><p>所以扩展到二维，到所有点距离最短的点就是所有点分别在x轴和y轴中位数的点。</p><p>因此可以遍历所有的点，记录是1的点的xy坐标，然后分别对xy坐标排序，取中位数的点，即为要求的点，再计算下距离就好。</p><p>优化：</p><p>可以把横纵坐标分离计算，按需加入list,这样就不需要排序了,直接取中位数位置的点</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestMeetingPoint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="external">Insert Interval</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p><p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p><p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p></blockquote><p>给定区间数组，区间之间没有overlap，又给定一个独立区间，将该独立区间加到数组的区间里，如有overlap将区间merge,返回加入独立区间后的数组</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>遍历数组中的区间，当数组中的区间和独立区间还没有交集（intervals.get(i).end &lt; newInterval.start）的时候，将这些区间原封不动放入result中</li><li>将区间start和end初始化为newInterval的start和end</li><li>继续遍历数组中的区间，直至intervals.get(i).start &gt; newInterval.end,也就是和独立区间不相交了，在此期间，更新数组的上下边界</li><li>将更新好的区间加入结果</li><li>将剩余区间加入结果</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertInterval</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start)&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i == intervals.size())&#123;</div><div class="line">            res.add(newInterval);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = newInterval.start;</div><div class="line">        <span class="keyword">int</span> end = newInterval.end;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end)&#123;</div><div class="line">            start = Math.min(start,intervals.get(i).start);</div><div class="line">            end = Math.max(end,intervals.get(i).end);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        res.add(<span class="keyword">new</span> Interval(start,end));</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size())&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a><a href="https://leetcode.com/problems/h-index/" target="_blank" rel="external">H-Index</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;hr&gt;
&lt;p&gt;title: 【leetcode】sort&lt;br&gt;date: 2018-02-08 13:38:35&lt;br&gt;tags:&lt;/p&gt;
&lt;h2 id=&quot;categories&quot;&gt;&lt;a href=&quot;#categories&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】两指针</title>
    <link href="http://yoursite.com/2018/02/02/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E4%B8%A4%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/02/02/【九章算法强化班】两指针/</id>
    <published>2018-02-02T04:31:57.000Z</published>
    <updated>2018-02-08T07:05:26.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol><li>一个数组，从两边往中间移动（对撞型）</li><li>一个数组，同时向前移动（前向型）</li><li>两个数组两根指针（并行型）</li></ol><h2 id="1-对撞型或相会型"><a href="#1-对撞型或相会型" class="headerlink" title="1.对撞型或相会型"></a>1.对撞型或相会型</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-12-41-27.png" alt=""> </p><h3 id="leetcode-11-Container-With-Most-Water"><a href="#leetcode-11-Container-With-Most-Water" class="headerlink" title="leetcode 11.Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">leetcode 11.Container With Most Water</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>灌水问题，从两边向内灌水，所以初始两个指针ij一头一尾，此时能够容纳的水量是i和j中比较高度的柱子高度*ij两个柱子之间的距离：</p><p>max(height[i] , height[j]) * (j - i)</p><p>然后考虑将柱子向内移动，其实我们只需要移动比较矮的柱子，因为如果移动长的一边的柱子，根据上面的公式，j-i会变短，max(height[i] , height[j])可能变小可能不变，所以总的水量不会增加，所以我们只有移动短的柱子，才有可能会遇到更高的柱子，使得水量增大。</p><p>这样一来，每次选取较短的柱子向内移动，时间复杂度为<script type="math/tex">O(n)</script></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">                max = Math.max(max,(j-i) *height[i]);</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max,(j-i) * height[j]);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Quick-select-—-Kth-Largest-Element-in-an-Array"><a href="#Quick-select-—-Kth-Largest-Element-in-an-Array" class="headerlink" title="Quick select — Kth Largest Element in an Array"></a>Quick select — <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p></blockquote><p>在一组数字中找到第K大的数字</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一：可以用堆，维护一个大小为K的堆，将数字依次加入堆，找到第k大，时间复杂度<script type="math/tex">O(nlogk)</script></p><p>方法二：quick select，基于quick sort的思想</p><ol><li>每次在数组中随机选取一个数组作为pivort，这里面随机选取，经过大量的验证，选取中间位置的数字作为pivot比较稳妥。</li><li>然后和快排一样，将比它小的放在它左边，比它大的放在右边，找到pivot的位置即是pivot的最终位置。<ol><li>如果此时pivot的位置==k-1，找到了</li><li>如果此时pivot的位置 &gt;k-1，只需在pivot左边寻找第k大</li><li>如果此时pivot的位置 &lt;k-1，只需在pivot右边寻找第k-pivot大</li></ol></li></ol><p>这种方法的时间复杂度为<script type="math/tex">O(n)+O(n/2)+O(n/4)+...+O(1) = O(2n) = O(n)</script></p><p>两种方法的比较：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-15-34-03.png" alt=""> </p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> pivotIdx = start+(end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> pivot = nums[pivotIdx];</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        swap(nums,i,pivotIdx);<span class="comment">//把pivot交换至数组头</span></div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= pivot)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            nums[i] = nums[j];</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= pivot)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            nums[j] = nums[i];</div><div class="line">        &#125;</div><div class="line">        nums[j] = pivot;</div><div class="line">        <span class="keyword">if</span>((j - start) == k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> pivot;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((j - start) &gt; k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,start,j-<span class="number">1</span>,k);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,j+<span class="number">1</span>,end,k-j+start-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> partition(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-16-57-31.png" alt=""> </p><h3 id="lintcode-399-Nuts-amp-Bolts-Problem"><a href="#lintcode-399-Nuts-amp-Bolts-Problem" class="headerlink" title="lintcode 399.Nuts &amp; Bolts Problem"></a><a href="https://www.lintcode.com/en/problem/nuts-bolts-problem/" target="_blank" rel="external">lintcode 399.Nuts &amp; Bolts Problem</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts。nuts 和 bolts 一一匹配。 不允许将 nut 之间互相比较，也不允许将 bolt 之间互相比较。也就是说，只许将 nut 与 bolt 进行比较， 或将 bolt 与 nut 进行比较。请比较 nut 与 bolt 的大小</p><p>样例</p><p>给出 nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;GG&#39;, &#39;DD&#39;, &#39;BC&#39;]</code><br>你的程序应该找出bolts和nuts的匹配。<br>一组可能的返回结果是：<br>nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;BC&#39;,&#39;DD&#39;,&#39;GG&#39;]</code></p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>因为nuts和bolts两个数组在各自的内部不能互相比较，只能在两个数组之间的元素进行比较。所以这就需要利用一个array中的元素对另一个array进行partition，并反过来重复这一个过程，最终让两个array都满足comparator所定义的相同顺序。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * public class NBCompare &#123;</span></div><div class="line"><span class="comment"> *     public int cmp(String a, String b);</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> * You can use compare.cmp(a, b) to compare nuts "a" and bolts "b",</span></div><div class="line"><span class="comment"> * if "a" is bigger than "b", it will return 1, else if they are equal,</span></div><div class="line"><span class="comment"> * it will return 0, else if "a" is smaller than "b", it will return -1.</span></div><div class="line"><span class="comment"> * When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> nuts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> bolts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> compare: a instance of Comparator</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: nothing</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(String[] nuts,String[] bolts,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</div><div class="line">         <span class="comment">//选取bolts中的第一个元素作为pivot，计算在nuts中对应的元素的位置</span></div><div class="line">         <span class="keyword">int</span> nuts_pivotidx = partition(nuts,bolts[start],compare,start,end);</div><div class="line">         <span class="comment">//利用nuts中的pivot对bolts中元素排序</span></div><div class="line">         partition(bolts,nuts[nuts_pivotidx],compare,start,end);</div><div class="line">         <span class="comment">//对picot左边右边分别排序</span></div><div class="line">         quicksort(nuts, bolts, compare, start, nuts_pivotidx - <span class="number">1</span>);</div><div class="line">         quicksort(nuts, bolts, compare, nuts_pivotidx + <span class="number">1</span>, end);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//输入nuts和bolts中的pivot,对nuts排序，返回对应元素的位置</span></div><div class="line">     <span class="comment">//输入bolts和nuts中的pivot,对bolts排序，返回对应元素的位置</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String[] str,String pivot,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="comment">//在另一个数组中找到对应的螺丝或者螺母</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">             <span class="keyword">if</span>(compare.cmp(str[i],pivot) == <span class="number">0</span> || </div><div class="line">             compare.cmp(pivot,str[i]) == <span class="number">0</span>)&#123;</div><div class="line">                 swap(str,i,start);</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//快速排序</span></div><div class="line">         String pivotTemp = str[start];</div><div class="line">         <span class="keyword">int</span> left = start;</div><div class="line">         <span class="keyword">int</span> right = end;</div><div class="line">         <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == -<span class="number">1</span> || </div><div class="line">            compare.cmp(pivot,str[right]) == <span class="number">1</span>))&#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            str[left] = str[right];</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == <span class="number">1</span> || </div><div class="line">            compare.cmp(pivot, str[right]) == -<span class="number">1</span>))&#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            str[right] = str[left];</div><div class="line">        &#125;</div><div class="line">        str[left] = pivotTemp;    </div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//交换元素</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] strings,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">         String temp = strings[i];</div><div class="line">         strings[i] = strings[j];</div><div class="line">         strings[j] = temp;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortNutsAndBolts</span><span class="params">(String[] nuts, String[] bolts, NBComparator compare)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">if</span>(nuts == <span class="keyword">null</span> || bolts == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(nuts.length != bolts.length) <span class="keyword">return</span>;</div><div class="line">        quicksort(nuts,bolts,compare,<span class="number">0</span>,nuts.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="2-窗口类"><a href="#2-窗口类" class="headerlink" title="2.窗口类"></a>2.窗口类</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-21-47-48.png" alt=""> </p><h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p></blockquote><p>返回数组中元素和&gt;=s的最长子数组的长度</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两指针控制滑动窗口类问题，当窗口内元素和&lt;s时右指针向右滑动，更新最大长度</p><p>当窗口内元素和&gt;=s时，左指针向右滑动至&lt;s，无需更新最大长度</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++)&#123;</div><div class="line">            sum += nums[j];</div><div class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</div><div class="line">                minLen = Math.min(minLen,j-i+<span class="number">1</span>);</div><div class="line">                sum -= nums[i];</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE?<span class="number">0</span>:minLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p></blockquote><p>查找字符串中没有重复元素的最长子串</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>记录窗口中出现过哪些字母，当遇到重复字母的时候窗口缩小</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//相当于hashmap</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt; s.length())&#123;</div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)] == <span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)] = <span class="number">1</span>;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//map[s.charAt(j)] == 1</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">while</span>(s.charAt(j) != s.charAt(i))&#123;</div><div class="line">                    map[s.charAt(i)] = <span class="number">0</span>;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring" target="_blank" rel="external">Minimum Window Substring</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<br><strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><br><strong>T</strong> = <code>&quot;ABC&quot;</code></p><p>Minimum window is <code>&quot;BANC&quot;</code>.</p></blockquote><p>返回s中能够包含t的最短子串</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>滑动窗口+hashtable的思想</p><p>首先需要两个hash表，一个存储t中的字母，一个存储s中子串的字母，还需要一个能够判别s中的子串是否能够包含t的函数。</p><p>然后两指针滑动窗口，右指针向右滑动，当滑窗中的子串能够包含t时，窗口缩小，左指针右移，更新最短窗口，直到窗口内子串不足以包含t中全部字母，此时右指针继续向后移动，重复上述过程。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//判断s是否包含t</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(<span class="keyword">int</span>[] mapT,<span class="keyword">int</span>[] mapS)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mapT.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(mapS[i] &lt; mapT[i])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] mapT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span>[] mapS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        StringBuilder minWindow = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : t.toCharArray())&#123;</div><div class="line">            mapT[ch]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++) &#123;</div><div class="line">            mapS[s.charAt(j)]++;</div><div class="line">            <span class="keyword">while</span>(isContain(mapT,mapS))&#123;</div><div class="line">                <span class="keyword">if</span>(minlen &gt; j-i+<span class="number">1</span>)&#123;</div><div class="line">                    minlen = j-i+<span class="number">1</span>;</div><div class="line">                    minWindow = <span class="keyword">new</span> StringBuilder(s.substring(i,j+<span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">                mapS[s.charAt(i)]--;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minWindow.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="Longest Substring with At Most K Distinct Characters"></a><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="external">Longest Substring with At Most K Distinct Characters</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the longest substring T that contains at most <em>k</em> distinct characters.</p><p>For example, Given s = <code>“eceba”</code> and k = 2,</p><p>T is “ece” which its length is 3.</p></blockquote><p>在字符串中找到一个子串，最多包含k个不同的字母，返回满足这样条件的子串的最大长度。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>还是滑窗+hash表</p><p>用hash表存储当前子串中字母，用charNum存储子串中的不同字母个数</p><ol><li>当窗口内字母个数&lt;=k时右指针向右滑动，扩大窗口，更新窗口大小</li><li>当窗口内字母个数&gt;k时，左指针右移，缩小窗口，</li></ol><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> charNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++)&#123;</div><div class="line">            <span class="comment">//之前已经出现过这个字母了</span></div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)]&gt;<span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数&lt;k</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (charNum &lt; k)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数==k</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                <span class="keyword">while</span>(charNum &gt; k)&#123;</div><div class="line">                    <span class="keyword">if</span>(map[s.charAt(i)] == <span class="number">1</span>)&#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                        charNum--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                    &#125;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="两个数组两个指针"><a href="#两个数组两个指针" class="headerlink" title="两个数组两个指针"></a>两个数组两个指针</h2><h3 id="最小差"><a href="#最小差" class="headerlink" title="最小差"></a><a href="http://www.lintcode.com/zh-cn/problem/the-smallest-difference/" target="_blank" rel="external">最小差</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定两个整数数组（第一个是数组 <code>A</code>，第二个是数组 <code>B</code>），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。</p><p>样例</p><p>给定数组 A = <code>[3,4,6,7]</code>， B = <code>[2,3,8,9]</code>，返回 <code>0</code>。</p></blockquote><p>给定两个数组，返回两个数组元素之间的最小差</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>baseline:双层for循环，A中循环一遍B中循环一遍，计算每两个元素之间的差值取最小，时间复杂度：<script type="math/tex">O(n^2)</script></p><p>优化：</p><p>先排序，排序之后遍历A中元素，用二分查找的思路在B中寻找与元素A[i]差值最小的元素，时间复杂度：<script type="math/tex">O(nlogn)</script></p><p>骚操作：</p><p>两指针ij分别指向AB，更新A[i]和B[j]的差值</p><p>当A[i]&lt;B[j]时，i后移，反之j后移</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    Arrays.sort(A);</div><div class="line">    Arrays.sort(B);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</div><div class="line">        min = Math.min(min,Math.abs(A[i]-B[j]));</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; B[j])&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Smallest-Range"><a href="#Smallest-Range" class="headerlink" title="Smallest Range"></a><a href="https://leetcode.com/problems/smallest-range/" target="_blank" rel="external">Smallest Range</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You have <code>k</code> lists of sorted integers in ascending order. Find the <strong>smallest</strong> range that includes at least one number from each of the <code>k</code> lists.</p><p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</div><div class="line">&gt; Output: [20,24]</div><div class="line">&gt; Explanation: </div><div class="line">&gt; List 1: [4, 10, 15, 24,26], 24 is in range [20,24].</div><div class="line">&gt; List 2: [0, 9, 12, 20], 20 is in range [20,24].</div><div class="line">&gt; List 3: [5, 18, 22, 30], 22 is in range [20,24].</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定k个数组，找到最短的区间，该区间需满足包含来自每个数组的至少一个元素</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>k个数组k个指针，k个指针中的最大最小即是当前情况下的区间。</p><p>每次将值最小的指针向后移动，更新当前情况下的区间长度。</p><p>这里就需要找到哪个指针所指的值是最小的了，所以我们需要一个最小堆来维护k个指针中的最小值。</p><p>另外，我们还需要计算k个指针中的最大值，这个最大值用一个变量max维护就可以了，每次入堆的元素都跟当前max比较更新一下就好。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallestRange</span> </span>&#123;</div><div class="line">  <span class="comment">//定义结构Node，存储节所在的数组idx和值</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];<span class="comment">//代表指针指向每一个数组</span></div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; minheap= <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);<span class="comment">//最小堆</span></div><div class="line">        <span class="keyword">int</span> max  = Integer.MIN_VALUE;<span class="comment">//存储当前遇到的最大值</span></div><div class="line">        <span class="keyword">int</span> minRangeLen = Integer.MAX_VALUE;<span class="comment">//存储最小区间的长读</span></div><div class="line">        <span class="keyword">int</span>[] minRange = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//存储最小区间</span></div><div class="line">        <span class="comment">//先把所有list第一个元素先入堆，同时记录最大值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; idx.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> val = nums.get(i).get(idx[i]);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(i,val));</div><div class="line">            max = Math.max(max,val);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//出堆</span></div><div class="line">        <span class="keyword">while</span> (!minheap.isEmpty())&#123;</div><div class="line">            <span class="comment">//取堆顶元素</span></div><div class="line">            Node temp = minheap.poll();</div><div class="line">            <span class="comment">//更新当前最小区间的长度</span></div><div class="line">            <span class="keyword">if</span>(max-temp.val &lt; minRangeLen)&#123;</div><div class="line">                minRangeLen = max-temp.val;</div><div class="line">                minRange[<span class="number">0</span>] = temp.val;</div><div class="line">                minRange[<span class="number">1</span>] = max;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//堆顶元素所在的区间指针后移一位</span></div><div class="line">            idx[temp.idx]++;</div><div class="line">            <span class="comment">//如果对顶元素所在的区间指针溢出了，跳出</span></div><div class="line">            <span class="keyword">if</span>(idx[temp.idx] == nums.get(temp.idx).size())&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//找到下一个值，更新max，入堆</span></div><div class="line">            <span class="keyword">int</span> nextval = nums.get(temp.idx).get(idx[temp.idx]);</div><div class="line">            max = Math.max(max,nextval);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(temp.idx,nextval));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minRange;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Partition-Labels"><a href="#Partition-Labels" class="headerlink" title="Partition Labels"></a><a href="https://leetcode.com/problems/partition-labels/" target="_blank" rel="external">Partition Labels</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">&gt; Output: [9,7,8]</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</div><div class="line">&gt; This is a partition so that each letter appears in at most one part.</div><div class="line">&gt; A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个字符串，要求将字符串分割，保证每个字母只出现在一个子串中，最终返回分割的字符串长度</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">由于每个字母只能出现在一个字符串中，比如第一个字母a，其所在的子串至少要从第一个a到最后一个a。</div><div class="line">S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">     ↑       ↑</div><div class="line">     i       maxRight</div><div class="line">但此时并不一定找到第一个合适的分割点了，因为在这两个a中其他字母，有可能出现在后半段中，所以我们还需要遍历这两个指针中间的字母，确定每一个字母在字符串中出现的最后位置，在这个过程中，前后两个指针的距离可能会变得更远，中间的每一个元素都需要遍历到。所以我们用maxRight来存储当前遍历过的字母的最远位置，则i的遍历区间应该是while (i &lt;= maxright)。</div></pre></td></tr></table></figure><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> maxright = i;<span class="comment">//初始化maxright</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= maxright)&#123;</div><div class="line">            <span class="keyword">char</span> ch = s.charAt(i);</div><div class="line">            <span class="keyword">while</span> (s.charAt(j) != ch)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//找到ch出现的最后一个位置</span></div><div class="line">            maxright = Math.max(maxright,j);<span class="comment">//更新最远距离</span></div><div class="line">            <span class="keyword">if</span>(i == maxright)&#123;<span class="comment">//找到了最后一个，跳出</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            j = end;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//更新结果集，继续分割右边</span></div><div class="line">        result.add(maxright-start+<span class="number">1</span>);</div><div class="line">        partition(s,maxright+<span class="number">1</span>,end);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</div><div class="line">        partition(S,<span class="number">0</span>,S.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;一个数组，从两边往中间移动（对撞型）&lt;/li&gt;
&lt;li&gt;一个数组，同时向前移动（前向型）
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2018/01/31/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/01/31/堆排序/</id>
    <published>2018-01-31T10:55:23.000Z</published>
    <updated>2018-01-31T10:55:23.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】从用户系统理解数据库和缓存</title>
    <link href="http://yoursite.com/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/01/30/【九章系统设计】从用户系统理解数据库和缓存/</id>
    <published>2018-01-30T15:49:17.000Z</published>
    <updated>2018-03-05T07:25:13.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ul><li>Design User System用户系统<ul><li>Mencached 优化数据库查询软件</li><li>Authentication 用户验证</li><li>SQL VS NoSQL 如何选取数据库</li><li>Friendship 存储好友关系（不用graph DB用什么）</li></ul></li><li>How to Scale?<ul><li>Sharding</li><li>Consistent Hashing(第5节)</li><li>Replica(第5节)</li></ul></li></ul><h1 id="4S分析法"><a href="#4S分析法" class="headerlink" title="4S分析法"></a>4S分析法</h1><ul><li><p>Scenario场景</p><ul><li><p>注册、登录、查询、用户修改信息</p><p>哪个需求量最大？查询最大，因为用户登录时给他展示的各种信息邓邓就是通过查询出来的结果</p></li><li><p>支持100M DAU(每日登录用户数)</p></li><li><p>注册，登录，信息修改QPS约：</p><ul><li>100M*0.1/86400 ~ 100</li><li>0.1=平均每个用户每天登陆+注册+信息修改</li><li>Peak = 100*3 = 300</li></ul></li><li><p>查询的QPS约为：</p><ul><li>100M*100/86400 ~ 100k</li><li>100 = 平均每个用户每天查询与用户信息相关的操作次数（查看好友、发信息，更新消息主页等）</li><li>Peak = 100k*3 = 300K</li></ul></li></ul></li><li><p>Service服务</p><ul><li>一个AuthService 负责登录注册</li><li>一个UserService 负责用户信息与存储</li><li>一个FriendshipService存储好友关系</li></ul></li><li><p>Storage:QPS与常用数据存储系统</p><ul><li>MySQL/PostgreSQL等数据库性能<ul><li>约1kQPS</li></ul></li><li>MongoDB/Cassandra等硬盘性NoSQL数据库<ul><li>约10QPS</li></ul></li><li>Redis/memcached等内存型NoSQL数据库性能<ul><li>100k~1mQPS</li></ul></li></ul></li><li><p>Scale</p><p>根据上面的QPS分析，注册、登录、信息修改300QPS，用mysql应该就够了</p><p>用户查询适合什么样的数据存储系统？</p></li></ul><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h1><h2 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1 Cache"></a>1.1 Cache</h2><p><strong>用户系统特点：读非常多，写非常少，一定要用Cache进行优化</strong></p><ul><li>Cache 是什么？<ul><li>缓存，把之后可能要查询的东西先存一下<ul><li>下次用的时候直接从这里拿，无需重新计算和存取数据库</li></ul></li><li>可以理解为一个Java中的HashMap</li><li>key-value的结构</li></ul></li><li>有哪些常用的Cache软件？<ul><li>memcached（不支持数据持久化）</li><li>Redis(支持数据持久化)</li></ul></li><li>Cache一定存在内存中么？<ul><li>不是</li><li>Cache是用于连接不同的介质，解决速度差异的问题</li><li>File System有时候也是一种cache</li><li>CPU也有Cache</li><li>内存是硬盘和CPU的cache</li></ul></li><li>Cache一定是Server Cache 么?<ul><li>不，浏览器也可能有客户端的cache</li></ul></li></ul><h2 id="1-2-Mem-Cache"><a href="#1-2-Mem-Cache" class="headerlink" title="1.2 Mem-Cache"></a>1.2 Mem-Cache</h2><p>内存中的Cache</p><p>Memcached：一个内存cache软件，就看成hashmap用</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-31-00-30-58.png" alt=""> </p><p>memcached如何优化DB的查询?</p><p>先去cache中查找，如果没有，再去DB中查找：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-23-56.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-28-05.png" alt=""> </p><p>分析：</p><p>我们认为database中的才是最正确的</p><p>A：database set时可能会出现问题，但没有太大问题，比如你发了一条微博，显示没成功。</p><p>但是如果database成功了，cache更新失败了，那么用户得到的数据都是更新之前的数据。</p><p>B：如果cache成功了，但是database没有成功，cache里存的不是database中的真正数据，看成脏数据。</p><p>C：如果cache delete成功了，但是database更新失败，没关系，还可以去database里面读取</p><p>D：如果database 修改成功了，但是cache失败了，此时用户从cache读取的就是之前的数据</p><p>相比之下C比较好，但是C也存在一定的问题：</p><p>比如第8行和第9行程序，如果我们刚刚获取了user但是这个时候有另一个进程修改了用户信息，此时再更新cache中的user信息就是旧数据了。</p><h2 id="1-3-Cache-Aside-和-Cache-Through"><a href="#1-3-Cache-Aside-和-Cache-Through" class="headerlink" title="1.3 Cache Aside 和 Cache Through"></a>1.3 Cache Aside 和 Cache Through</h2><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-21-40-11.png" alt=""> </p><p>前面代码中的例子就是Cache Aside，需要分别对Cache和DB进行操作，这样就会造成不同步的后果</p><h3 id="Cache-Through"><a href="#Cache-Through" class="headerlink" title="Cache Through"></a>Cache Through</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-21-40-30.png" alt=""> </p><h1 id="2-Service-服务"><a href="#2-Service-服务" class="headerlink" title="2. Service 服务"></a>2. Service 服务</h1><h2 id="2-1-Authentication-Service"><a href="#2-1-Authentication-Service" class="headerlink" title="2.1. Authentication Service"></a>2.1. Authentication Service</h2><ul><li>如何实现用户登录和保持登录</li><li>会话表，session</li></ul><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-44-43.png" alt=""> </p><ul><li>用户Login之后<ul><li>创建一个session对象</li><li>并把seesion_key作为cookie返回给浏览器</li><li>浏览器将该值记录在浏览器的cookie中</li><li>用户每次想服务器发送的访问，都会自动带上该网站所有的cookie</li><li>此时服务器检测到cookie中的session_key是有效的，就认为用户登录了</li></ul></li><li>用户logout之后，从session table中删除对应的数据</li><li>Session table存在哪？<ul><li>数据库？</li><li>缓存？</li><li>都可以？</li><li>理论上都可以的，但是如果只存在cache中，一旦负责cache的机器宕机，就会有很多用户同时需要重新登录，所以存在数据库里更好一些，如果访问用户多的话，可以用cache做优化。</li></ul></li></ul><h2 id="2-2-Friendship-Service"><a href="#2-2-Friendship-Service" class="headerlink" title="2.2. Friendship Service"></a>2.2. Friendship Service</h2><h3 id="好友关系分类"><a href="#好友关系分类" class="headerlink" title="好友关系分类"></a>好友关系分类</h3><ul><li><p>单向好友关系（微博、twitter、Instagram）</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-19-50.png" alt=""> </p></li></ul><ul><li><p>双向好友关系（微信、Facebook）</p><ul><li><p>方案一：存为两条信息，A关注了B，B关注了A</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-31-39.png" alt=""> </p></li><li><p>方案二：存为一条信息，但查询的时候需要查询两次</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-34-58.png" alt=""> </p></li></ul></li><li><p>好友关系所涉及的操作非常简单，基本都是Key-value</p><ul><li>求某个user的所有关注对象</li><li>求某个user的所有粉丝</li><li>A关注B → 插入一条数据</li><li>B关注A → 删除一条数据</li></ul></li></ul><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3. 小结"></a>2.3. 小结</h2><ul><li>对于用户系统而言：<ul><li>写很少</li><li>读很多</li></ul></li><li>写操作很少，意味着<ul><li>从QPS角度来说，一台mysql就够了</li></ul></li><li>读操作很多，意味着<ul><li>可以使用memcached进行读操作的缓存优化</li></ul></li><li>进一步的问题，如果读写操作都很多怎么办？<ul><li>方法一：使用更多的数据库服务器分摊流量</li><li>方法二：使用像Redis这样的读写操作都很快的Cache-through型数据库<ul><li>Memcached是一个Cached-aside型的database,Client需要自己负责管理Cache-miss时的数据的loading</li></ul></li></ul></li></ul><h1 id="3-Storage-数据库的选取"><a href="#3-Storage-数据库的选取" class="headerlink" title="3. Storage 数据库的选取"></a>3. Storage 数据库的选取</h1><h2 id="3-1-数据库的选取原则SQL-vs-NoSQL"><a href="#3-1-数据库的选取原则SQL-vs-NoSQL" class="headerlink" title="3.1. 数据库的选取原则SQL vs NoSQL"></a>3.1. 数据库的选取原则SQL vs NoSQL</h2><ol><li><p>大部分情况用SQL和noSQL都可以</p></li><li><p>需要支持transaction的话不能选用NoSQL</p><p>什么是transaction？（交易）</p><p>transaction需要数据处理同时成立，比如在银行转账，A转给B10元，需要A-10和B+10同时成立</p></li><li><p>SQL型的数据库比较成熟，可以帮你做很多事，但是NoSQL很多事都要亲力亲为，比如序列化，多级索引</p></li><li><p>如果想省点服务器获得更高的性能，NoSQL更好，硬盘型的NoSQL比SQL一般要快10倍以上</p></li></ol><h2 id="3-2-好友关系的存储"><a href="#3-2-好友关系的存储" class="headerlink" title="3.2. 好友关系的存储"></a>3.2. 好友关系的存储</h2><ol><li><p>存在SQL</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-46-37.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-48-30.png" alt=""> </p></li><li><p>存在NoSQL</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-46-59.png" alt=""> </p></li></ol><h2 id="3-3-以Cassandra为例剖析经典的NOSQL数据结构"><a href="#3-3-以Cassandra为例剖析经典的NOSQL数据结构" class="headerlink" title="3.3. 以Cassandra为例剖析经典的NOSQL数据结构"></a>3.3. 以Cassandra为例剖析经典的NOSQL数据结构</h2><h4 id="Cassandra是一个三层结构-三元组结构-的NoSQL数据库"><a href="#Cassandra是一个三层结构-三元组结构-的NoSQL数据库" class="headerlink" title="Cassandra是一个三层结构(三元组结构)的NoSQL数据库:"></a>Cassandra是一个三层结构(三元组结构)的NoSQL数据库:</h4><p><strong>插入数据：insert(row_key,column_key,value)</strong></p><ol><li>第一层：row_key<ul><li>又称为hash_key，cassandra会根据这个key计算一个hash值，然后决定这条数据存在哪</li><li>是传统我们所说的key-value中的key</li><li>任何查询都需要带上这个key，但无法进行range query</li><li>最常用的row_key:uer_id</li></ul></li><li>第二层：column_key<ul><li>是排序的，可以进行range query</li><li>可以按column指定顺序排序，支持按column范围查询query(row_key,column_start,column_end)</li><li>可以是复合值，比如是一个timestamp+user_id的组合</li></ul></li><li>第三层：value<ul><li>一般是string</li><li>如果需要存很多信息的话，可以自己做序列化</li></ul></li></ol><h4 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL  vs NoSQL"></a>SQL  vs NoSQL</h4><ul><li><p>SQL的一条数据以行为单位，取出整个row作为一条数据</p></li><li><p>SQL的column实在Schema中事先指定好的，不能随意添加。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-14-51-02.png" alt=""> </p></li><li><p>NoSQL的column是动态的，无限大，可以随意添加</p></li><li><p>一条数据以grid为单位，row_key + column_key + value = 一条数据</p></li><li><p>只需要提前定义好column_key本身的格式（是int还是int+string）</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-15-10-31.png" alt=""> </p></li></ul><h4 id="Cassandra存储friendship"><a href="#Cassandra存储friendship" class="headerlink" title="Cassandra存储friendship"></a>Cassandra存储friendship</h4><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-16-25-51.png" alt=""> </p><p> 重要的信息，需要频繁查的信息不能放在value中，要放在column_key中</p><h4 id="Cassandra存储NewsFeed"><a href="#Cassandra存储NewsFeed" class="headerlink" title="Cassandra存储NewsFeed"></a>Cassandra存储NewsFeed</h4><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-16-30-49.png" alt=""> </p><p>将create_time存在column_key中可以按时间排序</p><h1 id="4-How-to-scale-单点失效"><a href="#4-How-to-scale-单点失效" class="headerlink" title="4. How to scale? 单点失效"></a>4. How to scale? 单点失效</h1><p>100M用户存在一台mysql数据库存的下，Storage没问题</p><p>通过Cache优化读操作之后，只有300QPS的写，QPS也没有问题</p><p>还有什么问题？</p><p><strong>单点失效 Simgle Point Failure</strong></p><p>万一某一台数据库挂了，短暂的挂：网站不可用了，彻底挂了：数据全部丢失</p><p><strong>需要做sharding和Replica</strong></p><h2 id="4-1-Sharding-数据拆分"><a href="#4-1-Sharding-数据拆分" class="headerlink" title="4.1. Sharding 数据拆分"></a>4.1. Sharding 数据拆分</h2><ul><li>按照一定的规则，将数据拆分成不同的部分，保存在不同的机器上</li><li>这样就算某个机器挂了，也不会导致网站100%不可用。</li></ul><h3 id="4-1-1-Sharding-in-SQL-vs-NoSQL"><a href="#4-1-1-Sharding-in-SQL-vs-NoSQL" class="headerlink" title="4.1.1. Sharding in SQL vs NoSQL"></a>4.1.1. Sharding in SQL vs NoSQL</h3><p>SQL自身不带Sharding功能，需要手动实现</p><p>以Cassandra为代表的NoSQL大多自带Sharding</p><p>这就是为什么发明NoSQL</p><h3 id="4-1-2-纵向拆分（Horiaontal-Sharding）"><a href="#4-1-2-纵向拆分（Horiaontal-Sharding）" class="headerlink" title="4.1.2. 纵向拆分（Horiaontal Sharding）"></a>4.1.2. 纵向拆分（Horiaontal Sharding）</h3><p>简单的纵向切分：</p><ul><li>user table 放一台数据库</li><li>Friendship Table 放一台数据库</li><li>Message Table 放一台数据库</li></ul><p>复杂的纵向切分：</p><ul><li>比如User Table里有如下信息：<ul><li>Email</li><li>Username</li><li>Password</li><li>push_preference</li><li>avatar</li></ul></li><li>一般email/username/password不会经常变动，而push_preference,avatar变动频率较高</li><li>可以把这样的一张表拆分成两个表，User Table 和User Profile Table<ul><li>将这两张表放在两台机器上</li><li>如果UserprofileTable挂了，不会影响user的正常登录操作</li></ul></li></ul><p>实际上就是将table按column进行切分，存储在不同的机器上</p><p>缺点：如果数据量很大，有很多很多个用户，纵向拆分之后，仍然很大</p><h3 id="4-1-3-横向拆分（核心）"><a href="#4-1-3-横向拆分（核心）" class="headerlink" title="4.1.3. 横向拆分（核心）"></a>4.1.3. 横向拆分（核心）</h3><p>一个粗暴的想法：</p><p>假如拆分Friendship Table，假设有10台数据库的机器，可以想到按照from_user_id%10来进行查分，这样做有什么问题？</p><p>假设10台机器不够用了，现在买了一台新机器，原来的%10变成了%11，几乎所有的数据都需要进行位置大迁移！！！！</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-17-38-23.png" alt=""> </p><p><strong>数据迁移造成的问题：</strong></p><ol><li>慢，牵一发而动全身</li><li>前一期间，服务器压力增大，容易宕机</li><li>容易造成数据不一致</li></ol><p>如何解决？</p><p><strong>一致性Hash算法</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-17-42-48.png" alt=""></p><p>更具体的内容听说在下一节，哈哈</p><h2 id="4-2-Replica-数据备份"><a href="#4-2-Replica-数据备份" class="headerlink" title="4.2. Replica 数据备份"></a>4.2. Replica 数据备份</h2><ul><li>通常的做法是：一式三份（重要的事情说三遍）</li><li>Replica同时还能分摊读请求</li></ul><p>剩下的内容听说也在下一节，哈哈</p><h1 id="5-缓存淘汰算法："><a href="#5-缓存淘汰算法：" class="headerlink" title="5. 缓存淘汰算法："></a>5. 缓存淘汰算法：</h1><p>缓存调度算法，缓存页面调度算法：先分配一定的页面空间，使用页面的时候首先去查询空间是否有该页面的缓存，如果有的话直接拿出来，如果没有的话先查询，如果页面空间没有满的时候，使用新页面的时候，就释放旧的页面空间，把新页面缓存起来，以便下次使用同样的页面的时候方便调用。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">def <span class="title">getUser</span><span class="params">(user_id)</span>:</span></div><div class="line"><span class="function">user </span>= cache.get(user_id)</div><div class="line">    <span class="keyword">if</span> user :</div><div class="line">      <span class="keyword">return</span> user</div><div class="line">    user = database.get(user_id)</div><div class="line">    cache.set(key, user)</div><div class="line">    <span class="keyword">return</span> user</div><div class="line">  </div><div class="line"><span class="function">def <span class="title">setUser</span><span class="params">(user)</span>:</span></div><div class="line"><span class="function">  cache.<span class="title">delete</span><span class="params">(user.user_id)</span></span></div><div class="line"><span class="function">  database.<span class="title">set</span><span class="params">(user)</span></span></div></pre></td></tr></table></figure><p><code>cache</code> 一般是有有效期的，也就是如果缓存中这个数据过期了，那就从缓存中清理出去。而<code>cache</code> 的实现过程和淘汰机制不同，会导致不同的性能表现。常见的就是IFIO，LRU，LFU缓存过期策略。</p><ol><li>FIFO(First In First Out) : 先进先出。淘汰掉很久以前进来的数据，而新数据等到之后再淘汰。也就是一个队列。</li><li>LRU (Least recently used) : 最近最少使用。淘汰最近不适用的数据</li><li>LFU (Least frequently used) : 最近使用次数最少。淘汰掉使用次数最少的页面。</li></ol><h2 id="5-1-FIFO"><a href="#5-1-FIFO" class="headerlink" title="5.1. FIFO"></a>5.1. FIFO</h2><p>按照“先进先出（First In，First Out）”的原理淘汰数据，正好符合队列的特性，数据结构上使用队列Queue来实现。</p><p>如下图：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-54-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-54-58.png" alt="img"></a></p><ol><li>新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动；</li><li>淘汰FIFO队列头部的数据；</li></ol><h2 id="5-2-LRU-Cache"><a href="#5-2-LRU-Cache" class="headerlink" title="5.2. LRU Cache"></a>5.2. LRU Cache</h2><p>（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，因此优先将最近没有被访问的数据删掉。</p><p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-56-25.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-56-25.png" alt="img"></a></p><ol><li>新数据插入到链表头部；</li></ol><ol><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ol><p>leetcode题目： <a href="https://leetcode.com/problems/lru-cache" target="_blank" rel="external">LRU Cache</a></p><blockquote><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="external">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; LRUCache cache = new LRUCache( 2 /* capacity */ );</div><div class="line">&gt;</div><div class="line">&gt; cache.put(1, 1);</div><div class="line">&gt; cache.put(2, 2);</div><div class="line">&gt; cache.get(1);       // returns 1</div><div class="line">&gt; cache.put(3, 3);    // evicts key 2</div><div class="line">&gt; cache.get(2);       // returns -1 (not found)</div><div class="line">&gt; cache.put(4, 4);    // evicts key 1</div><div class="line">&gt; cache.get(1);       // returns -1 (not found)</div><div class="line">&gt; cache.get(3);       // returns 3</div><div class="line">&gt; cache.get(4);       // returns 4</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>简单的说，就是保证基本的get和set的功能的同时，还要保证最近访问(get或put)的节点保持在限定容量的Cache中，如果超过容量则应该把LRU(近期最少使用)的节点删除掉。</p><p>思路：</p><p>题目要求利用LRU缓存淘汰机制，在<script type="math/tex">O(1)</script> 时间复杂度下实现缓存的加入和删除操作</p><p>代码：</p><h2 id="5-2-LFU-Cache"><a href="#5-2-LFU-Cache" class="headerlink" title="5.2. LFU Cache"></a>5.2. <a href="https://leetcode.com/problems/lfu-cache" target="_blank" rel="external">LFU Cache</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Design User System用户系统&lt;ul&gt;
&lt;li&gt;Mencached 优化数
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java常用笔记</title>
    <link href="http://yoursite.com/2018/01/27/Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/27/Java常用笔记/</id>
    <published>2018-01-27T14:51:05.000Z</published>
    <updated>2018-02-08T07:05:26.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA集合类ArrayList删除指定值元素"><a href="#JAVA集合类ArrayList删除指定值元素" class="headerlink" title="JAVA集合类ArrayList删除指定值元素"></a>JAVA集合类ArrayList删除指定值元素</h2><h3 id="错误做法："><a href="#错误做法：" class="headerlink" title="错误做法："></a>错误做法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i = 0, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    if(list.get(i) == 1) &#123;  </div><div class="line">       list.remove(i);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为删除了元素，但是未改变迭代的下标，这样当迭代到最后一个的时候就会抛异常。</p><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>)&#123;  </div><div class="line">       list.remove(i);  </div><div class="line">       len--;</div><div class="line">       i--;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>更好的一个做法</li></ul><p>List接口内部实现了Iterator接口，提供开发者一个iterator()得到当前list对象的一个iterator对象。所以我们还有一个更好的做法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </div><div class="line">    <span class="keyword">int</span> i = iterator.next();  </div><div class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </div><div class="line">        iterator.remove();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="比较、排序Comparator-Comparable"><a href="#比较、排序Comparator-Comparable" class="headerlink" title="比较、排序Comparator/Comparable"></a>比较、排序Comparator/Comparable</h2><h3 id="1-自定义的类后面需要按指定属性实现排序等操作"><a href="#1-自定义的类后面需要按指定属性实现排序等操作" class="headerlink" title="1.自定义的类后面需要按指定属性实现排序等操作"></a>1.自定义的类后面需要按指定属性实现排序等操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">double</span> salary;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.salary);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-已有模板，定义排序顺序（最大堆、最小堆）"><a href="#2-已有模板，定义排序顺序（最大堆、最小堆）" class="headerlink" title="2.已有模板，定义排序顺序（最大堆、最小堆）"></a>2.已有模板，定义排序顺序（最大堆、最小堆）</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//先定义一个比较器</span></div><div class="line">Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1,Integer e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1 - e2;<span class="comment">//最小堆，默认</span></div><div class="line">         <span class="comment">//return e2-e1;最大堆</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure><p>Long型数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure><h2 id="string和int相互转化"><a href="#string和int相互转化" class="headerlink" title="string和int相互转化"></a>string和int相互转化</h2><h3 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h3><ol><li>int i = Integer.parseInt(String s);</li><li>int i = Integer.valueOf(String s).intValue();</li></ol><h3 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h3><ol><li>String s = String.valueOf(i);</li><li>String s = Integer.toString(i);</li><li>String s= “”+i;</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA集合类ArrayList删除指定值元素&quot;&gt;&lt;a href=&quot;#JAVA集合类ArrayList删除指定值元素&quot; class=&quot;headerlink&quot; title=&quot;JAVA集合类ArrayList删除指定值元素&quot;&gt;&lt;/a&gt;JAVA集合类ArrayList删
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】新鲜事系统</title>
    <link href="http://yoursite.com/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/01/27/【九章系统设计】新鲜事系统/</id>
    <published>2018-01-27T13:14:27.000Z</published>
    <updated>2018-02-08T07:05:26.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统涉及面试的两种形式及常见问题"><a href="#系统涉及面试的两种形式及常见问题" class="headerlink" title="系统涉及面试的两种形式及常见问题"></a>系统涉及面试的两种形式及常见问题</h2><h3 id="设计某某系统"><a href="#设计某某系统" class="headerlink" title="设计某某系统"></a>设计某某系统</h3><p>设计微博、滴滴、微信、短网址系统、nosql数据库</p><h3 id="找问题"><a href="#找问题" class="headerlink" title="找问题"></a>找问题</h3><ul><li>网站挂了怎么办</li><li>网站太慢怎么办</li><li>流量增长怎么</li></ul><h3 id="面试官：请设计Twitter"><a href="#面试官：请设计Twitter" class="headerlink" title="面试官：请设计Twitter"></a>面试官：请设计Twitter</h3><h3 id="系统设计问题的4S分析法"><a href="#系统设计问题的4S分析法" class="headerlink" title="系统设计问题的4S分析法"></a>系统设计问题的4S分析法</h3><ul><li>Scenario场景<ul><li>需要设计哪些功能，设计的多牛</li><li>向面试官提问：features/QPS/DAU(日活跃用户)/inerfaces</li></ul></li><li>Servece服务<ul><li>将大系统拆分成小服务</li><li>Split/Application/Module</li></ul></li><li>Storage存储<ul><li>数据如何存储与访问</li><li>Schema(表头字段)/data/sql/nosql/File System</li></ul></li><li>Scale升级<ul><li>解决缺陷，处理可能遇到的问题</li><li>Sharding/optimize/soecial case</li></ul></li></ul><h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><h4 id="Scenario场景-Ask"><a href="#Scenario场景-Ask" class="headerlink" title="Scenario场景-Ask"></a>Scenario场景-Ask</h4><p>询问面试官：</p><ol><li>需要设计哪些功能</li><li>需要承受多大的访问量？<ol><li>日活跃用户DAU</li><li>Twitter:MAU ：313M+ DAU：150M+（一般MAU是DAU的2倍）</li></ol></li></ol><h4 id="Scenario场景-Analyze-amp-predict"><a href="#Scenario场景-Analyze-amp-predict" class="headerlink" title="Scenario场景-Analyze&amp;predict"></a>Scenario场景-Analyze&amp;predict</h4><ul><li>根据DAU计算并发用户数：<ul><li><code>日活跃*每个用户平均请求次数/一天多少秒 = 150M*60/86400 ~100k</code></li><li>峰值peak = 3*QPS ~300k</li><li>快速增长的产品：<ul><li>max peak users in 3 months = peak users*2</li></ul></li></ul></li><li>读频率Read QPS(Queries per second)<ul><li>300k</li></ul></li><li>写频率Write QPS<ul><li>5k</li></ul></li></ul><h4 id="QPS有什么用"><a href="#QPS有什么用" class="headerlink" title="QPS有什么用"></a>QPS有什么用</h4><ul><li>QPS = 100<ul><li>用笔记本做web服务器就可以</li></ul></li><li>QPS = 1k<ul><li>用一台好一点的web服务器就差不多</li><li>需要考虑Single Point Failure</li></ul></li><li>QPS = 1m<ul><li>需要假设一个1000台web服务器的集群</li><li>需要考虑如何Maintanance(某一台挂了怎么办)</li></ul></li><li>QPS和web server/database之间的关系<ul><li>一台web service 承受量是1k QPS</li><li>一台SQL Database 承受量是1k QPS</li><li>一台 no SQL Database 承受量是10k QPS</li></ul></li></ul><h4 id="Scenario场景-需要设计哪些功能"><a href="#Scenario场景-需要设计哪些功能" class="headerlink" title="Scenario场景-需要设计哪些功能"></a>Scenario场景-需要设计哪些功能</h4><ul><li><p>step1:列举需要的功能</p><ul><li>注册、登录</li><li>用户信息展示、编辑</li><li>上传照片、视频</li><li>搜索</li><li>发送、分享推文</li><li>时间轴</li><li>关注、取关用户</li></ul></li><li><p>step2:sort按功能优先级排序</p><p>​</p></li></ul><h3 id="Service服务"><a href="#Service服务" class="headerlink" title="Service服务"></a>Service服务</h3><p>将大的系统拆分为小服务</p><ol><li>replay重放需求</li><li>merge归并需求</li></ol><p><img src="https://i.loli.net/2018/01/17/5a5ec793139ea.png" alt=""> </p><h3 id="storage存储——数据如何存储与访问（最重点占50-）"><a href="#storage存储——数据如何存储与访问（最重点占50-）" class="headerlink" title="storage存储——数据如何存储与访问（最重点占50%）"></a>storage存储——数据如何存储与访问（最重点占50%）</h3><ul><li>关系型数据库SQL Database（结构化数据）MySQL<ul><li>用户信息</li></ul></li><li>非关系型数据库（非结构化数据）MangoDB<ul><li>推文</li><li>社交图谱</li></ul></li><li>文件系统<ul><li>图片、视频（Media files）</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/17/5a5ec9773713d.png" alt=""> </p><p>Step1：为每个service选择合适的存储结构</p><p>Step2：选好合适的存储结构之后，设计数据表的结果，需要存储哪些字段</p><p><img src="https://i.loli.net/2018/01/17/5a5eca2f1b538.png" alt=""> </p><h3 id="新鲜事系统News-Feed"><a href="#新鲜事系统News-Feed" class="headerlink" title="新鲜事系统News Feed"></a>新鲜事系统News Feed</h3><ul><li>什么是新鲜事News Feed?<ul><li>登录Faebook/Twitter/朋友圈之后看到的信息流</li><li>你的所有朋友发的信息的集合</li></ul></li><li>典型新鲜事系统<ul><li>Facebook</li><li>Twitter</li><li>朋友圈</li><li>RSS Reader（头条）</li></ul></li><li>新鲜事系统的核心因素<ul><li>关注与被关注</li><li>每个人看到的新鲜事是不同的</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>Pull模型：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用merge K sorted arrays的思想</div><div class="line">用户的时间线：-&gt;整合成-&gt;feed流</div><div class="line">A：An1,An2,...↘</div><div class="line">B: Bn1,Bn2,...    →An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：Cn1,Cn2,... ↗</div><div class="line">...</div></pre></td></tr></table></figure><ul><li>当用户查看News Feed时，获取其每一个好友的最近100条推文，merge这些推文，按时间排序展示给用户</li><li>复杂度分析：<ul><li>News Feed:加入用户关注了N个对象，则时间为N此DB read的时间（读取数据库）+ N路归并的时间（在内存中计算的O(logK)，时间忽略）读取数据库耗时很长</li><li>Post a tweet:一次DB write（写入数据库）时间</li></ul></li></ul></li><li><p>Push模型：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用户的News Feed List：用户D\E\F发了tweet，推送到其好友的List中</div><div class="line">A：D,E...↘</div><div class="line">B: F,...    →An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：E,F,... ↗</div><div class="line">...</div></pre></td></tr></table></figure><ul><li><p>为每个用户建立一个List存储池存储其好友的News Feed信息，当用户发送一个tweet之后，将该推文推送到每一个关注了他的用户的News Feed中.用户需要查看News Feed时只需要从他的News Feed中读取最近的100条即可</p><p><strong>关键词：Fanout</strong></p></li><li><p>复杂度分析</p><ul><li>News Feed：1次DB read(相比push模型快很多)</li><li>post a tweet：N个粉丝需要N次DB writes<ul><li>如果粉丝数量N巨大，写入粉丝News Feed List耗时大</li><li>但好处是可以用异步任务在后台执行，无需用户等待</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/18/5a5f76ad915ab.png" alt=""> </p><p>所有的用户公用一个表格，当一个用户发送推文时，他自己和他的关注着都将看到，所以插入n+1条数经验，owner_id为他自己和他的好友们，然后读取时在数据表中select owner_id为自己的。</p><p><img src="https://i.loli.net/2018/01/18/5a5f76056f895.png" alt=""> </p><p>Web Server 到Asynct是通过消息队列发送，比如RabitMQ，拿到任务后，先去好友关系表中拿到发文用户的关注者们，然后把消息加入News Feed Table</p><p>缺陷：</p><ol><li><p>浪费数据库，但硬盘很便宜，不需要考虑存储数据量大</p></li><li><p>如果粉丝数量很大，异步操作需要时间，有些粉丝不能及时看到大V发送的tweet</p><p>​</p></li></ol></li></ul></li></ul><h2 id="Design-Twitter"><a href="#Design-Twitter" class="headerlink" title="Design Twitter"></a><a href="https://leetcode.com/problems/design-twitter" target="_blank" rel="external">Design Twitter</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTwitter</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,User&gt; UsersList;</div><div class="line">        <span class="keyword">int</span> tweetTimeStamp = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> id;</div><div class="line">            <span class="keyword">int</span> userId;</div><div class="line">            <span class="keyword">int</span> timeStamp;</div><div class="line">            Tweet(<span class="keyword">int</span> id,<span class="keyword">int</span> useId,<span class="keyword">int</span> timeStamp)&#123;</div><div class="line">                <span class="keyword">this</span>.id = id;</div><div class="line">                <span class="keyword">this</span>.userId = useId;</div><div class="line">                <span class="keyword">this</span>.timeStamp = timeStamp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> uid;</div><div class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;Integer&gt; followers = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//被谁关注</span></div><div class="line">            List&lt;Integer&gt; followees = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//关注了谁</span></div><div class="line">            User(<span class="keyword">int</span> uid)&#123;</div><div class="line">                <span class="keyword">this</span>.uid = uid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</div><div class="line">            UsersList = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Compose a new tweet. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">            &#125;</div><div class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(tweetId,userId,tweetTimeStamp);</div><div class="line">            UsersList.get(userId).tweets.add(tweet);</div><div class="line">            tweetTimeStamp++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">            List&lt;Integer&gt; feeds = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">                <span class="keyword">return</span> feeds;</div><div class="line">            &#125;</div><div class="line">            Comparator&lt;Tweet&gt; cmp = <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet t1,Tweet t2)</span></span>&#123;</div><div class="line">                    <span class="keyword">return</span> t2.timeStamp - t1.timeStamp;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Queue&lt;Tweet&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>,cmp);</div><div class="line">            <span class="comment">//先处理自己的新鲜事</span></div><div class="line">            List&lt;Tweet&gt; ownTweets = UsersList.get(userId).tweets;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = ownTweets.size()-<span class="number">1</span>;i &gt;= ownTweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                heap.add(ownTweets.get(i));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//处理关注的人的新鲜事</span></div><div class="line">            List&lt;Integer&gt; followees = UsersList.get(userId).followees;</div><div class="line">            <span class="keyword">for</span>(Integer followee : followees)&#123;</div><div class="line">                List&lt;Tweet&gt; tweets = UsersList.get(followee).tweets;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tweets.size()-<span class="number">1</span>;i &gt;= tweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                    heap.add(tweets.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty())&#123;</div><div class="line">                feeds.add(heap.poll().id);</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> feeds;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果没有用户，新建用户</span></div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followeeId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followeeId);</div><div class="line">                UsersList.put(followeeId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followerId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followerId);</div><div class="line">                UsersList.put(followerId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || UsersList.get(followerId).followees.contains(followeeId))&#123;<span class="keyword">return</span>;&#125;</div><div class="line">            <span class="comment">//更新用户关注和被关注列表</span></div><div class="line">            UsersList.get(followeeId).followers.add(followerId);</div><div class="line">            UsersList.get(followerId).followees.add(followeeId);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || !UsersList.containsKey(followeeId) || !UsersList.containsKey(followerId) ||</div><div class="line">                    !UsersList.get(followerId).followees.contains(followeeId) || !UsersList.get(followeeId).followers.contains(followerId))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator =  UsersList.get(followeeId).followers.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator.next();</div><div class="line">                <span class="keyword">if</span>(i == followerId)&#123;</div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator2 =  UsersList.get(followerId).followees.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator2.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator2.next();</div><div class="line">                <span class="keyword">if</span>(i == followeeId)&#123;</div><div class="line">                    iterator2.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Twitter obj = <span class="keyword">new</span> Twitter();</div><div class="line">        obj.postTweet(<span class="number">1</span>,<span class="number">5</span>);</div><div class="line">        List&lt;Integer&gt; param_2 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.follow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        obj.postTweet(<span class="number">2</span>,<span class="number">6</span>);</div><div class="line">        List&lt;Integer&gt; param_3 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.unfollow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        List&lt;Integer&gt; param_4 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        DesignTwitter test = <span class="keyword">new</span> DesignTwitter();</div><div class="line">        test.test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实这里有个问题，就是follow unfollow post这些都是用户的操作，应该放在用户类里面的，然后再外部调用。有时间重写一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统涉及面试的两种形式及常见问题&quot;&gt;&lt;a href=&quot;#系统涉及面试的两种形式及常见问题&quot; class=&quot;headerlink&quot; title=&quot;系统涉及面试的两种形式及常见问题&quot;&gt;&lt;/a&gt;系统涉及面试的两种形式及常见问题&lt;/h2&gt;&lt;h3 id=&quot;设计某某系统&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="http://yoursite.com/2018/01/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/01/24/Java垃圾回收机制/</id>
    <published>2018-01-24T07:12:30.000Z</published>
    <updated>2018-01-24T07:12:31.002Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】图与搜索</title>
    <link href="http://yoursite.com/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/01/23/【九章算法基础班】图与搜索/</id>
    <published>2018-01-23T02:52:30.000Z</published>
    <updated>2018-02-08T07:05:26.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><ul><li><p>graph</p><ul><li>Clone Graph</li><li>Topological Sorting</li></ul></li><li><p>Search</p><ul><li><p>DFS</p></li><li><p>BFS:（O(m+n)m为边树，n为点数)</p><ul><li><p>遍历图</p><p>树的BFS需要用队列，在图中除了要用队列还需要用到hash表，用来存储节点是否被访问过</p><p>BFS还可以用于求深度，最短路径</p></li><li><p>简单图求最短路径</p></li><li><p>拓扑排序</p></li></ul></li></ul></li></ul><h2 id="BFS例题"><a href="#BFS例题" class="headerlink" title="BFS例题"></a>BFS例题</h2><h3 id="1-Clone-Graph"><a href="#1-Clone-Graph" class="headerlink" title="1. Clone Graph"></a>1. <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">Clone Graph</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p><p>OJ’s undirected graph serialization:</p><p>Nodes are labeled uniquely.</p><p> We use <code>#</code>as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.</p><p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.</p><p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p><ol><li>First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.</li><li>Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.</li><li>Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.</li></ol><p>Visually, the graph looks like the following:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      /   \</div><div class="line">&gt;     0 --- 2</div><div class="line">&gt;          / \</div><div class="line">&gt;          \_/</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定图中的一个节点，克隆整个图</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>考点：</p><ol><li>从一个点出发，把整张图的所有节点找到（BFS）nodes</li><li>获得nodes之后复制所有的点，将新老节点建立映射关系，存入hashmap中</li><li>根据老节点之间的关系和新老节点的映射关系，复制所有的边</li><li>最后返回给定的node对应的新节点</li></ol><p>还可以用DFS：</p><p>递归调用复制节点和邻居关系。</p><p>DFS的输入是旧结点，返回值是新节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphClone</span> </span>&#123;</div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> label;</div><div class="line">         List&lt;UndirectedGraphNode&gt; neighbors;</div><div class="line">         UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</div><div class="line">     &#125;</div><div class="line">     HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//用于存储新旧节点映射关系</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; oldNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//旧结点</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; newNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新节点</span></div><div class="line"></div><div class="line">    <span class="comment">//bfs获取图中所有的点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node)</span></span>&#123;</div><div class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        HashSet&lt;UndirectedGraphNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        queue.add(node);</div><div class="line">        set.add(node);</div><div class="line">        <span class="comment">//BFS</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            UndirectedGraphNode temp = queue.poll();</div><div class="line">            UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(temp.label);</div><div class="line">            oldNodes.add(temp);<span class="comment">//加入旧点集</span></div><div class="line">            newNodes.add(newNode);<span class="comment">//加入新点集</span></div><div class="line">            nodeMap.put(temp,newNode);<span class="comment">//加入mapping</span></div><div class="line"></div><div class="line">            <span class="comment">//遍历当前节点的所有邻居</span></div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : temp.neighbors)&#123;</div><div class="line">                <span class="comment">//如果已经加入结合了，跳过</span></div><div class="line">                <span class="keyword">if</span>(set.contains(neighbor))&#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果还未加入</span></div><div class="line">                queue.add(neighbor);</div><div class="line">                set.add(neighbor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取图中所有的节点</span></div><div class="line">        bfs(node);</div><div class="line">        <span class="comment">//复制所有的边</span></div><div class="line">        <span class="keyword">for</span>(UndirectedGraphNode oldNode : oldNodes)&#123;</div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : oldNode.neighbors)&#123;</div><div class="line">                nodeMap.get(oldNode).neighbors.add(nodeMap.get(neighbor));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回node对应的新节点</span></div><div class="line">        <span class="keyword">return</span> nodeMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DFS：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">dfs</span><span class="params">(UndirectedGraphNode node,HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(map.containsKey(node))&#123;</div><div class="line">        <span class="keyword">return</span> map.get(node);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新建节点</span></div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node,newNode);</div><div class="line">    <span class="comment">//遍历邻居节点</span></div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">        newNode.neighbors.add(dfs(neighbor,map));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">    HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(node,map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h3><p>下面这个图假设是一种上课顺序，比如上1之前必须上0。求这个图的任意一个拓扑排序（按照这个顺序上课则可以上完所有课）</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></a></p><p>拓扑排序很好的参考资料：<a href="http://www.stoimen.com/blog/2012/10/01/computer-algorithms-topological-sort-of-a-graph/" target="_blank" rel="external">Topological Sort of a Graph</a></p><p>拓扑排序的思路如下：</p><ol><li>统计当前入度为0的点，加入队列</li><li>将当前所有入度为0的点删掉，并将这些点的下一点的连线删掉，将其下一个节点的入度减1</li><li>重复1和2，直到所有的点都被删掉</li><li>如果不能拓扑排序说明图中一定有环</li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" alt="img"></a></p><h3 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a><a href="http://www.lintcode.com/en/problem/topological-sorting/" target="_blank" rel="external">Topological Sorting</a></h3><blockquote><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p><ul><li>For each directed edge <code>A -&gt; B</code> in graph, A must before B in the order list.</li><li>The first node in the order can be any node in the graph with no nodes direct to it.</li></ul><p>Find any topological order for the given graph.</p><p>Example</p><p>For graph as follow:</p></blockquote><p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></p><blockquote><p>The topological order can be:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [0, 1, 2, 3, 4, 5]</div><div class="line">&gt; [0, 2, 3, 1, 5, 4]</div><div class="line">&gt; ...</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>核心就是根据拓扑排序给出一条合理的路径，能够遍历图中所有的点，且不违背箭头顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    HashMap&lt;DirectedGraphNode,Integer&gt; degreeIn = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    Queue&lt;DirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    ArrayList&lt;DirectedGraphNode&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//计算入度出度</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode nodeFrom : graph) &#123;</div><div class="line">        <span class="keyword">for</span> (DirectedGraphNode nodeEnd : nodeFrom.neighbors) &#123;</div><div class="line">            <span class="comment">//计算NodeEnd入度</span></div><div class="line">            <span class="keyword">if</span> (!degreeIn.containsKey(nodeEnd)) &#123;</div><div class="line">                degreeIn.put(nodeFrom, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                degreeIn.put(nodeEnd, degreeIn.get(nodeEnd) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs</span></div><div class="line">    <span class="comment">//queue.add(graph.get(0));</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">        <span class="keyword">if</span>(!degreeIn.containsKey(node))&#123;</div><div class="line">            queue.offer(node);</div><div class="line">            results.add(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        DirectedGraphNode node = queue.poll();</div><div class="line">        <span class="comment">//results.add(node);</span></div><div class="line">        <span class="keyword">for</span>(DirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">            degreeIn.put(neighbor,degreeIn.get(neighbor)-<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(degreeIn.get(neighbor) == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(neighbor);</div><div class="line">                results.add(neighbor);</div><div class="line">                <span class="comment">//numNodes--;</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule" target="_blank" rel="external">Course Schedule</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0]]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0],[0,1]]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p></blockquote><p>给定课程门数，和课程之间的依赖关系，判断是否可以无冲突完成课程。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>BFS和DFS都可以做</p><p>BFS：</p><p>拓扑排序的思想，如果最后所有的点都被访问到了，就是可以的，反之不可以。</p><p>DFS：</p><p>用DFS的核心思想就是遇到某条路径上有环就可以返回false，不用继续判断了。所以需要用一个visited数组来保存节点的访问状态。当沿着某一条路径前进时遇到之前已经访问过的节点，就返回false，如果一直没有出现环则在最后返回true。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] classDegreeIn = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录入度</span></div><div class="line">        <span class="keyword">int</span>[] classDegreeOut = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录出度</span></div><div class="line">        HashMap&lt;Integer,List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            classDegreeIn[edgeEnd]++;</div><div class="line">            classDegreeOut[edgeFrom]++;</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom,<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom,listTemp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//寻找入度为0的点入栈</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numCourses;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(classDegreeIn[i] == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(i);</div><div class="line">                counter++;</div><div class="line">                <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">                hasVisited[i] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> classID = queue.poll();</div><div class="line">            <span class="keyword">if</span>(edges.getOrDefault(classID,<span class="keyword">new</span> ArrayList&lt;&gt;()).size() == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历classID的所有邻居，将其入度-1</span></div><div class="line">            <span class="keyword">for</span>(Integer neighbor : edges.get(classID))&#123;</div><div class="line">                classDegreeIn[neighbor]--;</div><div class="line">                <span class="comment">//如果入度为0,入栈</span></div><div class="line">                <span class="keyword">if</span>(classDegreeIn[neighbor] == <span class="number">0</span>)&#123;</div><div class="line">                    queue.add(neighbor);</div><div class="line">                    counter++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter == numCourses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DFS：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used,HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges,Integer node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(used[node])&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(edges.containsKey(node)) &#123;</div><div class="line">            used[node] = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(Integer next: edges.get(node))&#123;</div><div class="line">                <span class="keyword">if</span>(!dfs(used,edges,next))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            used[node] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line"></div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom, <span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom, listTemp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Integer node : edges.keySet())&#123;</div><div class="line">            <span class="keyword">if</span>(!dfs(used,edges,node))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p></blockquote><p>求从起点到终点的最短路径长度</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>求路径长度一般用BFS，从起点开始把相差一个字母的单词一次入队列，知道遇到结束词时， 此时bfs的深度就是最短路径长度。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(beginWord);</div><div class="line">        <span class="keyword">int</span> step = <span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> queueSize = queue.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;</div><div class="line">                String temp  = queue.peek();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">                        <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;</div><div class="line">                            <span class="keyword">return</span> step;</div><div class="line">                        &#125;</div><div class="line">                        queue.add(wordList.get(j));</div><div class="line">                        isUsed[j] = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                queue.poll();</div><div class="line">            &#125;</div><div class="line">            step++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">        <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a><a href="https://leetcode.com/problems/word-ladder-ii" target="_blank" rel="external">Word Ladder II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>Return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</div><div class="line">&gt;   ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>返回所有的路径长度最短的合法路径。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>找到合法路径，考虑用BFS，找到所有合法的路径，考虑用DFS，这道题目要求找到路径最短的所有合法路径，所以是一道BFS和DFS的综合题目。</p><p>如果只用DFS找的话，要遍历所有的路径，势必会超时（我试了，真的超时）</p><p>所以采用dfs和bfs结合的办法：</p><p>先从endWord到beginWord用BFS找到最短的路径是多少，同时标记经过的点到endWord的最短距离是多少</p><p>然后再用DFS从beginWord到endWord找到确定的路径，此时只需要遍历之前遍历过的点，其余的没有经过的点无需遍历，而且可以按距离顺序来遍历，将所有合法的路径加入的结果结合中。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] disToBegin;<span class="comment">//记录距离起点的距离</span></div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs从后向前寻找最短路径长度,标记点到终点的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(endWord);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//endword深度为0</span></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            depth++;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                String temp = queue.poll();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;wordList.size();i++)&#123;</div><div class="line">                    String word = wordList.get(i);</div><div class="line">                    <span class="comment">//如果单词已经加入过队列了，或者和当前节点相差不为1，跳过</span></div><div class="line">                    <span class="keyword">if</span>(word.equals(endWord) || disToBegin[i] &gt; <span class="number">0</span> || !isValid(temp,word))&#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(word.equals(beginWord))&#123;</div><div class="line">                        <span class="keyword">return</span> depth;<span class="comment">//begin节点深度</span></div><div class="line">                    &#125;</div><div class="line">                    queue.add(word);</div><div class="line">                    disToBegin[i] = depth;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从前向后dfs确定具体路径</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String tempWord, String endWord,List&lt;String&gt; wordList,<span class="keyword">int</span> depth)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            temp.add(endWord);</div><div class="line">            results.add(temp);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disToBegin.length;i++)&#123;</div><div class="line">            String wordNext = wordList.get(i);</div><div class="line">            <span class="comment">//寻找深度和字母都符合的单词</span></div><div class="line">            <span class="keyword">if</span>(disToBegin[i] != depth || !isValid(tempWord,wordNext))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(wordNext);</div><div class="line">            dfs(wordNext,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//List&lt;String&gt; words = new ArrayList&lt;&gt;(wordList);</span></div><div class="line">        wordList.add(beginWord);</div><div class="line">        disToBegin = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</div><div class="line">        <span class="keyword">int</span> depth = bfs(beginWord,endWord,wordList);</div><div class="line">        result.add(beginWord);</div><div class="line">        dfs(beginWord,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="DFS排列组合"><a href="#DFS排列组合" class="headerlink" title="DFS排列组合"></a>DFS排列组合</h2><p>排列：</p><p><a href="https://leetcode.com/problems/permutations" target="_blank" rel="external">Permutations</a>   </p><p><a href="https://leetcode.com/problems/permutations-ii" target="_blank" rel="external">Permutations II</a>   </p><p>组合：</p><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning" target="_blank" rel="external">Palindrome Partitioning</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,<br>Return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>DFS，对字符串进行分割</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            i++;j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//规定左段包含i,右段不包含i</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end;i++)&#123;</div><div class="line">            String left = s.substring(start,i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(!Palindrome(left))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(left);</div><div class="line">            helper(s,i+<span class="number">1</span>,end);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        helper(s,<span class="number">0</span>,s.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/combination-sum" target="_blank" rel="external">Combination Sum</a> </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>找所有方案的问题一般都是DFS，90%的DFS是排列或者组合。</p><h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 <a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="external">Matrix</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p><p>The distance between two adjacent cells is 1.</p><p><strong>Example 1: </strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2: </strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 1 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 2 1</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>计算每个点距离最近的0的距离</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一:</p><p>用BFS，先将所有0的位置放入队列，然后出队列，将其周围点置位1，如队列，然后出队，将其周围点置为2，以此类推。</p><p>方法二：</p><p>动态规划，先从左上到右下计算每个点离最近的0的距离</p><p>然后从右下到左上再来一遍</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">  <span class="keyword">int</span> rows = matrix.length;</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">        dist[i][j] = <span class="number">0</span>;</div><div class="line">        queue.add(i*cols+j);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        dist[i][j] = -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size&gt;<span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> location = queue.poll();</div><div class="line">      <span class="keyword">int</span> row = location/cols;</div><div class="line">      <span class="keyword">int</span> col = location%cols;</div><div class="line">      <span class="keyword">int</span>[] rdelta = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">      <span class="keyword">int</span>[] cdelta = &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> new_row = row+rdelta[i];</div><div class="line">        <span class="keyword">int</span> new_col = col+cdelta[i];</div><div class="line">        <span class="keyword">if</span>(new_row &gt;=<span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_col &lt; cols &amp;&amp; dist[new_row][new_col] == -<span class="number">1</span>)&#123;</div><div class="line">          dist[new_row][new_col] = depth;</div><div class="line">          queue.add(new_row * cols + new_col);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dist;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dist;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="comment">//First pass: check for left and top</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</div><div class="line">                    dist[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    dist[i][j] = rows+cols;</div><div class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//Second pass: check for bottom and right</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Pacific-Atlantic-Water-Flow"><a href="#Pacific-Atlantic-Water-Flow" class="headerlink" title="Pacific Atlantic Water Flow"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="external">Pacific Atlantic Water Flow</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p><p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p><p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p><p><strong>Note:</strong></p><ol><li>The order of returned grid coordinates does not matter.</li><li>Both <em>m</em> and <em>n</em> are less than 150.</li></ol><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 5x5 matrix:</div><div class="line">&gt;</div><div class="line">&gt;   Pacific ~   ~   ~   ~   ~ </div><div class="line">&gt;        ~  1   2   2   3  (5) *</div><div class="line">&gt;        ~  3   2   3  (4) (4) *</div><div class="line">&gt;        ~  2   4  (5)  3   1  *</div><div class="line">&gt;        ~ (6) (7)  1   4   5  *</div><div class="line">&gt;        ~ (5)  1   1   2   4  *</div><div class="line">&gt;           *   *   *   *   * Atlantic</div><div class="line">&gt; Return:</div><div class="line">&gt; [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>矩阵左上是pacific 右下是atlantic,找出所有水能够同时流向两个ocean的位置</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用dfs，对pacific ocean从边缘的每一个点向内dfs搜索可以到达的点，就是考虑每一个点的上下左右四个邻居是否比自己高，如果比自己高而且之前还没有遍历过，就继续dfs。对atlantic做同样的操作。两边都可以到达的加入结果集。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] pacific,<span class="keyword">boolean</span>[][] used)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; rows || j &gt; cols)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        pacific[i][j] = <span class="keyword">true</span>;</div><div class="line">        used[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span>[] r_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] c_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> id = <span class="number">0</span> ; id  &lt; <span class="number">4</span>; id++)&#123;</div><div class="line">            <span class="keyword">int</span> new_row = i + r_delta[id];</div><div class="line">            <span class="keyword">int</span> new_col = j + c_delta[id];</div><div class="line">            <span class="keyword">if</span>(new_row &gt;= <span class="number">0</span> &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &lt; cols &amp;&amp; !used[new_row][new_col] &amp;&amp;matrix[new_row][new_col] &gt;= matrix[i][j])&#123;</div><div class="line">                <span class="comment">//pacific[new_row][new_col] = true;</span></div><div class="line">                dfs(matrix,new_row,new_col,pacific,used);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] pacific = n，ew <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理pacific</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[0][i] = true;</span></div><div class="line">            dfs(matrix,<span class="number">0</span>,i,pacific,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][0] = true;</span></div><div class="line">            dfs(matrix,i,<span class="number">0</span>,pacific,used);</div><div class="line">        &#125;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理atlantic</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[rows-1][i] = true;</span></div><div class="line">            dfs(matrix,rows-<span class="number">1</span>,i,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][cols-1] = true;</span></div><div class="line">            dfs(matrix,i,cols-<span class="number">1</span>,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//两个都是true的位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])&#123;</div><div class="line">                    results.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="external">Minesweeper</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定棋盘和点击的点，返回点击之后的棋盘</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>分两种情况讨论，如果点到的地雷，就显示地雷即可；</p><p>如果没有点到地雷，则要从这个点开始dfs计算其周围的每个点周围的8个点处有多少个地雷，如果没有就改成B，如果有的话显示数字。对于显示数字的点就无需继续dfs其周围的点了。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minesweeper</span> </span>&#123;</div><div class="line">    <span class="comment">//计算某个位置周围有多少个地雷</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calSweeper</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">            <span class="keyword">if</span>(i+x_delta[ii] &lt; <span class="number">0</span> || j+y_delta[ii] &lt; <span class="number">0</span> || i+x_delta[ii] &gt;= rows || j+y_delta[ii] &gt;= cols)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(board[i+x_delta[ii]][j+y_delta[ii]] == <span class="string">'M'</span>)&#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="comment">//如果出界了，返回</span></div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || board[i][j] == <span class="string">'B'</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'E'</span>)&#123;</div><div class="line">            <span class="keyword">int</span> sum = calSweeper(board,i,j);</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'B'</span>;</div><div class="line">                <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">                <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">                    <span class="comment">//如果还没点过，计算它周围有多少个地雷</span></div><div class="line">                    dfs(board,i+x_delta[ii],j+y_delta[ii]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                board[i][j] = Integer.toString(sum).charAt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="comment">//如果点到地雷</span></div><div class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)&#123;</div><div class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没点到地雷</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(board,click[<span class="number">0</span>],click[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Minesweeper test = <span class="keyword">new</span> Minesweeper();</div><div class="line">        <span class="keyword">char</span>[][] board = &#123;&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'M'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;&#125;;</div><div class="line">        <span class="keyword">char</span>[][] result = test.updateBoard(board,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">0</span>&#125;);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="external">Minimum Height Trees</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p><p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p><p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p><p><strong>Example 1:</strong></p><p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         0</div><div class="line">&gt;         |</div><div class="line">&gt;         1</div><div class="line">&gt;        / \</div><div class="line">&gt;       2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[1]</code></p><p><strong>Example 2:</strong></p><p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0  1  2</div><div class="line">&gt;       \ | /</div><div class="line">&gt;         3</div><div class="line">&gt;         |</div><div class="line">&gt;         4</div><div class="line">&gt;         |</div><div class="line">&gt;         5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[3, 4]</code></p></blockquote><p>选取图中某一点作为root，使得形成的树高度最小，返回所有高度最小的root点。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用BFS计算了每一个点作为root的深度，超时了。。。。</p><p>逐层去掉叶子节点，留下的就是作为root树高最小的节点。思路不难，但还是写了好久</p><p>步骤：</p><ol><li>存储图中节点的度数和点边关系</li><li>把度数为1的节点加入叶子节点集合</li><li>遍历叶子节点，将与之相连的节点的度数-1，然后将叶子节点删除，同时，如果有节点的度数为1，说明是下一层的叶子节点，加入新叶子集合</li><li>当新叶子集合的大小&lt;=2时，说明找到了最终的MHT的root</li></ol><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界条件处理</span></div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            res.add(<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储点边关系</span></div><div class="line">        List&lt;HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            map.add(<span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="keyword">int</span>[] edgesNum = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储节点的度数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;edges.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> node1 = edges[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> node2 = edges[i][<span class="number">1</span>];</div><div class="line">            edgesNum[node1]++;</div><div class="line">            edgesNum[node2]++;</div><div class="line">            map.get(node1).add(node2);</div><div class="line">            map.get(node2).add(node1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> counter = n;</div><div class="line">      <span class="comment">//叶子节点加入结合</span></div><div class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(edgesNum[i] == <span class="number">1</span>)&#123;</div><div class="line">                leaves.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//遍历叶子节点，将与之相连的点的度数-1，删去叶子节点</span></div><div class="line">        <span class="keyword">while</span> (counter &gt; <span class="number">2</span>)&#123;</div><div class="line">            counter -= leaves.size();</div><div class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存储下一轮的新叶子节点</span></div><div class="line">            <span class="keyword">for</span>(Integer leave : leaves)&#123;</div><div class="line">                edgesNum[leave]--;</div><div class="line">                <span class="keyword">for</span>(Integer node : map.get(leave))&#123;</div><div class="line">                    edgesNum[node]--;</div><div class="line">                    <span class="keyword">if</span>(edgesNum[node] == <span class="number">1</span>)&#123;<span class="comment">//遇到度数为1的节点就是下一轮的叶子节点</span></div><div class="line">                        newLeaves.add(node);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            leaves = newLeaves;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Maze"><a href="#The-Maze" class="headerlink" title="The Maze"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="external">The Maze</a></h3><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><blockquote><p>There is a <strong>ball</strong> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <strong>up</strong>, <strong>down</strong>, <strong>left</strong> or <strong>right</strong>, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p><p>Given the ball’s <strong>start position</strong>, the <strong>destination</strong> and the <strong>maze</strong>, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of <strong>empty spaces</strong> traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p><p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p><p><strong>Example 1</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (4, 4)</div><div class="line">&gt;</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: One shortest way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</div><div class="line">&gt;              The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (3, 2)</div><div class="line">&gt;</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: There is no way for the ball to stop at the destination.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>矩阵中1是障碍，0是通的，小球从start滚到destination，不遇到障碍或者边界小球不会停下来，返回小球是否可以从start滚到end</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>BFS，小球从起点开始可以向上下左右四个方向滚，每次滚到障碍或者边界处，滚到终点就返回true</p><p>另外需要一个数组记录小球是否到过该节点，如果到过，后续就无需再走这里了。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">if</span>(node[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; node[<span class="number">1</span>] == destination[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">while</span>(newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>)&#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]])&#123;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii],newStartY - y_delta[ii]&#125;);</div><div class="line">                    visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Maze-II"><a href="#The-Maze-II" class="headerlink" title="The Maze II"></a><a href="https://leetcode.com/problems/the-maze-ii" target="_blank" rel="external">The Maze II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>跟上一题一样，这个题要求返回从起点滚到终点的最短路径长度。如果滚不到就返回-1</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>用一个二维数组记录地图中的点到start的距离。BFS更新计算start到能够到达的点的最小距离，最后返回二维数组中的终点的值。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;distance.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; distance[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                distance[i][j] = Integer.MAX_VALUE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录走了多少步</span></div><div class="line">                <span class="keyword">while</span> (newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>) &#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果这条路径到达该点比之前的距离短，更新该点的最短距离</span></div><div class="line">                <span class="keyword">if</span> (distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count &lt; distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]]) &#123;</div><div class="line">                    distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]] = distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii], newStartY - y_delta[ii]&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] &lt; Integer.MAX_VALUE ? distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;graph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clone Graph&lt;/li&gt;
&lt;li&gt;T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】BFS问题</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90leetcode%E3%80%91BFS%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/20/【leetcode】BFS问题/</id>
    <published>2018-01-20T14:42:20.000Z</published>
    <updated>2018-02-08T07:05:26.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares" target="_blank" rel="external">Perfect Squares</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>典型的BFS题目</p><p>方法：</p><p>需要一个队列记录当前剩余的和。</p><p>首先将n加入队列，然后n出队列，计算小于他的最大平方数，然后递减计算剩余的数字差，如如队列，层数+1</p><p>当队列中有某一层出现剩余的和为0的时候说明找到了一条合法相加形式，此时就是所需的最少数组组合，返回此时的depth即可。</p><p>优化：DP</p><p>dp[n]：记录n可以由几个平方数加和得到</p><p>递推公式：dp[n] = min(dp[n-1]+1,dp[n-4]+1,dp[n-9]+1,……)</p><p>初始化：</p><p>​    dp[0] = 0;</p><p>​    dp[1] = 1;</p><p>返回值：dp[n]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(n);</div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = queue.poll();</div><div class="line">      <span class="comment">//计算小于等于n的最大的平方数</span></div><div class="line">      <span class="keyword">int</span> maxSquare = (<span class="keyword">int</span>) Math.sqrt(temp);</div><div class="line">      <span class="keyword">while</span>(maxSquare &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> sumLeft = temp - maxSquare*maxSquare;</div><div class="line">        <span class="keyword">if</span>(sumLeft == <span class="number">0</span>)&#123;<span class="comment">//和等于0了</span></div><div class="line">          <span class="keyword">return</span> depth;</div><div class="line">        &#125;</div><div class="line">        queue.add(sumLeft);</div><div class="line">        maxSquare--;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//动态规划</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)&#123;</div><div class="line">    <span class="keyword">int</span> dpMinTemp = dp[i-<span class="number">1</span>] +<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= i;j++)&#123;</div><div class="line">      dpMinTemp = Math.min(dpMinTemp,dp[i - j*j] +<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    dp[i] = dpMinTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Perfect-Squares&quot;&gt;&lt;a href=&quot;#Perfect-Squares&quot; class=&quot;headerlink&quot; title=&quot;Perfect Squares&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/pe
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】DFS问题</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90leetcode%E3%80%91DFS%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/20/【leetcode】DFS问题/</id>
    <published>2018-01-20T14:31:36.000Z</published>
    <updated>2018-02-08T07:05:26.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p><p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p><p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p><p>如上图的例子，DFS访问数组为：ABDECFG。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p><p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     struct TreeLinkNode &#123;</div><div class="line">&gt;       TreeLinkNode *left;</div><div class="line">&gt;       TreeLinkNode *right;</div><div class="line">&gt;       TreeLinkNode *next;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li></ul><p>For example,<br>Given the following perfect binary tree,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2    3</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4  5  6  7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>After calling your function, the tree should look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1 -&gt; NULL</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2 -&gt; 3 -&gt; NULL</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4-&gt;5-&gt;6-&gt;7 -&gt; NULL</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>就是将同一层上的节点的next指向右边的节点</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>tag是DFS，但我一开始想到的是BFS。</p><ol><li>BFS：</li></ol><p>将每一层节点加入队列，出队列时，左边节点的next指向右边节点。</p><p>但DFS会更快一些</p><ol><li>DFS：</li></ol><p>用DFS的核心思想是对于一个节点来说，将其左孩子的next指向右孩子，其右孩子的next指向其本身next节点的左孩子。</p><p>题目要求不能引入额外的空间，所以更应该用dfs的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersinEachNode</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> val;</div><div class="line">         TreeLinkNode left, right, next;</div><div class="line">         TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">     &#125;</div><div class="line"><span class="comment">//BFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">        Queue&lt;TreeLinkNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> len = queue.size();</div><div class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//如果是本层最后一个了，其next指向NULL</span></div><div class="line">                TreeLinkNode temp = queue.poll();</div><div class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">                    temp.next = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果不是本层最后一个，其next指向下一个节点</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    temp.next = queue.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.right);</div><div class="line">                &#125;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//DFS</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfshelper</span><span class="params">(TreeLinkNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            root.left.next = root.right;</div><div class="line">            <span class="keyword">if</span>(root.next !=<span class="keyword">null</span>)&#123;</div><div class="line">                root.right.next = root.next.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                root.right.next = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            dfshelper(root.left);</div><div class="line">            dfshelper(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//DFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDFS</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">         root.next = <span class="keyword">null</span>;</div><div class="line">         dfshelper(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \      \</div><div class="line">&gt;         7    2      1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p></blockquote><p>给定二叉树和一个整数sum,返回二叉树中是否存在一条从root到叶子的路径，长度为sum</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>DFS，分别对节点的左右孩子做DFS，sum需减掉当前节点的值。</p><p>当遇到叶子节点，且该点的值==sum时，即找到了一条合法路径，返回true</p><p>这里需要注意的是测试样例中有负数的情况，所以不能根据剩余的sum值进行剪枝。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfshelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//sum == root且root是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(sum == root.val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.left, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.right, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dfshelper(root,sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Path Sum II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \    / \</div><div class="line">&gt;         7    2  5   1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;    [5,4,11,2],</div><div class="line">&gt;    [5,8,4,5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>跟上一题一样的，这次要把合法路径全都记录下来返回。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(root.val);</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.add(root.val);</div><div class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.left,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.right,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        helper(root,sum);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii" target="_blank" rel="external">Path Sum III</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</div><div class="line">&gt;</div><div class="line">&gt;       10</div><div class="line">&gt;      /  \</div><div class="line">&gt;     5   -3</div><div class="line">&gt;    / \    \</div><div class="line">&gt;   3   2   11</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 3  -2   1</div><div class="line">&gt;</div><div class="line">&gt; Return 3. The paths that sum to 8 are:</div><div class="line">&gt;</div><div class="line">&gt; 1.  5 -&gt; 3</div><div class="line">&gt; 2.  5 -&gt; 2 -&gt; 1</div><div class="line">&gt; 3. -3 -&gt; 11</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>跟前面两道的不同是：起止点不一定是root和leaf可以是树中的任意两点</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>方法一：双层递归</p><p>对树中的每一个节点都进行搜索，从该点开始是否有合法路径。</p><p>可以转化为，对根节点搜索sum合法路径，然后对根节点的左右节点分别搜索sum合法路径，其中对其左右节点搜索合法路径时，也需要对其自身和其左右节点分别搜索，这是外层递归</p><p>搜索路径长度本身又是一层递归，每次减掉当前节点val，这是第二层递归</p><p>方法二：前缀长度</p><p>计算从root到每一个节点的路径长度，存储在一个hashmap中，key为root到树种节点的路径长度，value为出现次数。</p><p>当计算到某一个节点时，从root到该节点的路径长度为len，则以该节点为结尾的合法路径的个数为map中key为sum-len的value值。</p><p>注意：每次回退时需要将root到这点的路径长度在hashmap中的value-1。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>方法一：双层递归</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果到当前点已经是合法路径了，res+1</span></div><div class="line">        <span class="keyword">if</span>(root.val == sum)&#123;</div><div class="line">            res++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//接续沿着左右节点寻找是否还有合法路径</span></div><div class="line">        res += helper(root.left,sum - root.val);</div><div class="line">        res += helper(root.right,sum - root.val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：前缀搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum,<span class="keyword">int</span> fromR)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = fromR + root.val;</div><div class="line">        res += map.getOrDefault(temp - sum,<span class="number">0</span>);</div><div class="line">        map.put(temp,map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</div><div class="line">        res = res + helper(root.left,sum,temp)+helper(root.right,sum,temp);</div><div class="line">        map.put(temp,map.get(temp)-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-IV"><a href="#Path-Sum-IV" class="headerlink" title="Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv" target="_blank" rel="external">Path Sum IV</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>If the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.</p><p>For each integer in this list:</p><ol><li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li><li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree.</li><li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li></ol><p>Given a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 215, 221]</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is:</div><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   5   1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 5) + (3 + 1) = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 221]</div><div class="line">&gt; Output: 4</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is: </div><div class="line">&gt;     3</div><div class="line">&gt;      \</div><div class="line">&gt;       1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 1) = 4.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>以数组的形式给定一棵二叉树，用三位数表示节点，其中百位代表层数，十位代表在某一层中从左到右的位置，各位代表节点数值，计算从root到每一个leaf的路径长度之和。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>假设一个几点的百位和十位是xy，则其左孩子和右孩子分别是：</p><p>left：(x+1)(2y-1)</p><p>right：(x+1)(2y)</p><p>可以根据这个性质，将数组中的节点放入hashmap中，key为百位十位，value为节点值。然后在map中寻找左右节点进行DFS，当遍历到叶子节点时，将本条路径长度加入路径长度总和。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> root,<span class="keyword">int</span> res)</span></span>&#123;</div><div class="line">  res += map.get(root);</div><div class="line">  <span class="keyword">int</span> left = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>;</div><div class="line">  <span class="comment">//如果左右都没有了路径了，是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(!map.containsKey(left) &amp;&amp; !map.containsKey(right))&#123;</div><div class="line">    sum += res;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果左边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(left))&#123;</div><div class="line">    dfs(map,left,res);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果右边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(right))&#123;</div><div class="line">    dfs(map,right,res);</div><div class="line">  &#125;</div><div class="line">  res -= map.get(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;nums.length;i++)&#123;</div><div class="line">    map.put(nums[i]/<span class="number">10</span>,nums[i] % <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">  dfs(map,<span class="number">11</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">Flatten Binary Tree to Linked List</a></h4><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;         / \</div><div class="line">&gt;        2   5</div><div class="line">&gt;       / \   \</div><div class="line">&gt;      3   4   6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The flattened tree should look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;       \</div><div class="line">&gt;        3</div><div class="line">&gt;         \</div><div class="line">&gt;          4</div><div class="line">&gt;           \</div><div class="line">&gt;            5</div><div class="line">&gt;             \</div><div class="line">&gt;              6</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>将二叉树压到一条右子树上</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是要将每个节点左子树的前序遍历插入到右子树前面。</p><p>所以我的思路是如果遇到节点root有右子树，就先把右子树存下来，然后dfs处理左子树，当左子树处理完之后，再将右子树插入到左子树。</p><p>DSF的时候，把原来的左子树放到节点的右边，然后节点向下移动，递归处理左子树。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreetoLinkedList</span> </span>&#123;</div><div class="line">    TreeNode temp;<span class="comment">//记录当前节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果右节点不空，先把右边节点存下来</span></div><div class="line">        TreeNode right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            right = <span class="keyword">new</span> TreeNode(root.right.val);</div><div class="line">            right.left = root.right.left;</div><div class="line">            right.right = root.right.right;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果左子树非空，将左子树挪到右边，左子树置为空，temp下移，继续dfs temp的左子树</span></div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = temp.left;</div><div class="line">            temp.left = <span class="keyword">null</span>;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果右节点非空，将之前记录下来的右子树放到temp右边，然后temp下移，继续dfs</span></div><div class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = right;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        temp = root;</div><div class="line">        dfs(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的深度优先遍历&quot;&gt;&lt;a href=&quot;#二叉树的深度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的深度优先遍历&quot;&gt;&lt;/a&gt;二叉树的深度优先遍历&lt;/h2&gt;&lt;p&gt;DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回文问题</title>
    <link href="http://yoursite.com/2018/01/19/%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/19/回文问题/</id>
    <published>2018-01-19T05:55:25.000Z</published>
    <updated>2018-02-08T07:05:26.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串-Longest-Palindromic-Substring"><a href="#最长回文子串-Longest-Palindromic-Substring" class="headerlink" title="最长回文子串 Longest Palindromic Substring"></a>最长回文子串 <a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="external">Longest Palindromic Substring</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最长回文子串-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#最长回文子串-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串 Longest Palin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】数据结构</title>
    <link href="http://yoursite.com/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/19/【九章算法基础班】数据结构/</id>
    <published>2018-01-19T03:44:41.000Z</published>
    <updated>2018-02-11T11:35:37.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ul><li>线性数据结构<ul><li>Queue</li><li>Stack</li><li>HashTable</li></ul></li><li>树形数据结构<ul><li>Heap/Priority Queue</li><li>TreeMap</li></ul></li></ul><h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><ul><li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li><li>考点：宽度优先搜索BFS</li><li>多做做BFS就可以了</li></ul><h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><ul><li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li><li>考点：非递归实现DFS</li></ul><h3 id="例题Min-Stack"><a href="#例题Min-Stack" class="headerlink" title="例题Min Stack"></a>例题<a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="external">Min Stack</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; MinStack minStack = new MinStack();</div><div class="line">&gt; minStack.push(-2);</div><div class="line">&gt; minStack.push(0);</div><div class="line">&gt; minStack.push(-3);</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -3.</div><div class="line">&gt; minStack.pop();</div><div class="line">&gt; minStack.top();      --&gt; Returns 0.</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -2.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>要求实现一个stack能够在0(1)时间内实现push(x),pop(),top(),getMin()获取最小值</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>额外维护一个stack，存储最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; queue;</div><div class="line">    Stack&lt;Integer&gt; minqueue;</div><div class="line">    <span class="comment">//int min = Integer.MAX_VALUE;</span></div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        minqueue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">if</span>(minqueue.isEmpty())&#123;</div><div class="line">            min = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (x &lt; minqueue.peek()) &#123;</div><div class="line">                min = x;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> min = minqueue.peek();</div><div class="line">        &#125;</div><div class="line">        minqueue.add(min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.pop();</div><div class="line">        minqueue.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minqueue.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="external">Implement Queue using Stacks</a></h3><blockquote><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) — Push element x to the back of queue.</li><li>pop() — Removes the element from in front of queue.</li><li>peek() — Get the front element.</li><li>empty() — Return whether the queue is empty.</li></ul></blockquote><p>用stack实现queue</p><p>stack：先进后出</p><p>queue：先进先出</p><p>需要两个stack实现一个queue。</p><p>push时先将元素压入stack1，然后当pop时，如果stack2非空，就从stack2中pop出一个，否则将stack1中元素全部加入stcak2之后再pop</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack1;</div><div class="line">    Stack&lt;Integer&gt; stack2;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x to the back of queue. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        stack1.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the front element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; stack1.isEmpty())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">Largest Rectangle in Histogram</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="img"></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="img"></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return <code>10</code>.</p></blockquote><p>求直方图中的最大举行的面积。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：</p><p>两个指针i和j分别从前往后扫描，k在i和j之间扫描，找i和j中间最低的柱子Kmin，计算Kmin*(j-i)的最大值。时间复杂度<script type="math/tex">O(n^3)</script></p><p>优化：</p><p>K从左向右遍历，在每一位置，向左看，找到左边第一个比它小的位置i，向右看，找到右边第一个比他小的位置j，此时矩形面积为<script type="math/tex">K*(j-i-1)</script> ，找到最小的即可。时间复杂度<script type="math/tex">O(n^2)</script></p><p>Stack：</p><p>对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左以及向右第一个小于bar n的bar的索引位置。</p><p>我们可以从左到右遍历所有bar，并将其push到一个stack中，如果当前bar的高度小于栈顶bar，我们pop出栈顶的bar，同时以该bar计算矩形面积。那么我们如何知道该bar的ln和rn呢？rn就是当前遍历到的bar的索引，而ln则是弹出当前元素之后的栈顶bar的索引，因为此时栈顶中的元素都是递增的。</p><p>为了更好的处理最后一个bar的情况，我们在实际中会插入一个高度为0的bar，这样就能pop出最后一个bar并计算了。</p><p>stack中存储的是下标！！！</p><p>时间复杂度<script type="math/tex">O(n)</script></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.length;i++)&#123;</div><div class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> size = heights[stack.pop()] * (i-stack.peek()-<span class="number">1</span>);</div><div class="line">                max = Math.max(max,size);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> size = heights[stack.pop()] * (heights.length-stack.peek()-<span class="number">1</span>);</div><div class="line">            max = Math.max(max,size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="external">Maximal Rectangle</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>题目给定一个01矩阵，要求求出矩阵中面积最大的全1矩阵。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://upload-images.jianshu.io/upload_images/424375-2a5a361549e471e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>把每一行看作直方图的底，可以把这个题转化成上一道题，对每一行建立一个直方图，利用stack求直方图中的最大矩形，返回全局最大矩形的面积。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calMax</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span>[] heights)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights.length;j++)&#123;</div><div class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[j] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> area = heights[stack.pop()] * (j - stack.peek()- <span class="number">1</span>);</div><div class="line">                max = Math.max(max,area);</div><div class="line">            &#125;</div><div class="line">            stack.push(j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> area = heights[stack.pop()] * (heights.length - stack.peek()- <span class="number">1</span>);</div><div class="line">            max = Math.max(max,area);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;matrix.length;i++)&#123;</div><div class="line">            <span class="comment">//计算本行heights</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</div><div class="line">                    heights[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heights[j] += <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxArea = Math.max(maxArea,calMax(matrix,heights));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="external">Implement Stack using Queues</a></h3><blockquote><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>empty() — Return whether the stack is empty.</li></ul></blockquote><p>题目要求用队列实现栈。</p><p>方法一：</p><p>用两个queue实现，push时间复杂度<script type="math/tex">O(1)</script> , pop时间复杂度<script type="math/tex">O(n)</script></p><p>push的时候加入queue1:</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-45-34.png" alt=""> </p><p>pop的时候利用queue1，每次pop的时候将queue1中的元素放到queue2，保留一个pop，然后再把queue1和queue2交换，此时queue2又是空的了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-48-38.png" alt=""> </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue1.add(x);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.poll();</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.peek();</div><div class="line">  queue2.add(queue1.remove());</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><p>用两个queue实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p><p>push时先将元素push进queue2,然后将queue2中元素加入queue2，然后交换queue1和queue2</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-02.png" alt=""> </p><p>pop时直接pop q1中元素</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-27.png" alt=""> </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue2.add(x);</div><div class="line">  <span class="keyword">while</span>(!queue1.isEmpty())&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">  &#125;</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.poll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.peek();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法三：</p><p>用一个队列实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</div><div class="line">    Queue&lt;Integer&gt; queue;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x onto stack. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">            queue.add(queue.poll());</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.poll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the top element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Next-Greater-Element-I"><a href="#Next-Greater-Element-I" class="headerlink" title="Next Greater Element I"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="external">Next Greater Element I</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>‘s elements in the corresponding places of <code>nums2</code>.</p><p>The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</div><div class="line">&gt; Output: [-1,3,-1]</div><div class="line">&gt; Explanation:</div><div class="line">&gt;     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</div><div class="line">&gt;     For number 1 in the first array, the next greater number for it in the second array is 3.</div><div class="line">&gt;     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums1 = [2,4], nums2 = [1,2,3,4].</div><div class="line">&gt; Output: [3,-1]</div><div class="line">&gt; Explanation:</div><div class="line">&gt;     For number 2 in the first array, the next greater number for it in the second array is 3.</div><div class="line">&gt;     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定数组nums2,nums1中的元素来自nums2,返回nums1中的元素在nums2中右边第一个比它的大元素。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>baseline：两层循环，在nums2中寻找右边第一个比它大的,时间复杂度<script type="math/tex">O(m*n)</script></p><p>优化：利用栈+hashmap</p><p>将nums2中元素依次入栈：</p><ol><li>如果当前元素&lt;栈顶元素,压栈</li><li>当前元素i&gt;栈顶元素j，弹出栈顶元素i，此时i右边第一个大于i的元素为j，可以加入hashmap中</li><li>一次出栈之后如果还是满足当前元素i&gt;栈顶元素j，重复2知道栈为空或者站顶元素&gt;当前元素，将i压栈</li></ol><p>时间复杂度<script type="math/tex">O(m+n)</script></p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">    LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums1.length;i++)&#123;</div><div class="line">        map.put(nums1[i],-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums2.length;i++)&#123;</div><div class="line">        <span class="comment">//如果栈空，入栈</span></div><div class="line">        <span class="keyword">if</span>(stack.isEmpty() || nums2[i] &lt; stack.peek())&#123;</div><div class="line">            stack.push(nums2[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</div><div class="line">                <span class="keyword">int</span> val = stack.pop();</div><div class="line">                <span class="keyword">if</span>(map.containsKey(val))&#123;</div><div class="line">                    map.put(val,nums2[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            stack.push(nums2[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(Integer val:map.values())&#123;</div><div class="line">        result[ii] = val;</div><div class="line">        ii++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Next-Greater-Element-II"><a href="#Next-Greater-Element-II" class="headerlink" title="Next Greater Element II"></a><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="external">Next Greater Element II</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,1]</div><div class="line">&gt; Output: [2,-1,2]</div><div class="line">&gt; Explanation: The first 1&apos;s next greater number is 2; </div><div class="line">&gt; The number 2 can&apos;t find next greater number; </div><div class="line">&gt; The second 1&apos;s next greater number needs to search circularly, which is also 2.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个循环数组，返回数组中每个数字x右边第一个比x大的数字</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>和上一题一样的思路，但这次需要吧数组扩大2倍，做同样的操作</p><p>加入stack的元素是数组的下标，这样可以方便后面存储比x大的数字。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    Arrays.fill(result,-<span class="number">1</span>);</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>*nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(stack.isEmpty() || nums[stack.peek()] &gt;= nums[i%nums.length])&#123;</div><div class="line">            stack.push(i%nums.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i%nums.length])&#123;</div><div class="line">                <span class="keyword">int</span> idx = stack.pop();</div><div class="line">                result[idx] = nums[i%nums.length];</div><div class="line">            &#125;</div><div class="line">            stack.push(i%nums.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Decode-String"><a href="#Decode-String" class="headerlink" title="Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="external">Decode String</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an encoded string, return it’s decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</div><div class="line">&gt; s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</div><div class="line">&gt; s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>利用stack，从左向右遍历字符串：</p><ol><li>遇到数字：数字可能不止一位，因此继续遍历，累加数字，直到遇到非数字，将数字入栈</li><li>遇到字母和’[‘：入栈</li><li>遇到’]’：出栈，将字母加入字符串直到遇见’[‘，将’[‘弹出，将前面的数字弹出，计算完字符串之后入栈</li><li>重复上面操作，最后将stack中的字符串弹出连接成最终结果</li></ol><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder reusult = <span class="keyword">new</span> StringBuilder();</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; s.length())&#123;</div><div class="line">            <span class="comment">//数字</span></div><div class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                    num = num * <span class="number">10</span> + (s.charAt(i)-<span class="string">'0'</span>);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                stack.push(String.valueOf(num));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//字母和‘[’</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) != <span class="string">']'</span>)&#123;</div><div class="line">                stack.push(<span class="string">""</span> + s.charAt(i));</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                StringBuilder temp = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">while</span>(!stack.peek().equals(<span class="string">"["</span>))&#123;</div><div class="line">                    temp.insert(<span class="number">0</span>,stack.pop());</div><div class="line">                &#125;</div><div class="line">                stack.pop();</div><div class="line">                <span class="keyword">int</span> times = Integer.parseInt(stack.pop());</div><div class="line">                StringBuilder ntemp = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">while</span> (times &gt; <span class="number">0</span>)&#123;</div><div class="line">                    ntemp = ntemp.append(temp);</div><div class="line">                    times--;</div><div class="line">                &#125;</div><div class="line">                stack.push(ntemp.toString());</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            reusult.insert(<span class="number">0</span>,stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> reusult.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Remove-Duplicate-Letters"><a href="#Remove-Duplicate-Letters" class="headerlink" title="Remove Duplicate Letters"></a><a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank" rel="external">Remove Duplicate Letters</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p><p><strong>Example:</strong></p><p>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p><p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p></blockquote><p>移除字符串中重复的字母，保证字母间的相对顺序不变，返回结果中字典序最小的结果。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>这道题让我们移除重复字母，使得每个字符只能出现一次，而且结果要按字母顺序排，前提是不能打乱其原本的相对位置。我们的解题思路是：先建立一个哈希表来统计每个字母出现的次数，还需要一个visited数字来纪录每个字母是否被访问过，我们遍历整个字符串，对于遍历到的字符，先在哈希表中将其值减一，然后看visited中是否被访问过，若访问过则继续循环，说明该字母已经出现在结果中并且位置已经安排妥当。如果没访问过，我们和结果中最后一个字母比较，如果该字母的ASCII码小并且结果中的最后一个字母在哈希表中的值不为0(说明后面还会出现这个字母)，那么我们此时就要在结果中删去最后一个字母且将其标记为未访问，然后加上当前遍历到的字母，并且将其标记为已访问，以此类推直至遍历完整个字符串s，此时结果里的字符串即为所求。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">        map[s.charAt(i)-<span class="string">'a'</span>]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;<span class="keyword">if</span>(visited[s.charAt(i)-<span class="string">'a'</span>])&#123;</div><div class="line">            map[s.charAt(i)-<span class="string">'a'</span>]--;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; s.charAt(i) &lt; stack.peek().charAt(<span class="number">0</span>) &amp;&amp; map[stack.peek().charAt(<span class="number">0</span>)-<span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</div><div class="line">                visited[stack.peek().charAt(<span class="number">0</span>)-<span class="string">'a'</span>] = <span class="keyword">false</span>;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">            stack.push(String.valueOf(s.charAt(i)));</div><div class="line">            visited[s.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">true</span>;</div><div class="line">            map[s.charAt(i)-<span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">        res.insert(<span class="number">0</span>,stack.pop());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Basic-Calculator"><a href="#Basic-Calculator" class="headerlink" title="Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="external">Basic Calculator</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <strong>non-negative</strong>integers and empty spaces ``.</p><p>You may assume that the given expression is always valid.</p><p>Some examples:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;1 + 1&quot; = 2</div><div class="line">&gt; &quot; 2-1 + 2 &quot; = 3</div><div class="line">&gt; &quot;(1+(4+5+2)-3)+(6+8)&quot; = 23</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>这道题让我们实现一个基本的计算器来计算简单的算数表达式，而且题目限制了表达式中只有加减号，数字，括号和空格。我们需要一个栈来辅助计算，用个变量sign来表示当前的符号，由于有括号的存在，所以用变量res存储当前括号中计算的结果，将之前计算结果存在栈里。</p><p>我们遍历给定的字符串s：</p><ol><li>如果遇到了数字，由于可能是个多位数，所以我们要用while循环把之后的数字都读进来，然后用sign*num来更新结果res；</li><li>如果遇到了加号，则sign赋为1，如果遇到了符号，则赋为-1；</li><li>如果遇到了左括号，则把当前结果res和符号sign压入栈，res重置为0，sign重置为1；</li><li>如果遇到了右括号，结果res乘以栈顶的符号，栈顶元素出栈，结果res加上栈顶的数字，栈顶元素出栈。</li></ol><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; s.length())&#123;</div><div class="line">        <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i &lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                sum = sum*<span class="number">10</span> + s.charAt(i)-<span class="string">'0'</span>;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            res += sum * sign;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span>)&#123;</div><div class="line">            sign = -<span class="number">1</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">            stack.push(res);</div><div class="line">            stack.push(sign);</div><div class="line">            i++;</div><div class="line">            res = <span class="number">0</span>;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</div><div class="line">            res *= stack.pop();</div><div class="line">            res += stack.pop();</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">      <span class="keyword">else</span>&#123;i++;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Basic-Calculator-II"><a href="#Basic-Calculator-II" class="headerlink" title="Basic Calculator II"></a><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="external">Basic Calculator II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces ``. The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid.</p><p>Some examples:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;3+2*2&quot; = 7</div><div class="line">&gt; &quot; 3/2 &quot; = 1</div><div class="line">&gt; &quot; 3+5 / 2 &quot; = 5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>加减乘除运算，没有括号，求结果</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>用一个变量sign存储符号，用stack存储计算完的值。</p><p>遍历字符串：</p><ol><li>遇到符号：更新sign</li><li>遇到数字，计算数字num，根据sign的值入栈：<ol><li>sign==’+’:num入栈</li><li>sign==’-‘:-num入栈</li><li>sign==’*’:和栈顶元素做乘法后入栈</li><li>sign==’/‘:和栈顶元素做除法后入栈</li></ol></li><li>最后将栈中所有元素弹出做加法得到result</li></ol><p>总之核心思想就是将减法转化成相反数入栈，将*和/计算之后入栈，最后就都转化成加法了</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</div><div class="line">            <span class="comment">//记录符号</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'*'</span> || s.charAt(i) == <span class="string">'/'</span>)&#123;</div><div class="line">                sign = s.charAt(i);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果是数字</span></div><div class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                    sum = sum*<span class="number">10</span> + (s.charAt(i)-<span class="string">'0'</span>);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i--;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</div><div class="line">                    stack.push(sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</div><div class="line">                    stack.push(-sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</div><div class="line">                    stack.push(stack.pop() * sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</div><div class="line">                    stack.push(stack.pop()/sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            res += stack.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Flatten-Nested-List-Iterator"><a href="#Flatten-Nested-List-Iterator" class="headerlink" title="Flatten Nested List Iterator"></a><a href="https://leetcode.com/problems/flatten-nested-list-iterator/" target="_blank" rel="external">Flatten Nested List Iterator</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a nested list of integers, implement an iterator to flatten it.</p><p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p><p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>,</p><p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,1,2,1,1]</code>.</p><p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>,</p><p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,4,6]</code>.</p></blockquote><p>给定一个list，里面元素是nestedInteger,可能是Integer，也可能是个IntegerList,要求实现hasNext()和next()函数</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>利用stack</p><ol><li><p>初始化：将给定list中的元素都放入stack</p></li><li><p>在hasNext()中，如果栈顶元素是Integer直接返回true,如果不是Integer则是个List,遍历这个List将元素入栈。</p><p>循环上面的操作，直到栈空如果依然没有integer则返回false</p></li><li><p>next()函数直接pop()</p></li></ol><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenNestedListIterator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</div><div class="line">        <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line">        <span class="comment">// Return null if this NestedInteger holds a nested list</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line">        <span class="comment">// Return null if this NestedInteger holds a single integer</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack();</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = nestedList.size()-<span class="number">1</span>;i &gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">                stack.push(nestedList.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> stack.pop().getInteger();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (stack.peek().isInteger()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    List&lt;NestedInteger&gt; list = stack.pop().getList();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                        stack.push(list.get(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Simplify-Path"><a href="#Simplify-Path" class="headerlink" title="Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="external">Simplify Path</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an absolute path for a file (Unix-style), simplify it.</p><p>For example,<br><strong>path</strong> = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br><strong>path</strong> = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code></p><p><a href="https://leetcode.com/problems/simplify-path/description/#" target="_blank" rel="external">click to show corner cases.</a></p><p>Corner Cases:</p><ul><li>Did you consider the case where <strong>path</strong> = <code>&quot;/../&quot;</code>?<br>In this case, you should return <code>&quot;/&quot;</code>.</li><li>Another corner case is the path might contain multiple slashes <code>&#39;/&#39;</code> together, such as <code>&quot;/home//foo/&quot;</code>.<br>In this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</li></ul></blockquote><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>linux系统中<code>“../”</code>代表上层文件夹，<code>“./”</code>代表当前文件夹</p><p>利用stack存储路径</p><p>将给定字符串按“/”分割：</p><ol><li>遇到.和空字符串跳过，遇到“..”pop栈顶字符串</li><li>遇到正常字符串push(“/“+str)</li></ol><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(path.length()==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(String str : path.split(<span class="string">"/"</span>))&#123;</div><div class="line">            <span class="comment">//遇到..</span></div><div class="line">            <span class="keyword">if</span>(str.equals(<span class="string">".."</span>))&#123;</div><div class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">                    stack.pop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遇到.或者空字符串，跳过</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"."</span>) || str.equals(<span class="string">""</span>))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                stack.push(<span class="string">"/"</span>+str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            res.insert(<span class="number">0</span>,stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.length() == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="Verify Preorder Sequence in Binary Search Tree"></a><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/" target="_blank" rel="external">Verify Preorder Sequence in Binary Search Tree</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>验证一个序列是否是BST的中序遍历</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>BST根节点左边的元素都比根节点小，右边的元素都比跟节点大</p><p>利用这个性质，用一个栈和一个low变量来维护遍历过程</p><p>当出现比根大的元素之后，说明在根节点的右子树，此后就不可能出现比根小的元素了</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : preorder)&#123;</div><div class="line">            <span class="keyword">if</span>(p &lt; low)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; p&gt;stack.peek())&#123;</div><div class="line">                low = stack.pop();</div><div class="line">            &#125;</div><div class="line">            stack.push(p);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Mini-Parser"><a href="#Mini-Parser" class="headerlink" title="Mini Parser"></a><a href="https://leetcode.com/problems/mini-parser/" target="_blank" rel="external">Mini Parser</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p><p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p><p><strong>Note:</strong> You may assume that the string is well-formed:</p><ul><li>String is non-empty.</li><li>String does not contain white spaces.</li><li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given s = &quot;324&quot;,</div><div class="line">&gt;</div><div class="line">&gt; You should return a NestedInteger object which contains a single integer 324.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given s = &quot;[123,[456,[789]]]&quot;,</div><div class="line">&gt;</div><div class="line">&gt; Return a NestedInteger object containing a nested list with 2 elements:</div><div class="line">&gt;</div><div class="line">&gt; 1. An integer containing value 123.</div><div class="line">&gt; 2. A nested list containing two elements:</div><div class="line">&gt;     i.  An integer containing value 456.</div><div class="line">&gt;     ii. A nested list with one element:</div><div class="line">&gt;          a. An integer containing value 789.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>利用stack，每次遇到’[‘就新建一个nest放入stack,遇到，或者‘]’代表一个数字结束，放入栈顶的nest里</p><p>如果遇到的是‘]’还需要将栈顶的第一个nest嵌套入前一个nest中，最后栈中只有一个nest</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></div><div class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></div><div class="line"><span class="comment"> * public interface NestedInteger &#123;</span></div><div class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></div><div class="line"><span class="comment"> *     public NestedInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></div><div class="line"><span class="comment"> *     public NestedInteger(int value);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line"><span class="comment"> *     public boolean isInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></div><div class="line"><span class="comment"> *     public Integer getInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></div><div class="line"><span class="comment"> *     public void setInteger(int value);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></div><div class="line"><span class="comment"> *     public void add(NestedInteger ni);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></div><div class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) != <span class="string">'['</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.parseInt(s));</div><div class="line">        &#125;</div><div class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="comment">//NestedInteger nest = new NestedInteger();//存储当前未入栈nest</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">            <span class="comment">//遇到'['新建一个NestedInteger放入栈里</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>)&#123;</div><div class="line">                stack.push(<span class="keyword">new</span> NestedInteger());</div><div class="line">                left = i+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遇到','||']'将left和i之间的数字放入栈顶的nestedInteger里</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">','</span> || s.charAt(i) == <span class="string">']'</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(left &lt; i)&#123;</div><div class="line">                    NestedInteger nest = <span class="keyword">new</span> NestedInteger(Integer.parseInt(s.substring(left,i)));</div><div class="line">                    NestedInteger top = stack.pop();</div><div class="line">                    top.add(nest);</div><div class="line">                    stack.push(top);</div><div class="line">                &#125;</div><div class="line">                left = i+<span class="number">1</span>;</div><div class="line">              <span class="comment">//遇到']'，将stack中nested嵌套，最后只剩一个nest</span></div><div class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">']'</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(stack.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">                        NestedInteger first = stack.pop();</div><div class="line">                        NestedInteger second = stack.pop();</div><div class="line">                        second.add(first);</div><div class="line">                        stack.push(second);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="external">Verify Preorder Serialization of a Binary Tree</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      _9_</div><div class="line">&gt;     /   \</div><div class="line">&gt;    3     2</div><div class="line">&gt;   / \   / \</div><div class="line">&gt;  4   1  #  6</div><div class="line">&gt; / \ / \   / \</div><div class="line">&gt; # # # #   # #</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>#</code>represents a null node.</p><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p><p>Each comma separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing <code>null</code> pointer.</p><p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>&quot;1,,3&quot;</code>.</p><p><strong>Example 1:</strong><br><code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code><br>Return <code>true</code></p><p><strong>Example 2:</strong><br><code>&quot;1,#&quot;</code><br>Return <code>false</code></p><p><strong>Example 3:</strong><br><code>&quot;9,#,#,1&quot;</code><br>Return <code>false</code></p></blockquote><p>给定一个二叉树的前序遍历，#代表空节点，判断是否是一个二叉树</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用stack</p><p>遍历节点，压栈，如果遇到“#”，且当前栈顶也是“#”说明栈顶#前面的那个节点已经有两个空子节点了，则将栈顶的#和前一个节点弹出，压入一个“#”表示空节点，有点类似于剪枝，下面的如果是二叉树，就剪枝。</p><p>过程中如果有stack为空，则不是二叉树</p><p>最后如果栈里只剩一个“#”了就是二叉树</p><p>方法二：</p><p>根据节点的出度和入度</p><p>二叉树中，每增加一个非叶子节点增加2个出度1个入度，增加一个叶子节点增加0个出度1个入度</p><p>用一个变量diff记录出度-入度的差</p><p>跟节点时diff=1;</p><p>每增加一个非叶子节点diff+1;</p><p>每增加一个叶子节点diff-1;</p><p>在这个过程中diff应该恒大于0.</p><p>最后满二叉树的出度应该等于入度</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</div><div class="line">    String[] str = preorder.split(<span class="string">","</span>);</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length;i++)&#123;</div><div class="line">        <span class="keyword">while</span> (str[i].equals(<span class="string">"#"</span>) &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek().equals(<span class="string">"#"</span>))&#123;</div><div class="line">            stack.pop();</div><div class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        stack.push(str[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stack.size()==<span class="number">1</span> &amp;&amp; stack.peek().equals(<span class="string">"#"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</div><div class="line">    String[] str = preorder.split(<span class="string">","</span>);</div><div class="line">    <span class="keyword">int</span> diff = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length;i++)&#123;</div><div class="line">        diff--;</div><div class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!str[i].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            diff+=<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> diff==<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Closest-Binary-Search-Tree-Value-II"><a href="#Closest-Binary-Search-Tree-Value-II" class="headerlink" title="Closest Binary Search Tree Value II"></a><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="external">Closest Binary Search Tree Value II</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>给定一个BST，一个target，一个k</p><p>返回BST中和target最接近的k个节点的值。</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>根据性质BST的中序遍历是递增序列</p><p>所以用栈实现BST的中序遍历。又因为求k个最接近的，也就是差值的绝对值最小的k个，可以用维护一个最大堆的方法。</p><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> val;</div><div class="line">            <span class="keyword">double</span> delta;</div><div class="line">            Node(<span class="keyword">int</span> val,<span class="keyword">double</span> delta)&#123;</div><div class="line">                <span class="keyword">this</span>.delta = delta;</div><div class="line">                <span class="keyword">this</span>.val = val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o2.delta &gt; o1.delta)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</div><div class="line">        <span class="comment">//中序遍历</span></div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        TreeNode curt = root;</div><div class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(curt!= <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(curt);</div><div class="line">                curt = curt.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">                curt = stack.pop();</div><div class="line">                <span class="keyword">int</span> val = curt.val;</div><div class="line">                <span class="comment">//System.out.println(val);</span></div><div class="line">                <span class="keyword">double</span> delta = Math.abs(target-val);</div><div class="line">                <span class="keyword">if</span>(heap.size() == k &amp;&amp; delta &gt; heap.peek().delta)&#123;</div><div class="line">                    <span class="comment">//System.out.println("hh");</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(val,delta));</div><div class="line">                    <span class="keyword">if</span>(heap.size() &gt; k)&#123;</div><div class="line">                        heap.poll();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                curt = curt.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</div><div class="line">            res.add(heap.poll().val);</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="哈希表Hash"><a href="#哈希表Hash" class="headerlink" title="哈希表Hash"></a>哈希表Hash</h1><h3 id="hash-特性"><a href="#hash-特性" class="headerlink" title="hash 特性"></a>hash 特性</h3><ul><li>支持操作：Insert/Find/Delete,时间复杂度都是<script type="math/tex">O(1)</script></li><li>Hash Table/Hash Map/Hash Set的区别是什么？<ul><li>hash set 只有key没有value</li><li>hash table是线程安全的数据结构，hash map线程不安全</li><li>多线程和多进程的区别：线程之间共享同一片内存</li><li>hash table有锁，可以保证同一时间只有一个进程对其进行操作，因此是线程安全的</li></ul></li></ul><h3 id="hash-Table实现"><a href="#hash-Table实现" class="headerlink" title="hash Table实现"></a>hash Table实现</h3><p>通过一个Hash function将key映射到一个大数组中，查找的时候计算下标，直接获取<script type="math/tex">O(1)</script></p><p>Hash function的设计：</p><ul><li>无冲突</li><li>大数组的长度大概是key数量的10倍以上才是安全的</li></ul><p>Hash 函数解决冲突的两种办法：</p><ol><li><p>open hashing</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-20-31.png" alt=""> </p><p>每个位置可以维护一个链表，插入时，遇到冲突就加到链表里；查找时，查找下标对应的链表</p></li><li><p>closed hashing</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-23-30.png" alt=""> </p><p>占坑，如果hash函数计算完发现自己的坑被占了，就依次向后找到空位放进去；查找时，hash函数计算应该在的位置，如果不是该元素，继续向后寻找直到空</p></li></ol><p>rehashing问题</p><p>当已经存储的元素个数已经超过大数组的1/10l了就需要扩大hash表数组了，这就是rehashing问题。</p><p>需要把hash表中现有的元素全部扫描一遍，重新计算其在新的大hash表中的位置，放到新位置。</p><h3 id="Max-Points-on-a-Line"><a href="#Max-Points-on-a-Line" class="headerlink" title="Max Points on a Line"></a><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="external">Max Points on a Line</a></h3><p>给定2维坐标平面上n个点，求最多有多少个点共线</p><p>遍历每一个点，针对每一个点，用hashmap记录其余跟该点共线的点的个数，key是斜率，value是个数，因为斜率相等的一定在同一直线。遇到跟该点重合的点需要单独累加个数</p><p>其中斜率要用分数形式存储，存分子和分母，这就需要计算最大公约数了。</p><p>计算最大公约数的方法：辗转相除法</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//求最大公约数，递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">if</span> (x%y == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> gcd(y,x%y);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">//求最大公约数，非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">while</span> (x%y != <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = y;</div><div class="line">      y = x%y;</div><div class="line">      x = temp;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"> <span class="comment">//求最大公约数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> y;</div><div class="line">        <span class="keyword">while</span>(x%y != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = x%y;</div><div class="line">            x = y;</div><div class="line">            y = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (points.length &lt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> points.length;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历每一个点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.length;i++)&#123;</div><div class="line">            HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap();<span class="comment">//存储斜率和个数</span></div><div class="line">            Point p = points[i];</div><div class="line">            <span class="keyword">int</span> selfoverlap = <span class="number">0</span>;<span class="comment">//记录与本身重合的点的个数</span></div><div class="line">            <span class="keyword">int</span> lineNum = <span class="number">0</span>;</div><div class="line">            <span class="comment">//遍历后面的点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; points.length;j++)&#123;</div><div class="line">                Point q = points[j];</div><div class="line">                <span class="keyword">int</span> delta_x = p.x-q.x;</div><div class="line">                <span class="keyword">int</span> delta_y = p.y-q.y;</div><div class="line">                <span class="comment">//重合的点，单独计算</span></div><div class="line">                <span class="keyword">if</span>(delta_x == <span class="number">0</span> &amp;&amp; delta_y == <span class="number">0</span>)&#123;</div><div class="line">                    selfoverlap++;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> maxCommon = gcd(delta_x,delta_y);</div><div class="line">                delta_x = delta_x/maxCommon;</div><div class="line">                delta_y = delta_y/maxCommon;</div><div class="line"></div><div class="line">                String k = delta_x +<span class="string">"/"</span>+ delta_y;</div><div class="line">                <span class="keyword">int</span> count = map.getOrDefault(k,<span class="number">0</span>)+<span class="number">1</span>;</div><div class="line">                map.put(k,count);</div><div class="line">                lineNum = Math.max(lineNum,count);</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res,lineNum + selfoverlap + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul><li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p></li><li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p></li><li><p>Heap结构：</p><p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p></li></ul><ul><li><p>MaxHeap vs MinHeap</p><ul><li>MaxHeap：父亲节点比左右孩子都大</li><li>MinHeap：父亲节点比左右孩子都小</li></ul><p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p></li><li><p>堆的存储</p><p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p><p>对于元素A[i]：</p><ul><li>父节点：A[i-2/2] (右移1)</li><li>左孩子：A[2i+1] (左移1，可得到2i)</li><li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li></ul></li><li><p>插入操作</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span><span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line"><span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure><p>​</p></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">      <span class="number">1</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span><span class="number">2</span></div><div class="line"> ↙  ↘       ↙  ↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span><span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     <span class="number">100</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span><span class="number">2</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">      <span class="number">2</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span>  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">      <span class="number">2</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span>  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">100</span></div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure><p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p><p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p><p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p><p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p></li></ul><h2 id="leetcode相关习题"><a href="#leetcode相关习题" class="headerlink" title="leetcode相关习题"></a>leetcode相关习题</h2><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number" target="_blank" rel="external">Ugly Number</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p><p>Note that <code>1</code> is typically treated as an ugly number.</p></blockquote><p>检验输入数组num是否是unly number：因子只有2,3,5</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>思路就是把num中的2、3、5全部除掉，最后==1了就是ugly number，如果最后不是1，说明还有其他因数，因此返回false</p><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="external">Ugly Number II</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p><p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p></blockquote><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>从1开始分别乘{2,3,5}，得到2,3,5是ugly number，然后对于2，依次乘2,3,5，得到4,6,10是ugly number，此时ugly number有：1,2,3,4,5,6,10，1,2处理过了，继续处理3，由此，我们需要一个最小堆来维护现有ugly number中还未与2,3,5相乘的最小的，相乘之后加入该堆，同时需要一个hashmap记录已经计算过的ugly number，以免重复入堆。</p><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumberII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">                <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div><div class="line">        Long[] prime = &#123;Long.valueOf(<span class="number">2</span>),Long.valueOf(<span class="number">3</span>),Long.valueOf(<span class="number">5</span>)&#125;;</div><div class="line">        heap.add(Long.valueOf(<span class="number">1</span>));</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</div><div class="line">            Long ugly = heap.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i:prime)&#123;</div><div class="line">                <span class="keyword">if</span>(!set.contains(ugly*i))&#123;</div><div class="line">                    heap.add(ugly*i);</div><div class="line">                    set.add(ugly*i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> heap.peek().intValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Outline&quot;&gt;&lt;a href=&quot;#Outline&quot; class=&quot;headerlink&quot; title=&quot;Outline&quot;&gt;&lt;/a&gt;Outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;线性数据结构&lt;ul&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS &amp; DFS</title>
    <link href="http://yoursite.com/2018/01/16/BFS-DFS/"/>
    <id>http://yoursite.com/2018/01/16/BFS-DFS/</id>
    <published>2018-01-16T13:57:03.000Z</published>
    <updated>2018-02-08T07:05:26.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p></blockquote><p>给定起始单词和结束单词，利用wordlist中的单词爬梯子，每次只允许改变一个字母，返回能够到达结束词的最短路径长度</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一开始用了回溯，相当于暴力了所有可能，超时了，看了解答，这道题应该用广度优先搜索（BFS）：</p><p>需要用到队列<code>Queue</code></p><p>因为要求最短路径，如果我们用深度优先搜索的话必须遍历所有的路径才能确定哪个是最短的，而用广度优先搜索的话，一旦搜到目标就可以提前终止了，而且根据广度优先的性质，我们肯定是先通过较短的路径搜到目标。另外，为了避免产生环路和重复计算，我们找到一个存在于字典的新的词时，就要把它从字典中移去。这么做是因为根据广度优先，我们第一次发现词A的路径一定是从初始词到词A最短的路径，对于其他可能再经过词A的路径，我们都没有必要再计算了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line"><span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">      diffSum++;</div><div class="line">      <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(beginWord);</div><div class="line">  <span class="keyword">int</span> step = <span class="number">2</span>;<span class="comment">//记录层数</span></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> queueSize = queue.size();<span class="comment">//当前queue长度</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;<span class="comment">//遍历queue中元素，将其后续节点入队列</span></div><div class="line">      String temp  = queue.peek();</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">        <span class="comment">//如果该词与队列顶端元素只相差一个字母，入队列，标记为使用过</span></div><div class="line">        <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">          <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;<span class="comment">//一旦找到了endword结束搜索，返回当前层数</span></div><div class="line">            <span class="keyword">return</span> step;</div><div class="line">          &#125;</div><div class="line">          queue.add(wordList.get(j));</div><div class="line">          isUsed[j] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      queue.poll();</div><div class="line">    &#125;</div><div class="line">    step++;<span class="comment">//层数+1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">  isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">  <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Remove-Invalid-Parentheses"><a href="#Remove-Invalid-Parentheses" class="headerlink" title="Remove Invalid Parentheses"></a><a href="https://leetcode.com/problems/remove-invalid-parentheses" target="_blank" rel="external">Remove Invalid Parentheses</a></h3><blockquote><p>emove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p><p>Note: The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;()())()&quot; -&gt; [&quot;()()()&quot;, &quot;(())()&quot;]</div><div class="line">&gt; &quot;(a)())()&quot; -&gt; [&quot;(a)()()&quot;, &quot;(a())()&quot;]</div><div class="line">&gt; &quot;)(&quot; -&gt; [&quot;&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>思路：</p><p>BFS:set+queue</p><p>用set记录出现过的字符串，将字符串放入queue，一次删除一个字符，如果在set中没有出现，放入queue。</p><p>每次弹出一个字符串判断是否为合法字符串，如果合法加入结果集</p><p>由于只能返回去掉字符最少的字符串，所以采用按层遍历的方式，一旦某一层出现了合法字符串，本层遍历结束之后就返回结果，不再验证后面的字符串</p><p>DFS:</p><p>论坛上的高票解法，非常巧妙</p><p>核心思想就是记录当前出现过的左右括号数目，当右括号多于左括号时，说明从此位置向前可以删掉一个右括号，用dfs依次遍历删除此位置之前的每一个右括号，这里需要注意的有几点：</p><ol><li>对于相邻的右括号，删除哪一个都一样，所以只删除第一个就好</li><li>需要记录上一轮删除右括号的位置，下一轮dfs的时候不需要再删除在此之前的右括号</li><li>dfs到字符串末尾，说明字符串中的右括号不比左括号多了，但还需要保证左括号不比右括号多，所以需要将字符串翻转，再来一遍，最后满足条件了才可以放入结果集</li></ol><p>很难写出来的，看了答案写的，还没吃透，需要复习！！！</p><p>代码：</p><p>bfs:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> leftNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> rightNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">            leftNum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</div><div class="line">            rightNum++;</div><div class="line">            <span class="keyword">if</span>(rightNum &gt; leftNum)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> leftNum == rightNum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(s.isEmpty() || isValid(s))&#123;</div><div class="line">        res.add(s);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    queue.add(s);</div><div class="line">    set.add(s);</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">            String temp = queue.poll();</div><div class="line">            <span class="keyword">if</span>(isValid(temp))&#123;</div><div class="line">                res.add(temp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(temp.charAt(i) != <span class="string">'('</span> &amp;&amp; temp.charAt(i) != <span class="string">')'</span>)&#123;<span class="keyword">continue</span>;&#125;</div><div class="line">                String t = temp.substring(<span class="number">0</span>,i)+temp.substring(i+<span class="number">1</span>,temp.length());</div><div class="line">                <span class="keyword">if</span>(!set.contains(t))&#123;</div><div class="line">                    queue.add(t);</div><div class="line">                    set.add(t);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>dfs:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveInvalidParenthess</span> </span>&#123;</div><div class="line">    <span class="comment">//idx_i: idx_i以前左右括号数量相等    ddx_j:从idx_j开始）没有被删除了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j,List&lt;String&gt; res,<span class="keyword">char</span>[] ch)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> leftNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rightNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx_i;i &lt; s.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == ch[<span class="number">0</span>])&#123;</div><div class="line">                leftNum++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == ch[<span class="number">1</span>])&#123;</div><div class="line">                rightNum++;</div><div class="line">                <span class="comment">//如果右括号比左括号多了</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(rightNum &lt;= leftNum)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = idx_j;j &lt;= i;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(s.charAt(j) == ch[<span class="number">1</span>] &amp;&amp; (s.charAt(j-<span class="number">1</span>) != ch[<span class="number">1</span>] || j == idx_j))&#123;</div><div class="line">                    dfs(s.substring(<span class="number">0</span>,j)+s.substring(j+<span class="number">1</span>,s.length()),i,j,res,ch);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String reversed = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</div><div class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">')'</span>)&#123;</div><div class="line">            System.out.println(reversed);</div><div class="line">            res.add(reversed);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(reversed,<span class="number">0</span>,<span class="number">0</span>,res,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        dfs(s,<span class="number">0</span>, <span class="number">0</span>, res, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        RemoveInvalidParenthess test = <span class="keyword">new</span> RemoveInvalidParenthess();</div><div class="line">        String s = <span class="string">"()())()"</span>;</div><div class="line">        List&lt;String&gt; res = test.removeInvalidParentheses(s);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Word-Ladder&quot;&gt;&lt;a href=&quot;#Word-Ladder&quot; class=&quot;headerlink&quot; title=&quot;Word Ladder&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【DSP系统】Java UDP通信模拟监听模块</title>
    <link href="http://yoursite.com/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/01/10/【DSP系统】Java-UDP通信模拟监听模块/</id>
    <published>2018-01-10T15:52:29.000Z</published>
    <updated>2018-01-10T16:10:52.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ul><li>无连接，不可靠，会造成数据丢失</li><li>速度快，因为无需进行三次握手</li><li>限制数据传输大小64K</li></ul><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p>发送端模拟ADx发送竞价请求，这里采用从文件中按行读取数据，然后发送给接收端的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//DatagramSocket类表示用来发送和接收(udp)数据报包的套接字。</span></div><div class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</div><div class="line"></div><div class="line">  <span class="comment">//获取本机ip地址</span></div><div class="line">  String localIp = InetAddress.getLocalHost().getHostAddress();</div><div class="line"></div><div class="line">  <span class="comment">//读取文件名</span></div><div class="line">  String fileName = <span class="string">"D://datasets//ipinyou.contest.dataset//ipinyou.contest.dataset//training2nd//training2nd//conv.20130610.txt"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// read file content from file</span></div><div class="line">  <span class="comment">//StringBuffer sb= new StringBuffer("");</span></div><div class="line">  FileReader reader = <span class="keyword">new</span> FileReader(fileName);</div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">  String str = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//sb.append(str+"/n");</span></div><div class="line">    System.out.println(str);</div><div class="line"></div><div class="line">    <span class="comment">//需要发送的数据</span></div><div class="line">    <span class="comment">//byte[] buf = "Hello Udp".getBytes();</span></div><div class="line">    <span class="keyword">byte</span>[] buf = str.getBytes();</div><div class="line"></div><div class="line">    <span class="comment">//将数据传送到本地ip，端口为9999</span></div><div class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getByName(localIp), <span class="number">9999</span>);</div><div class="line"></div><div class="line">    <span class="comment">//发送数据报包</span></div><div class="line">    ds.send(dp);</div><div class="line">  &#125;</div><div class="line">  br.close();</div><div class="line">  reader.close();</div><div class="line"></div><div class="line">  <span class="comment">//关闭资源</span></div><div class="line">  ds.close();</div><div class="line">  System.out.println(<span class="string">"Done."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenModule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建udp服务对象，指定接收端口号为9999的报包</span></div><div class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</div><div class="line"></div><div class="line">        <span class="comment">//构造空的数据报包， 用于存储待会接收到的数据报包</span></div><div class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//接收数据</span></div><div class="line">            ds.receive(dp);</div><div class="line"></div><div class="line">            <span class="comment">//显示数据</span></div><div class="line">            String ipAddress = dp.getAddress().getHostAddress();</div><div class="line">            <span class="keyword">int</span> port = dp.getPort();</div><div class="line">            String datas = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line">            <span class="comment">//System.out.println(ipAddress + "::" + datas + "::" + port);</span></div><div class="line">            System.out.println(datas);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ds.close();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行时先运行接收端，后运行发送端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UDP特点&quot;&gt;&lt;a href=&quot;#UDP特点&quot; class=&quot;headerlink&quot; title=&quot;UDP特点&quot;&gt;&lt;/a&gt;UDP特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无连接，不可靠，会造成数据丢失&lt;/li&gt;
&lt;li&gt;速度快，因为无需进行三次握手&lt;/li&gt;
&lt;li&gt;限制数
      
    
    </summary>
    
    
  </entry>
  
</feed>
