<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-26T08:58:34.917Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【leetcode】713.Subarray-Product-Less-Than-K.md</title>
    <link href="http://yoursite.com/2017/10/26/%E3%80%90leetcode%E3%80%91713-Subarray-Product-Less-Than-K-md/"/>
    <id>http://yoursite.com/2017/10/26/【leetcode】713-Subarray-Product-Less-Than-K-md/</id>
    <published>2017-10-26T08:28:31.000Z</published>
    <updated>2017-10-26T08:58:34.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Your are given an array of positive integers nums.</p><p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">Output: 8</div><div class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个正整数组，和一个整数k，求成绩小于k的连续子数组个数</p><p>这道题真的是做了很久，想到了用滑窗，用一个数字记录窗口内数字成绩，但是算不明白个数</p><p>问题的关键在于:</p><p><strong>每次滑窗的末尾向后移动一位之后，满足条件的窗口内新增的连续子数组数目为：end-start+1</strong></p><p>因为每次滑窗末尾向后移动一位，新增的子数组必然包含最后一个数字，又必须是连续子数组，所以新增的个数是end-start+1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后附上很简单的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class="line">    int product = 1;</div><div class="line">    int count = 0;</div><div class="line">    int start = 0;</div><div class="line">    int end = 0;</div><div class="line">    while(end &lt; nums.size()&amp;&amp;start&lt;=end)&#123;</div><div class="line">        product = product*nums[end];</div><div class="line">        while(product&gt;=k&amp;&amp;start&lt;=end)&#123;</div><div class="line">            product = product/nums[start];</div><div class="line">            start++;</div><div class="line">        &#125;</div><div class="line">        count+=end-start+1;</div><div class="line">        end++;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>##<br><img src="http://omaby2s5z.bkt.clouddn.com/blog/171026/1g02kLeb0H.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Your are given an array of positive integers nums.&lt;/p&gt;
&lt;p&gt;Count and pr
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】 628. Maximum Product of Three Numbers</title>
    <link href="http://yoursite.com/2017/08/01/%E3%80%90leetcode%E3%80%91-628-Maximum-Product-of-Three-Numbers/"/>
    <id>http://yoursite.com/2017/08/01/【leetcode】-628-Maximum-Product-of-Three-Numbers/</id>
    <published>2017-08-01T12:27:59.000Z</published>
    <updated>2017-08-01T12:28:42.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p><p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3]</div><div class="line">Output: 6</div></pre></td></tr></table></figure></p><p><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: [1,2,3,4]</div><div class="line">Output: 24</div></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>The length of the given array will be in range [3,$10^4$] and all elements are in the range [-1000, 1000].<br>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果数组里面没有负整数，那最大的乘积就是三个最大的数字乘积，题目说明数组中的数字范围是<strong>[-1000, 1000]</strong>，所以会有两种情况：</p><ol><li>两个最小的负数*一个最大的正数</li><li>三个最大的正数相乘</li></ol><p>所以只需要定义5个变量用来存储两个最小的和三个最大的数字，遍历一遍数组获取5个变量的值，然后返回两种情况中值较大的那种。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    //声明变量用来存储两个最小的数字和三个最大的数字</div><div class="line">    int min1 = 1001, min2 = 1001, max1 = -1001, max2 = -1001, max3 = -1001;</div><div class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</div><div class="line">        //遇到比min1还小的</div><div class="line">        if (nums[i] &lt; min1) &#123;</div><div class="line">            min2 = min1;</div><div class="line">            min1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &lt; min2) &#123;</div><div class="line">            min2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        if (nums[i] &gt; max1) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = max1;</div><div class="line">            max1 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max2) &#123;</div><div class="line">            max3 = max2;</div><div class="line">            max2 = nums[i];</div><div class="line">        &#125;</div><div class="line">        else if (nums[i] &gt; max3) &#123;</div><div class="line">            max3 = nums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = min1*min2*max1;</div><div class="line">    int y = max1*max2*max3;</div><div class="line">    if (x &gt; y)</div><div class="line">        return x;</div><div class="line">    else</div><div class="line">        return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597ffda9bb7c7.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an integer array, find three numbers whose product is maximum an
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1. Two Sum</title>
    <link href="http://yoursite.com/2017/08/01/%E3%80%90leetcode%E3%80%911-Two-Sum/"/>
    <id>http://yoursite.com/2017/08/01/【leetcode】1-Two-Sum/</id>
    <published>2017-07-31T16:33:36.000Z</published>
    <updated>2017-07-31T16:34:41.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line"></div><div class="line">return [0, 1].</div></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给一个数组和一个整数，返回数组中和恰好等于这个整数的两个数组的位置</p><p>自己就只想出来了从前向后遍历的方法，时间复杂度$O(n^2)$</p><p>代码如下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        hash_map&lt;int,int&gt; map;</div><div class="line">        for(int i = 0;i &lt; nums.size();i++)&#123;</div><div class="line">            int res = target-nums[i];</div><div class="line">            if (map.)</div><div class="line">            for(int j = i+1;j &lt; nums.size();j++)&#123;</div><div class="line">                if (res == nums[j])&#123;</div><div class="line">                    result.push_back(i);</div><div class="line">                    result.push_back(j);</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>看了solution才知道这道题正确的打开方式是用hash_map，可以先把数组中的元素存入hash_map中，这样就可以实现O(1)复杂度的按值查找了。</p><p>不过还有更好的方式，就是采用边查找边插入的方式，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt; a,int b) &#123;</div><div class="line">    vector&lt;int&gt; res;</div><div class="line">    unordered_map&lt;int, int&gt; map;</div><div class="line">    for (int i = 0; i &lt; a.size(); i++) &#123;</div><div class="line">        int temp = b - a[i];</div><div class="line">        //查看map里是否已经有要找的元素</div><div class="line">        unordered_map&lt;int, int&gt;::iterator it = map.find(temp);</div><div class="line">        //如果没有，把当前元素的值和idx插入map</div><div class="line">        if (it == map.end()) &#123;</div><div class="line">            map.insert(make_pair(a[i], i));</div><div class="line">        &#125;</div><div class="line">        //找到了符合要求的，返回idx</div><div class="line">        else&#123;</div><div class="line">            res.push_back(it-&gt;second);</div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样在查找指定值元素的时候就可以有$O(1)$的复杂度了，遍历的复杂度是$O(n)$,总的复杂度是$O(n)$</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2017/08/01/597f5b7c55158.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such tha
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="hash_table" scheme="http://yoursite.com/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2017/07/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/23/归并排序/</id>
    <published>2017-07-23T15:50:46.000Z</published>
    <updated>2017-07-23T15:56:02.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>分治法</strong><br>将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p><p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//将两个有序数组合并成一个有序数组</div><div class="line">void merge(int a[], int begin,int mid,int end,int b[]) &#123;</div><div class="line">    int i = begin;</div><div class="line">    int j = mid + 1;</div><div class="line">    int k = 0;</div><div class="line">    while ((i &lt;= mid) &amp;&amp; (j &lt;= end)) &#123;</div><div class="line">        if (a[i] &lt; a[j]) &#123;</div><div class="line">            b[k] = a[i];</div><div class="line">            k++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            b[k] = a[j];</div><div class="line">            k++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (i&lt;=mid)&#123;</div><div class="line">        b[k] = a[i];</div><div class="line">        k++;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= end)&#123;</div><div class="line">        b[k] = a[j];</div><div class="line">        k++;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; k; i++)&#123;</div><div class="line">        a[begin + i] = b[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//归并排序</div><div class="line">void MergeSort(int a[], int begin,int end,int b[]) &#123;</div><div class="line">    if (begin &lt; end) &#123;</div><div class="line">        int mid = (begin + end) / 2;</div><div class="line">        MergeSort(a, begin, mid, b);</div><div class="line">        MergeSort(a, mid + 1, end, b);</div><div class="line">        merge(a, begin, mid, end, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况$O(n\log(n))$<br>平均情况$O(n\log(n))$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;分治法&lt;/strong&gt;&lt;br&gt;将数组分成A、B两组，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>不使用中间变量交换两个数字</title>
    <link href="http://yoursite.com/2017/07/22/%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2017/07/22/不使用中间变量交换两个数字/</id>
    <published>2017-07-22T14:18:13.000Z</published>
    <updated>2017-07-22T14:18:26.178Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数字a和b，要求不使用中间变量交换二者</p><h3 id="一般做法"><a href="#一般做法" class="headerlink" title="一般做法"></a>一般做法</h3><p>一般的做法很简单</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    int temp = a;</div><div class="line">    a = b;</div><div class="line">    b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不使用中间变量的做法"><a href="#不使用中间变量的做法" class="headerlink" title="不使用中间变量的做法"></a>不使用中间变量的做法</h3><p>采用位操作符中的异或操作<code>^</code></p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">功能</th><th>用法</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">取反</td><td>0变1,1变0</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td><td>后面补0</td></tr><tr><td style="text-align:center">>&gt;</td><td style="text-align:center">右移</td><td>前面补0，后面吞位</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td><td>只有两个都为1，则为1。<strong>x&amp;…00100…用于提取x某一位</strong></td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td><td>只有一个为1，则为 1。<strong>用于判断两位是否相同</strong> a^b^a = b 用于交换数值</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center"></td><td>位或</td><td>有一个或2个1，则为1。<strong>用于做and运算</strong></td></tr></tbody></table><p>容易发现<code>^</code>的性质：</p><ol><li>两个相同的数字做<code>^</code>操作得0</li><li>任何数字跟0做<code>^</code>操作还是它本身</li></ol><p>所以可以通过下面的方式交换两个数字</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    a = a^b;</div><div class="line">    b = b^a;</div><div class="line">    a = a^b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个程序大部分时间正确，但是有个致命缺陷，当a和b指向同一个位置时，计算a^b得0，也就是说a和b所指向的地址是同一个，所以此时a=b=0。所以上面这样写的前提是假设两个指针不会指向同一个位置。这也是编译器优化时经常考虑的一点，这种两个指针指向同一个存储器的情况叫做存储器别名使用（memory aliasing）。</p><p>因此正确的程序应该如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void swap(int &amp;a;int &amp;b)&#123;</div><div class="line">    if (a!=b)&#123;</div><div class="line">        a = a^b;</div><div class="line">        b = b^a;</div><div class="line">        a = a^b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个数字a和b，要求不使用中间变量交换二者&lt;/p&gt;
&lt;h3 id=&quot;一般做法&quot;&gt;&lt;a href=&quot;#一般做法&quot; class=&quot;headerlink&quot; title=&quot;一般做法&quot;&gt;&lt;/a&gt;一般做法&lt;/h3&gt;&lt;p&gt;一般的做法很简单&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2017/07/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/22/选择排序/</id>
    <published>2017-07-22T14:17:57.000Z</published>
    <updated>2017-07-22T14:18:45.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次从无序区选择一个最小的放大有序区的最后</p><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p></li><li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//选择排序</div><div class="line">void SekectSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        int min = a[i];</div><div class="line">        int loc = i;</div><div class="line">        //寻找最小的元素</div><div class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</div><div class="line">            if (a[j] &lt; min) &#123;</div><div class="line">                min = a[j];</div><div class="line">                loc = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //把最小的元素放在有序区后面</div><div class="line">        int temp = a[loc];</div><div class="line">        a[loc] = a[i];</div><div class="line">        a[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;每次从无序区选择一个最小的放大有序区的最后&lt;/p&gt;
&lt;p&gt;设数组为a[0…n-1]。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始时，数组全为无序区
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2017/07/22/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/22/希尔排序/</id>
    <published>2017-07-22T09:09:32.000Z</published>
    <updated>2017-07-22T09:09:54.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>希尔排序的实质是分组插入排序，又称缩小增量排序。</p><p>该方法的基本思想是：</p><ol><li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的），对这些子序列分别进行直接插入排序</li><li>依次缩减增量再进行排序</li><li>待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</li></ol><p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在我们要将这样一个数组排序，一共有10个元素</p><p><img src="https://i.loli.net/2017/07/20/59701858e5e96.png" alt=""> </p><ul><li><strong>第一次 增量 gap = 10/2 = 5</strong></li></ul><p><img src="https://i.loli.net/2017/07/20/59701a2be3ef5.png" alt=""> </p><p>整个数组被分成了5个子数组，分别是[49,13]，[38,27]，[65,49]，[97,55]，[26,4]<br>然后对这五个子数组进行插入排序，得到下面结果</p><p><img src="https://i.loli.net/2017/07/20/59701b9f8c66f.png" alt=""> </p><ul><li><strong>第二次 增量 gap = 5/2 = 2</strong></li></ul><p><img src="https://ooo.0o0.ooo/2017/07/20/59701bfe5a204.png" alt=""> </p><p>这次我们把整个数组分成了两个子数组，分别是[13,49,4,38,97],[27,55,49,65,26]<br>对这个两个子数组排序，结果如下：<br><img src="https://i.loli.net/2017/07/20/59701d3805da5.png" alt=""> </p><ul><li><strong>第三次 增量 gap = 2/2 = 1</strong><br>此时整个数组已经接近有序，对整个数组进行全排列</li></ul><p><img src="https://i.loli.net/2017/07/20/59701e32a8bb1.png" alt=""> </p><p>最终得到数组有序</p><p><img src="https://ooo.0o0.ooo/2017/07/20/59701fd2c547a.png" alt=""> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; delta; i++) &#123;//分成了delta个子序列</div><div class="line">            //对每个子序列进行插入排序</div><div class="line">            for (int j = i + delta; j &lt; len; j = j + delta) &#123;</div><div class="line">                int jj = j - delta;</div><div class="line">                int temp = a[j];</div><div class="line">                while ((a[jj] &gt; temp)&amp;&amp;(jj&gt;=0)) &#123;</div><div class="line">                    a[jj + delta] = a[jj];</div><div class="line">                    jj -= delta;</div><div class="line">                &#125;</div><div class="line">                //插入</div><div class="line">                a[jj + delta] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">白话经典算法系列</a>原文是这么说的</p><blockquote><p>很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较…….。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。</p></blockquote><p>我理解了一下，思路就是把在序列中提取子序列的过程简化了，我们可以从第gap个元素开始，向后遍历到序列末尾，可以个元素都跟其所在的子序列中位于它前面的数字做插入排序，最终就会得到一个有序数列了~</p><p>画个图表示一下吧，还是刚才那个序列，比如说此时进行到第二次排序了，gap=2的情况：</p><p>从a[2]开始遍历，此时a[2]所在的子序列为[a[0],a[2],a[4],a[6],a[8]]，需要将a[2]和位于它前面的a[0]比较，插入到合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731239a3cd2.png" alt=""> </p><p>指针后移一位， 同上此时a[3]所在的子序列为[a[1],a[3],a[5],a[7],a[9]]，需要将a[3]和位于它前面的a[1]比较，插入合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731264440fc.png" alt=""> </p><p>接下来指针指向a[4],此时需要将a[4]和位于它前面的a[2]、a[0]比较，插入合适的位置：</p><p><img src="https://i.loli.net/2017/07/22/59731282140fd.png" alt=""> </p><p>下面重复上面的步骤：</p><p><img src="https://i.loli.net/2017/07/22/597312a912c5c.png" alt=""> </p><p><img src="https://i.loli.net/2017/07/22/597312ca290dc.png" alt=""> </p><p>此处省略剩余步骤…..最终可以将数组排列至有序状态</p><p>现在可以上代码了~<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void HillSort(int a[], int len) &#123;</div><div class="line">    int delta = len/2;</div><div class="line">    while (delta &gt; 0) &#123;</div><div class="line">        for (int i = delta; i &lt; len; i++) &#123;//遍历</div><div class="line">            //对该元素子前面的子数组进行插入排序</div><div class="line">            int temp = a[i];</div><div class="line">            int jj = i - delta;</div><div class="line">            while ((jj &gt;=0)&amp;&amp;(a[jj]&gt;temp))&#123;</div><div class="line">                swap(a[jj], a[jj+delta]);</div><div class="line">                jj -= delta;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        delta = delta / 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="external">MoreWindows Blog 白话经典算法系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;希尔排序的实质是分组插入排序，又称缩小增量排序。&lt;/p&gt;
&lt;p&gt;该方法的基本思想是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先将整个待排元素序列分割成若
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2017/07/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/20/插入排序/</id>
    <published>2017-07-20T01:47:19.000Z</published>
    <updated>2017-07-22T08:21:53.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p></li><li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><p>在查找某元素应该插入到前面有序序列的位置时，我们可以采用边交换边插入的方式，直到无需交换</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                int temp = a[j];</div><div class="line">                a[j] = a[j - 1];</div><div class="line">                a[j - 1] = temp;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中交换元素部分可以调用STL中的swap函数实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//插入排序</div><div class="line">void InsertSort(int a[],int len) &#123;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        //查找应该插入的位置</div><div class="line">        for (int j = i; j &gt; 0; j--)&#123;</div><div class="line">            if (a[j - 1] &gt; a[j]) &#123;</div><div class="line">                swap(a[j], a[j - 1]);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2017/07/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/20/冒泡排序/</id>
    <published>2017-07-19T16:54:24.000Z</published>
    <updated>2017-07-19T16:54:57.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>依次比较相邻的两个数据，如果前面的比后面的大，就将其交换</li><li>这样交换一轮之后，整个序列中最大的就“沉”到了最后面的位置</li><li>重复上述过程，依次把第二大、第三大…的数字放到后面的位置。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        for (int j = 0; j &lt; len -1-i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来可以优化一下，上面的程序中一共进行了N轮比较，其实如果有一趟没有发生交换就说明这时候每两个相邻数据都已经呈现前边比后边小的状态了，此时已经达到有序状态了，所以后面就无需再继续比较了</p><h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int flag = 1;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;//一共需要遍历len轮</div><div class="line">        int flag = 0;//用来记录本轮是否发生交换</div><div class="line">        for (int j = 0; j &lt; len - 1 - i; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = 1;//本轮发生交换了</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 0) &#123;//如果本轮未发生交换，跳出</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还可以进一步优化，假设有100个数的数组，只有前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。</p><p>一般地，冒泡排序在进行过程中，也会出现后面已经排好了的情况，所以如果记录一下有序的位置，下一次就可以不用向后遍历了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void BubbleSort(int a[], int len) &#123;</div><div class="line">    int k ;//用于记录从那个数据开始之后的数据为</div><div class="line">    int flag = len-1;//用于几率从哪个数据开始之后的数据有序</div><div class="line">    while (flag &gt; 0) &#123;</div><div class="line">        k = flag;//计算到k之前</div><div class="line">        flag = 0;//用于记录本轮是否有交换</div><div class="line">        for (int j = 0; j &lt; k; j++) &#123;//后面的len-1个数据</div><div class="line">            if (a[j] &gt; a[j + 1]) &#123;</div><div class="line">                int temp = a[j + 1];</div><div class="line">                a[j + 1] = a[j];</div><div class="line">                a[j] = temp;</div><div class="line">                flag = j;//本轮交换了，更新交换位置</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总结一下冒泡排序的关键点就是相邻元素两两比较交换，执行N轮，如果有某一轮没有发生交换说明已经有序，停止；记录下每一轮交换停止的位置，这之后的数据时有序的，下一轮无需考察。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;依次比较相邻的两个数据，如果前面的比后面的大，就将其交换&lt;/li&gt;
&lt;li&gt;这样交换一轮之后，整个序列中最大的就“沉”到了最后面
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2017/07/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/17/快速排序/</id>
    <published>2017-07-17T06:21:23.000Z</published>
    <updated>2017-07-18T07:17:26.877Z</updated>
    
    <content type="html"><![CDATA[<p>感谢@MoreWindows的白话经典算法系列，浅显易懂，让我终于看懂了快速排序，总结一下</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>从数列中选择一个作为<strong>基准数</strong></li><li><strong>分区</strong>操作：把比基准数小的都排在基准数的左边，比基准数大的都排在基准数的右边</li><li>对基准数的左边和右边<strong>分治</strong>排序</li></ol><h3 id="具体实现：挖坑填数-分治法"><a href="#具体实现：挖坑填数-分治法" class="headerlink" title="具体实现：挖坑填数+分治法"></a>具体实现：挖坑填数+分治法</h3><p>这里结合个实际例子说明</p><p><img src="https://i.loli.net/2017/07/18/596da83e7801a.png" alt=""> </p><p>根据上面的步骤，选取第一个作为<strong>基准数</strong>，接下来我们需要把比它小的数字放到它的左边，比它大的数字放到它的右边，这里就需要重点注意<strong>挖坑填数</strong>的方法了，划重点！！！</p><p><img src="https://i.loli.net/2017/07/18/596da86bf0f53.png" alt="">  temp=72</p><p>我们先把基准数72保存到变量temp中，这时候就相当于在数组的第一个位置上挖了一个“坑”，如果我们在后边发现有比temp小的数字，就可以把那个比较小的数字填到这个空缺的“坑”里了。</p><p><img src="https://i.loli.net/2017/07/18/596dada8c0f65.png" alt=""> </p><p>我们定义一个从后向前遍历的指针j，发现a[8]位置上的48比72小，所以我们要把48放到前面去，填补之前72留下的空缺.</p><p><img src="https://i.loli.net/2017/07/18/596da9ed5c6da.png" alt=""> </p><p>这时候原来存放48的这个位置就空了出来，有了一个新的“坑”，此时指针i向后遍历，如果找到比temp大的数字，便可以填补之前的48留下的坑了。恩，我们找到了a[3]位置上的88，将他填补到之前48留下来的“坑”里。</p><p><img src="https://i.loli.net/2017/07/18/596dabf678c11.png" alt=""> </p><p>接下来继续重复上面的过程，先从后向前找到比基准值小的，填补在前面的“坑”里，然后再从前向后找比基准值大的，填补刚才空出来的“坑”。直到最终两个指着相遇。</p><p><img src="https://i.loli.net/2017/07/18/596dacb08d160.png" alt=""> </p><p>而此时空缺的位置，恰好就是基准值temp的位置。将基准值填入空缺位置，至此就完成了一次分区的操作，此时基准数前面的数字都比基准数小，后面的都比基准数大。</p><p>接下来就是对基准数前后两段数组分而治之，采用递归调用的思想，将整个数组调整至有序状态。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void quiksort(vector&lt;int&gt; &amp;vec, int i, int j) &#123;</div><div class="line">    if (i &lt; j) &#123;</div><div class="line">        int temp = vec[i];//存储基准值</div><div class="line">        int left = i;</div><div class="line">        int right = j;</div><div class="line">        while (left &lt; right) &#123;</div><div class="line">            //后指针向前遍历，寻找比基准值小的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[right] &gt;= temp) &#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[left] = vec[right];</div><div class="line">            //前指针向后遍历，寻找比基准值大的数字</div><div class="line">            while (left &lt; right &amp;&amp; vec[left] &lt;= temp) &#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            //填数</div><div class="line">            vec[right] = vec[left];</div><div class="line">        &#125;</div><div class="line">        vec[right] = temp;</div><div class="line">        //递归调用</div><div class="line">        quiksort(vec, i, right - 1);</div><div class="line">        quiksort(vec, right + 1, j);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec = &#123;&#125;;</div><div class="line">    scanf_s(&quot;%d&quot;, &amp;n);</div><div class="line">    while (n &gt; 0) &#123;</div><div class="line">        scanf_s(&quot;%d&quot;, &amp;temp);</div><div class="line">        vec.push_back(temp);</div><div class="line">        n--;</div><div class="line">    &#125;</div><div class="line">    quiksort(vec, 0, vec.size() - 1);</div><div class="line">    for (int i = 0; i &lt; vec.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; vec[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最坏时间复杂度：$O(n^2)$</li><li>期望时间复杂度：$O(n\log(n))$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感谢@MoreWindows的白话经典算法系列，浅显易懂，让我终于看懂了快速排序，总结一下&lt;/p&gt;
&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;h3 id=&quot;步骤：&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>今日头条-算法岗</title>
    <link href="http://yoursite.com/2017/07/17/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E7%AE%97%E6%B3%95%E5%B2%97/"/>
    <id>http://yoursite.com/2017/07/17/今日头条-算法岗/</id>
    <published>2017-07-17T06:06:32.000Z</published>
    <updated>2017-07-18T03:39:02.725Z</updated>
    
    <content type="html"><![CDATA[<p>昨天去头条面试了，意料之中的挂了23333</p><p>没怎么考察算法，就做了个自我介绍，简单介绍了一下项目，问了问ffm的原理，跟fm比起来有哪些优势</p><p>紧接着上了两道算法题，两道题都很基础，但自己真心不扎实，难怪人家看不上==</p><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><p>给一个句子，把句子翻转但单词不翻转<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:&quot;I am a coder&quot;</div><div class="line">output:&quot;coder a am I&quot;</div></pre></td></tr></table></figure></p><p>对字符串、字符数组这里一直都很懵逼，看到题就知道自己写不出来了，挣扎了一会投降了==<br>而且我的重点都放在了要怎么读进来啊！不会读进来啊！怎么读啊！要好好看c++了啊喂！</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>先翻转整个句子，再把每一个单词翻转过来。翻转字符串的时候前后对换，能减少一半的时间复杂度</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//反转字符串</div><div class="line">void ReverseString(char *begin, char *end) &#123;</div><div class="line">    while (begin &lt; end) &#123;</div><div class="line">        char temp = *begin;</div><div class="line">        *begin = *end;</div><div class="line">        *end = temp;</div><div class="line">        begin++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//反转句子</div><div class="line">char* ReverseSentance(char *ch) &#123;</div><div class="line">    char *begin = ch;</div><div class="line">    char *end = ch;</div><div class="line"></div><div class="line">    while (*end != &apos;\0&apos;)</div><div class="line">        end++;</div><div class="line">    end--;</div><div class="line">    //反转整个句子</div><div class="line">    ReverseString(begin, end);</div><div class="line"></div><div class="line">    //逐个反转单词</div><div class="line">    begin = ch;</div><div class="line">    end = ch;</div><div class="line">    while ((*begin != &apos;\0&apos;)) &#123;</div><div class="line">        while ((*end != &apos; &apos;) &amp;&amp; (*end != &apos;\0&apos;)) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        ReverseString(begin, end - 1);</div><div class="line">        if (*end != &apos;\0&apos;) &#123;</div><div class="line">            end++;</div><div class="line">        &#125;</div><div class="line">        begin = end;</div><div class="line">    &#125;</div><div class="line">    return ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    /*fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    char str[1024];</div><div class="line">    int i = 0;</div><div class="line">    while ((str[i] = getchar()) != &apos;\n&apos;) &#123;</div><div class="line">        i++;</div><div class="line">    &#125; </div><div class="line">    int length = sizeof(str)/sizeof(str[0]);</div><div class="line">    char *array = str;*/</div><div class="line">    char a[] = &quot;I am a coder&quot;;</div><div class="line">    char *array = a;</div><div class="line">    int length = sizeof(a) / sizeof(a[0]);</div><div class="line">    cout &lt;&lt; length;</div><div class="line">    array = ReverseSentance(array);</div><div class="line">    for (int i = 0; i &lt; length-1; i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *array;</div><div class="line">        array++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个有序数组和一个数字，统计该数字在数组中出现的次数</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input:3</div><div class="line">1 2 3 3 4 5 6</div><div class="line">output:2</div></pre></td></tr></table></figure><p>我想到了用二分查找来解决，然后我竟然找到了这个数字时候左右分别递归再找==</p><p>其实找到了之后就向左向右遍历就可以了，因为数组本身已经是有序的了嘛。。。。</p><h3 id="关键思路"><a href="#关键思路" class="headerlink" title="关键思路"></a>关键思路</h3><p><strong>二分查找该数字是否在数组中出现，如果找到了就分别向左侧和右侧探测连续出现了几次</strong></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">FILE *fin;</div><div class="line"></div><div class="line">//二分查找</div><div class="line">int midfind(vector&lt;int&gt; &amp;vec,int head,int tail,int n) &#123;</div><div class="line">    if (head &gt; tail)</div><div class="line">        return -1;</div><div class="line">    else &#123;</div><div class="line">        int mid = (head + tail) / 2;</div><div class="line">        if (vec[mid] == n)</div><div class="line">            return mid;</div><div class="line">        else if (vec[mid] &lt; n) &#123;</div><div class="line">            return midfind(vec, mid + 1, tail, n);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return midfind(vec, head, mid - 1, n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);</div><div class="line">    int n;</div><div class="line">    int temp;</div><div class="line">    vector&lt;int&gt; vec;</div><div class="line">    fscanf(fin,&quot;%d&quot;,&amp;n);</div><div class="line">    while (fscanf(fin, &quot;%d&quot;,&amp;temp)!=EOF) &#123;</div><div class="line">        vec.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    int len = vec.size();</div><div class="line">    int pos = midfind(vec, 0, len - 1, n);</div><div class="line">    if (pos == -1)</div><div class="line">        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</div><div class="line">    else &#123;</div><div class="line">        int pos1 = pos - 1;</div><div class="line">        int pos2 = pos + 1;</div><div class="line">        int sum = 1;</div><div class="line">        while ((pos1&gt;=0) &amp;&amp; (vec[pos1]==n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos1--;</div><div class="line">        &#125;</div><div class="line">        while ((pos2&lt;len) &amp;&amp; (vec[pos2] == n))</div><div class="line">        &#123;</div><div class="line">            sum++;</div><div class="line">            pos2++;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>立flag 好好刷算法了要！！！！！基础很重要！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天去头条面试了，意料之中的挂了23333&lt;/p&gt;
&lt;p&gt;没怎么考察算法，就做了个自我介绍，简单介绍了一下项目，问了问ffm的原理，跟fm比起来有哪些优势&lt;/p&gt;
&lt;p&gt;紧接着上了两道算法题，两道题都很基础，但自己真心不扎实，难怪人家看不上==&lt;/p&gt;
&lt;h2 id=&quot;字符
      
    
    </summary>
    
      <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimal Real-Time Bidding for Display Advertising论文笔记</title>
    <link href="http://yoursite.com/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/07/17/Optimal-Real-Time-Bidding-for-Display-Advertising论文笔记/</id>
    <published>2017-07-17T06:04:26.000Z</published>
    <updated>2017-07-17T06:05:09.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014"><a href="#Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014" class="headerlink" title="Optimal Real-Time Bidding for Display Advertising——KDD2014"></a>Optimal Real-Time Bidding for Display Advertising——KDD2014</h2><p>参考着师兄的博客<a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a>，仔细读完了这篇paper，总结一下，方便日后回顾</p><p>ps:十分感谢师兄@<a href="http://blog.csdn.net/breada" target="_blank" rel="external">面包包包包包包</a>，看了师兄的三篇博客可算是入了门，不然真是一头雾水hold不住啊</p><p>这篇文章的核心就是提出了一个<strong>非线性的竞价函数</strong>，相比于KDD2012的<a href="http://cwds.uw.edu/sites/default/files/p804.pdf" target="_blank" rel="external">《Bid Optimizing and Inventory Scoring in Targeted Online Advertising》</a>中提出的线性竞价函数，本文认为出价应该与点击率、转化率等指标具有<strong>非线性关系</strong></p><p>首先，文章将现实问题用数学方法建模为限制条件下的优化问题，并通过拉格朗日乘子法，求得出价策略的数学表达式（非线性竞价函数）；然后利用iPinYou数据拟合出价策略中的参数；最后，做实验验证结果，发现了一个有意思的结论：相比少量高品质的展示机会，那些大量低品质的展示机会同样可以具有较好的广告效果，值得出价。这个发现对于那些预算不够，同时又想做广告的小广告主来说，简直就是福音。</p><h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><h3 id="选择合适的出价策略，在预算的限制下实现广告效果最大化"><a href="#选择合适的出价策略，在预算的限制下实现广告效果最大化" class="headerlink" title="选择合适的出价策略，在预算的限制下实现广告效果最大化"></a>选择合适的出价策略，在预算的限制下实现广告效果最大化</h3><p>把这句话用数学的形式表达出来就是下面的样子：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p><p>看起来来有点复杂，其实很简单，两个式子，第一行是优化目标：寻找似的收益最大化的出价函数b()</p><p>第二行就是预算约束，就是花的钱不能超过预算约束B</p><p>模型中涉及的具体符号定义如下：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e0b0486d.png" alt=""> </p><h3 id="结合着具体的符号定义，可以解释一下之前建立的数学模型了"><a href="#结合着具体的符号定义，可以解释一下之前建立的数学模型了" class="headerlink" title="结合着具体的符号定义，可以解释一下之前建立的数学模型了"></a>结合着具体的符号定义，可以解释一下之前建立的数学模型了</h3><p>$dx$：x代表一次bid request，也就是一次竞价请求的特征向量，是ADX发给DSP的竞价请求“标识XXX,男性，20-25岁，跑鞋爱好者，广告位为首页”，即一次广告展示机会。之所以是dx而不是x，是因为我们关注的是整个广告推广计划中所有的竞价过程，而非某一次竞价。</p><p>$p_x(x)$：广告展示机会的概率密度分布，我的理解是在全网所有的竞价中，满足我DSP要求的、或者是我能收到的bid request所占的比例。因此，$p_x(x)*dx$的物理意义是我能收到的展示机会。</p><p>$\theta(x)$：θ是赢得此次竞价所能带来的收益(KPI)，本文用CTR来衡量，CTR越高，收益就越高。</p><p>$b(\theta(x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我所出的价格bid。</p><p>$\omega(b(\theta(x),x),x)$：对于此次展示机会，在能带来收益为θ(x)的情况下，我的出价bid能获胜的概率是多少。因此，$\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$表示对于本次我所收到的这个展示机会来说，在该机会能带来收益（如CTR,CVR等）为θ(x)，我出价为bid的情况下，我能打败对手获得此次展示机会的概率。</p><p>以$\theta(x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会后，所能获得的收益。</p><p>以$b(\theta(x),x)\omega(b(\theta(x),x),x)<em>p_x(x)</em>dx$的物理含义是我出价为bid，赢得这次展示机会所花费的钱。</p><p>$N_T$：生存时间T内广告推广活动中所有的bid request数量</p><p>总之还是那句话：<strong>选择合适的出价策略，在预算的限制下实现广告效果最大化</strong></p><h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><p><img src="https://ooo.0o0.ooo/2017/05/11/59141e20788bf.png" alt=""> </p><p>经过一系列的化简，我们可以把模型的函数表达式简化成下面的样子，具体过程参考原文</p><p><img src="https://ooo.0o0.ooo/2017/05/11/591426f75561b.png" alt=""> </p><p>现在参数就只有$\theta$了，也就是CTR，接下来要怎么求解最大值呢？这是要一个带约束条件的最优化问题，作者是用了拉格朗日乘子法来解决的</p><p>通过拉格朗日乘子法，我们可以将不等式乘一个参数$\lambda$后和等式写进一个公式里(化简过程已省略)，得到如下结果:</p><p><img src="https://ooo.0o0.ooo/2017/05/11/591427c023edb.png" alt=""> </p><p>然后对其求导，令导数为0得到：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142a08a7855.png" alt=""> </p><p>进而求得出价函数$b(\theta)$与赢得竞价概率之间的函数关系为：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142a857ef5e.png" alt=""> </p><p>也就是说，我们想要的出价函数b()与胜率函数w()有关，那我们就来看看他们之间到底有什么关系。作者利用数据集绘制出二者之间的关系如图：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142bedeeacb.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/05/11/59142c7551aaa.png" alt=""> </p><p>我们发现这个函数走势很像$y=\frac{x}{c+x}$啊！！！对，作者也发现了，于是乎就有了下面的非线性竞价函数：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142c9e5260d.png" alt=""> </p><p>然后把（9）带回到（8）中就求得了我们梦寐以求的非线性出价函数：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142ce77aa66.png" alt=""> </p><p>画个图看看上面的两个函数走势吧：</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59142d47bf56d.png" alt=""> </p><p>还是很符合实际情况的，点击率越高，出价也就越高，出价越高，赢得竞价的可能行也就越高</p><p>到此，我们就已经把问题的数学转化和模型求解弄完了，那剩下的关键问题就是要<strong>求解两个参数：$\lambda$和$c$了</strong></p><p>可以看出来$c$是可以直接根据历史数据拟合出来的，利用最小二乘法使得均方误差最小即可</p><p>难点在于$\lambda$的求解，文章采用的方法是：<strong>通过不断调整以获得在测试数据中得到最大收益（点击量）来获得</strong></p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><ol><li>利用iPinYou实时竞价数据，每一条数据是一个竞价请求，包含其特征、赢得竞价的价格、用户反馈（点击or转化）</li><li>将数据集按2:1分割分别作为训练和测试集</li><li>流程：用训练数据训练出点击率预估模型和出价函数，根据测试数据特征，计算出一个出价，如果超过数据集中的真实出价，则认为竞价成功</li><li>根据真是数据集中的情况进行模型评估</li><li>为了对比，将预算分别设置为原始预算的1/64,1/32,1/16,1/8,1/4,1/2进行实验</li><li>对比策略：按固定值出价，随机出价，按最大eCPC出价，线性出价</li></ol><p>经过一系列的实验，文章得出了下面的结论：</p><ol><li><strong>非线性出价策略赢得的总点击量大，而且单次点击所产生的费用低</strong></li><li><strong>预算约束越严格的情况下，相比于线性出价策略，非线性出价策略对于点击量的提升越大</strong></li><li>预算越低，$\lambda$的最优解的值越大，出价相对也越低，但是对于低价值的展示机会，非线性出价策略的出价比线性出价策略的出价略高。如下图所示</li></ol><p><img src="https://ooo.0o0.ooo/2017/05/11/59145d12c4aea.png" alt=""> </p><p>我们可以很直观的看出，我们所得到的出价策略是一个非线性的。横坐标θ代表了广告展示计划的品质，ORTB会对低价值的展示机会出高价，这样的结果能为我们带来什么，谁会去要那些低价值的展示机会呢？我们来看下面这张图</p><p><img src="https://ooo.0o0.ooo/2017/05/11/59145cfc4d8d4.png" alt=""> </p><p>在此图中，我们盯着一条曲线看，比如蓝色的(1/32)。随着λ增加，收获的点击量是增加的，意味着λ越高，我们的收益越高。对于我们获得的出价策略而言，λ越高，我们的出价是越低的，也就意味着这次展示机会的价值是很低的。这样的结果值得我们深思，我们以为低价值的展示机会是不值钱的，但数据说明，这些看似不值钱的展示所能带来的回报还算不错。特别地，在λ=1e-05时三条曲线的几乎重合，而红色代表有钱的广告主，蓝色代表穷广告主，虽然预算差了16倍，但是获得的收益是相同的，这个结论对于预算有限的小广告主而言，是个天大的好消息：虽然我们钱不多，但只要我们出价合适，依然可以收获很好的广告效果，四两拨千斤，极大的调动了小广告主参加程序化交易的积极性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/Breada/article/details/50697030" target="_blank" rel="external">计算广告小窥[中]这孙子怎么什么都知道</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014&quot;&gt;&lt;a href=&quot;#Optimal-Real-Time-Bidding-for-Display-Advertising——KDD2014&quot; cl
      
    
    </summary>
    
      <category term="RTB" scheme="http://yoursite.com/categories/RTB/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】169. Majority Element</title>
    <link href="http://yoursite.com/2017/04/10/%E3%80%90leetcode%E3%80%91169-Majority-Element/"/>
    <id>http://yoursite.com/2017/04/10/【leetcode】169-Majority-Element/</id>
    <published>2017-04-10T09:29:01.000Z</published>
    <updated>2017-04-10T09:35:27.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code>times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个数组长度为n，其中有一个元素出现的次数大于<code>⌊ n/2 ⌋</code>，现在我们要找出这个元素</p><h2 id="moore-voting算法"><a href="#moore-voting算法" class="headerlink" title="moore-voting算法"></a>moore-voting算法</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>找出一对不同的元素就去掉它们，最后剩下的一定是所找的元素。</p><p>需要<strong>两个指针</strong>和<strong>一个计数器</strong>，其中一个指针指向当前出现次数最大的元素，另一个向后遍历，count存储当前出现次数最大的元素出现的次数</p><ol><li>当用于遍历的指针2指向元素和指针1指向的元素相等时，count加1，否则减1</li><li>当count减至0的时候，指针1需要向后移动到指针2的位置，指针2继续向后遍历</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">    int len = nums.size();</div><div class="line">    int result = 0;</div><div class="line">    int count = 1;</div><div class="line">    int temp = 0;</div><div class="line">    for (int i = 1; i &lt; len; i++) &#123;</div><div class="line">        if (count != 0) &#123;</div><div class="line">            if (nums[i] == nums[temp])</div><div class="line">                count++;</div><div class="line">            else</div><div class="line">                count--;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            temp = i;</div><div class="line">            count = 1;</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">    return nums[temp];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb46e839db1.png" alt=""> </p><h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h3><p>把数字都转化为二进制处理。如果majority element第i位上的数字是1，那么所有数字第i位上为1的总个数一定会大于<code>⌊ n/2 ⌋</code>,反之，如果majority element第i位上的数字是0，那么所有数字第i位上为0的总个数一定会大于<code>⌊ n/2 ⌋</code></p><p>所以，如果我们统计所有的n个数字的第i位上1(或者0)的个数，看是否大于<code>⌊ n/2 ⌋</code>，就可以确定majority element第i位到底是0还是1了</p><p>int型数据一共有32bit，所有需要计算32个二进制位。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i,j,count,major=0;</div><div class="line">        for(i=0;i&lt;32;i++)</div><div class="line">        &#123;</div><div class="line">            for(j=0,count=0;j&lt;nums.size();j++)</div><div class="line">            &#123;</div><div class="line">                if((nums[j]&gt;&gt;i&amp;1)==1)</div><div class="line">                    count++;</div><div class="line">            &#125;</div><div class="line">            if(count&gt;nums.size()/2)</div><div class="line">                major+=(1&lt;&lt;i);</div><div class="line">        &#125;</div><div class="line">        return major;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ooo.0o0.ooo/2017/04/10/58eb4bc45530f.png" alt=""> </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在用bit manipulation方法时，在已经确定了定majority element第i位到底是0还是1之后恢复majority element的时候，遇到了一个问题，查了很久，在这里总结一下</p><p>一开始我用了下面这样的方法恢复majority element</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (int i = 0; i &lt; 32; i++) &#123;</div><div class="line">    if (countones[i] &gt; len / 2)</div><div class="line">        result += pow(2, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是我们平时手算二进制转化成10进制的方法，但是发现遇到负数的时候就不能正确恢复了==</p><p>然后就查啊查，发现：</p><p><strong>int类型默认是signed的</strong>，也就是说带符号的，32bit中<strong>最高的那一位是用来表示符号的，最高位是0表示非负数，最高位是1表示负数</strong>，所以能够表示的整数的范围是$-2^{31}-1$~$2^{31}-1$。关于负数的二进制表示，之前写过一篇博客 <a href="https://siyaozhang.github.io/2017/04/04/c-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9C-%E2%80%9D/" target="_blank" rel="external">负数的二进制表示</a>，可以看出来确实负数的二进制表示最高位是1</p><p>所以用上面的方法<strong>不断叠加</strong>$2^i$（<strong>正数</strong>）是<strong>永远都不会恢复到原来的负数</strong>的，因为最高位永远都不会由0变为1，而且$2^{31}$已经超过int型的表示范围了。</p><p>因此，还是要<strong>用bit运算根据各个位是0还是1来恢复出原来的majority element</strong>，这样无论是正是负就都不会出错了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority elem
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="bit manipulation" scheme="http://yoursite.com/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>北邮ACM2017练习赛B. 斐波那契数列 矩阵快速幂</title>
    <link href="http://yoursite.com/2017/04/08/%E5%8C%97%E9%82%AEACM2017%E7%BB%83%E4%B9%A0%E8%B5%9BB-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>http://yoursite.com/2017/04/08/北邮ACM2017练习赛B-斐波那契数列-矩阵快速幂/</id>
    <published>2017-04-08T15:19:59.000Z</published>
    <updated>2017-04-08T15:20:16.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/08/58e8ff74c74b3.png" alt=""> </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>矩阵快速幂<br>快速幂</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int mod = 10000;</div><div class="line">const int N = 2;//矩阵的维数,角标从0开始</div><div class="line">struct Matrix</div><div class="line">&#123;</div><div class="line">    long long v[N][N];</div><div class="line">    Matrix()</div><div class="line">    &#123;</div><div class="line">        memset(v,0,sizeof(v));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//矩阵的乘法p1*p2</div><div class="line">Matrix multi(Matrix p1,Matrix p2)</div><div class="line">&#123;</div><div class="line">    Matrix res;</div><div class="line">    for(int i=0;i&lt;N;i++)</div><div class="line">        for(int j=0;j&lt;N;j++)</div><div class="line">            if(p1.v[i][j])//代码优化，是0的话就不用计算</div><div class="line">                for(int k=0;k&lt;N;k++)</div><div class="line">                    res.v[i][k]=(res.v[i][k]+(p1.v[i][j]*p2.v[j][k]))%mod;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">//矩阵的快速幂p^k</div><div class="line">Matrix pow(Matrix p,long long k)</div><div class="line">&#123;</div><div class="line">    Matrix t;</div><div class="line">    for(int i=0;i&lt;N;i++)//初始化为单位矩阵</div><div class="line">        t.v[i][i]=1;</div><div class="line">    while(k)</div><div class="line">    &#123;</div><div class="line">        if(k&amp;1)</div><div class="line">            t=multi(t,p);</div><div class="line">        p=multi(p,p);</div><div class="line">        k=k&gt;&gt;1;</div><div class="line">    &#125;</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    long long n;</div><div class="line">    Matrix e,ans;</div><div class="line">    e.v[0][0]=e.v[0][1]=e.v[1][0]=1;</div><div class="line">    e.v[1][1]=0;</div><div class="line">    while(scanf(&quot;%I64dd&quot;,&amp;n)!=EOF&amp;&amp;n!=-1)</div><div class="line">    &#123;</div><div class="line">        ans = pow(e,n);</div><div class="line">        printf(&quot;%I64d\n&quot;,ans.v[0][1]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/08/58e8ff74c74b3.png&quot; alt=&quot;&quot;&gt; &lt;/
      
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>北邮ACM2017练习赛A. Email Adress</title>
    <link href="http://yoursite.com/2017/04/08/%E5%8C%97%E9%82%AEACM2017%E7%BB%83%E4%B9%A0%E8%B5%9BA-Email-Adress/"/>
    <id>http://yoursite.com/2017/04/08/北邮ACM2017练习赛A-Email-Adress/</id>
    <published>2017-04-08T14:03:41.000Z</published>
    <updated>2017-04-08T14:04:22.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>大概就是给一串字符，表示email地址，其中<code>@</code>用at表示，<code>.</code>用dot表示，当然了字母串里可能本来就有at和dot。<br>所以要想将给定的字符串恢复成尽可能短的email地址需要注意下面几条：</p><ol><li>只能含有一个<code>@</code>，且不能在开头处，即除开头外遇到的第一个at转化成<code>@</code>，其余还是at</li><li>除开头和结尾的dot不能转化成<code>.</code>以外其余的全部转化成<code>.</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">char arrin[10000];</div><div class="line">FILE *fin;</div><div class="line">int main()&#123;</div><div class="line">    fin=fopen(&quot;in.txt&quot;,&quot;r&quot;);</div><div class="line">    char ch;</div><div class="line">    while(~fscanf(fin,&quot;%c&quot;,&amp;ch))&#123;</div><div class="line">        int i =1;</div><div class="line">        bool atflag = false;</div><div class="line">        memset(arrin,0,10000);</div><div class="line">        //存入字符串 </div><div class="line">        arrin[0]=ch;</div><div class="line">        while(fscanf(fin,&quot;%c&quot;,&amp;ch) &amp;&amp; ch!=&apos;\n&apos;)&#123;</div><div class="line">            arrin[i]=ch;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        //arrin[i]=-1;</div><div class="line">        //计算输出</div><div class="line">        printf(&quot;%c&quot;,arrin[0]);</div><div class="line">        for(int j =1;j &lt; i;j++)&#123;</div><div class="line">            if(arrin[j] == &apos;a&apos; &amp;&amp; arrin[j+1] == &apos;t&apos; &amp;&amp; atflag == false)&#123;//第一次遇到at </div><div class="line">                printf(&quot;%c&quot;,&apos;@&apos;);</div><div class="line">                atflag = true;</div><div class="line">                j+=1;</div><div class="line">            &#125;</div><div class="line">            else if(arrin[j] == &apos;d&apos; &amp;&amp; arrin[j+1] == &apos;o&apos; &amp;&amp; arrin[j+2] == &apos;t&apos; &amp;&amp; arrin[j+3] != &apos;\0&apos;)&#123;//dot不在结尾的情况 </div><div class="line">                printf(&quot;%c&quot;,&apos;.&apos;);</div><div class="line">                j+=2;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                printf(&quot;%c&quot;,arrin[j]);</div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">        printf(&quot;\n&quot;);   </div><div class="line">    &#125; </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;大概就是给一串字符，表示email地址，其中&lt;code&gt;@&lt;/code&gt;用at表示，&lt;code&gt;.&lt;/code&gt;用dot表示，当然了字母串里
      
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>北邮ACM2017网预 Square Coins-动态规划</title>
    <link href="http://yoursite.com/2017/04/05/%E5%8C%97%E9%82%AEACM2017%E7%BD%91%E9%A2%84-Square-Coins-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2017/04/05/北邮ACM2017网预-Square-Coins-动态规划/</id>
    <published>2017-04-05T01:44:10.000Z</published>
    <updated>2017-04-05T01:46:09.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Artoria, also known as Saber-chan, was born into a time of chaos and war that began with the demise of the Roman empire. Somewhere in the far east, people in Utopia know nothing about war or conflicts. They live in peace for quite a long time and developed a strange currency system. In particular, they use square coins. Not only have they square shapes but also their values are square integers. Coins with values of all square numbers up to 289 (=172), i.e., 1-credit coins, 4-credit coins, 9-credit coins, …, and 289-credit coins, are available in Utopia.</p><p>According to the Utopia currency system, there are four combinations of coins to pay ten credits:</p><p>ten 1-credit coins,<br>one 4-credit coin and six 1-credit coins,<br>two 4-credit coins and two 1-credit coins, and<br>one 9-credit coin and one 1-credit coin.</p><p>Your mission is to count the number of ways to pay a given amount using coins of Utopia. The answer may be very big, please output the answer module 1000000009.</p><p><strong>input</strong></p><p>The input begins with a line containing a single integer T(1≤T≤2000), indicating the number of test cases. Each of the next T lines each containing an integer meaning an amount to be paid. You may assume that all the amounts are positive and less than 2000. </p><p><strong>output</strong></p><p>For each of the given amount, output one line containing a single integer representing the number of combinations of coins module 1000000009. No other characters should appear in the output.</p><p><strong>sample</strong><br>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2</div><div class="line">10</div><div class="line">30</div></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4</div><div class="line">27</div></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一共有17种面值的硬币，个数不限，给定一个数值n，给出有多少种组合方式</p><p>利用<strong>动态规划</strong>的思想，可以预先计算好组成n的组合方式</p><p><strong>dp[i+coin[j]] = dp[i+coin[j]]+dp[i]</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">int dp[2005];</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; result;</div><div class="line">    memset(dp, 0, 2005);</div><div class="line">    dp[0] = 1;</div><div class="line">    for (int i = 1; i &lt;= 17; i++) &#123;</div><div class="line">        for (int j = 0; j &lt; 2005; j++) &#123;</div><div class="line">            dp[j + i*i] = (dp[j + i*i] + dp[j])% 1000000009;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int N;</div><div class="line">    scanf(&quot;%d&quot;, &amp;N);</div><div class="line">    while (N) &#123;</div><div class="line">        int n;</div><div class="line">        scanf(&quot;%d&quot;, &amp;n);</div><div class="line">        printf(&quot;%d\n&quot;,dp[n]);</div><div class="line">        N--;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Artoria, also known as Saber-chan, was born into a time of chaos and w
      
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>增强学习</title>
    <link href="http://yoursite.com/2017/04/04/%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/04/04/增强学习/</id>
    <published>2017-04-04T09:00:47.000Z</published>
    <updated>2017-04-04T09:01:04.914Z</updated>
    
    <content type="html"><![CDATA[<p>增强学习</p><p>机器学习中的一个领域，关注智能体如何基于环境而采取一系列的行动，以取得最大化的预期利益或回报</p><p>特点</p><p>试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。</p><p>延迟回报，增强学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</p><p>例子</p><p>比如下象棋，每一步都是一个决策过程，但决策的结果事后才知道<br>再比如机器人的行走，移动过程中不知道如何挪动<br>一种可行的思路是设计一个回报函数，每执行一步决策后，向agent进行汇报，比如四足机器人，如果他向前走了一步（接近目标），那么回报函数为正，后退为负。这样，我们对每一步进行评价，得到相应的回报函数，我们只需要找到一条回报值最大的路径（每步的回报之和最大），就认为是最佳的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;增强学习&lt;/p&gt;
&lt;p&gt;机器学习中的一个领域，关注智能体如何基于环境而采取一系列的行动，以取得最大化的预期利益或回报&lt;/p&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;p&gt;试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳
      
    
    </summary>
    
      <category term="deep learning" scheme="http://yoursite.com/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>word2vec（文本深度表示模型）</title>
    <link href="http://yoursite.com/2017/04/04/word2vec%EF%BC%88%E6%96%87%E6%9C%AC%E6%B7%B1%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/04/word2vec（文本深度表示模型）/</id>
    <published>2017-04-04T08:59:51.000Z</published>
    <updated>2017-04-04T09:00:19.723Z</updated>
    
    <content type="html"><![CDATA[<p>简介</p><p>Word2vec 是 Google 在 2013 年年中开源的一款将词表征为实数值向量的高效工具, 其利用深度学习的思想，可以通过训练，把对文本内容的处理简化为 K 维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。Word2vec输出的词向量可以被用来做很多 NLP 相关的工作，比如聚类、找同义词、词性分析等等。如果换个思路， 把词当做特征，那么Word2vec就可以把特征映射到 K 维向量空间，可以为文本数据寻求更加深层次的特征表示 。</p><p>Word2vec 使用的是 Distributed representation 的词向量表示方式。Distributed representation 最早由 Hinton在 1986 年提出[4]。其基本思想是 通过训练将每个词映射成 K 维实数向量（K 一般为模型中的超参数），通过词之间的距离（比如 cosine 相似度、欧氏距离等）来判断它们之间的语义相似度.其采用一个 三层的神经网络 ，输入层-隐层-输出层。有个核心的技术是 根据词频用Huffman编码 ，使得所有词频相似的词隐藏层激活的内容基本一致，出现频率越高的词语，他们激活的隐藏层数目越少，这样有效的降低了计算的复杂度。而Word2vec大受欢迎的一个原因正是其高效性，Mikolov 在论文[2]中指出，一个优化的单机版本一天可训练上千亿词。</p><p>这个三层神经网络本身是 对语言模型进行建模 ，但也同时 获得一种单词在向量空间上的表示 ，而这个副作用才是Word2vec的真正目标。</p><p>与潜在语义分析（Latent Semantic Index, LSI）、潜在狄立克雷分配（Latent Dirichlet Allocation，LDA）的经典过程相比，Word2vec利用了词的上下文，语义信息更加地丰富。</p><p>参考文献</p><p>有道技术沙龙-Deep Learning实战之word2vec</p><p>卷积和pooling</p><p>Deep Learning in NLP （一）词向量和语言模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;Word2vec 是 Google 在 2013 年年中开源的一款将词表征为实数值向量的高效工具, 其利用深度学习的思想，可以通过训练，把对文本内容的处理简化为 K 维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。Word2v
      
    
    </summary>
    
      <category term="deep learning" scheme="http://yoursite.com/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>北邮ACM2017热身赛-A题</title>
    <link href="http://yoursite.com/2017/04/04/%E5%8C%97%E9%82%AEACM2017-A%E9%A2%98/"/>
    <id>http://yoursite.com/2017/04/04/北邮ACM2017-A题/</id>
    <published>2017-04-04T08:58:07.000Z</published>
    <updated>2017-04-08T14:03:53.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/04/58e34e2ccb0cc.png" alt=""> </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个列数字，求这列数字中的三元组$(a_i,a_j,a_k)$满足下面两个条件</p><ol><li>$a_i\leq a_j\leq a_k$</li><li>$a_i+a_j+a_k=0$<br>注意：<strong>重复的只算一次</strong></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先排序</p><p>三个元素和为0，那么一定有两个元素大于等于0，一个小于0；或者两个小于等于0，一个大于0。总之<strong>不能三个元素都同号</strong></p><p>设三个指针，low从前往后扫描，high从后往前扫描，mid在这两个指针中间从前往后扫描：<br>先固定low指针，从前往后扫描，知道元素值&gt;=0时停止</p><ul><li>当三个指针指向的元素和为0时，记录下来。</li><li>当三个指针指向的元素和&gt;0时，high向前移动。</li><li>当三个指针指向的元素和&lt;0时，mid向后移动。</li></ul><p>需要注意的地方：</p><ol><li>同一个指针扫过的<strong>相等的元素只计算第一次</strong>，后面的要略过</li><li>元素值的平方已经超过int的最大位数，要用<strong>long long</strong>型</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line"> </div><div class="line">int main() &#123;</div><div class="line">    int arr[2005] = &#123; 0 &#125;;</div><div class="line">    char c;</div><div class="line">    vector&lt;int&gt; output;</div><div class="line">    int samplenum;</div><div class="line">    cin &gt;&gt; samplenum;</div><div class="line">    while (samplenum)</div><div class="line">    &#123;</div><div class="line">        long long result = 0;</div><div class="line">        int len;</div><div class="line">        cin &gt;&gt; len;</div><div class="line">        getchar();</div><div class="line">        int ii = 0;</div><div class="line">        //读入数据</div><div class="line">        while ((c = getchar()) != &apos;\n&apos;)</div><div class="line">        &#123;</div><div class="line">            if (c != &apos; &apos;)//把这句判断条件改动  </div><div class="line">            &#123;</div><div class="line">                ungetc(c, stdin);</div><div class="line">                cin &gt;&gt; arr[ii++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //排序</div><div class="line">        sort(arr, arr + len);</div><div class="line">        //low指针从前向后遍历</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            if (i &gt; 0 &amp;&amp; arr[i] == arr[i - 1]) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            int lo = i + 1;</div><div class="line">            int hi = len - 1;</div><div class="line">            while (lo &lt; hi) &#123;</div><div class="line">                if ((arr[i] + arr[lo] + arr[hi]) == 0) &#123;</div><div class="line">                    long long aa = (long long)arr[i] * arr[i];</div><div class="line">                    long long bb = (long long)arr[lo] * arr[lo];</div><div class="line">                    long long cc = (long long)arr[hi] * arr[hi];</div><div class="line">                    long long aaa = aa + bb + cc;</div><div class="line">                    result += aaa;</div><div class="line">                    //略过相同元素</div><div class="line">                    while (lo + 1 &lt;= hi &amp;&amp; arr[lo + 1] == arr[lo]) &#123;</div><div class="line">                        lo++;</div><div class="line">                    &#125;</div><div class="line">                    while (hi - 1 &gt;= lo &amp;&amp; arr[hi - 1] == arr[hi]) &#123;</div><div class="line">                        hi--;</div><div class="line">                    &#125;</div><div class="line">                    lo++;</div><div class="line">                    hi--;</div><div class="line">                &#125;</div><div class="line">                else if ((arr[i] + arr[lo] + arr[hi]) &gt; 0) &#123;</div><div class="line">                    hi--;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    lo++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        output.push_back(result % 1000000007);</div><div class="line">        samplenum--;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; output.size(); i++)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; output[i] &lt;&lt; endl;</div><div class="line">    &#125;   </div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/04/58e34e2ccb0cc.png&quot; alt=&quot;&quot;&gt; &lt;/
      
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>北邮ACM2017热身赛-D题</title>
    <link href="http://yoursite.com/2017/04/04/%E5%8C%97%E9%82%AEACM2017-D%E9%A2%98/"/>
    <id>http://yoursite.com/2017/04/04/北邮ACM2017-D题/</id>
    <published>2017-04-04T08:57:58.000Z</published>
    <updated>2017-04-08T14:04:01.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://ooo.0o0.ooo/2017/04/04/58e35af64bb4e.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/04/58e35b082f8e5.png" alt=""> </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个整数，将它分解成连续素数的和，求这样的分解方法数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先利用素数筛打出素数表</p><p>然后</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">vector&lt;int&gt; primes;</div><div class="line">bool is_prime[1000006];</div><div class="line"></div><div class="line">//建立素数表和存储素数的vector</div><div class="line">void init_primes()</div><div class="line">&#123;</div><div class="line">    memset(is_prime,true, 1000005);</div><div class="line">    is_prime[0] = is_prime[1] = false;</div><div class="line">    for (int i = 2; i &lt;= 1000005; ++i)&#123;</div><div class="line">        if (is_prime[i])&#123;</div><div class="line">            primes.push_back(i);</div><div class="line">            for (int j = 2; j*i &lt;= 1000005; j++)&#123;</div><div class="line">                is_prime[i*j] = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()&#123;</div><div class="line">    vector&lt;int&gt; output;</div><div class="line">    init_primes();</div><div class="line">    int primesnum = primes.size();</div><div class="line">    int n;</div><div class="line">    while (cin &gt;&gt; n)&#123;</div><div class="line">        //i是分解形式的首个素数，j是最后一个素数</div><div class="line">        int i = 0, j = 0, sum = 0, result = 0;</div><div class="line">        while(true)&#123;</div><div class="line">            while (sum &lt; n &amp;&amp; j &lt; primesnum)&#123;</div><div class="line">                sum += primes[j++];</div><div class="line">            &#125;</div><div class="line">            //加到最后一个素数了，和还是小于n，说明后面没有满足条件的分解方式了，跳出循环结束运算</div><div class="line">            if (sum &lt; n)&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if (sum == n)&#123;</div><div class="line">                ++result;</div><div class="line">            &#125;</div><div class="line">            //i向后移</div><div class="line">            sum -= primes[i++];</div><div class="line">        &#125;</div><div class="line">        output.push_back(result);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; output.size(); i++) &#123;</div><div class="line">        cout &lt;&lt; output[i] &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/04/58e35af64bb4e.png&quot; alt=&quot;&quot;&gt;&lt;br
      
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
  </entry>
  
</feed>
