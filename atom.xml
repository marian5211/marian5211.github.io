<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-20T06:43:23.804Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【RTB论文笔记】</title>
    <link href="http://yoursite.com/2017/11/20/%E3%80%90RTB%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91/"/>
    <id>http://yoursite.com/2017/11/20/【RTB论文笔记】/</id>
    <published>2017-11-20T06:43:23.000Z</published>
    <updated>2017-11-20T06:43:23.804Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记3——堆Heap</title>
    <link href="http://yoursite.com/2017/11/18/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%A0%86Heap/"/>
    <id>http://yoursite.com/2017/11/18/【九章算法强化班】课程笔记3——堆Heap/</id>
    <published>2017-11-18T07:15:48.000Z</published>
    <updated>2017-11-18T07:15:48.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">Trapping Rain Water</a></h2><blockquote><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p><p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt="img"></p></blockquote><p>向柱子中灌水，求能够灌水的总量。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以从边缘向内灌水，灌水的高度不会超过边缘柱子的高度的最小值，所以说：<strong>边缘高度奠定了灌水的基调</strong></p><p>从低的一边（高度为h）向内灌水，能够灌水的量为（h-h_temp），遇到更高的柱子时，更新边缘。</p><p>显然，这是一个<strong>双指针</strong>问题。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-31-18.png" alt=""> </p><p>开始时，令总水量sum=0，双指针指向边缘，左选择较小的向内移动，假如选择左边指针。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-32-16.png" alt=""> </p><p>sum += 1，指针继续向右移动</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-33-23.png" alt=""> </p><p>此时左边指针遇到了跟高的边缘，右边指针开始向内移动</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-34-14.png" alt=""> </p><p>右边指针也同样遇到了更高的柱子，此时再从左右两边指针中选择一个较小的向内移动，假如选的依然是左边的，向内移动，更新sum，知道遇到更高的柱子</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-18-15-35-36.png" alt=""> </p><p>右侧指针左移，直到两指针相遇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public int trap(int[] height) &#123;</div><div class="line">    int left = 0;</div><div class="line">    int right = height.length-1;</div><div class="line">    int sum = 0;</div><div class="line">    while(left &lt; right)&#123;</div><div class="line">        if(height[left]&lt;height[right])&#123;</div><div class="line">            int min = height[left];</div><div class="line">            left++;</div><div class="line">            while(height[left]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[left];</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            int min = height[right];</div><div class="line">            right--;</div><div class="line">            while(height[right]&lt;=min &amp;&amp; left &lt; right)&#123;</div><div class="line">                sum+=min-height[right];</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Trapping-Rain-Water-II"><a href="#Trapping-Rain-Water-II" class="headerlink" title="Trapping Rain Water II"></a><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">Trapping Rain Water II</a></h2><blockquote><p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p><p><strong>Note:</strong><br>Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 3x6 height map:</div><div class="line">&gt; [</div><div class="line">&gt;   [1,4,3,1,3,2],</div><div class="line">&gt;   [3,2,1,3,2,4],</div><div class="line">&gt;   [2,3,3,2,3,1]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; Return 4.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><img src="https://leetcode.com/static/images/problemset/rainwater_empty.png" alt="img"><br>The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.</p><p><img src="https://leetcode.com/static/images/problemset/rainwater_fill.png" alt="img"><br>After the rain, water are trapped between the blocks. The total volume of water trapped is 4.</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这一题是上一题在二维空间上的扩展。</p><p>对比上一题的思路，上一题的围墙是左右两边的柱子，而这道题的围墙是矩阵四周一圈的墙。我们可以从最矮的墙头向内灌水，然后将被灌水的位置加入围墙。</p><p>有两个要解决的点：</p><ol><li>找到围墙中最矮的墙头</li><li>从最矮的墙头向围墙内灌水，要知道那边是围墙“内”</li></ol><p>对于第1点，要求围墙中最矮的墙头，且墙头是动态插入的，可以维护一个最小堆，每次出堆元素即为最小的。</p><p>对于第2点，可以额外维护一个标记数组，记录是否已经被访问过，每次入堆就将该点对应的位置标记，若某一点没有被标记则是在围墙内。</p><p>以上图为例：</p><p>首先将四周设为围墙，将围墙元素入堆[1,4,3,1,3,2,3,4,2,3,3,2,3,1]</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-30-45.png" alt=""> </p><p>选取围墙中最小的，向内灌水，比如：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-53-16.png" alt=""> </p><p>由于3&gt;1，不能灌水，将3所在位置加入围墙[<del>1</del>,4,3,1,3,2,3,4,2,3,3,2,3,1, 3]</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-55-43.png" alt=""> </p><p>然后依次选取高度为1的其他几个围墙作为最矮的围墙，发现都不能够往里灌水，接下来选择高度为2的围墙，发现也不能向内灌水了，选取高度为3的围墙，比如：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-10-56-45.png" alt=""> </p><p>发现可以灌水量为2，然后将此点灌水后的高度加入围墙，[<del>1</del>,4,<del>3</del>,<del>1,</del>3,<del>2</del>,3,4,<del>2</del>,3,3,<del>2</del>,3,<del>1</del>,3,  3]：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-20-11-03-13.png" alt=""> </p><p>继续重复上边的步骤，知道堆为空</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRain2</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        Node(<span class="keyword">int</span> val,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node e1,Node e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1.val-e2.val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(heightMap.length == <span class="number">0</span> || heightMap[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[heightMap.length][heightMap[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(cmp);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="comment">//初始边界入堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heightMap.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; heightMap[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == heightMap.length-<span class="number">1</span> || j == heightMap[<span class="number">0</span>].length-<span class="number">1</span>)&#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(heightMap[i][j],i,j));</div><div class="line">                    visited[i][j] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            Node top =  heap.peek();</div><div class="line">            heap.remove();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">                <span class="keyword">int</span> x_new = top.x+x_delta[i];</div><div class="line">                <span class="keyword">int</span> y_new = top.y+y_delta[i];</div><div class="line">                <span class="keyword">if</span>(x_new &gt;=<span class="number">0</span> &amp;&amp; x_new &lt; heightMap.length &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt; heightMap[<span class="number">0</span>].length &amp;&amp; !visited[x_new][y_new])&#123;</div><div class="line">                    <span class="keyword">if</span>(heightMap[x_new][y_new] &lt; top.val)&#123;</div><div class="line">                        sum += top.val-heightMap[x_new][y_new];</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(top.val,x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        heap.add(<span class="keyword">new</span> Node(heightMap[x_new][y_new],x_new,y_new));</div><div class="line">                    &#125;</div><div class="line">                    visited[x_new][y_new] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TrappingRain2 test = <span class="keyword">new</span> TrappingRain2();</div><div class="line">        <span class="keyword">int</span>[][] heightMap = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">        <span class="keyword">int</span> sum = test.trapRainWater(heightMap);</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;h2 id=&quot;Trapping-Rain-Water&quot;&gt;&lt;a href=&quot;#Trapping-Rain-Water&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2——扫描线</title>
    <link href="http://yoursite.com/2017/11/17/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <id>http://yoursite.com/2017/11/17/【九章算法强化班】课程笔记2——扫描线/</id>
    <published>2017-11-17T09:38:49.000Z</published>
    <updated>2017-11-17T09:39:12.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h2 id="lintcode391-数飞机"><a href="#lintcode391-数飞机" class="headerlink" title="lintcode391. 数飞机"></a><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给出飞机的起飞和降落时间的列表，用 interval 序列表示. 请计算出天上同时最多有多少架飞机？</p><p>样例</p><p>对于每架飞机的起降时间列表：<code>[[1,10],[2,3],[5,8],[4,7]]</code>, 返回<code>3</code>。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-17-20-40-58.png" alt=""> </p><p>计算空中的飞机个数，可以看成用一个线从左到右扫描的过程，计算每一时刻空中飞机的数量。</p><p>优化：只计算所有线段起始位置时天上的飞机即可，因为只有起始点是可能发生变化的点。遇到起点，天上的飞机数+1，遇到终点则-1。</p><p>因此，我们先将所有线段的起点、终点排序，并标记是起点还是终点，然后从小到大遍历这些点，遇到起点则+1，遇到终点-1，返回过程中最大的数值即为空中飞机数的最大值。</p><p><strong>需要注意的是</strong>：在同一点上会同时有开始点和结尾点，此时应该把结尾点放在前面，否则会出现多计算的情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.operations.Bool;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">airplane_count</span> </span>&#123;</div><div class="line">    <span class="comment">//Definition of Interval:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span></span>&#123;</div><div class="line">        Integer start, end;</div><div class="line">        Interval(Integer start, Integer end) &#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Definition of node:</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line">        Integer val;</div><div class="line">        <span class="keyword">boolean</span> isstart;</div><div class="line">        Node(Integer val, <span class="keyword">boolean</span> isstart) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.isstart = isstart;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//定义排序接口</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node Other)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.val == Other.val)&#123;<span class="comment">//如果连个节点位置相同，把结束点排在前面</span></div><div class="line">                <span class="keyword">return</span> Boolean.compare(<span class="keyword">this</span>.isstart,Other.isstart);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.val, Other.val);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(List&lt;Interval&gt; airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> size = airplanes.size();</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        Node[] array = <span class="keyword">new</span> Node[<span class="number">2</span> * size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.size(); i++) &#123;</div><div class="line">            array[<span class="number">2</span> * i] = (<span class="keyword">new</span> Node(airplanes.get(i).start, <span class="keyword">true</span>));</div><div class="line">            array[<span class="number">2</span> * i + <span class="number">1</span>] = (<span class="keyword">new</span> Node(airplanes.get(i).end, <span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(array);</div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i].isstart) &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252.Meeting Rooms"></a><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></h4><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), determine if a person could attend all meetings.</p><p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>false</code>.</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目是说判断一个人是否可以参加给出的所有的会议，可以沿用扫描线的思路：同一时刻最多只有一个会议正在召开，就可以参加所有会议。</p><p>还有另外一种更快的思路：</p><p>如果每一个会议的开始都在上一个会议结束之后，那么就不会有时间冲突的会议，就可以都参加了，所以可以将给出的所有会议的开始时间和结束时间分别放入两个数组中，分别排序，然后判断是否所有的时间满足：starts[i]&gt;ends[i-1]。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] airplanes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[airplanes.length];</div><div class="line"></div><div class="line">        <span class="comment">//插入元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; airplanes.length; i++) &#123;</div><div class="line">            starts[i] = airplanes[i].start;</div><div class="line">            ends[i] = airplanes[i].end;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(starts);</div><div class="line">        Arrays.sort(ends);</div><div class="line"></div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; starts.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (starts[i]&lt;ends[i-<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253.Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扫描线&quot;&gt;&lt;a href=&quot;#扫描线&quot; class=&quot;headerlink&quot; title=&quot;扫描线&quot;&gt;&lt;/a&gt;扫描线&lt;/h1&gt;&lt;h2 id=&quot;lintcode391-数飞机&quot;&gt;&lt;a href=&quot;#lintcode391-数飞机&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sweep_line" scheme="http://yoursite.com/tags/sweep-line/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】题目摘要</title>
    <link href="http://yoursite.com/2017/11/16/%E3%80%90leetcode%E3%80%91%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81/"/>
    <id>http://yoursite.com/2017/11/16/【leetcode】题目摘要/</id>
    <published>2017-11-16T01:56:40.000Z</published>
    <updated>2017-11-16T01:56:40.749Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>题目</th><th>题意</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">208.Implement Trie (Prefix Tree)</a></td><td>实现一个Trie树模板，支持插入、搜索、前缀搜索操作</td><td>Trie</td></tr><tr><td><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">211.Add and Search Word - Data structure design</a></td><td>实现Trie树的插入、搜索，支持搜索”a.b”格式，”.”表示通配符</td><td>Trie+DFS</td></tr><tr><td><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">677.Map Sum Pairs</a></td><td>单词有权重，输入前缀词，给出所有以此为前缀的词的权重之和</td><td>Trie+DFS</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">200.Number of Islands</a></td><td>统计中有0,1，相邻1为island，统计island个数(连通子图)</td><td>并查集、DFS</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-islands-ii/" target="_blank" rel="external">305.Number of Islands II</a></td><td>初始矩阵为0，每次随机将某一位改变成1，统计每一时刻island个数</td><td>并查集</td></tr><tr><td><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="external">130.Surrounded Regions</a></td><td>“XXOO”将被X包围的O改成X，处于边界的O不算被包围</td><td>DFS、并查集</td></tr><tr><td><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="external">261.Graph Valid Tree</a></td><td>给定点集和边集，判断此图是否为树</td><td>并查集</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="external">323.Number of Connected Components in an Undirected Graph</a></td><td>给定点集和边集，返回连通子图个数</td><td>并查集</td></tr><tr><td><a href="https://leetcode.com/problems/word-search" target="_blank" rel="external">79.Word Search</a></td><td>给一个字母矩阵和一个单词，查找字母矩阵中是否有该单词</td><td>回溯+BFS</td></tr><tr><td><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">212.Word Search II</a></td><td>给一个字母矩阵和一个单词数组，返回数组，里面包含出现在矩阵中的所有单词</td><td>Trie+DFS</td></tr><tr><td><a href="http://www.lintcode.com/zh-cn/problem/number-of-airplanes-in-the-sky/" target="_blank" rel="external">lintcode391. 数飞机</a></td><td>给定一些区间，求同一时刻空中最多有多少飞机</td><td>扫描线</td></tr><tr><td><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252.Meeting Rooms</a></td><td>给定一些区间，判断是否可以参加所有会议（所有会议没有冲突）</td><td>排序扫描/扫描线</td></tr><tr><td><a href="https://leetcode.com/problems/meeting-rooms-ii" target="_blank" rel="external">253.Meeting Rooms II</a></td><td>给定一些区间，求最多需要多少间会议室（最多有多少会议同时开）</td><td>扫描线</td></tr><tr><td><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">42.Trapping Rain Water</a></td><td>一维接雨水</td><td>双指针</td></tr><tr><td><a href="https://leetcode.com/problems/trapping-rain-water-ii" target="_blank" rel="external">407.Trapping Rain Water II</a></td><td>二维接雨水</td><td>堆</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.com/problems/triangle" target="_blank" rel="external">120.Triangle</a></td><td>给定一个三角形，求从顶端走到最下面的最短路径</td><td>DP</td></tr><tr><td></td><td></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;题意&lt;/th&gt;
&lt;th&gt;知识点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://lee
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2——Trie树</title>
    <link href="http://yoursite.com/2017/11/14/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2017/11/14/【九章算法强化班】课程笔记2——Trie树/</id>
    <published>2017-11-14T14:11:55.000Z</published>
    <updated>2017-11-15T12:57:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="leetcode相关题目"><a href="#leetcode相关题目" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><ul><li><del><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></del></li><li><del><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></del></li><li><del><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></del></li><li>​</li></ul><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p><p>Trie树，即字典树/前缀树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p><p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p><p>将单词插入Trie树，只在跟之前的字符串出现分歧时分裂，对最后一个字母做标记，这样查找的时候，根据最后一个字母的标记，即可判断出该单词是否出现过。</p><p>这里有一个巧妙的操作，可以让插入和查询操作同时完成，所以查询的时间复杂度简化为所要查询的单词的长度，即<script type="math/tex">O(1)</script>。</p><p>它有3个基本性质：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container"><table><thead><tr><th></th><th>hash_table</th><th>TIRE树</th></tr></thead><tbody><tr><td>查找时间复杂度</td><td>O(1)</td><td>O(1)</td></tr><tr><td>空间复杂度</td><td></td><td>优于hash_table</td></tr></tbody></table></div><p>对于a,aa,aaa,aaaa的情况</p><div class="table-container"><table><thead><tr><th></th><th>hash</th><th>trie</th></tr></thead><tbody><tr><td>存储</td><td>10个a</td><td>5个a节点</td></tr><tr><td>可用操作</td><td>有/无/查询</td><td>有/无/前缀查询</td></tr><tr><td></td><td>1行</td><td>75~100行</td></tr></tbody></table></div><p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p><h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p><p>需要节约空间</p><p>查找前缀</p><h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>有两种方式来实现Trie树，对于存储char类型的Trie树，因为只有26个字母，故可采用映射的方式将字母映射到长度为26的数组上，而下标就是字母。</p><p>而对于其他类型，比如int数目未知，可以考虑用hashmap的方式来实现。</p><h3 id="1-hashmap实现Trie树"><a href="#1-hashmap实现Trie树" class="headerlink" title="1. hashmap实现Trie树"></a>1. hashmap实现Trie树</h3><p>c++版：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">char</span> ch;</div><div class="line"><span class="keyword">bool</span> istail;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childern;</div><div class="line"></div><div class="line">TrieNode() &#123;</div><div class="line">childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line"><span class="comment">//childern = NULL;</span></div><div class="line">istail = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">TrieNode(<span class="keyword">char</span> c) &#123;</div><div class="line">ch = c;</div><div class="line">childern = <span class="keyword">new</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;();</div><div class="line"><span class="comment">//childern = NULL;</span></div><div class="line">istail = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">TrieNode* root;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line">Trie() &#123;</div><div class="line">root = <span class="keyword">new</span> TrieNode();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Inserts a word into the trie. */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">TrieNode* node = <span class="keyword">this</span>-&gt;root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line"><span class="keyword">char</span> chtemp = word[i];</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">iter = (*childrenmap).find(chtemp);</div><div class="line"><span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">node = iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">TrieNode* newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">node = newnode;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; newmap;</div><div class="line">TrieNode *newnode = <span class="keyword">new</span> TrieNode(chtemp);</div><div class="line">(*childrenmap).insert(make_pair(chtemp, newnode));</div><div class="line">node = newnode;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">node-&gt;istail = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns if the word is in the trie. */</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (word.size() == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">TrieNode* node = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line"><span class="keyword">char</span> chtemp = word[i];</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">iter = (*childrenmap).find(chtemp);</div><div class="line"><span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">node = iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//children为空</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (node-&gt;ch == word[word.size() - <span class="number">1</span>] &amp;&amp; node-&gt;istail) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line">TrieNode* node = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.size(); i++) &#123;</div><div class="line"><span class="keyword">char</span> chtemp = prefix[i];</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;* childrenmap = node-&gt;childern;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(*childrenmap).empty()) &#123;</div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt;::iterator iter;</div><div class="line">iter = (*childrenmap).find(chtemp);</div><div class="line"><span class="keyword">if</span> (iter != (*childrenmap).end()) &#123;<span class="comment">//包含此字母</span></div><div class="line">node = iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//children空</span></div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>java版本：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        HashMap&lt;Character,TrieNode&gt; children;</div><div class="line">        <span class="keyword">boolean</span> istail;</div><div class="line">        TrieNode()&#123;</div><div class="line">            children = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">        TrieNode root;</div><div class="line">        Trie()&#123;</div><div class="line">            root = <span class="keyword">new</span> TrieNode();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;word.length();i++) &#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span> (node.children.containsKey(chtemp)) &#123;<span class="comment">//已经包含此字母</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//不包含此字母</span></div><div class="line">                    node.children.put(chtemp, <span class="keyword">new</span> TrieNode());</div><div class="line">                &#125;</div><div class="line">                node = node.children.get(chtemp);</div><div class="line">            &#125;</div><div class="line">            node.istail=<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(word.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length();i++)&#123;</div><div class="line">                <span class="keyword">char</span> chtemp = word.charAt(i);</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(chtemp)) &#123;<span class="comment">//包含此字母</span></div><div class="line">                    node = node.children.get(chtemp);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(node.istail)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span> (prefix.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(node.children.containsKey(prefix.charAt(i)))&#123;</div><div class="line">                    node = node.children.get(prefix.charAt(i));</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure><h3 id="2-数组实现Trie树"><a href="#2-数组实现Trie树" class="headerlink" title="2. 数组实现Trie树"></a>2. 数组实现Trie树</h3><p>对于char类型的数据，只有26个字母，所以，可以用一个长度为26的数组存储后续的节点，数组index对应的就是字母的顺序：a~z</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[prefix.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="leetcode相关题目-1"><a href="#leetcode相关题目-1" class="headerlink" title="leetcode相关题目"></a>leetcode相关题目</h2><h3 id="Add-and-Search-Word-Data-structure-design"><a href="#Add-and-Search-Word-Data-structure-design" class="headerlink" title="Add and Search Word - Data structure design"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="external">Add and Search Word - Data structure design</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; void addWord(word)</div><div class="line">&gt; bool search(word)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; addWord(&quot;bad&quot;)</div><div class="line">&gt; addWord(&quot;dad&quot;)</div><div class="line">&gt; addWord(&quot;mad&quot;)</div><div class="line">&gt; search(&quot;pad&quot;) -&gt; false</div><div class="line">&gt; search(&quot;bad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;.ad&quot;) -&gt; true</div><div class="line">&gt; search(&quot;b..&quot;) -&gt; true</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用Tire树，搜索时遇到”.”对所有节点进行DFS</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">boolean</span> istail;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.istail=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Adds a word into the data structure. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.istail=<span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchHelper</span><span class="params">(String word,<span class="keyword">int</span> startIdx,TrieNode node)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIdx ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word.charAt(i) == <span class="string">'.'</span>)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>;j++) &#123;</div><div class="line">                    <span class="keyword">if</span> (node.children[j] != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//TrieNode nodetemp = node.children[j];</span></div><div class="line">                        <span class="keyword">boolean</span> has = searchHelper(word, i + <span class="number">1</span>, node.children[j]);</div><div class="line">                        <span class="keyword">if</span> (has) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(node.istail) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> searchHelper(word,<span class="number">0</span>,<span class="keyword">this</span>.root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></div><div class="line"><span class="comment"> * obj.addWord(word);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><h3 id="Map-Sum-Pairs"><a href="#Map-Sum-Pairs" class="headerlink" title="Map Sum Pairs"></a><a href="https://leetcode.com/problems/map-sum-pairs/" target="_blank" rel="external">Map Sum Pairs</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement a MapSum class with <code>insert</code>, and <code>sum</code> methods.</p><p>For the method <code>insert</code>, you’ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.</p><p>For the method <code>sum</code>, you’ll be given a string representing the prefix, and you need to return the sum of all the pairs’ value whose key starts with the prefix.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: insert(&quot;apple&quot;, 3), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 3</div><div class="line">&gt; Input: insert(&quot;app&quot;, 2), Output: Null</div><div class="line">&gt; Input: sum(&quot;ap&quot;), Output: 5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>建立Trie树，将原来的标记是否为单词结尾的bool型属性改为int型权重属性，单词结尾的字母值为该单词的权重值，其余字母权重设为0，找到前缀所在分支之后，DFS该前缀词下面的所有节点，累加权重值。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="keyword">int</span> weight;<span class="comment">//记录是否是某个单词的末尾</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.weight = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; key.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[key.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[key.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[key.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.weight=val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode node)</span></span>&#123;</div><div class="line">        res = res+node.weight;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[i]!=<span class="keyword">null</span>)&#123;</div><div class="line">                dfs(node.children[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; prefix.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (node.children[prefix.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有这个字母</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node = node.children[prefix.charAt(i) - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        res=<span class="number">0</span>;</div><div class="line">        dfs(node);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * MapSum obj = new MapSum();</span></div><div class="line"><span class="comment"> * obj.insert(key,val);</span></div><div class="line"><span class="comment"> * int param_2 = obj.sum(prefix);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><h3 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">Word Search II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p><p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>For example,<br>Given <strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</div><div class="line">&gt;   [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</div><div class="line">&gt;   [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Return </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [&quot;eat&quot;,&quot;oath&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>Word Search 1要求我们返回某一个单词是否在矩阵中，Word Search 2作为升级版。给出了一串单词，搜索是否在矩阵中，如果一个一个搜索效率会很低，尤其是在要搜索的单词序列中有大量相同的前缀时，所以，考虑<strong>将搜索的单词序列构建Trie树，然后再在字母矩阵中用DFS的方式搜索</strong>。</p><p>然而想到了思路，要想完整地写出这道题，也十分艰难。</p><p>这里有几个需要注意的点：</p><ol><li><p>要将能够搜索到的单词加入最终的结果表中，可以适当修改Trie的结构，在叶子节点存储该条路径对应的word，方便后续找到路径之后将该单词加入结果表</p></li><li><p>已经用过的字母不能用第二次，所以要对字母矩阵中遍历过的字母做标记，DFS搜索结束后要恢复标记，后面还可以继续使用。这里我一开始用的方法是额外建立一个boolean型矩阵进行存储，看了大神的代码发现可以直接在原字母矩阵中进行标记即可。</p></li><li><p>在矩阵中某点周围寻找下一个字母是否存在时，我一开始采用的方式是：</p><p>在Trie树中遍历下一层node中的字母然后再去字母矩阵中某点周围四个点搜索，这样遍历下一层node判断是否还有字母，每次需要遍历26个字母，看了大神的代码有更好的方式：</p><p>从矩阵当前点周围的四个点入手，获取周围四个点的字母（实际上最多是三个，因为至少已经有一个被访问了），然后再去node中直接获取下层节是否存在该字母即可。</p></li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">        TrieNode[] children;</div><div class="line">        <span class="comment">//boolean istail;//记录是否是某个单词的末尾</span></div><div class="line">        String word;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="comment">//this.istail=false;</span></div><div class="line">            <span class="keyword">this</span>.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TrieNode root = <span class="keyword">new</span> TrieNode();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        TrieNode node = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; word.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(node.children[word.charAt(i)-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;<span class="comment">//如果有这个字母</span></div><div class="line">                node.children[word.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            node = node.children[word.charAt(i)-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        node.word = word;</div><div class="line">        <span class="comment">//node.istail=true;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchBoard</span><span class="params">(<span class="keyword">char</span>[][] board, TrieNode node,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,List&lt;String&gt; result)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> ch = board[x_idx][y_idx];</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'#'</span> || node.children[ch-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        node = node.children[ch-<span class="string">'a'</span>];</div><div class="line">        <span class="keyword">if</span>(node.word != <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(node.word);</div><div class="line">            node.word = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = <span class="string">'#'</span>;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">            <span class="keyword">int</span> x = x_idx+x_delta[i];</div><div class="line">            <span class="keyword">int</span> y = y_idx+y_delta[i];</div><div class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length)&#123;</div><div class="line">                searchBoard(board,node,x,y,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        board[x_idx][y_idx] = ch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length;i++)&#123;</div><div class="line">            insert(words[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board.length;j++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; board[<span class="number">0</span>].length;k++)&#123;</div><div class="line">                searchBoard(board,root,j,k,result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title=&quot;Trie树&quot;&gt;&lt;/a&gt;Trie树&lt;/h1&gt;&lt;h2 id=&quot;leetcode相关题目&quot;&gt;&lt;a href=&quot;#leetcode相关题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Logistic Regression相关</title>
    <link href="http://yoursite.com/2017/11/06/Logistic-Regression%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/11/06/Logistic-Regression相关/</id>
    <published>2017-11-06T14:47:50.000Z</published>
    <updated>2017-11-06T14:47:50.130Z</updated>
    
    <content type="html"><![CDATA[<p>LR真的很基础而且也非常非常重要，算法面试必考，啃了好多遍，总结一下，希望能够经常复习。</p><p>暑假去头条面试，一面的面试官问到：</p><ol><li>推导一下LR吧</li><li>为什么要用sigmod函数</li><li>如何优化求解（梯度下降）</li><li>代码实现一下</li></ol><h2 id="LR模型推导"><a href="#LR模型推导" class="headerlink" title="LR模型推导"></a>LR模型推导</h2><h2 id="梯度下降求解LR"><a href="#梯度下降求解LR" class="headerlink" title="梯度下降求解LR"></a>梯度下降求解LR</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LR真的很基础而且也非常非常重要，算法面试必考，啃了好多遍，总结一下，希望能够经常复习。&lt;/p&gt;
&lt;p&gt;暑假去头条面试，一面的面试官问到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推导一下LR吧&lt;/li&gt;
&lt;li&gt;为什么要用sigmod函数&lt;/li&gt;
&lt;li&gt;如何优化求解（梯度下降）&lt;/
      
    
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/categories/machine-learning/"/>
    
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
  </entry>
  
  <entry>
    <title>【神经网络和深度学习】课程笔记1</title>
    <link href="http://yoursite.com/2017/11/06/%E3%80%90%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2017/11/06/【神经网络和深度学习】课程笔记1/</id>
    <published>2017-11-06T12:26:32.000Z</published>
    <updated>2017-11-06T12:26:32.269Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="DeepLearning" scheme="http://yoursite.com/categories/DeepLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2——并查集</title>
    <link href="http://yoursite.com/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2017/11/05/【九章算法强化班】课程笔记2——并查集/</id>
    <published>2017-11-05T08:28:47.000Z</published>
    <updated>2017-11-15T12:57:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Union-Find并查集"><a href="#Union-Find并查集" class="headerlink" title="Union Find并查集"></a>Union Find并查集</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>一种用来解决集合查询合并的数据结构</strong></p><p>假如A、B、C三人在Microsoft工作，D、E、F、G四人在Linkedin工作，给七个人都分发一个工牌，上面写着自己的公司名字，告诉他们自己的老大是哪家公司，则可以表示成如下形式。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-10-31.png" alt=""></p><p>如果A遇到F，看一眼对方的工牌，跟自己是不是一个boss，就知道对方是不是跟自己是同一家公司的人了。</p><p>如果有一天M公司把L公司收购了，那么此时，需要对两个公司的员工进行合并操作，给员工分发新的工牌，为了减少重新分配的麻烦，就把L的boss指向M，此时L下面的员工最大的boss是M了，那么A和E就在一个阵营了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-15-16.png" alt=""></p><p>如果在M公司三个员工和L公司四个员工中分别选出一个作为该公司的boss，可以表示成如下形式：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-34.png" alt=""></p><p>那么合并之后，J的boss设置为B，此时大家都是一个阵营的了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-14-45.png" alt=""></p><h2 id="并查集的精髓"><a href="#并查集的精髓" class="headerlink" title="并查集的精髓"></a><strong>并查集的精髓</strong></h2><p>一共包含三个操作</p><ol><li><p>初始化</p><p>初始化操作中，每个元素的boss指向自己.</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">HashMap&lt;Integer,Integer&gt; father = <span class="keyword">new</span> HashMap&lt;integer,integer&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    father.put(nums[i],nums[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​</p></li><li><p>查找</p><p>查找元素所在的集合，也就是最大的boss。</p><p>如果要判断两个点是否属于同一个集合，就看这两个点的boss是否是同一个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> parent = x;</div><div class="line">  <span class="keyword">while</span>(parent!=father.get(parent))&#123;</div><div class="line">    parent = fater.get(parent);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度：<script type="math/tex">O(n)</script></p></li><li><p>合并</p><p>两个不想交的集合，其中一个的大boss认另一个为boss。</p><p>找到两个元素的boss，如果不是同一个，就把一个的boss指向另一个的boss。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> fa_x = find(x);</div><div class="line">  <span class="keyword">int</span> fa_y = find(y);</div><div class="line">  <span class="keyword">if</span>(fa_x != f_y)&#123;</div><div class="line">    father.put(fa_X,fa_y);<span class="comment">//合并两个boss</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度：<script type="math/tex">O(n)</script></p></li></ol><h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a><strong>并查集的优化</strong></h2><p>baseline的find流程：</p><p>如果有这样一条路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F</div></pre></td></tr></table></figure><p>查找A的boss时，需要遍历整个路径，寻找B、C、D时还需要再遍历一次，这显然是大量重复的工作，所以我们可以把一次遍历途中经过的节点都直接指向boss，下次再查询的时候，时间复杂的就是<script type="math/tex">O(1)</script>了，这就是<strong>带路径压缩的并查集</strong>的查找：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-41-32.png" alt=""></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-16-42-34.png" alt=""></p><p>平均时间复杂度降至<script type="math/tex">O(1)</script></p><h2 id="并查集模板-c-版"><a href="#并查集模板-c-版" class="headerlink" title="并查集模板(c++版)"></a>并查集模板(c++版)</h2><ol><li><p>hash_map实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; father;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">//初始化并查集</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements)</span></span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; elements.size();i++)&#123;</div><div class="line">                father.insert(make_pair(elements[i],elements[i]));</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//并查集中插入操作，不支持删除</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> x_fa)</span></span>&#123;</div><div class="line">            father.insert(make_pair(x,x_fa));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在并查集中查找元素的boss</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> parent = x;</div><div class="line">            <span class="keyword">while</span>(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//带路径压缩的并查集</span></div><div class="line">            <span class="keyword">while</span>(father.find(x)-&gt;second != x)&#123;</div><div class="line">                x = father[x];</div><div class="line">                father[x] = parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//合并两个元素</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> x_father = findfather(x);</div><div class="line">            <span class="keyword">int</span> y_father = findfather(y);</div><div class="line">            <span class="keyword">if</span>(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//计算并查集中有多少个不想交的子集合</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">countsets</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; father_set;</div><div class="line">            <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter = father.begin();iter != father.end();iter++)&#123;</div><div class="line">                <span class="keyword">int</span> parent = findfather(iter-&gt;first);</div><div class="line">                iter-&gt;second = parent;</div><div class="line">                father_set.insert(parent);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>vector实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>用vector会比hashmap快，但如果数据很稀疏，空间复杂度会比较高。</p></li></ol><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external"><del>leetcode200. Number of Islands</del></a></li><li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/" target="_blank" rel="external"><del>leetcode323. Number of Connected Components in an Undirected Graph</del></a></li><li><a href="https://leetcode.com/problems/number-of-islands-ii/description/" target="_blank" rel="external"><del>leetcode305. Number of Islands II</del></a></li><li><a href="https://leetcode.com/problems/graph-valid-tree/description/" target="_blank" rel="external"><del>leetcode261. Graph Valid Tree</del></a></li><li><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="external"><del>leetcode130. Surrounded Regions</del></a></li><li><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="external">leetcode128. Longest Consecutive Sequence</a></li><li><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="external">leetcode547. Friend Circles</a></li></ul><h3 id="leetcode200-Number-of-Islands"><a href="#leetcode200-Number-of-Islands" class="headerlink" title="leetcode200. Number of Islands"></a>leetcode200. Number of Islands</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11110</div><div class="line">&gt; 11010</div><div class="line">&gt; 11000</div><div class="line">&gt; 00000</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Answer: 1</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 11000</div><div class="line">&gt; 11000</div><div class="line">&gt; 00100</div><div class="line">&gt; 00011</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Answer: 3</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目的意思是说矩阵中的1代表陆地，0代表海洋，如果某个1的上或下或左或右也是1的话，就是属于同一片陆地，要求矩阵中陆地的个数。也就是找出矩阵中连接子图的个数。</p><p>有两种思路：</p><ol><li><p>并查集</p><p>找出矩阵中子图的个数，可以利用并查集，在每个点附近做查找和合并操作，如果其周围有1，就讲其归为一类，最后返回并查集的集合个数就是所求的。</p><p>并查集处理二维矩阵时索引比较麻烦，所以这里需要先将二维坐标转化为一维并查集坐标：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">矩阵维度：m*n</div><div class="line">二维坐标：(i,j) --&gt; 一维坐标：x*n+j</div><div class="line">一维坐标：idx     --&gt; 二维坐标：(idx/m,idx%m)</div></pre></td></tr></table></figure><p>经过坐标转化，可以使用并查集进行计算了</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = grid.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    UnionFind unionfindset;<span class="comment">//声明并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; island;<span class="comment">//存储是1的元素</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isseen(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//记录是否遍历过</span></div><div class="line">    <span class="comment">//初始化,插入元素</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</div><div class="line">                <span class="comment">//father.insert(make_pair(i*cols+j,i*cols+j));</span></div><div class="line">                unionfindset.add(i*cols+j,i*cols+j);</div><div class="line">                island.push_back(&#123;i,j&#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; island.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> x_idx = island[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> y_idx = island[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> idx = x_idx*cols+y_idx;</div><div class="line">        <span class="keyword">if</span>(isseen[x_idx][y_idx]==<span class="number">0</span>)&#123;</div><div class="line">            isseen[x_idx][y_idx] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(x_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx<span class="number">-1</span>][y_idx]==<span class="string">'1'</span>)&#123;<span class="comment">//上</span></div><div class="line">                isseen[x_idx<span class="number">-1</span>][y_idx] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx-cols,idx);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(y_idx<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x_idx][y_idx<span class="number">-1</span>]==<span class="string">'1'</span>)&#123;<span class="comment">//左</span></div><div class="line">                isseen[x_idx][y_idx<span class="number">-1</span>] = <span class="number">1</span>;</div><div class="line">                unionfindset.unionset(idx<span class="number">-1</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> unionfindset.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BFS/DFS</p><p>从矩阵中的一个1开始做深度或广度优先遍历，其周围能够遍历到的1都是跟其属于同片陆地的，把遍历过的陆地标记为0，并把count++；然后继续从下一个出现1的地方开始遍历，跟前面的操作一样，最后就可以得到count就是矩阵中陆地的个数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x_idx,<span class="keyword">int</span> y_idx,<span class="keyword">int</span>&amp; rows,<span class="keyword">int</span>&amp; cols)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x_idx&lt;<span class="number">0</span> || x_idx &gt;=rows || y_idx&lt;<span class="number">0</span> || y_idx &gt;= cols || grid[x_idx][y_idx]==<span class="string">'0'</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    grid[x_idx][y_idx]=<span class="string">'0'</span>;</div><div class="line">    bfs(grid,x_idx,y_idx<span class="number">-1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx<span class="number">-1</span>,y_idx,rows,cols);</div><div class="line">    bfs(grid,x_idx,y_idx+<span class="number">1</span>,rows,cols);</div><div class="line">    bfs(grid,x_idx+<span class="number">1</span>,y_idx,rows,cols);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>int numIslands(vector<vector<char>&gt;&amp; grid) {</vector<char></p><pre><code>int rows = grid.size();if(rows==0){    return 0;}int cols = grid[0].size();if(cols==0){    return 0;}//unordered_map&lt;int,int&gt; father;//并查集//vector&lt;vector&lt;int&gt;&gt; island;//存储是1的元素int count = 0;for(int i = 0; i &lt; rows;i++){    for(int j = 0 ; j &lt; cols;j++){        if(grid[i][j]==&#39;1&#39;){            count++;            bfs(grid,i,j,rows,cols);        }    }}return count;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### leetcode305.Number of Islands II </div><div class="line"></div><div class="line">#### 题目</div><div class="line">&gt; A 2d grid map of `m` rows and `n` columns is initially filled with water. We may perform an *addLand* operation which turns the water at position (row, col) into a land. Given a list of positions to operate, **count the number of islands after each addLand operation**. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</div><div class="line">&gt;</div><div class="line">&gt; **Example:**</div><div class="line">&gt;</div><div class="line">&gt; Given `m = 3, n = 3`, `positions = [[0,0], [0,1], [1,2], [2,1]]`.</div><div class="line">&gt; Initially, the 2d grid `grid` is filled with water. (Assume 0 represents water and 1 represents land).</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ol><blockquote><p>0 0 0<br>0 0 0<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 0 0<br>0 0 0   Number of islands = 1<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 1 0<br>0 0 0   Number of islands = 1<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 1 0<br>0 0 1   Number of islands = 2<br>0 0 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>1 1 0<br>0 0 1   Number of islands = 3<br>0 1 0</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; We return the result as an array: `[1, 1, 2, 3]`</div><div class="line"></div><div class="line">一个矩阵，元素都是0，代表海洋，每次选择一个元素标记为1，代表陆地，输出每轮矩阵中的island个数。</div><div class="line"></div><div class="line">#### 思路</div><div class="line"></div><div class="line">这道题目跟上面题目不同的地方在于这次是每次选择一个点进行更新，所以如果每次用DFS/BFS遍历的话，会有大量重复的运算，如果用并查集，则只需要每次对于新加入的island对其周围进行检查然后对并查集进行更新即可。</div><div class="line"></div><div class="line">#### 代码</div><div class="line"></div><div class="line">​```c++</div><div class="line">//用vector定义并查集，index就是元素值</div><div class="line">class UnionFind&#123;</div><div class="line">    private:</div><div class="line">        vector&lt;int&gt; father;</div><div class="line">    public:</div><div class="line">        //初始化并查集</div><div class="line">        void initial(int n)&#123;</div><div class="line">            father.resize(n,-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //并查集中更新操作</div><div class="line">        void fresh(int x,int x_fa)&#123;</div><div class="line">            father[x] = x_fa;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在并查集中查找元素的boss</div><div class="line">        int findfather(int x)&#123;</div><div class="line">            int parent = x;</div><div class="line">            while(father[parent] != parent)&#123;</div><div class="line">                parent = father[parent];</div><div class="line">            &#125;</div><div class="line">            //带路径压缩的并查集</div><div class="line">            while(father[x] != x)&#123;</div><div class="line">                father[x] = parent;</div><div class="line">                x = father[x];</div><div class="line">            &#125;</div><div class="line">            return parent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //合并两个元素</div><div class="line">        void unionset(int x,int y)&#123;</div><div class="line">            int x_father = findfather(x);</div><div class="line">            int y_father = findfather(y);</div><div class="line">            if(x_father != y_father)&#123;</div><div class="line">                father[y_father] = x_father;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //计算并查集中有多少个不想交的子集合</div><div class="line">        int countsets()&#123;</div><div class="line">            unordered_set&lt;int&gt; father_set;</div><div class="line">            for(int i = 0; i &lt; father.size();i++)&#123;</div><div class="line">                if(father[i]!=-1)&#123;</div><div class="line">                    int fathertemp = findfather(father[i]);</div><div class="line">                    if(fathertemp!=-1)&#123;</div><div class="line">                        father_set.insert(fathertemp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return father_set.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">public:</div><div class="line">vector&lt;int&gt; numIslands2(int m, int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; positions) &#123;</div><div class="line">    int count = 0;</div><div class="line">    vector&lt;int&gt; results;</div><div class="line">    UnionFind UnionFindset;</div><div class="line">    vector&lt;int&gt; x_add = &#123;0,0,1,-1&#125;;</div><div class="line">    vector&lt;int&gt; y_add = &#123;1,-1,0,0&#125;;</div><div class="line">    //初始化地图</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; mapmatrix(m,vector&lt;int&gt;(n,0));</div><div class="line">    for(int i = 0; i &lt; positions.size();i++)&#123;</div><div class="line">        int x = positions[i].first;</div><div class="line">        int y = positions[i].second;</div><div class="line">        mapmatrix[x][y] = 1;</div><div class="line">        int idx_demension_one = x*n+y;</div><div class="line">        UnionFindset.add(idx_demension_one,idx_demension_one);//加入并查集</div><div class="line">        count++;</div><div class="line">        for(int j = 0 ; j &lt; 4;j++)&#123;</div><div class="line">            //相邻元素的坐标</div><div class="line">            int x_neighbor = x+x_add[j];</div><div class="line">            int y_neighbor = y+y_add[j];</div><div class="line">            int idx_demension_one_neighbor = x_neighbor*n+y_neighbor;</div><div class="line">            //如果相邻元素还在地图中，而且是陆地（val=1）</div><div class="line">            if(x_neighbor&gt;=0 &amp;&amp; x_neighbor&lt;m &amp;&amp; y_neighbor&gt;=0 &amp;&amp; y_neighbor&lt;n &amp;&amp; mapmatrix[x_neighbor][y_neighbor]==1 &amp;&amp; UnionFindset.findfather(idx_demension_one) != UnionFindset.findfather(idx_demension_one_neighbor))&#123;</div><div class="line">                UnionFindset.unionset(idx_demension_one,idx_demension_one_neighbor);</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        results.push_back(count);</div><div class="line">    &#125;</div><div class="line">    return results;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h3 id="leetcode261-Graph-Valid-Tree"><a href="#leetcode261-Graph-Valid-Tree" class="headerlink" title="leetcode261. Graph Valid Tree"></a>leetcode261. Graph Valid Tree</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p><p>For example:</p><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.</p><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.</p><p><strong>Note</strong>: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code>and thus will not appear together in <code>edges</code>.</p></blockquote><p>给定n个节点和节点之间的边集，判断由这些节点和边集是否能够构成树。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>给定n个几点和边集构成树的条件有两个：</p><ol><li>所有的点都在一个并查集中，也就是都属于一个root节点</li><li>不能有环</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        <span class="keyword">int</span> start_fa = UnionFindgraph.findfather(start);</div><div class="line">        <span class="keyword">int</span> end_fa = UnionFindgraph.findfather(end);</div><div class="line">        <span class="keyword">if</span>(start_fa == end_fa)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            UnionFindgraph.unionset(start_fa,end_fa);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(UnionFindgraph.countsets()==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph"><a href="#leetcode323-Number-of-Connected-Components-in-an-Undirected-Graph" class="headerlink" title="leetcode323. Number of Connected Components in an Undirected Graph"></a>leetcode323. Number of Connected Components in an Undirected Graph</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0          3</div><div class="line">&gt;      |          |</div><div class="line">&gt;      1 --- 2    4</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, return <code>2</code>.</p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0           4</div><div class="line">&gt;      |           |</div><div class="line">&gt;      1 --- 2 --- 3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</code>, return <code>1</code>.</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>判断矩阵中联通子图图的个数，遍历边集，将边首尾节点合并，最终的并查集boss数就是联通子图的个数。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">    UnionFind UnionFindgraph;</div><div class="line">    UnionFindgraph.initial(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n;i++)&#123;</div><div class="line">        UnionFindgraph.fresh(i,i);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历边</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; edges.size();i++)&#123;</div><div class="line">        <span class="keyword">int</span> start = edges[i].first;</div><div class="line">        <span class="keyword">int</span> end = edges[i].second;</div><div class="line">        UnionFindgraph.unionset(start,end);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> UnionFindgraph.countsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="leetcode130-Surrounded-Regions"><a href="#leetcode130-Surrounded-Regions" class="headerlink" title="leetcode130. Surrounded Regions"></a>leetcode130. Surrounded Regions</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the <strong>letter</strong> O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p><p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X O O X</div><div class="line">&gt; X X O X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>After running your function, the board should be:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X X X X</div><div class="line">&gt; X O X X</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>将被X围住的O标记为X。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>通过分析可知，就是要将所有以O组成、但没有连通到网格边缘的区域变为X。</p><ol><li>BFS/DFS：沿着四个边向内找O，找到每一个O就把相连的都变成N，因为 他们都是要保留的，最后遍历二维数组，遇到O变成X，遇到N变回O</li><li>并查集：将区域内的O合并，组成集合，如果有元素在边界，就将该集合的father设为N，最后遍历所有的0，如果其father为N，就标记为O，否则标记为X。</li></ol><p>显然，1会比较快，下面使用BFS实现的.</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>&#123;</div><div class="line">    <span class="comment">// if(x&lt;0 || x &gt;= rows || y&lt;0 || y &gt;= cols || board[x][y]=='X')&#123;</span></div><div class="line">    <span class="comment">//     return;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; board[x][y]==<span class="string">'O'</span>)&#123;</div><div class="line">        board[x][y]=<span class="string">'N'</span>;</div><div class="line">        dfs(board,x<span class="number">-1</span>,y,rows,cols);</div><div class="line">        dfs(board,x+<span class="number">1</span>,y,rows,cols);</div><div class="line">        dfs(board,x,y<span class="number">-1</span>,rows,cols);</div><div class="line">        dfs(board,x,y+<span class="number">1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> rows = board.size();</div><div class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(cols==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//上下边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">        dfs(board,<span class="number">0</span>,i,rows,cols);</div><div class="line">        dfs(board,rows<span class="number">-1</span>,i,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//左右边框</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        dfs(board,i,<span class="number">0</span>,rows,cols);</div><div class="line">        dfs(board,i,cols<span class="number">-1</span>,rows,cols);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'N'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'O'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'X'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么时候用并查集？</p><ul><li>集合合并</li><li>判断两个点是否在同一个集合内</li></ul><h1 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h1><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><p>源自单词：retrieve</p><p>假设有[b，abc，abd，bcd，abcd，efg，hii ]这6个单词 , 查找abc 在不在字典里面</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-06-17-49-17.png" alt=""> </p><h2 id="hash和trie的比较"><a href="#hash和trie的比较" class="headerlink" title="hash和trie的比较"></a>hash和trie的比较</h2><div class="table-container"><table><thead><tr><th></th><th>hash_table</th><th>TIRE树</th></tr></thead><tbody><tr><td>查找时间复杂度</td><td>O(1)</td><td>O(1)</td></tr><tr><td>空间复杂度</td><td></td><td>优于hash_table</td></tr></tbody></table></div><p>对于a,aa,aaa,aaaa的情况</p><div class="table-container"><table><thead><tr><th></th><th>hash</th><th>trie</th></tr></thead><tbody><tr><td>存储</td><td>10个a</td><td>5个a节点</td></tr><tr><td>可用操作</td><td>有/无/查询</td><td>有/无/前缀查询</td></tr><tr><td></td><td>1行</td><td>75~100行</td></tr></tbody></table></div><p>所以选择hash原因是代码量小, 但是涉及到前缀查询的时候, 考虑trie树</p><h2 id="什么时候更适合用trie树"><a href="#什么时候更适合用trie树" class="headerlink" title="什么时候更适合用trie树"></a>什么时候更适合用trie树</h2><p>一个一个字符串遍历的时候。</p><p>需要节约空间</p><p>查找前缀</p><h2 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h2><p>例题：</p><p>Word search II</p><h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://stomachache007.wordpress.com/2017/10/23/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E9%AB%98%E7%BA%A7%E7%8F%AD%E7%AC%94%E8%AE%B02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/" target="_blank" rel="external">stomachache007的blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Union-Find并查集&quot;&gt;&lt;a href=&quot;#Union-Find并查集&quot; class=&quot;headerlink&quot; title=&quot;Union Find并查集&quot;&gt;&lt;/a&gt;Union Find并查集&lt;/h1&gt;&lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="UnionFind" scheme="http://yoursite.com/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班习题集】</title>
    <link href="http://yoursite.com/2017/11/05/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E4%B9%A0%E9%A2%98%E9%9B%86%E3%80%91/"/>
    <id>http://yoursite.com/2017/11/05/【九章算法强化班习题集】/</id>
    <published>2017-11-05T06:54:00.000Z</published>
    <updated>2017-11-05T07:00:42.265Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 请输入文章密码！ "/> <label for="pass"> 请输入文章密码！ </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      私密文章！
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>c++中struct的一些操作</title>
    <link href="http://yoursite.com/2017/11/04/c-%E4%B8%ADstruct%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/04/c-中struct的一些操作/</id>
    <published>2017-11-04T08:49:08.000Z</published>
    <updated>2017-11-04T08:49:08.612Z</updated>
    
    <content type="html"><![CDATA[<p>c++中class和struct的构造函数方式相同：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  Node()：x(<span class="number">0</span>),y(<span class="number">0</span>),z(<span class="number">0</span>)&#123;&#125;;<span class="comment">//无参构造函数</span></div><div class="line">  Node(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k):x(i),y(j),val(k)&#123;&#125;<span class="comment">//有参构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;c++中class和struct的构造函数方式相同：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>c++STL中vector的一些操作</title>
    <link href="http://yoursite.com/2017/11/04/c-STL%E4%B8%ADvector%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/04/c-STL中vector的一些操作/</id>
    <published>2017-11-04T08:36:41.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<p>记录c++STL中vector的一些操作</p><h2 id="指定长度vector声明"><a href="#指定长度vector声明" class="headerlink" title="指定长度vector声明"></a>指定长度vector声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);<span class="comment">//长度为n</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n,t);<span class="comment">//长度为n,值为t</span></div></pre></td></tr></table></figure><h2 id="指定长度二维vector声明"><a href="#指定长度二维vector声明" class="headerlink" title="指定长度二维vector声明"></a>指定长度二维vector声明</h2><p>声明一个<script type="math/tex">m*n</script>维的矩阵：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//所有元素都是0</span></div></pre></td></tr></table></figure><h2 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line">sort(vec.begin(),vec.end());</div></pre></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>resize()可以用来重新定义vector的大小，也可以用在声明数组时指定数组的长度</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;<span class="comment">//重定义vector的长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, value_type val)</span></span>;<span class="comment">//重定义vector的长度和数值</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录c++STL中vector的一些操作&lt;/p&gt;
&lt;h2 id=&quot;指定长度vector声明&quot;&gt;&lt;a href=&quot;#指定长度vector声明&quot; class=&quot;headerlink&quot; title=&quot;指定长度vector声明&quot;&gt;&lt;/a&gt;指定长度vector声明&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vetcor" scheme="http://yoursite.com/tags/vetcor/"/>
    
  </entry>
  
  <entry>
    <title>回溯法、【leetcode】51.52 N-Queens</title>
    <link href="http://yoursite.com/2017/11/04/%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E3%80%90leetcode%E3%80%9151-52-N-Queens/"/>
    <id>http://yoursite.com/2017/11/04/回溯法、【leetcode】51-52-N-Queens/</id>
    <published>2017-11-04T08:35:06.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h2><p>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。<br>如果用爬山来比喻：<br>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。<br>第二点脑子是回溯知道剪枝；如果有一条岔路走不通，那这条路我们不走，就可以少走很多不必要走的路。</p><h2 id="识别回溯问题"><a href="#识别回溯问题" class="headerlink" title="识别回溯问题"></a>识别回溯问题</h2><p>判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。<br>一般回溯的问题有三种：</p><ol><li>Find a path to success 有没有解</li><li>Find all paths to success 求所有解</li></ol><ul><li>求所有解的个数</li><li>求所有解的具体信息</li></ul><ol><li>Find the best path to success 求最优解</li></ol><p>还有一些爱混淆的概念：递归，回溯，DFS。<br>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。<br>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。在树和图上回溯时人们叫它DFS。<br>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</p><p>关于回溯的三种问题，模板略有不同，<br>第一种，返回值是true/false。<br>第二种，求个数，设全局counter，返回值是void；求所有解信息，设result，返回值void。<br>第三种，设个全局变量best，返回值是void。</p><h2 id="求解模板"><a href="#求解模板" class="headerlink" title="求解模板"></a>求解模板</h2><p>第一种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">boolean solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, return true</div><div class="line">        else return false</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            if solve(c) succeeds, return true</div><div class="line">        &#125;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, count++, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第三种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void solve(Node n) &#123;</div><div class="line">    if n is a leaf node &#123;</div><div class="line">        if the leaf is a goal node, update best result, return;</div><div class="line">        else return</div><div class="line">    &#125; else &#123;</div><div class="line">        for each child c of n &#123;</div><div class="line">            solve(c)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>八皇后问题是大数学家高斯于1850年提出来的。该问题是在8×8的国际象棋棋盘上放置8个皇后，使得没有一个皇后能“吃掉”任何其他一个皇后，即没有任何两个皇后被放置在棋盘的同一行、同一列或同一斜线上。</p><p>扩展到一般情况就是：在n*n的棋盘上放置n和棋子，使得没有任何两个棋子在同一行、同一列或同一对角线上</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了更好的理解回溯法，把这个问题分解成三个子问题：</p><ol><li>是否有这样的安放方法，满足游戏规则</li><li>如果有，有多少个安放方式[leetcode 52]</li><li>输出所有的安放方式[leetcode 51]</li></ol><p>因为任何两个皇后不可能在同一行，所以我们可以采用如下的策略：<br><strong>一行一行地安放皇后，每次放置皇后时需要确保此次放置的皇后跟之前已经放置的皇后没有处于同行、同列、同对角线上</strong></p><p>需要下面两个函数：</p><ol><li>递归调用安放皇后（回溯法）<br>逐个遍历可以安放皇后的位置，并递归调用取定下一层可以安放皇后的位置。直到最后一行的元素存在合法的放置位置，说明这是一种合理的安放情况。</li></ol><ol><li>判断在某一点放queen是否合法</li></ol><p>因为是一行一行放，所以可以保证不在一行上，需要判断同一列是否已经有皇后，以及左上方和右上方对角线方向是否已经有皇后。</p><p>另外还需要一个额外的空间标记当前皇后们安放的位置</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>三个子问题的函数2，判断某一点是否可以放置皇后的函数一样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断是否可以放置</div><div class="line">bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">    //判断左上方对角线是否有皇后</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==1)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断右上方对角线是否有皇后</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==1)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==1)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code>是用来存放当前棋盘上放置的皇后位置。</p><p>差别在于回溯函数：</p><h4 id="1-是否存在"><a href="#1-是否存在" class="headerlink" title="1. 是否存在"></a>1. 是否存在</h4><p>只需要找到一个满足条件的放置方案即可，逐行放置皇后，遇到不满足条件的情况就回退到上一层，继续寻找</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//递归调用，判断皇后放置字当前点之后是否存在合法路径</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一行，安放最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//如果存在合法安放情况，返回true</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//该点合理，将皇后放到该点，递归调用，判断下一层是否存在合法方案</div><div class="line">                vec[k][i]=1;//房子皇后，标记皇后位置</div><div class="line">                if (solve(vec,n,k+1,i))//下一层存在合法方案。返回true 否则回退，将皇后从该点移除</div><div class="line">                    return true;</div><div class="line">                vec[k][i]=0;//取消皇后位置标记</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool ifNQueens(int n) &#123;</div><div class="line">    if(n==1)</div><div class="line">        return true;</div><div class="line">    if(n&lt;4)</div><div class="line">        return false</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));//存储当前棋盘皇后位置</div><div class="line">    //遍历首行放置皇后</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        if(solve(vec,n,1,i))//找到一条合法放置方式，返回true</div><div class="line">            return true</div><div class="line">        vec[0][i]=0;//否则恢复该点未被选中的棋盘，继续遍历下一个点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-存在多少种安放方式-leetcode-51"><a href="#2-存在多少种安放方式-leetcode-51" class="headerlink" title="2. 存在多少种安放方式 [leetcode] 51"></a>2. 存在多少种安放方式 [leetcode] 51</h4><p>在上面存在的基础之上，引入一个count计数变量，记录合法方案的数量，也就是没找到一个合法的安放方式就+1，知道遍历完所有的情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//</div><div class="line">void solve(vector&lt;vector&lt;int&gt;&gt;&amp; vec,int n,int k,int l,int&amp; count)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;//找到合法方案，计数变量+1</div><div class="line">                count++;break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=1;</div><div class="line">                solve(vec,n,k+1,i,count);</div><div class="line">                vec[k][i]=0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int totalNQueens(int n) &#123;</div><div class="line">    if(n&lt;2)</div><div class="line">        return n;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; vec(n,vector&lt;int&gt;(n,0));</div><div class="line">    int count = 0;//新增计数变量</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=1;</div><div class="line">        solve(vec,n,1,i,count);</div><div class="line">        vec[0][i]=0;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-输出所有的安放方式-leetcode-51"><a href="#3-输出所有的安放方式-leetcode-51" class="headerlink" title="3.输出所有的安放方式 [leetcode] 51"></a>3.输出所有的安放方式 [leetcode] 51</h4><p>这次需要我们将所有合法的安放方式都输出，也就当找到一条合法安放方式时，就把当前的皇后放置情况输出到结果集。</p><p>另外根据题目输出结果格式要求：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line"> [&quot;.Q..&quot;,  // Solution 1</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;..Q.&quot;],</div><div class="line"></div><div class="line"> [&quot;..Q.&quot;,  // Solution 2</div><div class="line">  &quot;Q...&quot;,</div><div class="line">  &quot;...Q&quot;,</div><div class="line">  &quot;.Q..&quot;]</div><div class="line">]</div></pre></td></tr></table></figure><p>对保存安放情况的变量类型作出修改：由原来的<code>vector&lt;vector&lt;int&gt;&gt;&amp; vec</code> 变为<code>vector&lt;string&gt;&amp; vec</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//判断该位置是否可以放置</div><div class="line">bool isvalid(vector&lt;string&gt;&amp; vec,int n, int k,int i)&#123;</div><div class="line">     //k为当前行，i为当前列</div><div class="line">     //判断同列是否有元素</div><div class="line">    for(int j = 0; j &lt; k ;j++)&#123;</div><div class="line">        if(vec[j][i]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">    //判断对角是否已经有元素</div><div class="line">    int left = i;</div><div class="line">    int up = k;</div><div class="line">    while(left&gt;=0&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][left]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">        left--;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    int right = i;</div><div class="line">    up = k;</div><div class="line">    while(right&lt;=n-1&amp;&amp;up&gt;=0)&#123;</div><div class="line">        if(vec[up][right]==&apos;Q&apos;)</div><div class="line">            return false;</div><div class="line">        right++;</div><div class="line">        up--;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void solve(vector&lt;string&gt;&amp; vec,int n,int k,int l,vector&lt;vector&lt;string&gt;&gt;&amp; res)&#123;</div><div class="line">    //k为当前行，l为上一个的列</div><div class="line">    //判断下一行是否有位置放置queen</div><div class="line">    if(k==n-1)&#123;//最后一个皇后</div><div class="line">        for(int i=0;i &lt;n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=&apos;Q&apos;;</div><div class="line">                res.push_back(vec);//存在合法方案，保存到结果集</div><div class="line">                vec[k][i]=&apos;.&apos;;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">            if(isvalid(vec,n,k,i))&#123;</div><div class="line">                vec[k][i]=&apos;Q&apos;;</div><div class="line">                solve(vec,n,k+1,i,res);</div><div class="line">                vec[k][i]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">    if(n==1)&#123;</div><div class="line">        vector&lt;string&gt; vv = &#123;&quot;Q&quot;&#125;;</div><div class="line">        res.push_back(vv);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    if(n&lt;4)</div><div class="line">        return res;</div><div class="line">    vector&lt;string&gt; vec(n,string(n,&apos;.&apos;));//用以记录结果</div><div class="line">    for(int i = 0 ; i &lt; n;i++)&#123;</div><div class="line">        vec[0][i]=&apos;Q&apos;;</div><div class="line">        solve(vec,n,1,i,res);</div><div class="line">        vec[0][i]=&apos;.&apos;;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006121957" target="_blank" rel="external">liuqi627的博客</a><br><a href="http://www.jianshu.com/p/8f3b8df612ae" target="_blank" rel="external">Jason_Yuan的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是回溯&quot;&gt;&lt;a href=&quot;#什么是回溯&quot; class=&quot;headerlink&quot; title=&quot;什么是回溯&quot;&gt;&lt;/a&gt;什么是回溯&lt;/h2&gt;&lt;p&gt;回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++STL中堆的使用</title>
    <link href="http://yoursite.com/2017/11/04/c-STL%E4%B8%AD%E5%A0%86%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/04/c-STL中堆的使用/</id>
    <published>2017-11-04T03:18:38.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：priority-queue"><a href="#方法一：priority-queue" class="headerlink" title="方法一：priority_queue"></a>方法一：priority_queue</h2><p>这种方法需要<code>#include&lt;queue&gt;</code></p><p>最基本的使用方法，对于一串数字建堆：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">riority_queue&lt;<span class="keyword">int</span>&gt; heap;</div></pre></td></tr></table></figure><p>这种情况下默认为最大堆，也就是堆顶元素值最大。</p><p>如果需要建立最小堆，可以采用如下方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最小堆</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;qi2;<span class="comment">//最大堆</span></div></pre></td></tr></table></figure><p>然而在多数情况下，我们还需要记录一些排序元素的额外信息，比如索引之类的，则需要以下三个步骤：</p><ol><li><p>定义堆中需要存储的结构体：</p><p>​</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">int</span> y;</div><div class="line"><span class="keyword">int</span> val;</div><div class="line">Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​</p></li><li><p>确定堆中元素的存储顺序，也就是最大堆还是最小堆</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置比较函数，确定堆中元素的顺序，是最大堆还是最小堆，</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> a.val&gt;b.val;<span class="comment">//最小堆</span></div><div class="line">      <span class="comment">//return a.val&lt;b.val;//最大堆</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​</p></li><li><p>建堆</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; heap;<span class="comment">//建堆</span></div><div class="line">heap.pop();<span class="comment">//出堆</span></div><div class="line">heap.push();<span class="comment">//入堆</span></div><div class="line">heap.top();<span class="comment">//获取堆顶元素</span></div></pre></td></tr></table></figure></li></ol><h2 id="方法二：利用vector"><a href="#方法二：利用vector" class="headerlink" title="方法二：利用vector"></a>方法二：利用vector</h2><p>这种法法需要<code>#include&lt;algorithm&gt;</code> <code>#include &lt;functional&gt;</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</div><div class="line"><span class="comment">//建堆</span></div><div class="line">make_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大堆</span></div><div class="line">make_heap(a.begin(),a.end(), greater&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小堆</span></div><div class="line"><span class="comment">//pop</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大值出堆</span></div><div class="line">pop_heap(a.begin(),a.end(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小值出堆</span></div><div class="line"><span class="comment">//插入元素</span></div><div class="line">push_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">//堆排序</span></div><div class="line">sort_heap(a.begin(),a.end(),cmp);</div><div class="line"><span class="comment">// push_heap ( begin , end )   将最后一个元素插入堆中（堆自动调整）</span></div><div class="line"><span class="comment">// pop_heap ( begin , end )   将第一个元素从堆中删去（堆自动调整），并放到最后</span></div><div class="line"><span class="comment">// find ( begin , end , value ) 从begin到end查找value，若找不到，返回end</span></div></pre></td></tr></table></figure><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一：priority-queue&quot;&gt;&lt;a href=&quot;#方法一：priority-queue&quot; class=&quot;headerlink&quot; title=&quot;方法一：priority_queue&quot;&gt;&lt;/a&gt;方法一：priority_queue&lt;/h2&gt;&lt;p&gt;这种方法需要
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记2</title>
    <link href="http://yoursite.com/2017/11/04/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2017/11/04/【九章算法强化班】课程笔记1/</id>
    <published>2017-11-04T03:05:07.000Z</published>
    <updated>2017-11-04T08:47:16.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p><ol><li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li><li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li><li>Kth Largest in N Arrays</li></ol><h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p></blockquote><p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p><p><strong>example</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p><p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p><p>看了leetcode题解，有二分查找的方式更快。</p><p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p><ul><li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li><li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li><li>直到min和max回合，此时就找到了第k个元素。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p><p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p><p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p></blockquote><p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>7</th><th>11</th></tr></thead><tbody><tr><td>2</td><td>2+1=3</td><td>2+7=9</td><td>2+11=13</td></tr><tr><td>4</td><td>4+1=5</td><td>4+7=11</td><td>4+11=15</td></tr><tr><td>6</td><td>6+1=7</td><td>6+7=13</td><td>6+11=17</td></tr></tbody></table></div><p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定N个无序数组，从中找出第k大的元素</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p><ol><li>将N个数组中的最大值入堆</li><li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li><li>循环k次，找到第k大的元素</li></ol><p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       <span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li><li>见到第k小，想到用堆维护候选集合，出堆k次</li><li>见到数组要往排序上面想，先排序，然后再其他操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求数组-矩阵的第k大元素&quot;&gt;&lt;a href=&quot;#求数组-矩阵的第k大元素&quot; class=&quot;headerlink&quot; title=&quot;求数组/矩阵的第k大元素&quot;&gt;&lt;/a&gt;求数组/矩阵的第k大元素&lt;/h1&gt;&lt;p&gt;涉及leetcode题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="九章算法" scheme="http://yoursite.com/tags/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】课程笔记1</title>
    <link href="http://yoursite.com/2017/11/04/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2017/11/04/九章算法强化班课程笔记1/</id>
    <published>2017-11-04T03:05:07.000Z</published>
    <updated>2017-11-05T06:54:43.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求数组-矩阵的第k大元素"><a href="#求数组-矩阵的第k大元素" class="headerlink" title="求数组/矩阵的第k大元素"></a>求数组/矩阵的第k大元素</h1><p>涉及leetcode题目</p><ol><li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="external">278. Kth Smallest Number In Matrix</a></li><li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="external">373. Kth Smallest Sum In Two Sorted Arrays</a> </li><li>Kth Largest in N Arrays</li></ol><h2 id="278-Kth-Smallest-Number-In-Matrix"><a href="#278-Kth-Smallest-Number-In-Matrix" class="headerlink" title="278. Kth Smallest Number In Matrix"></a>278. Kth Smallest Number In Matrix</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p></blockquote><p>给定一个<script type="math/tex">n*n</script>的矩阵，满足行递增和列递增，要求返回第k大的元素。</p><p><strong>example</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1：堆"><a href="#方法1：堆" class="headerlink" title="方法1：堆"></a>方法1：堆</h4><p>看到第k大问题，要想到用<strong>堆</strong></p><p>因为矩阵满足行递增和列递增，所以矩阵中的每一个元素的右边和下边元素一定比这个元素大。可以从左上角开始将元素放入一个最小堆中，每次从最小堆中取出一个元素，将其右边和下边的元素放入最小堆，这样就可以保证直到取出第k次的元素就是矩阵中第k大的元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):x(a),y(b),val(valin)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.val&gt;b.val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆</span></div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,matrix[i][j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=matrix.size()||ytemp&gt;=matrix[<span class="number">0</span>].size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,matrix[xadd][ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;      <span class="keyword">if</span>(yadd&gt;=matrix.size()||xtemp&gt;=matrix[<span class="number">0</span>].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h4><p>利用堆的方法可以解决上面的问题，但是时间复杂度不是很好。</p><p>看了leetcode题解，有二分查找的方式更快。</p><p>先找到矩阵的最大值max和最小值min，即左上和右下元素，然后以此作为二叉搜索的左右两边，求出其中间值mid，遍历矩阵元素，求出比该中值小的元素的个数count，分一下三种情况讨论：</p><ul><li>count&lt;k，说明比mid小的元素个数不足k个，则要寻找的值比mid大，故mid++;</li><li>count&gt;=k，说明比mid小或和mid值相等的元素个数多于k个，则要寻找的值&lt;=mid，故令max = mid，继续查找;</li><li>直到min和max回合，此时就找到了第k个元素。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(min &lt; max)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//matrix中记录比mid小的元素的个数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;=mid)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</div><div class="line">            max = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            min = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p><p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p><p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p></blockquote><p>给定一个整数k和两个数组<script type="math/tex">nums1</script>和<script type="math/tex">nums2</script>，两个数组内部升序排列，分别从两个数组中选择一个元素<script type="math/tex">u</script>和<script type="math/tex">v</script>构成数对<script type="math/tex">(u,v)</script>，返回和最小的前k个数对<script type="math/tex">(u_1,v_1),(u_2,v_2),...,(u_k,v_k)</script></p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></div><div class="line">  </div><div class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">The first <span class="number">3</span> pairs are returned from the sequence:</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</div></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题就是278的升级版，两个升序数组中各取一个元素做和，求最小的前k个，可以把两个升序数组看成是矩阵的两个维度：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>7</th><th>11</th></tr></thead><tbody><tr><td>2</td><td>2+1=3</td><td>2+7=9</td><td>2+11=13</td></tr><tr><td>4</td><td>4+1=5</td><td>4+7=11</td><td>4+11=15</td></tr><tr><td>6</td><td>6+1=7</td><td>6+7=13</td><td>6+11=17</td></tr></tbody></table></div><p>显然，由元素对生成的矩阵和上题中具有相同的性质，同行同列都递增，所以只需要对上面的代码做轻微的调整即可：记录下元素对在原数组中的idx。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; results;</div><div class="line">    <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>||nums2.size()==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    <span class="keyword">int</span> len1 = nums1.size();</div><div class="line">    <span class="keyword">int</span> len2 = nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(len1,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2,<span class="number">0</span>));</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,j,nums1[i]+nums2[j])</span></span>;</div><div class="line">    minheap.push(nodetemp);</div><div class="line">    isin[i][j]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numslen = len1*len2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kkk = <span class="number">0</span>; kkk &lt; k&amp;&amp;kkk&lt;numslen;kkk++)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">        <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">        results.push_back(make_pair(nums1[xtemp],nums2[ytemp]));</div><div class="line">        <span class="keyword">int</span> xadd = xtemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> yadd = ytemp+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(xadd&gt;=nums1.size()||ytemp&gt;=nums2.size()||isin[xadd][ytemp])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xadd,ytemp,nums1[xadd]+nums2[ytemp]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(xtemp&gt;=nums1.size()||yadd&gt;=nums2.size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,nums1[xtemp]+nums2[yadd]));</div><div class="line">            isin[xtemp][yadd]=<span class="number">1</span>;</div><div class="line">        &#125;        </div><div class="line">        minheap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-in-N-Arrays"><a href="#Kth-Largest-in-N-Arrays" class="headerlink" title="Kth Largest in N Arrays"></a>Kth Largest in N Arrays</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定N个无序数组，从中找出第k大的元素</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>看到数组先排序，然后再想思路。寻找第k大的元素，需要维护一个堆。</p><ol><li>将N个数组中的最大值入堆</li><li>每次出堆一个元素，将该元素所在数组中的下一个入堆</li><li>循环k次，找到第k大的元素</li></ol><p>依旧沿用上面题的思路，这次除元素大小外，需要记录的额外信息为元素所在的数组idx1，以及在该数组中的idx2。</p><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rows = matrix.size();</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">if</span>(rows*cols&lt;k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; minheap;</div><div class="line">    <span class="comment">//按行排序,每行第一个入堆</span></div><div class="line">    <span class="keyword">for</span>(inti= <span class="number">0</span> ;i&lt;rows;i++)&#123;</div><div class="line">      sort(matrix[i].begin(),matrix[i].end());</div><div class="line">      <span class="function">Node <span class="title">nodetemp</span><span class="params">(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>])</span></span>;</div><div class="line">      minheap.push(nodetemp);</div><div class="line">      isin[i][j]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isin(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="number">0</span>));<span class="comment">//用于记录某元素是否已经入过堆  </span></div><div class="line">    <span class="keyword">int</span> kkk=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(kkk &lt; k<span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> xtemp = minheap.top().x;</div><div class="line">      <span class="keyword">int</span> ytemp = minheap.top().y;</div><div class="line">       <span class="keyword">int</span> yadd = ytemp++;</div><div class="line">        <span class="keyword">if</span>(yadd&gt;=matrix[x].size()||isin[xtemp][yadd])&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            minheap.push(Node(xtemp,yadd,matrix[xtemp][yadd]));</div><div class="line">            isin[xadd][ytemp]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        minheap.pop();</div><div class="line">        kkk++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minheap.top().val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>见到需要维护集合的最小/最大值的时候要想到<strong>堆</strong></li><li>见到第k小，想到用堆维护候选集合，出堆k次</li><li>见到数组要往排序上面想，先排序，然后再其他操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求数组-矩阵的第k大元素&quot;&gt;&lt;a href=&quot;#求数组-矩阵的第k大元素&quot; class=&quot;headerlink&quot; title=&quot;求数组/矩阵的第k大元素&quot;&gt;&lt;/a&gt;求数组/矩阵的第k大元素&lt;/h1&gt;&lt;p&gt;涉及leetcode题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="九章算法" scheme="http://yoursite.com/tags/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>DSP国内硕士论文总结</title>
    <link href="http://yoursite.com/2017/11/02/DSP%E5%9B%BD%E5%86%85%E7%A1%95%E5%A3%AB%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/11/02/DSP国内硕士论文总结/</id>
    <published>2017-11-02T09:01:51.000Z</published>
    <updated>2017-11-15T12:57:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>准备开题，先看一下国内的相关硕士学位论文，知网上down的。</p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><ul><li><p><strong>大数据平台下的互联网广告点击率预估模型</strong></p><p>基于腾讯社交广告数据集，hive+hadoop环境下实现GBDT+FM分布式点击率预估，用到贝叶斯平滑等，竞赛在分布式环境下的扩展。</p></li></ul><ul><li>​</li></ul><h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><ul><li><p><strong>针对在线广告实时竞价系统的相关算法研究、电子科大、郭威</strong></p><p>将竞价策略总结为预算控制和估价算法两个步骤，提出一种<strong>预算步进（buget pacing）算法和一个出价模型</strong></p><p>数据集：iPinyou</p><p>2.2介绍计算广告核心问题和<strong>结算方式</strong></p><p>核心问题：广告主、用户、媒体三方博弈，涉及信息检索、机器学习、最优化三个领域。</p><p><strong>结算方式以及适用场景：CPT-&gt;CPM-&gt;CPC-&gt;eCPM</strong> 这里总结的很好</p><p>第3章点击率预估：LR\GBDT \FM\在线算法online SGD，FTRL数据集Criteo</p><p>第4章设计了一个 <strong>buget pacing(预算步进)</strong> 策略</p><p>第5章竞价算法设计：DSP策略中的关键技术图</p><p>这个问题通常是一个约束最优化问题，约束是广告主一天的广告预算，最优某个性能指标，如点击数或转化数。</p></li></ul><h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><ul><li><p><strong>在线广告 DSP 平台实时竞价算法的研究与实现 、上海交通、韩静</strong></p><p>主要研究实时竞价算法，点击率预估和竞价策略。</p><p>ctr预估：LR和GBDT。</p><p>竞价策略：提出固定竞价、分组竞价（M6D）、综合竞价（非线性竞价）三种策略，进行数学推导</p><p>数据集：iPinyou，评价指标KPI</p><p><strong>利用这份数据集做实验的流程</strong> （第四章）：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-02-19-39-45.png" alt=""> </p></li></ul><ul><li><p><strong>广告点击率预估的深层神经网络模型研究</strong> 北邮 王孝舒</p><p>Criteo竞赛数据</p><p>baseline：LR</p><p>优化：DNN，分别选取sigmod和Relu作为激活函数进行实验</p></li><li><p>互联网广告精准投放平台设计与实现 成都理工 葛泽泽</p><p>基于hadoop、hive实现DSP平台</p><p><strong>国内外发展情况可参考</strong></p></li><li><p>基于流式计算的广告特征提取系统的设计与实现 钟晓诚 南京大学</p><p>做的是搜索广告的</p><p>流式广告特征提取系统，实时处理广告数据，不断训练、更新ctr预估模型，基于百度开发的流式计算框架Task Manager，集合HDFS\MapReduce</p><p>可以将广告特征数据反映到线上模型的时间缩短至分钟级</p><p>​</p></li><li><p>基于逻辑回归的在线广告ctr优化和预测 浙江大学 代成雷</p><p>用了LR和FTRL进行ctr预估</p></li><li><p>基于深度学习的搜索广告点击率预测方法研究 哈工大 李思琴</p><p>GPU、深度学习CTR预估与贝叶斯分类、LR、svm对比</p><p><strong>卷积神经网络</strong></p><p>KDD2012数据集</p><p>特征用到w2v</p><p>评估：AUC</p><p>​</p></li><li><p>在线广告中实时竞价机制研究与算法实现 华中师范 朱丽辉</p><p>当竞价较低时，提升竞价能大幅增加赢得竞价的概率；当竞价较高时，降低竞价对赢得竞价的概率影响不大。提出了预算再分配模型，将竞价空间分成不同的区间，将预算消耗在最优价格区间。结合上述两点给出了一个基于动态点击率预估的分段竞价算法，很好地解决了小广告主的利益问题。</p><p>本文提出了一个＂预算再分配＂的竞价策略：将广告主的整个竞价空间按照价格的高低划分为三个区间Ｐｉ，Ｐ２，Ｐ３，当估价在ＰＩ，Ｐ３的时候，对其进行相应的降价措施，当估价在Ｐ２的时候对其进行提价操作。</p><p>核心思想：当广告主的预算在非常有限的情况下，应该放弃那些过高的竞价以及没意义的竞价（估价过低），将预算尽量分配在适当的竞价范围。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-11-16-22-39-56.png" alt=""> </p><p>数据集：ipinyou</p></li><li><p>​</p></li></ul><h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><ul><li><p>互联网广告精准投放平台研究 华中师范 李志</p><p>实现了一个DSP平台</p><p>用贝叶斯分类，对用户特征进行分类</p><p><strong>背景写的很好，有国内外DSP产品比较</strong></p><p><strong>平台设计和流程需要参考</strong></p><p>​</p></li><li><p>​</p></li></ul><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备开题，先看一下国内的相关硕士学位论文，知网上down的。&lt;/p&gt;
&lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;大数据平台下的
      
    
    </summary>
    
      <category term="DSP" scheme="http://yoursite.com/categories/DSP/"/>
    
    
      <category term="DSP" scheme="http://yoursite.com/tags/DSP/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2017/11/02/test-1/"/>
    <id>http://yoursite.com/2017/11/02/test-1/</id>
    <published>2017-11-02T06:12:42.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hive中静态分区和动态分区</title>
    <link href="http://yoursite.com/2017/11/02/Hive%E4%B8%AD%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2017/11/02/Hive中静态分区和动态分区/</id>
    <published>2017-11-02T01:36:01.000Z</published>
    <updated>2017-11-04T08:47:16.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对应列的值自动分区写入，如果该列值对应的分区目录还没有创建， 会自动创建并写入数据。</p><h2 id="静态分区"><a href="#静态分区" class="headerlink" title="静态分区"></a>静态分区</h2><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>create table zhangsiyao.dt_0802_0815 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>load data local inpath ‘/home/warehouse/user.txt’ overwrite into table teacher partition(work_date=”2016-07-12”);</p><p>需要按照分区一个分区一个分区导入数据</p><h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><h3 id="创建分区表（和静态分区一样）"><a href="#创建分区表（和静态分区一样）" class="headerlink" title="创建分区表（和静态分区一样）"></a>创建分区表（和静态分区一样）</h3><p>create table zhangsiyao.dt_0811_0820 (itime string,uid string,gid string,app_ver string,unet int ,device_type string,device_os string,client_type string,crtv_id int,country string,province string ,city string,isp string,ad_location string,ad_status string,age_gt string,sex_gt string,income_gt string,marital_status_gt string,sponsor_id int,creative_name string,creative_title string,creative_abstract string,category_id int,create_time string,update_time string) partitioned by (dt string);</p><h3 id="创建数据表（中间数据）"><a href="#创建数据表（中间数据）" class="headerlink" title="创建数据表（中间数据）"></a>创建数据表（中间数据）</h3><p>create table zhangsiyao.data_analy_11_20 as select a.itime,a.uid,a.gid,a.app_ver,a.unet ,a.device_type,a.device_os,a.client_type,a.crtv_id,a.country,a.province,a.city,a.isp,a.ad_location,a.ad_status,a.dt,b.age_gt,b.sex_gt,b.income_gt,b.marital_status_gt,c.sponsor_id,c.creative_name,c.creative_title,c.creative_abstract,c.category_id,c.create_time,c.update_time from (select <em> from ad.wireless_ad_org_final where dt&gt;’2017-08-10’ and crtv_id &lt;&gt;-1) a left join (select </em> from user_portraint.focus_user_portraint_profile where dt&gt;’2017-08-10’) b on (a.dt=b.dt and a.client_type=b.client_type and a.uid=b.uid) left join (select * from ad.ad_creative_ods where dt&gt;’2017-08-10’) c on (a.dt=b.dt and a.crtv_id=c.creative_id);</p><h3 id="设置动态分区"><a href="#设置动态分区" class="headerlink" title="设置动态分区"></a>设置动态分区</h3><p>set hive.exec.dynamic.partition=true;(可通过这个语句查看：set hive.exec.dynamic.partition;)<br>set hive.exec.dynamic.partition.mode=nonstrict; （strict要求至少有一个静态分区， nonstrict可以都是动态分区）<br>set hive.exec.max.dynamic.partitions=100000;(如果自动分区数大于这个参数，将会报错)<br>set hive.exec.max.dynamic.partitions.pernode=100000;</p><h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><p>insert overwrite table zhangsiyao.dt_0811_0820 partition(dt) select itime,uid,gid,app_ver,unet,device_type,device_os,client_type,crtv_id,country,province,city,isp,ad_location,ad_status,age_gt,sex_gt,income_gt,marital_status_gt,sponsor_id,creative_name,creative_title,creative_abstract,category_id,create_time,update_time,dt from zhangsiyao.data_analy_11_20 where dt&lt;’2017-08-21’;</p><p><strong>这里需要注意的是，用select选择数据导入动态分区时，要把关键字放在最后面，因为动态分区默认以最后一个关键字作为分区关键字</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;差别&quot;&gt;&lt;a href=&quot;#差别&quot; class=&quot;headerlink&quot; title=&quot;差别&quot;&gt;&lt;/a&gt;差别&lt;/h2&gt;&lt;p&gt;两者主要的差别在于：加载数据的时候，静态分区需要手动设定不同的分区，按分区分别导入数据，；而动态分区不需要指定分区key的值，会根据key对
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>利用Hive中percentile_approx计算等频划分分位点</title>
    <link href="http://yoursite.com/2017/11/02/%E5%88%A9%E7%94%A8Hive%E4%B8%ADpercentile-approx%E8%AE%A1%E7%AE%97%E7%AD%89%E9%A2%91%E5%88%92%E5%88%86%E5%88%86%E4%BD%8D%E7%82%B9/"/>
    <id>http://yoursite.com/2017/11/02/利用Hive中percentile-approx计算等频划分分位点/</id>
    <published>2017-11-02T01:34:39.000Z</published>
    <updated>2017-11-04T08:47:16.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等频划分"><a href="#等频划分" class="headerlink" title="等频划分"></a>等频划分</h2><p>等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间</p><p>等比划分：按照数据的全部取值情况，平均划分成k个区间</p><h2 id="Hive-中计算分位数的函数：percentile-approx"><a href="#Hive-中计算分位数的函数：percentile-approx" class="headerlink" title="Hive 中计算分位数的函数：percentile_approx"></a>Hive 中计算分位数的函数：<code>percentile_approx</code></h2><p>hive 中的<code>percentile_approx</code>函数可以确定等频划分的分位点<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">percentile_approx(col,array(0.2,0.4,0.6,0.8))</div><div class="line">[0.0,4001.0,4061.0]</div></pre></td></tr></table></figure></p><p>其中col为要划分的列，array中的数字代表划分的位置，比如(0.2,0.4,0.6,0.8)就是钱20%数量的样本被分到一个区间，然后20%-40%的样本被分到一个区间….</p><p>返回值是一个array</p><p>如果希望变成一列，可以用<code>explode</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explode(percentile_approx(cast(col as double),array(0.05,0.5,0.95),9999))as percentile</div><div class="line"></div><div class="line">percentile</div><div class="line">0.0</div><div class="line">4001.1</div><div class="line">4061.0</div></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table zhangsiyao.percentile_of_dt_fea_0818_0820_2 as select explode(percentile_approx(adloc_age_sex_ctr,array(0.25,0.5,0.75))) as adloc_age_sex_ctr_percentile,explode(percentile_approx(adloc_income_ctr,array(0.25,0.5,0.75))) as adloc_income_ctr_percentile,explode(percentile_approx(adloc_marry_ctr,array(0.25,0.5,0.75))) as adloc_marry_ctr_percentile,explode(percentile_approx(adloc_province_ctr,array(0.25,0.5,0.75))) as adloc_province_ctr_percentile,explode(percentile_approx(adloc_clinttype_ctr,array(0.25,0.5,0.75))) as adloc_clinttype_ctr_percentile,explode(percentile_approx(adloc_sponsorid_ctr,array(0.25,0.5,0.75))) as adloc_sponsorid_ctr_percentile,explode(percentile_approx(adloc_categoryid_ctr,array(0.25,0.5,0.75))) as adloc_categoryid_ctr_percentile,explode(percentile_approx(adloc_crtvid_ctr,array(0.25,0.5,0.75))) as adloc_crtvid_ctr_percentile,explode(percentile_approx(adloc_unet_ctr,array(0.25,0.5,0.75))) as adloc_unet_ctr_percentile,explode(percentile_approx(adloc_isp_ctr,array(0.25,0.5,0.75))) as adloc_isp_ctr_percentile,explode(percentile_approx(adloc_appver_ctr,array(0.25,0.5,0.75))) as adloc_appver_ctr_percentile,explode(percentile_approx(adloc_devicetype_ctr ,adloc_deviceos_ctr,array(0.25,0.5,0.75))) as adloc_devicetype_ctr ,adloc_deviceos_ctr_percentile,explode(percentile_approx(age_province_ctr,array(0.25,0.5,0.75))) as age_province_ctr_percentile,explode(percentile_approx(age_marry_ctr,array(0.25,0.5,0.75))) as age_marry_ctr_percentile,explode(percentile_approx(age_categoryid_ctr,array(0.25,0.5,0.75))) as age_categoryid_ctr_percentile,explode(percentile_approx(age_crtvid_ctr,array(0.25,0.5,0.75))) as age_crtvid_ctr_percentile,explode(percentile_approx(sex_marry_ctr,array(0.25,0.5,0.75))) as sex_marry_ctr_percentile,explode(percentile_approx(sex_categoryid_ctr,array(0.25,0.5,0.75))) as sex_categoryid_ctr_percentile,explode(percentile_approx(income_categoryid_ctr,array(0.25,0.5,0.75))) as income_categoryid_ctr_percentile,explode(percentile_approx(income_crtvid_ctr,array(0.25,0.5,0.75))) as income_crtvid_ctr_percentile,explode(percentile_approx(marry_categoryid_ctr,array(0.25,0.5,0.75))) as marry_categoryid_ctr_percentile,explode(percentile_approx(marry_crtvid_ctr,sponsorid_unet_ctr,array(0.25,0.5,0.75))) as marry_crtvid_ctr,sponsorid_unet_ctr_percentile from zhangsiyao.dt_fea_0818_0820;</div></pre></td></tr></table></figure><p>由此就找到了将特征等频划分的分位点，可以按照得到的分位点队连续型特征进行分桶操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;等频划分&quot;&gt;&lt;a href=&quot;#等频划分&quot; class=&quot;headerlink&quot; title=&quot;等频划分&quot;&gt;&lt;/a&gt;等频划分&lt;/h2&gt;&lt;p&gt;等频划分：按照数据的分布情况，每个区间的数据数量一样，平均划分成k个区间&lt;/p&gt;
&lt;p&gt;等比划分：按照数据的全部取值情况，平
      
    
    </summary>
    
      <category term="hive" scheme="http://yoursite.com/categories/hive/"/>
    
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>TPC_DS工具生成数据导入Hive</title>
    <link href="http://yoursite.com/2017/11/02/TPC-DS%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Hive/"/>
    <id>http://yoursite.com/2017/11/02/TPC-DS工具生成数据导入Hive/</id>
    <published>2017-11-02T01:29:43.000Z</published>
    <updated>2017-11-04T08:47:16.411Z</updated>
    
    <content type="html"><![CDATA[<p>生成步骤</p><p>1.在官网上(<a href="http://www.tpc.org/tpcds/" target="_blank" rel="external">http://www.tpc.org/tpcds/</a> )去下载最新的：TPC-DS. </p><p>2.解压: 下载的 zip 文件放在 Linux 上解压,并进入他的 tools 目录.</p><p>3.编译：make (忽略编译警告，只保证生成过程成功完成). 这里需要Linux安装上了 gcc , gcc c++, expect 等.</p><p>4.生成数据：在tools目录下执行：./dsdgen -scale 100 -force (-force:会覆盖原来生成的data,否则不覆盖);生成的25个.dat 的数据文件.</p><p>默认只能生成 100GB, 300GB, 1TB, 3TB, 10TB, 30TB and 100TB大小的数据，如果想要生成一个比较小的数据集，可以使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">100M:</div><div class="line">./dsdgen -scale 1000 -dir tmp/ -parallel 1000 -child 1</div></pre></td></tr></table></figure></p><ol><li>hive中创建相应的数据表，导入之前生成的数据<br>运行脚本<code>hive_create_table.sql</code></li></ol><p>“hive -f hive_create_table.sql”<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">use tpc_ds;</div><div class="line"></div><div class="line">create table if not exists dbgen_version</div><div class="line">(</div><div class="line">    dv_version varchar(16),</div><div class="line">    dv_create_date date,</div><div class="line">    dv_create_time string,</div><div class="line">    dv_cmdline_args varchar(200) </div><div class="line">)</div><div class="line">row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/dbgen_version_1_10000.dat&quot; overwrite into table tpc_ds.dbgen_version;</div><div class="line"></div><div class="line">create table if not exists customer_address</div><div class="line">(</div><div class="line">    ca_address_sk int,</div><div class="line">    ca_address_id char(16),</div><div class="line">    ca_street_number char(10),</div><div class="line">    ca_street_name varchar(60),</div><div class="line">    ca_street_type char(15),</div><div class="line">    ca_suite_number char(10),</div><div class="line">    ca_city varchar(60),</div><div class="line">    ca_county varchar(30),</div><div class="line">    ca_state char(2),</div><div class="line">    ca_zip char(10),</div><div class="line">    ca_country varchar(20),</div><div class="line">    ca_gmt_offset decimal(5,2),</div><div class="line">    ca_location_type char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_address_1_10000.dat&quot; overwrite into table tpc_ds.customer_address;</div><div class="line"></div><div class="line">create table if not exists customer_demographics</div><div class="line">(</div><div class="line">    cd_demo_sk int,</div><div class="line">    cd_gender char(1),</div><div class="line">    cd_marital_status char(1),</div><div class="line">    cd_education_status char(20),</div><div class="line">    cd_purchase_estimate int,</div><div class="line">    cd_credit_rating char(10),</div><div class="line">    cd_dep_count int,</div><div class="line">    cd_dep_employed_count int,</div><div class="line">    cd_dep_college_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_demographics_1_10000.dat&quot; overwrite into table tpc_ds.customer_demographics;</div><div class="line"></div><div class="line">create table if not exists date_dim</div><div class="line">(</div><div class="line">    d_date_sk int,</div><div class="line">    d_date_id char(16) ,</div><div class="line">    d_date date ,</div><div class="line">    d_month_seq int,</div><div class="line">    d_week_seq int,</div><div class="line">    d_quarter_seq int,</div><div class="line">    d_year int,</div><div class="line">    d_dow int,</div><div class="line">    d_moy int,</div><div class="line">    d_dom int,</div><div class="line">    d_qoy int,</div><div class="line">    d_fy_year int,</div><div class="line">    d_fy_quarter_seq int,</div><div class="line">    d_fy_week_seq int,</div><div class="line">    d_day_name char(9),</div><div class="line">    d_quarter_name char(6),</div><div class="line">    d_holiday char(1),</div><div class="line">    d_weekend char(1),</div><div class="line">    d_following_holiday char(1),</div><div class="line">    d_first_dom int,</div><div class="line">    d_last_dom int,</div><div class="line">    d_same_day_ly int,</div><div class="line">    d_same_day_lq int,</div><div class="line">    d_current_day char(1),</div><div class="line">    d_current_week char(1),</div><div class="line">    d_current_month char(1),</div><div class="line">    d_current_quarter char(1),</div><div class="line">    d_current_year char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/date_dim_1_10000.dat&quot; overwrite into table tpc_ds.date_dim;</div><div class="line"></div><div class="line">create table if not exists warehouse</div><div class="line">(</div><div class="line">    w_warehouse_sk int,</div><div class="line">    w_warehouse_id char(16),</div><div class="line">    w_warehouse_name varchar(20),</div><div class="line">    w_warehouse_sq_ft int,</div><div class="line">    w_street_number char(10),</div><div class="line">    w_street_name varchar(60),</div><div class="line">    w_street_type char(15),</div><div class="line">    w_suite_number char(10),</div><div class="line">    w_city varchar(60),</div><div class="line">    w_county varchar(30),</div><div class="line">    w_state char(2),</div><div class="line">    w_zip char(10),</div><div class="line">    w_country varchar(20),</div><div class="line">    w_gmt_offset decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/warehouse_1_10000.dat&quot; overwrite into table tpc_ds.warehouse;</div><div class="line"></div><div class="line">create table if not exists ship_mode</div><div class="line">(</div><div class="line">    sm_ship_mode_sk int,</div><div class="line">    sm_ship_mode_id char(16),</div><div class="line">    sm_type char(30),</div><div class="line">    sm_code char(10),</div><div class="line">    sm_carrier char(20),</div><div class="line">    sm_contract char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/ship_mode_1_10000.dat&quot; overwrite into table tpc_ds.ship_mode;</div><div class="line"></div><div class="line">create table if not exists time_dim</div><div class="line">(</div><div class="line">    t_time_sk int,</div><div class="line">    t_time_id char(16),</div><div class="line">    t_time int,</div><div class="line">    t_hour int,</div><div class="line">    t_minute int,</div><div class="line">    t_second int,</div><div class="line">    t_am_pm char(2),</div><div class="line">    t_shift char(20),</div><div class="line">    t_sub_shift char(20),</div><div class="line">    t_meal_time char(20)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/time_dim_1_10000.dat&quot; overwrite into table tpc_ds.time_dim;</div><div class="line"></div><div class="line">create table if not exists reason</div><div class="line">(</div><div class="line">    r_reason_sk int,</div><div class="line">    r_reason_id char(16),</div><div class="line">    r_reason_desc char(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/reason_1_10000.dat&quot; overwrite into table tpc_ds.reason;</div><div class="line"></div><div class="line">create table if not exists income_band</div><div class="line">(</div><div class="line">    ib_income_band_sk int,</div><div class="line">    ib_lower_bound int,</div><div class="line">    ib_upper_bound int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/income_band_1_10000.dat&quot; overwrite into table tpc_ds.income_band;</div><div class="line"></div><div class="line">create table if not exists item</div><div class="line">(</div><div class="line">    i_item_sk int,</div><div class="line">    i_item_id char(16),</div><div class="line">    i_rec_start_date date ,</div><div class="line">    i_rec_end_date date ,</div><div class="line">    i_item_desc varchar(200),</div><div class="line">    i_current_price decimal(7,2),</div><div class="line">    i_wholesale_cost decimal(7,2),</div><div class="line">    i_brand_id int,</div><div class="line">    i_brand char(50),</div><div class="line">    i_class_id int,</div><div class="line">    i_class char(50),</div><div class="line">    i_category_id int,</div><div class="line">    i_category char(50),</div><div class="line">    i_manufact_id int,</div><div class="line">    i_manufact char(50),</div><div class="line">    i_size char(20),</div><div class="line">    i_formulation char(20),</div><div class="line">    i_color char(20),</div><div class="line">    i_units char(10),</div><div class="line">    i_container char(10),</div><div class="line">    i_manager_id int,</div><div class="line">    i_product_name char(50)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/item_1_10000.dat&quot; overwrite into table tpc_ds.item;</div><div class="line"></div><div class="line">create table if not exists store</div><div class="line">(</div><div class="line">    s_store_sk int,</div><div class="line">    s_store_id char(16),</div><div class="line">    s_rec_start_date date ,</div><div class="line">    s_rec_end_date date ,</div><div class="line">    s_closed_date_sk int,</div><div class="line">    s_store_name varchar(50),</div><div class="line">    s_number_employees int,</div><div class="line">    s_floor_space int,</div><div class="line">    s_hours char(20),</div><div class="line">    s_manager varchar(40),</div><div class="line">    s_market_id int,</div><div class="line">    s_geography_class varchar(100),</div><div class="line">    s_market_desc varchar(100),</div><div class="line">    s_market_manager varchar(40),</div><div class="line">    s_division_id int,</div><div class="line">    s_division_name varchar(50),</div><div class="line">    s_company_id int,</div><div class="line">    s_company_name varchar(50),</div><div class="line">    s_street_number varchar(10),</div><div class="line">    s_street_name varchar(60),</div><div class="line">    s_street_type char(15),</div><div class="line">    s_suite_number char(10),</div><div class="line">    s_city varchar(60),</div><div class="line">    s_county varchar(30),</div><div class="line">    s_state char(2),</div><div class="line">    s_zip char(10),</div><div class="line">    s_country varchar(20),</div><div class="line">    s_gmt_offset decimal(5,2),</div><div class="line">    s_tax_precentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_1_10000.dat&quot; overwrite into table tpc_ds.store;</div><div class="line"></div><div class="line">create table if not exists call_center</div><div class="line">(</div><div class="line">    cc_call_center_sk int,</div><div class="line">    cc_call_center_id char(16),</div><div class="line">    cc_rec_start_date date ,</div><div class="line">    cc_rec_end_date date ,</div><div class="line">    cc_closed_date_sk int,</div><div class="line">    cc_open_date_sk int,</div><div class="line">    cc_name varchar(50),</div><div class="line">    cc_class varchar(50),</div><div class="line">    cc_employees int,</div><div class="line">    cc_sq_ft int,</div><div class="line">    cc_hours char(20),</div><div class="line">    cc_manager varchar(40),</div><div class="line">    cc_mkt_id int,</div><div class="line">    cc_mkt_class char(50),</div><div class="line">    cc_mkt_desc varchar(100),</div><div class="line">    cc_market_manager varchar(40),</div><div class="line">    cc_division int,</div><div class="line">    cc_division_name varchar(50),</div><div class="line">    cc_company int,</div><div class="line">    cc_company_name char(50),</div><div class="line">    cc_street_number char(10),</div><div class="line">    cc_street_name varchar(60),</div><div class="line">    cc_street_type char(15),</div><div class="line">    cc_suite_number char(10),</div><div class="line">    cc_city varchar(60),</div><div class="line">    cc_county varchar(30),</div><div class="line">    cc_state char(2),</div><div class="line">    cc_zip char(10),</div><div class="line">    cc_country varchar(20),</div><div class="line">    cc_gmt_offset decimal(5,2),</div><div class="line">    cc_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/call_center_1_10000.dat&quot; overwrite into table tpc_ds.call_center;</div><div class="line"></div><div class="line">create table if not exists customer</div><div class="line">(</div><div class="line">    c_customer_sk int,</div><div class="line">    c_customer_id char(16),</div><div class="line">    c_current_cdemo_sk int,</div><div class="line">    c_current_hdemo_sk int,</div><div class="line">    c_current_addr_sk int,</div><div class="line">    c_first_shipto_date_sk int,</div><div class="line">    c_first_sales_date_sk int,</div><div class="line">    c_salutation char(10),</div><div class="line">    c_first_name char(20),</div><div class="line">    c_last_name char(30),</div><div class="line">    c_preferred_cust_flag char(1),</div><div class="line">    c_birth_day int,</div><div class="line">    c_birth_month int,</div><div class="line">    c_birth_year int,</div><div class="line">    c_birth_country varchar(20),</div><div class="line">    c_login char(13),</div><div class="line">    c_email_address char(50),</div><div class="line">    c_last_review_date char(10)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/customer_1_10000.dat&quot; overwrite into table tpc_ds.customer;</div><div class="line"></div><div class="line">create table if not exists web_site</div><div class="line">(</div><div class="line">    web_site_sk int,</div><div class="line">    web_site_id char(16),</div><div class="line">    web_rec_start_date date ,</div><div class="line">    web_rec_end_date date ,</div><div class="line">    web_name varchar(50),</div><div class="line">    web_open_date_sk int,</div><div class="line">    web_close_date_sk int,</div><div class="line">    web_class varchar(50),</div><div class="line">    web_manager varchar(40),</div><div class="line">    web_mkt_id int,</div><div class="line">    web_mkt_class varchar(50),</div><div class="line">    web_mkt_desc varchar(100),</div><div class="line">    web_market_manager varchar(40),</div><div class="line">    web_company_id int,</div><div class="line">    web_company_name char(50),</div><div class="line">    web_street_number char(10),</div><div class="line">    web_street_name varchar(60),</div><div class="line">    web_street_type char(15),</div><div class="line">    web_suite_number char(10),</div><div class="line">    web_city varchar(60),</div><div class="line">    web_county varchar(30),</div><div class="line">    web_state char(2),</div><div class="line">    web_zip char(10),</div><div class="line">    web_country varchar(20),</div><div class="line">    web_gmt_offset decimal(5,2),</div><div class="line">    web_tax_percentage decimal(5,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_site_1_10000.dat&quot; overwrite into table tpc_ds.web_site;</div><div class="line"></div><div class="line">create table if not exists store_returns</div><div class="line">(</div><div class="line">    sr_returned_date_sk int,</div><div class="line">    sr_return_time_sk int,</div><div class="line">    sr_item_sk int,</div><div class="line">    sr_customer_sk int,</div><div class="line">    sr_cdemo_sk int,</div><div class="line">    sr_hdemo_sk int,</div><div class="line">    sr_addr_sk int,</div><div class="line">    sr_store_sk int,</div><div class="line">    sr_reason_sk int,</div><div class="line">    sr_ticket_number int,</div><div class="line">    sr_return_quantity int,</div><div class="line">    sr_return_amt decimal(7,2),</div><div class="line">    sr_return_tax decimal(7,2),</div><div class="line">    sr_return_amt_inc_tax decimal(7,2),</div><div class="line">    sr_fee decimal(7,2),</div><div class="line">    sr_return_ship_cost decimal(7,2),</div><div class="line">    sr_refunded_cash decimal(7,2),</div><div class="line">    sr_reversed_charge decimal(7,2),</div><div class="line">    sr_store_credit decimal(7,2),</div><div class="line">    sr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_returns_1_10000.dat&quot; overwrite into table tpc_ds.store_returns;</div><div class="line"></div><div class="line">create table if not exists household_demographics</div><div class="line">(</div><div class="line">    hd_demo_sk int,</div><div class="line">    hd_income_band_sk int,</div><div class="line">    hd_buy_potential char(15),</div><div class="line">    hd_dep_count int,</div><div class="line">    hd_vehicle_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/household_demographics_1_10000.dat&quot; overwrite into table tpc_ds.household_demographics;</div><div class="line"></div><div class="line">create table if not exists web_page</div><div class="line">(</div><div class="line">    wp_web_page_sk int,</div><div class="line">    wp_web_page_id char(16),</div><div class="line">    wp_rec_start_date date ,</div><div class="line">    wp_rec_end_date date ,</div><div class="line">    wp_creation_date_sk int,</div><div class="line">    wp_access_date_sk int,</div><div class="line">    wp_autogen_flag char(1),</div><div class="line">    wp_customer_sk int,</div><div class="line">    wp_url varchar(100),</div><div class="line">    wp_type char(50),</div><div class="line">    wp_char_count int,</div><div class="line">    wp_link_count int,</div><div class="line">    wp_image_count int,</div><div class="line">    wp_max_ad_count int</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_page_1_10000.dat&quot; overwrite into table tpc_ds.web_page;</div><div class="line"></div><div class="line">create table if not exists promotion</div><div class="line">(</div><div class="line">    p_promo_sk int,</div><div class="line">    p_promo_id char(16),</div><div class="line">    p_start_date_sk int,</div><div class="line">    p_end_date_sk int,</div><div class="line">    p_item_sk int,</div><div class="line">    p_cost decimal(15,2),</div><div class="line">    p_response_target int,</div><div class="line">    p_promo_name char(50),</div><div class="line">    p_channel_dmail char(1),</div><div class="line">    p_channel_email char(1),</div><div class="line">    p_channel_catalog char(1),</div><div class="line">    p_channel_tv char(1),</div><div class="line">    p_channel_radio char(1),</div><div class="line">    p_channel_press char(1),</div><div class="line">    p_channel_event char(1),</div><div class="line">    p_channel_demo char(1),</div><div class="line">    p_channel_details varchar(100),</div><div class="line">    p_purpose char(15),</div><div class="line">    p_discount_active char(1)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/promotion_1_10000.dat&quot; overwrite into table tpc_ds.promotion;</div><div class="line"></div><div class="line">create table if not exists catalog_page</div><div class="line">(</div><div class="line">    cp_catalog_page_sk int,</div><div class="line">    cp_catalog_page_id char(16),</div><div class="line">    cp_start_date_sk int,</div><div class="line">    cp_end_date_sk int,</div><div class="line">    cp_department varchar(50),</div><div class="line">    cp_catalog_number int,</div><div class="line">    cp_catalog_page_number int,</div><div class="line">    cp_description varchar(100),</div><div class="line">    cp_type varchar(100)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_page_1_10000.dat&quot; overwrite into table tpc_ds.catalog_page;</div><div class="line"></div><div class="line">create table if not exists inventory</div><div class="line">(</div><div class="line">    inv_date_sk int,</div><div class="line">    inv_item_sk int,</div><div class="line">    inv_warehouse_sk int,</div><div class="line">    inv_quantity_on_hand int)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/inventory_1_10000.dat&quot; overwrite into table tpc_ds.inventory;</div><div class="line"></div><div class="line">create table if not exists catalog_returns</div><div class="line">(</div><div class="line">    cr_returned_date_sk int,</div><div class="line">    cr_returned_time_sk int,</div><div class="line">    cr_item_sk int,</div><div class="line">    cr_refunded_customer_sk int,</div><div class="line">    cr_refunded_cdemo_sk int,</div><div class="line">    cr_refunded_hdemo_sk int,</div><div class="line">    cr_refunded_addr_sk int,</div><div class="line">    cr_returning_customer_sk int,</div><div class="line">    cr_returning_cdemo_sk int,</div><div class="line">    cr_returning_hdemo_sk int,</div><div class="line">    cr_returning_addr_sk int,</div><div class="line">    cr_call_center_sk int,</div><div class="line">    cr_catalog_page_sk int,</div><div class="line">    cr_ship_mode_sk int,</div><div class="line">    cr_warehouse_sk int,</div><div class="line">    cr_reason_sk int,</div><div class="line">    cr_order_number int,</div><div class="line">    cr_return_quantity int,</div><div class="line">    cr_return_amount decimal(7,2),</div><div class="line">    cr_return_tax decimal(7,2),</div><div class="line">    cr_return_amt_inc_tax decimal(7,2),</div><div class="line">    cr_fee decimal(7,2),</div><div class="line">    cr_return_ship_cost decimal(7,2),</div><div class="line">    cr_refunded_cash decimal(7,2),</div><div class="line">    cr_reversed_charge decimal(7,2),</div><div class="line">    cr_store_credit decimal(7,2),</div><div class="line">    cr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_returns_1_10000.dat&quot; overwrite into table tpc_ds.catalog_returns;</div><div class="line"></div><div class="line">create table if not exists web_returns</div><div class="line">(</div><div class="line">    wr_returned_date_sk int,</div><div class="line">    wr_returned_time_sk int,</div><div class="line">    wr_item_sk int,</div><div class="line">    wr_refunded_customer_sk int,</div><div class="line">    wr_refunded_cdemo_sk int,</div><div class="line">    wr_refunded_hdemo_sk int,</div><div class="line">    wr_refunded_addr_sk int,</div><div class="line">    wr_returning_customer_sk int,</div><div class="line">    wr_returning_cdemo_sk int,</div><div class="line">    wr_returning_hdemo_sk int,</div><div class="line">    wr_returning_addr_sk int,</div><div class="line">    wr_web_page_sk int,</div><div class="line">    wr_reason_sk int,</div><div class="line">    wr_order_number int,</div><div class="line">    wr_return_quantity int,</div><div class="line">    wr_return_amt decimal(7,2),</div><div class="line">    wr_return_tax decimal(7,2),</div><div class="line">    wr_return_amt_inc_tax decimal(7,2),</div><div class="line">    wr_fee decimal(7,2),</div><div class="line">    wr_return_ship_cost decimal(7,2),</div><div class="line">    wr_refunded_cash decimal(7,2),</div><div class="line">    wr_reversed_charge decimal(7,2),</div><div class="line">    wr_account_credit decimal(7,2),</div><div class="line">    wr_net_loss decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_returns_1_10000.dat&quot; overwrite into table tpc_ds.web_returns;</div><div class="line"></div><div class="line">create table if not exists web_sales</div><div class="line">(</div><div class="line">    ws_sold_date_sk int,</div><div class="line">    ws_sold_time_sk int,</div><div class="line">    ws_ship_date_sk int,</div><div class="line">    ws_item_sk int,</div><div class="line">    ws_bill_customer_sk int,</div><div class="line">    ws_bill_cdemo_sk int,</div><div class="line">    ws_bill_hdemo_sk int,</div><div class="line">    ws_bill_addr_sk int,</div><div class="line">    ws_ship_customer_sk int,</div><div class="line">    ws_ship_cdemo_sk int,</div><div class="line">    ws_ship_hdemo_sk int,</div><div class="line">    ws_ship_addr_sk int,</div><div class="line">    ws_web_page_sk int,</div><div class="line">    ws_web_site_sk int,</div><div class="line">    ws_ship_mode_sk int,</div><div class="line">    ws_warehouse_sk int,</div><div class="line">    ws_promo_sk int,</div><div class="line">    ws_order_number int,</div><div class="line">    ws_quantity int,</div><div class="line">    ws_wholesale_cost decimal(7,2),</div><div class="line">    ws_list_price decimal(7,2),</div><div class="line">    ws_sales_price decimal(7,2),</div><div class="line">    ws_ext_discount_amt decimal(7,2),</div><div class="line">    ws_ext_sales_price decimal(7,2),</div><div class="line">    ws_ext_wholesale_cost decimal(7,2),</div><div class="line">    ws_ext_list_price decimal(7,2),</div><div class="line">    ws_ext_tax decimal(7,2),</div><div class="line">    ws_coupon_amt decimal(7,2),</div><div class="line">    ws_ext_ship_cost decimal(7,2),</div><div class="line">    ws_net_paid decimal(7,2),</div><div class="line">    ws_net_paid_inc_tax decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship decimal(7,2),</div><div class="line">    ws_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    ws_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/web_sales_1_10000.dat&quot; overwrite into table tpc_ds.web_sales;</div><div class="line"></div><div class="line">create table if not exists catalog_sales</div><div class="line">(</div><div class="line">    cs_sold_date_sk int,</div><div class="line">    cs_sold_time_sk int,</div><div class="line">    cs_ship_date_sk int,</div><div class="line">    cs_bill_customer_sk int,</div><div class="line">    cs_bill_cdemo_sk int,</div><div class="line">    cs_bill_hdemo_sk int,</div><div class="line">    cs_bill_addr_sk int,</div><div class="line">    cs_ship_customer_sk int,</div><div class="line">    cs_ship_cdemo_sk int,</div><div class="line">    cs_ship_hdemo_sk int,</div><div class="line">    cs_ship_addr_sk int,</div><div class="line">    cs_call_center_sk int,</div><div class="line">    cs_catalog_page_sk int,</div><div class="line">    cs_ship_mode_sk int,</div><div class="line">    cs_warehouse_sk int,</div><div class="line">    cs_item_sk int,</div><div class="line">    cs_promo_sk int,</div><div class="line">    cs_order_number int,</div><div class="line">    cs_quantity int,</div><div class="line">    cs_wholesale_cost decimal(7,2),</div><div class="line">    cs_list_price decimal(7,2),</div><div class="line">    cs_sales_price decimal(7,2),</div><div class="line">    cs_ext_discount_amt decimal(7,2),</div><div class="line">    cs_ext_sales_price decimal(7,2),</div><div class="line">    cs_ext_wholesale_cost decimal(7,2),</div><div class="line">    cs_ext_list_price decimal(7,2),</div><div class="line">    cs_ext_tax decimal(7,2),</div><div class="line">    cs_coupon_amt decimal(7,2),</div><div class="line">    cs_ext_ship_cost decimal(7,2),</div><div class="line">    cs_net_paid decimal(7,2),</div><div class="line">    cs_net_paid_inc_tax decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship decimal(7,2),</div><div class="line">    cs_net_paid_inc_ship_tax decimal(7,2),</div><div class="line">    cs_net_profit decimal(7,2)</div><div class="line">)row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/catalog_sales_1_10000.dat&quot; overwrite into table tpc_ds.catalog_sales;</div><div class="line"></div><div class="line">create table if not exists store_sales</div><div class="line">(</div><div class="line">    ss_sold_date_sk int,</div><div class="line">    ss_sold_time_sk int,</div><div class="line">    ss_item_sk int,</div><div class="line">    ss_customer_sk int,</div><div class="line">    ss_cdemo_sk int,</div><div class="line">    ss_hdemo_sk int,</div><div class="line">    ss_addr_sk int,</div><div class="line">    ss_store_sk int,</div><div class="line">    ss_promo_sk int,</div><div class="line">    ss_ticket_number int,</div><div class="line">    ss_quantity int,</div><div class="line">    ss_wholesale_cost decimal(7,2),</div><div class="line">    ss_list_price decimal(7,2),</div><div class="line">    ss_sales_price decimal(7,2),</div><div class="line">    ss_ext_discount_amt decimal(7,2),</div><div class="line">    ss_ext_sales_price decimal(7,2),</div><div class="line">    ss_ext_wholesale_cost decimal(7,2),</div><div class="line">    ss_ext_list_price decimal(7,2),</div><div class="line">    ss_ext_tax decimal(7,2),</div><div class="line">    ss_coupon_amt decimal(7,2),</div><div class="line">    ss_net_paid decimal(7,2),</div><div class="line">    ss_net_paid_inc_tax decimal(7,2),</div><div class="line">    ss_net_profit decimal(7,2))row format delimited</div><div class="line">fields terminated by &apos;|&apos;</div><div class="line">lines terminated by &apos;\n&apos;</div><div class="line">stored as textfile;</div><div class="line">load data local inpath &quot;/home/spark/zsy/v2.4.0/tools/tmp/store_sales_1_10000.dat&quot; overwrite into table tpc_ds.store_sales;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生成步骤&lt;/p&gt;
&lt;p&gt;1.在官网上(&lt;a href=&quot;http://www.tpc.org/tpcds/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tpc.org/tpcds/&lt;/a&gt; )去下载最新的：TPC-DS. &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
