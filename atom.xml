<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Siyao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-28T07:35:25.015Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siyao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【九章算法强化班】follow up</title>
    <link href="http://yoursite.com/2018/02/26/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91follow-up/"/>
    <id>http://yoursite.com/2018/02/26/【九章算法强化班】follow-up/</id>
    <published>2018-02-26T07:07:15.000Z</published>
    <updated>2018-02-28T07:35:25.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-26-20-43-25.png" alt=""> </p><h2 id="例题1-Find-Peak-Element"><a href="#例题1-Find-Peak-Element" class="headerlink" title="例题1.Find Peak Element"></a>例题1.<a href="https://leetcode.com/problems/find-peak-element" target="_blank" rel="external">Find Peak Element</a></h2><blockquote><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p><p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p></blockquote><p>找局部最大值。</p><p>思路：</p><ol><li><p>baseline：</p><p>遍历，找到i：nums[i-1]&lt;num[i]&lt;num[i+1]</p><p>复杂度<script type="math/tex">O(n)</script></p></li></ol><ol><li><p>优化：二分法</p><p>首先我们找到中间节点mid，如果大于两边返回当前index就可以了，如果左边的节点比mid大，那么我们可以继续在左半区间查找，这里面一定存在一个peak，为什么这么说呢？假设此时的区间范围为[0, mid - 1]， 因为num[mid - 1]一定大于num[mid]了，如果num[mid - 2] &lt;= num[mid - 1]，那么num[mid - 1]就是一个peak。如果num[mid - 2] &gt; num[mid - 1]，那么我们就继续在[0, mid - 2]区间查找，因为num[-1]为负无穷，所以最终我们绝对能在左半区间找到一个peak。同理右半区间一样。</p><p>复杂度<script type="math/tex">O(logn)</script></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遇到这种需要判断元素左右的将start设为1，end设为len-2,放置越界</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(start+<span class="number">1</span>&lt;end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &gt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((nums[mid] &lt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums[mid] &gt; nums[mid+<span class="number">1</span>]) &amp;&amp; (nums[mid] &lt; nums[mid-<span class="number">1</span>]))&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[end])&#123;</div><div class="line">            <span class="keyword">return</span>  end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-Find-Peak-Element-II"><a href="#follow-up-Find-Peak-Element-II" class="headerlink" title="follow up: Find Peak Element II"></a>follow up: Find Peak Element II</h3><p> 由一维拓展到二维，在矩阵上找peak element</p><p>peak element：<code>matrix[i][j]</code> 比其上下左右相邻元素大</p><p>思路：</p><ol><li><p>baseline：</p><p>遍历</p><p>复杂度复杂度<script type="math/tex">O(n^2)</script></p></li><li><p>优化：二分法</p><ul><li>找到中间行的最大值<code>matrix[i][j]</code></li><li>跟相邻上下元素比较，决定向上/向下走</li><li>如果上面的元素比较大，向上走，否则向下走</li></ul><p>复杂度<script type="math/tex">O(nlogn)</script></p></li><li><p>优化：行列交替二分</p><ul><li>找到中间行的最大值<code>matrix[i][j]</code> <script type="math/tex">O(n)</script></li><li>跟相邻上下元素比较，决定向上/向下走 剩下一半矩阵</li><li>找中间列的最大值<code>matrix[i][j]</code><script type="math/tex">O(n/2)</script></li><li>跟相邻左右元素比较，决定向左/向右走 剩下n/4矩阵</li></ul><p>复杂度<script type="math/tex">O(n)</script></p></li></ol><h2 id="例题2-Subarray-Sum"><a href="#例题2-Subarray-Sum" class="headerlink" title="例题2. Subarray Sum"></a>例题2. <a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">Subarray Sum</a></h2><blockquote><p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p><p>Example</p><p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p></blockquote><p>找子数组，和为0</p><p>思路：</p><ol><li><p>baseline:</p><p>两指针遍历</p><p>复杂度复杂度<script type="math/tex">O(n^2)</script></p></li><li><p>prefix sum:</p><p>用hash表记录前缀和的取值</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                result.add(<span class="number">0</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="follow-up-1-Submatrix-Sum"><a href="#follow-up-1-Submatrix-Sum" class="headerlink" title="follow up 1: Submatrix Sum"></a>follow up 1: <a href="http://www.lintcode.com/en/problem/submatrix-sum/" target="_blank" rel="external">Submatrix Sum</a></h3><blockquote><p>Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.</p><p>Example</p><p>Given matrix</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;   [1 ,5 ,7],</div><div class="line">&gt;   [3 ,7 ,-8],</div><div class="line">&gt;   [4 ,-8 ,9],</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[(1,1), (2,2)]</code></p></blockquote><p>求元素和为0的子矩阵，返回矩阵的左上角和右下角元素位置</p><p>思路：</p><ol><li><p>先定位子矩阵的首行和尾行（外层循环）</p></li><li><p>把首行和尾行之间的元素压成一行，变成一个数组</p></li><li><p>对上面的数组做subarray sum，找到和为0的子数组就可以定位子矩阵的首列和尾列。</p><p>​</p></li></ol><p>预计算presum矩阵：</p><p><code>presum[i][j] = matrix[0][0]到matrix[i][j]的所有元素和</code></p><p>当外层循环固定为l和h时，内层循环j从0开始遍历，矩阵的前缀和为<code>presum[h][j]-presum[l][j]</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] submatrixSum(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> rows = matrix.length;</div><div class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[][] presum = <span class="keyword">new</span> <span class="keyword">int</span>[rows+<span class="number">1</span>][cols+<span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows+<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols+<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</div><div class="line">                presum[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                presum[i][j] = matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] + presum[i-<span class="number">1</span>][j] + presum[i][j-<span class="number">1</span>] - presum[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; rows + <span class="number">1</span>; j++) &#123;</div><div class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cols + <span class="number">1</span>; k++) &#123;</div><div class="line">                <span class="keyword">int</span> diff = presum[j][k] - presum[i][k];</div><div class="line">                <span class="keyword">if</span> (map.containsKey(diff)) &#123;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">0</span>] = i;</div><div class="line">                    result[<span class="number">0</span>][<span class="number">1</span>] = map.get(diff);</div><div class="line">                    result[<span class="number">1</span>][<span class="number">0</span>] = j-<span class="number">1</span>;</div><div class="line">                    result[<span class="number">1</span>][<span class="number">1</span>] = k-<span class="number">1</span>;</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    map.put(diff, k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-2-Subarray-Sum-II"><a href="#follow-up-2-Subarray-Sum-II" class="headerlink" title="follow up 2: Subarray Sum II"></a>follow up 2: Subarray Sum II</h3><p>给定一个数组nums和一个区间interval，返回nums数组中和在区间interval中的子数组个数，如nums = [1,2,3,4]，interval = [1,3],return 4,the possible answers are:[0,0],[0,1],[1,1],[2,2]</p><p>思路：</p><p>low &lt; prefix[j] - prefix[i] &lt; high</p><p>low + prefix[i] &lt; prefix[j] &lt; high + prefix[i]</p><p>prefix[i]  &lt;  prefix[j] - low</p><p>prefix[i]  &gt; prefix[j] - high</p><p>所以本题就是要找到在[prefix[j] - high , prefix[j] - low]范围内的prefix[i] </p><p>由于prefix[i]是递增的，所以可以存在数组中，用二分法查找</p><h2 id="例题3-Maximum-Subarray"><a href="#例题3-Maximum-Subarray" class="headerlink" title="例题3. Maximum Subarray"></a>例题3. <a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p></blockquote><p>找和最大的子数组</p><p>思路：</p><p>方法1：prefixsum</p><p>维护最小的prefixsum和当前最大的子数组和</p><p>方法2：dp</p><p>dp[i] = max(dp[i-1] + num[i],num[i])</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</div><div class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</div><div class="line">            maxVal = Math.max(maxVal,dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="follow-up-循环连续子数组"><a href="#follow-up-循环连续子数组" class="headerlink" title="follow up 循环连续子数组"></a>follow up 循环连续子数组</h2><p>上题的数组变成循环数组。</p><p>处理循环数组三种方法：</p><ol><li>拆开</li><li>扩展</li><li>取反</li></ol><p>分别看对于这道题是否可行：</p><ol><li><p>拆开</p><p>house robber用到了这个方法，抢第一个就不能抢最后一个，抢最后一个就不能抢第一个</p></li><li><p>扩展</p><p>将数组翻一倍，[-3, 1, 3, -3, 4]变成[-3, 1, 3, -3, 4,-3,1,3,-3]，然后找最大子数组，但是长度不能超过nums的长度。</p></li><li><p>取反</p><p>找循环数组中的最大子数组，有两种情况：</p><ol><li>在数组的中部，正常找就行了</li><li>一半在数组后面，一半在数组头部，因为数组的总和是一定的，因此这种情况可以转化成在数组中部找最小的子数组</li></ol><p>然后取上面两种情况的最大值。</p><p>​</p></li></ol><h2 id="例题4-Wiggle-Sort"><a href="#例题4-Wiggle-Sort" class="headerlink" title="例题4.  Wiggle Sort"></a>例题4.  <a href="https://leetcode.com/problems/wiggle-sort" target="_blank" rel="external">Wiggle Sort</a></h2><blockquote><p>Given an unsorted array <code>nums</code>, reorder it <strong>in-place</strong> such that <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...</code>.</p><p>For example, given <code>nums = [3, 5, 2, 1, 6, 4]</code>, one possible answer is <code>[1, 6, 2, 5, 3, 4]</code>.</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[start];</div><div class="line">                start++;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-Wiggle-Sort-II"><a href="#follow-up-Wiggle-Sort-II" class="headerlink" title="follow up Wiggle Sort II"></a>follow up <a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p><p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>对数组排序，排序之后将数组分成大小两堆，然后依次选取排序</p></li><li><p>quick sort思想</p><p>利用quick sort 找到中点，然后对左右两边元素一次选取排序</p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="例题5-Building-Post-Office-Best-Meeting-Point"><a href="#例题5-Building-Post-Office-Best-Meeting-Point" class="headerlink" title="例题5. Building Post Office Best Meeting Point"></a>例题5. Building Post Office <a href="https://leetcode.com/problems/best-meeting-point" target="_blank" rel="external">Best Meeting Point</a></h2><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>遍历所有位置，计算每个位置到所有人的距离，取最小的</p></li><li><p>优化：</p><p>看成一维，对于所有人来说，meeting point选在所有人的中位数的位置距离和最近，因此对行和列坐标分别选取中位数，得到meeting point</p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//int  num = 0;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                    <span class="comment">//num++;</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up1-Shortest-Distance-from-All-Buildings"><a href="#follow-up1-Shortest-Distance-from-All-Buildings" class="headerlink" title="follow up1. Shortest Distance from All Buildings"></a>follow up1. <a href="https://leetcode.com/problems/shortest-distance-from-all-buildings" target="_blank" rel="external">Shortest Distance from All Buildings</a></h3><blockquote><p>You want to build a house on an <em>empty</em> land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values <strong>0</strong>, <strong>1</strong> or <strong>2</strong>, where:</p><ul><li>Each <strong>0</strong> marks an empty land which you can pass by freely.</li><li>Each <strong>1</strong> marks a building which you cannot pass through.</li><li>Each <strong>2</strong> marks an obstacle which you cannot pass through.</li></ul><p>For example, given three buildings at <code>(0,0)</code>, <code>(0,4)</code>, <code>(2,2)</code>, and an obstacle at <code>(0,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 2 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(1,2)</code> is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>bfs，计算每个点到所有人的距离，取距离和最小的</p><p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层bfs<script type="math/tex">O(n^2)</script>，因此时间复杂度<script type="math/tex">O(n^4)</script></p></li><li><p>反向bfs</p><p>计算每个人到所有位置的距离<code>dis[k][i][j]</code> ，复杂度<script type="math/tex">O(n^2)</script></p><p>然后再遍历矩阵中每一个点，查询距离，取最小值，复杂度<script type="math/tex">O(n^2)</script></p><p>因此时间复杂度<script type="math/tex">O(n^2)</script></p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//计算到所有空地的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> idx,<span class="keyword">int</span>[][][] distance,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">int</span>[][] grid)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(i*cols+j);</div><div class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">int</span> val = queue.poll();</div><div class="line">                <span class="keyword">int</span> x = val/cols;</div><div class="line">                <span class="keyword">int</span> y = val % cols;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                    <span class="keyword">int</span> x_new = x + x_delta[ii];</div><div class="line">                    <span class="keyword">int</span> y_new = y + y_delta[ii];</div><div class="line">                    <span class="keyword">if</span>(x_new &gt;= <span class="number">0</span> &amp;&amp; x_new &lt; rows &amp;&amp; y_new &gt;= <span class="number">0</span> &amp;&amp; y_new &lt;cols) &#123;</div><div class="line">                        <span class="keyword">if</span>(grid[x_new][y_new] == <span class="number">0</span> &amp;&amp; distance[idx][x_new][y_new] == <span class="number">0</span>)&#123;</div><div class="line">                            distance[idx][x_new][y_new] = dis;</div><div class="line">                            queue.add(x_new * cols + y_new);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">            dis++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">        <span class="comment">//计算有多少个1</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[count][rows][cols];</div><div class="line">        <span class="comment">//计算（i,j）到所有0点的距离</span></div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    bfs(i,j,idx,distance,rows,cols,grid);</div><div class="line">                    idx++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</div><div class="line">        <span class="comment">//找距离和最短的</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; distance.length;k++)&#123;</div><div class="line">                        <span class="keyword">if</span>(distance[k][i][j] == <span class="number">0</span>)&#123;</div><div class="line">                            flag = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span>&#123;</div><div class="line">                            sum += distance[k][i][j];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(flag)&#123;</div><div class="line">                        minDist = Math.min(minDist,sum);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minDist == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minDist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="follow-up-2-Bomb-Enemy"><a href="#follow-up-2-Bomb-Enemy" class="headerlink" title="follow up 2. Bomb Enemy"></a>follow up 2. <a href="https://leetcode.com/problems/bomb-enemy" target="_blank" rel="external">Bomb Enemy</a></h3><blockquote><p>Given a 2D grid, each cell is either a wall <code>&#39;W&#39;</code>, an enemy <code>&#39;E&#39;</code> or empty <code>&#39;0&#39;</code> (the number zero), return the maximum enemies you can kill using one bomb.<br>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br>Note that you can only put the bomb at an empty cell.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For the given grid</div><div class="line">&gt;</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt; E 0 W E</div><div class="line">&gt; 0 E 0 0</div><div class="line">&gt;</div><div class="line">&gt; return 3. (Placing a bomb at (1,1) kills 3 enemies)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>思路：</p><ol><li><p>baseline：</p><p>bfs，计算每个点能够炸到的到所有人</p><p>时间复杂度：外层循环<script type="math/tex">O(n^2)</script> 然后内层<script type="math/tex">O(n)</script>，因此时间复杂度<script type="math/tex">O(n^3)</script></p></li><li><p>反向bfs</p><p>申请四个数组：</p><p><code>left[i][j]:在(i,j)放炸弹，向左最多炸人数</code></p><p><code>right[i][j]:在(i,j)放炸弹，向右最多炸人数</code></p><p><code>up[i][j]:在(i,j)放炸弹，向上最多炸人数</code></p><p><code>dowm[i][j]:在(i,j)放炸弹，向下最多炸人数</code></p><p>将四个数组相加就得到在(i,j)放炸弹，总共炸人数</p><p>因此时间复杂度<script type="math/tex">O(n^2)</script> </p></li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombEnemy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxKilledEnemies</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = grid.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] left = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] up = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">int</span> leftsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> rightsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span>)&#123; left[i][j] = leftsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'W'</span>)&#123; leftsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'E'</span>)&#123; leftsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'0'</span>)&#123; right[i][cols-<span class="number">1</span>-j] = rightsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'W'</span>)&#123; rightsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[i][cols-<span class="number">1</span>-j] == <span class="string">'E'</span>)&#123; rightsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cols;i++)&#123;</div><div class="line">            <span class="keyword">int</span> upsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> downsum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; rows;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'0'</span>)&#123; up[j][i] = upsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'W'</span>)&#123; upsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="string">'E'</span>)&#123; upsum++; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'0'</span>)&#123; down[rows-<span class="number">1</span>-j][i] = downsum; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'W'</span>)&#123; downsum = <span class="number">0</span>; &#125;</div><div class="line">                <span class="keyword">if</span>(grid[rows-<span class="number">1</span>-j][i] == <span class="string">'E'</span>)&#123; downsum++; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</div><div class="line">                maxnum = Math.max(maxnum,left[i][j] + right[i][j] + up[i][j] + down[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxnum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="例题6-N个数组的第K大问题"><a href="#例题6-N个数组的第K大问题" class="headerlink" title="例题6. N个数组的第K大问题"></a>例题6. N个数组的第K大问题</h2><p>在N个数组中找到第K大的元素</p><p>排序+heap</p><p>类似merge K sorted list</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://omaby2s5z.bkt.clouddn.com/2018-02
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】线段树</title>
    <link href="http://yoursite.com/2018/02/08/%E3%80%90leetcode%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2018/02/08/【leetcode】线段树/</id>
    <published>2018-02-08T14:27:03.000Z</published>
    <updated>2018-02-11T13:34:17.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线段树入门"><a href="#1-线段树入门" class="headerlink" title="1. 线段树入门"></a>1. 线段树入门</h1><p>本文主要参考自<a href="https://jiayi797.github.io/2018/01/23/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="external">jiayi797的专栏</a> 、 <a href="http://www.cnblogs.com/TenosDoIt/" target="_blank" rel="external">JustDoIT</a> 和 <a href="https://www.jiuzhang.com/article/kSiBNt/" target="_blank" rel="external">线段树知识点总结</a></p><p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。</p><p>线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]。线段树形如：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-18-59-58.png" alt="img"></a></p><p>下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0…n-1]中查找某个数组某个区间内的最大值，其中数组大小固定，但是数组中的元素的值可以随时更新。从这题可以看出：区间(a,b)的最大值和区间(b,c)的最大值中，取较大的就是区间(a,c)的最大值。很明显这个操作具有区间的性质。</p><p>我们可以用线段树来解决这个区间最大值问题。根据这个问题我们构造如下的二叉线段树。区间的第三维就是区间的最大值。</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-19-01-44.png" alt="img"></a></p><p>加入第三维的时候，只需要在构建完左右区间后，根据左右区间的最大值更新当前区间最大值即可。</p><p>因为每次将区间长度一分为二，所有构造的节点个数为：</p><p>n + 1/2 <em>n + 1/4 </em>n + 1/8 * n + …</p><p>= (1 + 1/2 + 1/4 + 1/8 + …) * n</p><p>= 2n</p><p>所以构造线段树的时空复杂度都为O(n)。</p><h2 id="1-1-线段树常见题型"><a href="#1-1-线段树常见题型" class="headerlink" title="1.1. 线段树常见题型"></a>1.1. 线段树常见题型</h2><p>一道题可不可以用线段树来做，基本是看这道题的操作有没有<strong>区间的性质</strong>。也就是在一个区间上的操作是否可以转化为两个子区间上的操作。</p><ul><li>求区间和，积，最小值，gcd等</li><li>以当前节点的值作为节点处理。例如给出N个数字，再给一个数，问比这个数大的有多少个。</li><li>区间加减同一个值，或者区间同时赋一个值。</li></ul><h2 id="1-2-链式线段树"><a href="#1-2-链式线段树" class="headerlink" title="1.2. 链式线段树"></a>1.2. 链式线段树</h2><p>我们常见的二叉树都是链式结构。因此我们先完成链式的线段树。</p><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>复杂度O(n)</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</div><div class="line">    <span class="comment">//线段树节点定义</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        <span class="keyword">int</span> max;</div><div class="line">        SegmentTreeNode left = <span class="keyword">null</span>;<span class="comment">//定义左右节点</span></div><div class="line">        SegmentTreeNode right = <span class="keyword">null</span>;</div><div class="line">        SegmentTreeNode(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> max)&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">builder</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,A.length-<span class="number">1</span>,A);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SegmentTreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (low &gt; high)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        SegmentTreeNode root = <span class="keyword">new</span> SegmentTreeNode(low,high,A[low]);</div><div class="line">        <span class="keyword">if</span>(low == high)&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            root.left = helper(low,high/<span class="number">2</span>,A);</div><div class="line">            root.left = helper(high/<span class="number">2</span>+<span class="number">1</span>,high,A);</div><div class="line">            root.max = Math.max(root.left.max,root.right.max);<span class="comment">//更新当前节点max值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>复杂度 O(log(n))O(log(n))</p><p>构造线段树目的是为了更快地查询。例如给定区间，要求区间中的最大值。而线段树的区间查询操作就是将当前区间分解为较小的子区间，然后由子区间的最大值就可以快速得到需要查询区间的最大值。例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">query(1,3) = max(query(1,1), query(2,3)) = max(4,3) = 4</div></pre></td></tr></table></figure><p>查询实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在线段树中查找[low,high]区间的最大值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.start == low &amp;&amp; root.end == high)&#123;</div><div class="line">        <span class="keyword">return</span> root.max;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">if</span>(mid &gt;= low)&#123;<span class="comment">//查询区间与左半区间有交集，最大值有可能在左半区间</span></div><div class="line">        result = Math.max(result,query(root.left,low,mid));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= high)&#123; <span class="comment">//查询区间与右半区间有交集，最大值有可能在右半区间</span></div><div class="line">        result = Math.max(result,query(root.right,mid+<span class="number">1</span>,high));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><p>复杂度 O(log(n))O(log(n))</p><p>更新序列中的一个节点，那么如何把这种变化体现到线段树中呢？</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-15-07.png" alt="img"></a></p><p>例如要将第4个点更新为5.就要变动3个区间的值，分别为[3,3], [2,3], [0,3]</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-23-20-16-03.png" alt="img"></a></p><p>改动一个节点，与这个节点对应的叶子结点都要变动。并且，这个节点变动后，这个节点的属性值也有可能会变动，那么就有可能影响到这个节点的父亲节点的属性值（例如可能影响到最大值）。所以需要从叶子节点一路走到根节点。</p><p>单点更新实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(SegmentTreeNode root,<span class="keyword">int</span> idx,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="comment">////如果找到相应叶子节点了</span></div><div class="line">    <span class="keyword">if</span>(root.start == root.end &amp;&amp; root.start == idx)&#123;</div><div class="line">        root.max = val;<span class="comment">//修改max值</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (root.start + root.end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(idx &lt;= mid)&#123;<span class="comment">//要修改的在左边</span></div><div class="line">        modify(root.left,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        modify(root.right,idx,val);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//跟新root的max</span></div><div class="line">    root.max = Math.max(root.left.max,root.right.max);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-线段树入门&quot;&gt;&lt;a href=&quot;#1-线段树入门&quot; class=&quot;headerlink&quot; title=&quot;1. 线段树入门&quot;&gt;&lt;/a&gt;1. 线段树入门&lt;/h1&gt;&lt;p&gt;本文主要参考自&lt;a href=&quot;https://jiayi797.github.io/2018/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计数排序、基数排序、桶排序</title>
    <link href="http://yoursite.com/2018/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/02/08/计数排序、基数排序、桶排序/</id>
    <published>2018-02-08T07:03:21.000Z</published>
    <updated>2018-02-11T13:34:17.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为比较排序。</p><p>可以证明，基于比较的排序算法在最坏情况下的时间下界是Ω(nlgn)。堆排序和归并排序的运行时间上界为O(nlgn)，因此这两种排序算法都是渐进最优的比较排序算法。</p><p>而<strong>非基于比较的排序</strong>，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限，达到线性时间复杂度<script type="math/tex">O(n)</script>。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p><p>基数排序：O(dn) (d次调用桶排序)，空间复杂度 O(k) </p><p>桶排序：O(n)时间复杂度，O(n)空间复杂度</p><p>计数排序：O(n)时间复杂度，O(k)空间复杂度，每一个元素都是整数，并且位于0到k - 1之间</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)。</p><p>计数排序的思想是，对每一个输入元素，计算小于它的元素个数，如果有10个元素小于它，那么它就应该放在11的位置上，如果有17个元素小于它，它就应该放在18的位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。下图展示了实际的运行过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1186132-945c959a74a71c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/597" alt="img"></p><p>计数排序</p><p>构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，得到图(a)的结果。然后把C中每个元素变成前面所有元素的累加和，得到图(b)的结果。接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到B中的位置，即是该元素排序后的位置。例如，图中A的最后一个元素是3，找到C[3]是7，再令B[7]=3即可，然后顺便把C[3]减一，这是防止相同的数被放到同一个位置。</p><p>计数排序的时间代价可以这样计算，第一次遍历A并计算C所花时间是Θ(n)，C累加所花时间是Θ(k)，再次遍历A并给B赋值所花时间是Θ(n)，因此，总时间为Θ(k + n)。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>对于一组数据，我们可以按照每一位对它们进行排序。比如，考虑下面一组十进制数</p><blockquote><p>329<br>457<br>839<br>355</p></blockquote><p>先按最后一位从小到大排序，得到</p><blockquote><p>35<strong>5</strong><br>45<strong>7</strong><br>32<strong>9</strong><br>83<strong>9</strong></p></blockquote><p>再按中间一位从小到大排序，得到</p><blockquote><p>3<strong>2</strong>9<br>8<strong>3</strong>9<br>3<strong>5</strong>5<br>4<strong>5</strong>7</p></blockquote><p>最后按第一位从小到大排序，得到</p><blockquote><p><strong>3</strong>29<br><strong>3</strong>55<br><strong>4</strong>57<br><strong>8</strong>39</p></blockquote><p>其中，对任何一位的排序算法必须是稳定的，即相同数字不能改变它们的前后顺序。</p><p>基数排序算法的运行时间很容易计算，对于n个k进制d位数，假如每一位的排序使用计数排序算法，则该位排序用时为Θ(n + k)，总共d位数，总排序用时就是Θ(d(n + k))。当d为常数且k=O(n)时，总排序时间为Θ(n)。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p><p>我们将[0,1)区间划分为n个相同大小的子区间，称为桶。然后将输入数据分别放到各个桶中。如果数据分布得很均匀，每个桶中的数据就不会太多，都会维持在常数量级。我们先对每个桶中的元素排序，然后把所有桶中的元素顺序列出来即可。下图为n=10的一个案例。</p><p><img src="http://upload-images.jianshu.io/upload_images/1186132-1ea2b9a00e9dbeb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675" alt="img"></p><p>桶排序.png</p><p>创建一个长度也为10的数组，将A中的元素按照大小找到B中合适的位置，插入链表。之后，分别对B中每个链表中的元素执行插入排序。最后将B中的所有元素依次取出即可。</p><p>现在分析桶排序的时间代价。将A中元素放入B用时Θ(n)，B中每个链表执行插入排序的用时，可以证明是O(2 - 1/n)，于是总用时就是Θ(n) + n * O(2 - 1/n) = Θ(n)。具体证明过程比较难理解，这里我想给出一个容易理解的解释，虽然不一定对，但还是可以帮助理解为什么总用时是Θ(n)。n个数放入n个桶，平均下来每个桶只有一个数，在实际中，可能有的多有的少，但都不会差得太离谱。因此我们可以认为每个桶中只有常数个数，那么对常数个数执行插入排序所用的时间当然也就是O(1)了。于是n个桶总用时就是O(n)，加上前面的Θ(n)，桶排序总用时就是Θ(n)了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非比较排序&quot;&gt;&lt;a href=&quot;#非比较排序&quot; class=&quot;headerlink&quot; title=&quot;非比较排序&quot;&gt;&lt;/a&gt;非比较排序&lt;/h2&gt;&lt;p&gt;插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的
      
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/02/08/%E3%80%90leetcode%E3%80%91sort/"/>
    <id>http://yoursite.com/2018/02/08/【leetcode】sort/</id>
    <published>2018-02-08T05:38:35.636Z</published>
    <updated>2018-02-11T13:34:17.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr><p>title: 【leetcode】sort<br>date: 2018-02-08 13:38:35<br>tags:</p><h2 id="categories"><a href="#categories" class="headerlink" title="categories:"></a>categories:</h2></blockquote><p>leetcode 排序相关问题</p><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a><a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="external">Largest Number</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p></blockquote><p>给定数组返回由该数组构成的最大数字，返回string类型</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先把数字转化成字符串，然后按字符串顺序排序，这里有一个小技巧，判断字符串s1和s2谁应该放在前面时，比较s1+s2和s2+s1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Comparator&lt;String&gt; cmp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</div><div class="line">                String s1 = o1+o2;</div><div class="line">                String s2 = o2+o1;</div><div class="line">                <span class="keyword">return</span> s2.compareTo(s1);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            strs[i] = String.valueOf(nums[i]);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(strs,cmp);</div><div class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</div><div class="line">            sb.append(strs[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a><a href="https://leetcode.com/problems/maximum-gap/" target="_blank" rel="external">Maximum Gap</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Try to solve it in linear time/space.</p><p>Return 0 if the array contains less than 2 elements.</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p></blockquote><p>给定一个无序数组，返回数组中相邻元素（排序后）之差的最大值</p><p>复杂度要求：线性时间复杂度</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：排序，计算相邻元素最大值，时间复杂度<script type="math/tex">O(nlogn)</script></p><p>优化：桶排序</p><ol><li>确定数组中最大和最小元素max和min，数组中元素个数N</li><li>这N个数字的平均间隔为：avg = (max-min)/(N-1)，maxGap &gt;= avg，所以我们令桶的大小int <code>bucketSize = Math.max(1,(max - min) / (N-1));</code> 这样每一个桶内，元素的差值不会超过avg了，那么相邻元素之间的最大间隔一定在桶之间。</li><li>根据桶的大小，可以计算出桶的个数为<code>int bucketNum = (max - min)/bucketSize + 1;</code> ,</li><li>遍历数组中的元素，将元素放入对应的桶中，并维护每个桶的最大值和最小值</li><li>计算相邻桶的最小值和最大值的差，遇到桶中没有元素的跳过，取最大的差值即为所求。</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> N = nums.length;</div><div class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(N == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Math.abs(nums[<span class="number">0</span>] - nums[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//查找nums中最大和最小值</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</div><div class="line">            min = Math.min(min,num);</div><div class="line">            max = Math.max(max,num);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//maxGap &gt; avg = (max-min)/(N-1);bucketSize = floor(max-min)/(N-1);</span></div><div class="line">        <span class="keyword">int</span> bucketSize = Math.max(<span class="number">1</span>,(max - min) / (N-<span class="number">1</span>));<span class="comment">//桶大小</span></div><div class="line">        <span class="comment">//bucketNum = ceil (max-min)/bucketSize</span></div><div class="line">        <span class="keyword">int</span> bucketNum = (max - min)/bucketSize + <span class="number">1</span>;<span class="comment">//桶个数</span></div><div class="line"></div><div class="line">        <span class="comment">//用于记录每个bucket中的最大和最小值</span></div><div class="line">        <span class="keyword">int</span>[] bucketMin = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMin[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] bucketMax = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            bucketMax[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[(nums[i]-min)/bucketSize] == -<span class="number">1</span>)&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; bucketMin[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMin[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; bucketMax[(nums[i]-min)/bucketSize])&#123;</div><div class="line">                bucketMax[(nums[i]-min)/bucketSize] = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lastMax =  bucketMax[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; bucketNum;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(bucketMin[i] == -<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            maxGap = Math.max(maxGap,bucketMin[i] - lastMax);</div><div class="line">            lastMax = bucketMax[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxGap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="external">Best Meeting Point</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="external">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 - 0 - 0 - 0 - 1</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 0 - 0 - 0</div><div class="line">&gt; |   |   |   |   |</div><div class="line">&gt; 0 - 0 - 1 - 0 - 0</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p></blockquote><p>给定二维数组，1代表n个人的出发地，0代表其余地点，找到数组中的一个位置，使得大家到这个地点的曼哈顿距离之和最短，返回最短距离</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>只想到了暴力的思路。。。</p><p>看了solution，需要从一维的入手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Case #1: 1-0-0-0-1</div><div class="line">Case #2: 0-1-0-1-0</div><div class="line">Case #3: 1-0-0-0-0-0-0-1-1</div><div class="line">Case #4: 1-1-0-0-1</div></pre></td></tr></table></figure><p>给了这么几个例子，说明到所有点最短的距离就是中位数的点。</p><p>所以扩展到二维，到所有点距离最短的点就是所有点分别在x轴和y轴中位数的点。</p><p>因此可以遍历所有的点，记录是1的点的xy坐标，然后分别对xy坐标排序，取中位数的点，即为要求的点，再计算下距离就好。</p><p>优化：</p><p>可以把横纵坐标分离计算，按需加入list,这样就不需要排序了,直接取中位数位置的点</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestMeetingPoint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;grid[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</div><div class="line">                    rows.add(i);</div><div class="line">                    cols.add(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = rows.size()/<span class="number">2</span>;</div><div class="line">        Collections.sort(rows);</div><div class="line">        Collections.sort(cols);</div><div class="line">        <span class="keyword">int</span> x = rows.get(num);</div><div class="line">        <span class="keyword">int</span> y = cols.get(num);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows.size();i++)&#123;</div><div class="line">            result += Math.abs(x- rows.get(i));</div><div class="line">            result += Math.abs(y- cols.get(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="external">Insert Interval</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p><p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p><p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p></blockquote><p>给定区间数组，区间之间没有overlap，又给定一个独立区间，将该独立区间加到数组的区间里，如有overlap将区间merge,返回加入独立区间后的数组</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>遍历数组中的区间，当数组中的区间和独立区间还没有交集（intervals.get(i).end &lt; newInterval.start）的时候，将这些区间原封不动放入result中</li><li>将区间start和end初始化为newInterval的start和end</li><li>继续遍历数组中的区间，直至intervals.get(i).start &gt; newInterval.end,也就是和独立区间不相交了，在此期间，更新数组的上下边界</li><li>将更新好的区间加入结果</li><li>将剩余区间加入结果</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertInterval</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start)&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i == intervals.size())&#123;</div><div class="line">            res.add(newInterval);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = newInterval.start;</div><div class="line">        <span class="keyword">int</span> end = newInterval.end;</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end)&#123;</div><div class="line">            start = Math.min(start,intervals.get(i).start);</div><div class="line">            end = Math.max(end,intervals.get(i).end);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        res.add(<span class="keyword">new</span> Interval(start,end));</div><div class="line">        <span class="keyword">while</span>(i &lt; intervals.size())&#123;</div><div class="line">            res.add(intervals.get(i));</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a><a href="https://leetcode.com/problems/h-index/" target="_blank" rel="external">H-Index</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;hr&gt;
&lt;p&gt;title: 【leetcode】sort&lt;br&gt;date: 2018-02-08 13:38:35&lt;br&gt;tags:&lt;/p&gt;
&lt;h2 id=&quot;categories&quot;&gt;&lt;a href=&quot;#categories&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法强化班】两指针</title>
    <link href="http://yoursite.com/2018/02/02/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%BC%BA%E5%8C%96%E7%8F%AD%E3%80%91%E4%B8%A4%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/02/02/【九章算法强化班】两指针/</id>
    <published>2018-02-02T04:31:57.000Z</published>
    <updated>2018-02-08T07:05:26.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol><li>一个数组，从两边往中间移动（对撞型）</li><li>一个数组，同时向前移动（前向型）</li><li>两个数组两根指针（并行型）</li></ol><h2 id="1-对撞型或相会型"><a href="#1-对撞型或相会型" class="headerlink" title="1.对撞型或相会型"></a>1.对撞型或相会型</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-12-41-27.png" alt=""> </p><h3 id="leetcode-11-Container-With-Most-Water"><a href="#leetcode-11-Container-With-Most-Water" class="headerlink" title="leetcode 11.Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">leetcode 11.Container With Most Water</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>灌水问题，从两边向内灌水，所以初始两个指针ij一头一尾，此时能够容纳的水量是i和j中比较高度的柱子高度*ij两个柱子之间的距离：</p><p>max(height[i] , height[j]) * (j - i)</p><p>然后考虑将柱子向内移动，其实我们只需要移动比较矮的柱子，因为如果移动长的一边的柱子，根据上面的公式，j-i会变短，max(height[i] , height[j])可能变小可能不变，所以总的水量不会增加，所以我们只有移动短的柱子，才有可能会遇到更高的柱子，使得水量增大。</p><p>这样一来，每次选取较短的柱子向内移动，时间复杂度为<script type="math/tex">O(n)</script></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">                max = Math.max(max,(j-i) *height[i]);</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max,(j-i) * height[j]);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Quick-select-—-Kth-Largest-Element-in-an-Array"><a href="#Quick-select-—-Kth-Largest-Element-in-an-Array" class="headerlink" title="Quick select — Kth Largest Element in an Array"></a>Quick select — <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p></blockquote><p>在一组数字中找到第K大的数字</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一：可以用堆，维护一个大小为K的堆，将数字依次加入堆，找到第k大，时间复杂度<script type="math/tex">O(nlogk)</script></p><p>方法二：quick select，基于quick sort的思想</p><ol><li>每次在数组中随机选取一个数组作为pivort，这里面随机选取，经过大量的验证，选取中间位置的数字作为pivot比较稳妥。</li><li>然后和快排一样，将比它小的放在它左边，比它大的放在右边，找到pivot的位置即是pivot的最终位置。<ol><li>如果此时pivot的位置==k-1，找到了</li><li>如果此时pivot的位置 &gt;k-1，只需在pivot左边寻找第k大</li><li>如果此时pivot的位置 &lt;k-1，只需在pivot右边寻找第k-pivot大</li></ol></li></ol><p>这种方法的时间复杂度为<script type="math/tex">O(n)+O(n/2)+O(n/4)+...+O(1) = O(2n) = O(n)</script></p><p>两种方法的比较：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-15-34-03.png" alt=""> </p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> pivotIdx = start+(end-start)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> pivot = nums[pivotIdx];</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        swap(nums,i,pivotIdx);<span class="comment">//把pivot交换至数组头</span></div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= pivot)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            nums[i] = nums[j];</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= pivot)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            nums[j] = nums[i];</div><div class="line">        &#125;</div><div class="line">        nums[j] = pivot;</div><div class="line">        <span class="keyword">if</span>((j - start) == k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> pivot;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((j - start) &gt; k-<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,start,j-<span class="number">1</span>,k);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> partition(nums,j+<span class="number">1</span>,end,k-j+start-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> partition(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-16-57-31.png" alt=""> </p><h3 id="lintcode-399-Nuts-amp-Bolts-Problem"><a href="#lintcode-399-Nuts-amp-Bolts-Problem" class="headerlink" title="lintcode 399.Nuts &amp; Bolts Problem"></a><a href="https://www.lintcode.com/en/problem/nuts-bolts-problem/" target="_blank" rel="external">lintcode 399.Nuts &amp; Bolts Problem</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts。nuts 和 bolts 一一匹配。 不允许将 nut 之间互相比较，也不允许将 bolt 之间互相比较。也就是说，只许将 nut 与 bolt 进行比较， 或将 bolt 与 nut 进行比较。请比较 nut 与 bolt 的大小</p><p>样例</p><p>给出 nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;GG&#39;, &#39;DD&#39;, &#39;BC&#39;]</code><br>你的程序应该找出bolts和nuts的匹配。<br>一组可能的返回结果是：<br>nuts = <code>[&#39;ab&#39;,&#39;bc&#39;,&#39;dd&#39;,&#39;gg&#39;]</code>, bolts = <code>[&#39;AB&#39;,&#39;BC&#39;,&#39;DD&#39;,&#39;GG&#39;]</code></p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>因为nuts和bolts两个数组在各自的内部不能互相比较，只能在两个数组之间的元素进行比较。所以这就需要利用一个array中的元素对另一个array进行partition，并反过来重复这一个过程，最终让两个array都满足comparator所定义的相同顺序。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * public class NBCompare &#123;</span></div><div class="line"><span class="comment"> *     public int cmp(String a, String b);</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> * You can use compare.cmp(a, b) to compare nuts "a" and bolts "b",</span></div><div class="line"><span class="comment"> * if "a" is bigger than "b", it will return 1, else if they are equal,</span></div><div class="line"><span class="comment"> * it will return 0, else if "a" is smaller than "b", it will return -1.</span></div><div class="line"><span class="comment"> * When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> nuts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> bolts: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> compare: a instance of Comparator</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: nothing</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(String[] nuts,String[] bolts,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</div><div class="line">         <span class="comment">//选取bolts中的第一个元素作为pivot，计算在nuts中对应的元素的位置</span></div><div class="line">         <span class="keyword">int</span> nuts_pivotidx = partition(nuts,bolts[start],compare,start,end);</div><div class="line">         <span class="comment">//利用nuts中的pivot对bolts中元素排序</span></div><div class="line">         partition(bolts,nuts[nuts_pivotidx],compare,start,end);</div><div class="line">         <span class="comment">//对picot左边右边分别排序</span></div><div class="line">         quicksort(nuts, bolts, compare, start, nuts_pivotidx - <span class="number">1</span>);</div><div class="line">         quicksort(nuts, bolts, compare, nuts_pivotidx + <span class="number">1</span>, end);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//输入nuts和bolts中的pivot,对nuts排序，返回对应元素的位置</span></div><div class="line">     <span class="comment">//输入bolts和nuts中的pivot,对bolts排序，返回对应元素的位置</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String[] str,String pivot,NBComparator compare,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">         <span class="comment">//在另一个数组中找到对应的螺丝或者螺母</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">             <span class="keyword">if</span>(compare.cmp(str[i],pivot) == <span class="number">0</span> || </div><div class="line">             compare.cmp(pivot,str[i]) == <span class="number">0</span>)&#123;</div><div class="line">                 swap(str,i,start);</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//快速排序</span></div><div class="line">         String pivotTemp = str[start];</div><div class="line">         <span class="keyword">int</span> left = start;</div><div class="line">         <span class="keyword">int</span> right = end;</div><div class="line">         <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == -<span class="number">1</span> || </div><div class="line">            compare.cmp(pivot,str[right]) == <span class="number">1</span>))&#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            str[left] = str[right];</div><div class="line">             <span class="keyword">while</span>(left &lt; end &amp;&amp; (compare.cmp(str[right], pivot) == <span class="number">1</span> || </div><div class="line">            compare.cmp(pivot, str[right]) == -<span class="number">1</span>))&#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            str[right] = str[left];</div><div class="line">        &#125;</div><div class="line">        str[left] = pivotTemp;    </div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//交换元素</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] strings,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">         String temp = strings[i];</div><div class="line">         strings[i] = strings[j];</div><div class="line">         strings[j] = temp;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortNutsAndBolts</span><span class="params">(String[] nuts, String[] bolts, NBComparator compare)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">if</span>(nuts == <span class="keyword">null</span> || bolts == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(nuts.length != bolts.length) <span class="keyword">return</span>;</div><div class="line">        quicksort(nuts,bolts,compare,<span class="number">0</span>,nuts.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="2-窗口类"><a href="#2-窗口类" class="headerlink" title="2.窗口类"></a>2.窗口类</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-02-21-47-48.png" alt=""> </p><h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p></blockquote><p>返回数组中元素和&gt;=s的最长子数组的长度</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>两指针控制滑动窗口类问题，当窗口内元素和&lt;s时右指针向右滑动，更新最大长度</p><p>当窗口内元素和&gt;=s时，左指针向右滑动至&lt;s，无需更新最大长度</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++)&#123;</div><div class="line">            sum += nums[j];</div><div class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</div><div class="line">                minLen = Math.min(minLen,j-i+<span class="number">1</span>);</div><div class="line">                sum -= nums[i];</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE?<span class="number">0</span>:minLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p></blockquote><p>查找字符串中没有重复元素的最长子串</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>记录窗口中出现过哪些字母，当遇到重复字母的时候窗口缩小</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//相当于hashmap</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt; s.length())&#123;</div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)] == <span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)] = <span class="number">1</span>;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//map[s.charAt(j)] == 1</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">while</span>(s.charAt(j) != s.charAt(i))&#123;</div><div class="line">                    map[s.charAt(i)] = <span class="number">0</span>;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring" target="_blank" rel="external">Minimum Window Substring</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<br><strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><br><strong>T</strong> = <code>&quot;ABC&quot;</code></p><p>Minimum window is <code>&quot;BANC&quot;</code>.</p></blockquote><p>返回s中能够包含t的最短子串</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>滑动窗口+hashtable的思想</p><p>首先需要两个hash表，一个存储t中的字母，一个存储s中子串的字母，还需要一个能够判别s中的子串是否能够包含t的函数。</p><p>然后两指针滑动窗口，右指针向右滑动，当滑窗中的子串能够包含t时，窗口缩小，左指针右移，更新最短窗口，直到窗口内子串不足以包含t中全部字母，此时右指针继续向后移动，重复上述过程。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//判断s是否包含t</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(<span class="keyword">int</span>[] mapT,<span class="keyword">int</span>[] mapS)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mapT.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(mapS[i] &lt; mapT[i])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] mapT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span>[] mapS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        StringBuilder minWindow = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : t.toCharArray())&#123;</div><div class="line">            mapT[ch]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++) &#123;</div><div class="line">            mapS[s.charAt(j)]++;</div><div class="line">            <span class="keyword">while</span>(isContain(mapT,mapS))&#123;</div><div class="line">                <span class="keyword">if</span>(minlen &gt; j-i+<span class="number">1</span>)&#123;</div><div class="line">                    minlen = j-i+<span class="number">1</span>;</div><div class="line">                    minWindow = <span class="keyword">new</span> StringBuilder(s.substring(i,j+<span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">                mapS[s.charAt(i)]--;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen == Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minWindow.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="Longest Substring with At Most K Distinct Characters"></a><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="external">Longest Substring with At Most K Distinct Characters</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the longest substring T that contains at most <em>k</em> distinct characters.</p><p>For example, Given s = <code>“eceba”</code> and k = 2,</p><p>T is “ece” which its length is 3.</p></blockquote><p>在字符串中找到一个子串，最多包含k个不同的字母，返回满足这样条件的子串的最大长度。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>还是滑窗+hash表</p><p>用hash表存储当前子串中字母，用charNum存储子串中的不同字母个数</p><ol><li>当窗口内字母个数&lt;=k时右指针向右滑动，扩大窗口，更新窗口大小</li><li>当窗口内字母个数&gt;k时，左指针右移，缩小窗口，</li></ol><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span> charNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s.length();j++)&#123;</div><div class="line">            <span class="comment">//之前已经出现过这个字母了</span></div><div class="line">            <span class="keyword">if</span>(map[s.charAt(j)]&gt;<span class="number">0</span>)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数&lt;k</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (charNum &lt; k)&#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                maxlen = Math.max(maxlen,j-i+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//之前没出现过这个字母,但出现的字母数==k</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map[s.charAt(j)]++;</div><div class="line">                charNum++;</div><div class="line">                <span class="keyword">while</span>(charNum &gt; k)&#123;</div><div class="line">                    <span class="keyword">if</span>(map[s.charAt(i)] == <span class="number">1</span>)&#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                        charNum--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        map[s.charAt(i)]--;</div><div class="line">                    &#125;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="两个数组两个指针"><a href="#两个数组两个指针" class="headerlink" title="两个数组两个指针"></a>两个数组两个指针</h2><h3 id="最小差"><a href="#最小差" class="headerlink" title="最小差"></a><a href="http://www.lintcode.com/zh-cn/problem/the-smallest-difference/" target="_blank" rel="external">最小差</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定两个整数数组（第一个是数组 <code>A</code>，第二个是数组 <code>B</code>），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。</p><p>样例</p><p>给定数组 A = <code>[3,4,6,7]</code>， B = <code>[2,3,8,9]</code>，返回 <code>0</code>。</p></blockquote><p>给定两个数组，返回两个数组元素之间的最小差</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>baseline:双层for循环，A中循环一遍B中循环一遍，计算每两个元素之间的差值取最小，时间复杂度：<script type="math/tex">O(n^2)</script></p><p>优化：</p><p>先排序，排序之后遍历A中元素，用二分查找的思路在B中寻找与元素A[i]差值最小的元素，时间复杂度：<script type="math/tex">O(nlogn)</script></p><p>骚操作：</p><p>两指针ij分别指向AB，更新A[i]和B[j]的差值</p><p>当A[i]&lt;B[j]时，i后移，反之j后移</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    Arrays.sort(A);</div><div class="line">    Arrays.sort(B);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</div><div class="line">        min = Math.min(min,Math.abs(A[i]-B[j]));</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; B[j])&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Smallest-Range"><a href="#Smallest-Range" class="headerlink" title="Smallest Range"></a><a href="https://leetcode.com/problems/smallest-range/" target="_blank" rel="external">Smallest Range</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You have <code>k</code> lists of sorted integers in ascending order. Find the <strong>smallest</strong> range that includes at least one number from each of the <code>k</code> lists.</p><p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</div><div class="line">&gt; Output: [20,24]</div><div class="line">&gt; Explanation: </div><div class="line">&gt; List 1: [4, 10, 15, 24,26], 24 is in range [20,24].</div><div class="line">&gt; List 2: [0, 9, 12, 20], 20 is in range [20,24].</div><div class="line">&gt; List 3: [5, 18, 22, 30], 22 is in range [20,24].</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定k个数组，找到最短的区间，该区间需满足包含来自每个数组的至少一个元素</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>k个数组k个指针，k个指针中的最大最小即是当前情况下的区间。</p><p>每次将值最小的指针向后移动，更新当前情况下的区间长度。</p><p>这里就需要找到哪个指针所指的值是最小的了，所以我们需要一个最小堆来维护k个指针中的最小值。</p><p>另外，我们还需要计算k个指针中的最大值，这个最大值用一个变量max维护就可以了，每次入堆的元素都跟当前max比较更新一下就好。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallestRange</span> </span>&#123;</div><div class="line">  <span class="comment">//定义结构Node，存储节所在的数组idx和值</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];<span class="comment">//代表指针指向每一个数组</span></div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; minheap= <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);<span class="comment">//最小堆</span></div><div class="line">        <span class="keyword">int</span> max  = Integer.MIN_VALUE;<span class="comment">//存储当前遇到的最大值</span></div><div class="line">        <span class="keyword">int</span> minRangeLen = Integer.MAX_VALUE;<span class="comment">//存储最小区间的长读</span></div><div class="line">        <span class="keyword">int</span>[] minRange = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//存储最小区间</span></div><div class="line">        <span class="comment">//先把所有list第一个元素先入堆，同时记录最大值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; idx.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> val = nums.get(i).get(idx[i]);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(i,val));</div><div class="line">            max = Math.max(max,val);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//出堆</span></div><div class="line">        <span class="keyword">while</span> (!minheap.isEmpty())&#123;</div><div class="line">            <span class="comment">//取堆顶元素</span></div><div class="line">            Node temp = minheap.poll();</div><div class="line">            <span class="comment">//更新当前最小区间的长度</span></div><div class="line">            <span class="keyword">if</span>(max-temp.val &lt; minRangeLen)&#123;</div><div class="line">                minRangeLen = max-temp.val;</div><div class="line">                minRange[<span class="number">0</span>] = temp.val;</div><div class="line">                minRange[<span class="number">1</span>] = max;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//堆顶元素所在的区间指针后移一位</span></div><div class="line">            idx[temp.idx]++;</div><div class="line">            <span class="comment">//如果对顶元素所在的区间指针溢出了，跳出</span></div><div class="line">            <span class="keyword">if</span>(idx[temp.idx] == nums.get(temp.idx).size())&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//找到下一个值，更新max，入堆</span></div><div class="line">            <span class="keyword">int</span> nextval = nums.get(temp.idx).get(idx[temp.idx]);</div><div class="line">            max = Math.max(max,nextval);</div><div class="line">            minheap.add(<span class="keyword">new</span> Node(temp.idx,nextval));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minRange;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Partition-Labels"><a href="#Partition-Labels" class="headerlink" title="Partition Labels"></a><a href="https://leetcode.com/problems/partition-labels/" target="_blank" rel="external">Partition Labels</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">&gt; Output: [9,7,8]</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</div><div class="line">&gt; This is a partition so that each letter appears in at most one part.</div><div class="line">&gt; A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个字符串，要求将字符串分割，保证每个字母只出现在一个子串中，最终返回分割的字符串长度</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">由于每个字母只能出现在一个字符串中，比如第一个字母a，其所在的子串至少要从第一个a到最后一个a。</div><div class="line">S = &quot;ababcbacadefegdehijhklij&quot;</div><div class="line">     ↑       ↑</div><div class="line">     i       maxRight</div><div class="line">但此时并不一定找到第一个合适的分割点了，因为在这两个a中其他字母，有可能出现在后半段中，所以我们还需要遍历这两个指针中间的字母，确定每一个字母在字符串中出现的最后位置，在这个过程中，前后两个指针的距离可能会变得更远，中间的每一个元素都需要遍历到。所以我们用maxRight来存储当前遍历过的字母的最远位置，则i的遍历区间应该是while (i &lt;= maxright)。</div></pre></td></tr></table></figure><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line">        <span class="keyword">int</span> maxright = i;<span class="comment">//初始化maxright</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= maxright)&#123;</div><div class="line">            <span class="keyword">char</span> ch = s.charAt(i);</div><div class="line">            <span class="keyword">while</span> (s.charAt(j) != ch)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//找到ch出现的最后一个位置</span></div><div class="line">            maxright = Math.max(maxright,j);<span class="comment">//更新最远距离</span></div><div class="line">            <span class="keyword">if</span>(i == maxright)&#123;<span class="comment">//找到了最后一个，跳出</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            j = end;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//更新结果集，继续分割右边</span></div><div class="line">        result.add(maxright-start+<span class="number">1</span>);</div><div class="line">        partition(s,maxright+<span class="number">1</span>,end);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</div><div class="line">        partition(S,<span class="number">0</span>,S.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;一个数组，从两边往中间移动（对撞型）&lt;/li&gt;
&lt;li&gt;一个数组，同时向前移动（前向型）
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2018/01/31/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/01/31/堆排序/</id>
    <published>2018-01-31T10:55:23.000Z</published>
    <updated>2018-01-31T10:55:23.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】从用户系统理解数据库和缓存</title>
    <link href="http://yoursite.com/2018/01/30/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BB%8E%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/01/30/【九章系统设计】从用户系统理解数据库和缓存/</id>
    <published>2018-01-30T15:49:17.000Z</published>
    <updated>2018-02-11T13:34:17.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ul><li>Design User System用户系统<ul><li>Mencached 优化数据库查询软件</li><li>Authentication 用户验证</li><li>SQL VS NoSQL 如何选取数据库</li><li>Friendship 存储好友关系（不用graph DB用什么）</li></ul></li><li>How to Scale?<ul><li>Sharding</li><li>Consistent Hashing(第5节)</li><li>Replica(第5节)</li></ul></li></ul><h1 id="4S分析法"><a href="#4S分析法" class="headerlink" title="4S分析法"></a>4S分析法</h1><ul><li><p>Scenario场景</p><ul><li><p>注册、登录、查询、用户修改信息</p><p>哪个需求量最大？查询最大，因为用户登录时给他展示的各种信息邓邓就是通过查询出来的结果</p></li><li><p>支持100M DAU(每日登录用户数)</p></li><li><p>注册，登录，信息修改QPS约：</p><ul><li>100M*0.1/86400 ~ 100</li><li>0.1=平均每个用户每天登陆+注册+信息修改</li><li>Peak = 100*3 = 300</li></ul></li><li><p>查询的QPS约为：</p><ul><li>100M*100/86400 ~ 100k</li><li>100 = 平均每个用户每天查询与用户信息相关的操作次数（查看好友、发信息，更新消息主页等）</li><li>Peak = 100k*3 = 300K</li></ul></li></ul></li><li><p>Service服务</p><ul><li>一个AuthService 负责登录注册</li><li>一个UserService 负责用户信息与存储</li><li>一个FriendshipService存储好友关系</li></ul></li><li><p>Storage:QPS与常用数据存储系统</p><ul><li>MySQL/PostgreSQL等数据库性能<ul><li>约1kQPS</li></ul></li><li>MongoDB/Cassandra等硬盘性NoSQL数据库<ul><li>约10QPS</li></ul></li><li>Redis/memcached等内存型NoSQL数据库性能<ul><li>100k~1mQPS</li></ul></li></ul></li><li><p>Scale</p><p>根据上面的QPS分析，注册、登录、信息修改300QPS，用mysql应该就够了</p><p>用户查询适合什么样的数据存储系统？</p></li></ul><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h1><h2 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1 Cache"></a>1.1 Cache</h2><p><strong>用户系统特点：读非常多，写非常少，一定要用Cache进行优化</strong></p><ul><li>Cache 是什么？<ul><li>缓存，把之后可能要查询的东西先存一下<ul><li>下次用的时候直接从这里拿，无需重新计算和存取数据库</li></ul></li><li>可以理解为一个Java中的HashMap</li><li>key-value的结构</li></ul></li><li>有哪些常用的Cache软件？<ul><li>memcached（不支持数据持久化）</li><li>Redis(支持数据持久化)</li></ul></li><li>Cache一定存在内存中么？<ul><li>不是</li><li>Cache是用于连接不同的介质，解决速度差异的问题</li><li>File System有时候也是一种cache</li><li>CPU也有Cache</li><li>内存是硬盘和CPU的cache</li></ul></li><li>Cache一定是Server Cache 么?<ul><li>不，浏览器也可能有客户端的cache</li></ul></li></ul><h2 id="1-2-Mem-Cache"><a href="#1-2-Mem-Cache" class="headerlink" title="1.2 Mem-Cache"></a>1.2 Mem-Cache</h2><p>内存中的Cache</p><p>Memcached：一个内存cache软件，就看成hashmap用</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-31-00-30-58.png" alt=""> </p><p>memcached如何优化DB的查询?</p><p>先去cache中查找，如果没有，再去DB中查找：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-23-56.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-28-05.png" alt=""> </p><p>分析：</p><p>我们认为database中的才是最正确的</p><p>A：database set时可能会出现问题，但没有太大问题，比如你发了一条微博，显示没成功。</p><p>但是如果database成功了，cache更新失败了，那么用户得到的数据都是更新之前的数据。</p><p>B：如果cache成功了，但是database没有成功，cache里存的不是database中的真正数据，看成脏数据。</p><p>C：如果cache delete成功了，但是database更新失败，没关系，还可以去database里面读取</p><p>D：如果database 修改成功了，但是cache失败了，此时用户从cache读取的就是之前的数据</p><p>相比之下C比较好，但是C也存在一定的问题：</p><p>比如第8行和第9行程序，如果我们刚刚获取了user但是这个时候有另一个进程修改了用户信息，此时再更新cache中的user信息就是旧数据了。</p><h2 id="1-3-Cache-Aside-和-Cache-Through"><a href="#1-3-Cache-Aside-和-Cache-Through" class="headerlink" title="1.3 Cache Aside 和 Cache Through"></a>1.3 Cache Aside 和 Cache Through</h2><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-21-40-11.png" alt=""> </p><p>前面代码中的例子就是Cache Aside，需要分别对Cache和DB进行操作，这样就会造成不同步的后果</p><h3 id="Cache-Through"><a href="#Cache-Through" class="headerlink" title="Cache Through"></a>Cache Through</h3><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-21-40-30.png" alt=""> </p><h1 id="2-Service-服务"><a href="#2-Service-服务" class="headerlink" title="2. Service 服务"></a>2. Service 服务</h1><h2 id="2-1-Authentication-Service"><a href="#2-1-Authentication-Service" class="headerlink" title="2.1. Authentication Service"></a>2.1. Authentication Service</h2><ul><li>如何实现用户登录和保持登录</li><li>会话表，session</li></ul><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-01-23-44-43.png" alt=""> </p><ul><li>用户Login之后<ul><li>创建一个session对象</li><li>并把seesion_key作为cookie返回给浏览器</li><li>浏览器将该值记录在浏览器的cookie中</li><li>用户每次想服务器发送的访问，都会自动带上该网站所有的cookie</li><li>此时服务器检测到cookie中的session_key是有效的，就认为用户登录了</li></ul></li><li>用户logout之后，从session table中删除对应的数据</li><li>Session table存在哪？<ul><li>数据库？</li><li>缓存？</li><li>都可以？</li><li>理论上都可以的，但是如果只存在cache中，一旦负责cache的机器宕机，就会有很多用户同时需要重新登录，所以存在数据库里更好一些，如果访问用户多的话，可以用cache做优化。</li></ul></li></ul><h2 id="2-2-Friendship-Service"><a href="#2-2-Friendship-Service" class="headerlink" title="2.2. Friendship Service"></a>2.2. Friendship Service</h2><h3 id="好友关系分类"><a href="#好友关系分类" class="headerlink" title="好友关系分类"></a>好友关系分类</h3><ul><li><p>单向好友关系（微博、twitter、Instagram）</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-19-50.png" alt=""> </p></li></ul><ul><li><p>双向好友关系（微信、Facebook）</p><ul><li><p>方案一：存为两条信息，A关注了B，B关注了A</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-31-39.png" alt=""> </p></li><li><p>方案二：存为一条信息，但查询的时候需要查询两次</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-34-58.png" alt=""> </p></li></ul></li><li><p>好友关系所涉及的操作非常简单，基本都是Key-value</p><ul><li>求某个user的所有关注对象</li><li>求某个user的所有粉丝</li><li>A关注B → 插入一条数据</li><li>B关注A → 删除一条数据</li></ul></li></ul><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3. 小结"></a>2.3. 小结</h2><ul><li>对于用户系统而言：<ul><li>写很少</li><li>读很多</li></ul></li><li>写操作很少，意味着<ul><li>从QPS角度来说，一台mysql就够了</li></ul></li><li>读操作很多，意味着<ul><li>可以使用memcached进行读操作的缓存优化</li></ul></li><li>进一步的问题，如果读写操作都很多怎么办？<ul><li>方法一：使用更多的数据库服务器分摊流量</li><li>方法二：使用像Redis这样的读写操作都很快的Cache-through型数据库<ul><li>Memcached是一个Cached-aside型的database,Client需要自己负责管理Cache-miss时的数据的loading</li></ul></li></ul></li></ul><h1 id="3-Storage-数据库的选取"><a href="#3-Storage-数据库的选取" class="headerlink" title="3. Storage 数据库的选取"></a>3. Storage 数据库的选取</h1><h2 id="3-1-数据库的选取原则SQL-vs-NoSQL"><a href="#3-1-数据库的选取原则SQL-vs-NoSQL" class="headerlink" title="3.1. 数据库的选取原则SQL vs NoSQL"></a>3.1. 数据库的选取原则SQL vs NoSQL</h2><ol><li><p>大部分情况用SQL和noSQL都可以</p></li><li><p>需要支持transaction的话不能选用NoSQL</p><p>什么是transaction？（交易）</p><p>transaction需要数据处理同时成立，比如在银行转账，A转给B10元，需要A-10和B+10同时成立</p></li><li><p>SQL型的数据库比较成熟，可以帮你做很多事，但是NoSQL很多事都要亲力亲为，比如序列化，多级索引</p></li><li><p>如果想省点服务器获得更高的性能，NoSQL更好，硬盘型的NoSQL比SQL一般要快10倍以上</p></li></ol><h2 id="3-2-好友关系的存储"><a href="#3-2-好友关系的存储" class="headerlink" title="3.2. 好友关系的存储"></a>3.2. 好友关系的存储</h2><ol><li><p>存在SQL</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-46-37.png" alt=""> </p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-48-30.png" alt=""> </p></li><li><p>存在NoSQL</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-10-22-46-59.png" alt=""> </p></li></ol><h2 id="3-3-以Cassandra为例剖析经典的NOSQL数据结构"><a href="#3-3-以Cassandra为例剖析经典的NOSQL数据结构" class="headerlink" title="3.3. 以Cassandra为例剖析经典的NOSQL数据结构"></a>3.3. 以Cassandra为例剖析经典的NOSQL数据结构</h2><h4 id="Cassandra是一个三层结构-三元组结构-的NoSQL数据库"><a href="#Cassandra是一个三层结构-三元组结构-的NoSQL数据库" class="headerlink" title="Cassandra是一个三层结构(三元组结构)的NoSQL数据库:"></a>Cassandra是一个三层结构(三元组结构)的NoSQL数据库:</h4><p><strong>插入数据：insert(row_key,column_key,value)</strong></p><ol><li>第一层：row_key<ul><li>又称为hash_key，cassandra会根据这个key计算一个hash值，然后决定这条数据存在哪</li><li>是传统我们所说的key-value中的key</li><li>任何查询都需要带上这个key，但无法进行range query</li><li>最常用的row_key:uer_id</li></ul></li><li>第二层：column_key<ul><li>是排序的，可以进行range query</li><li>可以按column指定顺序排序，支持按column范围查询query(row_key,column_start,column_end)</li><li>可以是复合值，比如是一个timestamp+user_id的组合</li></ul></li><li>第三层：value<ul><li>一般是string</li><li>如果需要存很多信息的话，可以自己做序列化</li></ul></li></ol><h4 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL  vs NoSQL"></a>SQL  vs NoSQL</h4><ul><li><p>SQL的一条数据以行为单位，取出整个row作为一条数据</p></li><li><p>SQL的column实在Schema中事先指定好的，不能随意添加。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-14-51-02.png" alt=""> </p></li><li><p>NoSQL的column是动态的，无限大，可以随意添加</p></li><li><p>一条数据以grid为单位，row_key + column_key + value = 一条数据</p></li><li><p>只需要提前定义好column_key本身的格式（是int还是int+string）</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-15-10-31.png" alt=""> </p></li></ul><h4 id="Cassandra存储friendship"><a href="#Cassandra存储friendship" class="headerlink" title="Cassandra存储friendship"></a>Cassandra存储friendship</h4><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-16-25-51.png" alt=""> </p><p> 重要的信息，需要频繁查的信息不能放在value中，要放在column_key中</p><h4 id="Cassandra存储NewsFeed"><a href="#Cassandra存储NewsFeed" class="headerlink" title="Cassandra存储NewsFeed"></a>Cassandra存储NewsFeed</h4><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-16-30-49.png" alt=""> </p><p>将create_time存在column_key中可以按时间排序</p><h1 id="4-How-to-scale-单点失效"><a href="#4-How-to-scale-单点失效" class="headerlink" title="4. How to scale? 单点失效"></a>4. How to scale? 单点失效</h1><p>100M用户存在一台mysql数据库存的下，Storage没问题</p><p>通过Cache优化读操作之后，只有300QPS的写，QPS也没有问题</p><p>还有什么问题？</p><p><strong>单点失效 Simgle Point Failure</strong></p><p>万一某一台数据库挂了，短暂的挂：网站不可用了，彻底挂了：数据全部丢失</p><p><strong>需要做sharding和Replica</strong></p><h2 id="4-1-Sharding-数据拆分"><a href="#4-1-Sharding-数据拆分" class="headerlink" title="4.1. Sharding 数据拆分"></a>4.1. Sharding 数据拆分</h2><ul><li>按照一定的规则，将数据拆分成不同的部分，保存在不同的机器上</li><li>这样就算某个机器挂了，也不会导致网站100%不可用。</li></ul><h3 id="4-1-1-Sharding-in-SQL-vs-NoSQL"><a href="#4-1-1-Sharding-in-SQL-vs-NoSQL" class="headerlink" title="4.1.1. Sharding in SQL vs NoSQL"></a>4.1.1. Sharding in SQL vs NoSQL</h3><p>SQL自身不带Sharding功能，需要手动实现</p><p>以Cassandra为代表的NoSQL大多自带Sharding</p><p>这就是为什么发明NoSQL</p><h3 id="4-1-2-纵向拆分（Horiaontal-Sharding）"><a href="#4-1-2-纵向拆分（Horiaontal-Sharding）" class="headerlink" title="4.1.2. 纵向拆分（Horiaontal Sharding）"></a>4.1.2. 纵向拆分（Horiaontal Sharding）</h3><p>简单的纵向切分：</p><ul><li>user table 放一台数据库</li><li>Friendship Table 放一台数据库</li><li>Message Table 放一台数据库</li></ul><p>复杂的纵向切分：</p><ul><li>比如User Table里有如下信息：<ul><li>Email</li><li>Username</li><li>Password</li><li>push_preference</li><li>avatar</li></ul></li><li>一般email/username/password不会经常变动，而push_preference,avatar变动频率较高</li><li>可以把这样的一张表拆分成两个表，User Table 和User Profile Table<ul><li>将这两张表放在两台机器上</li><li>如果UserprofileTable挂了，不会影响user的正常登录操作</li></ul></li></ul><p>实际上就是将table按column进行切分，存储在不同的机器上</p><p>缺点：如果数据量很大，有很多很多个用户，纵向拆分之后，仍然很大</p><h3 id="4-1-3-横向拆分（核心）"><a href="#4-1-3-横向拆分（核心）" class="headerlink" title="4.1.3. 横向拆分（核心）"></a>4.1.3. 横向拆分（核心）</h3><p>一个粗暴的想法：</p><p>假如拆分Friendship Table，假设有10台数据库的机器，可以想到按照from_user_id%10来进行查分，这样做有什么问题？</p><p>假设10台机器不够用了，现在买了一台新机器，原来的%10变成了%11，几乎所有的数据都需要进行位置大迁移！！！！</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-17-38-23.png" alt=""> </p><p><strong>数据迁移造成的问题：</strong></p><ol><li>慢，牵一发而动全身</li><li>前一期间，服务器压力增大，容易宕机</li><li>容易造成数据不一致</li></ol><p>如何解决？</p><p><strong>一致性Hash算法</strong></p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-02-11-17-42-48.png" alt=""></p><p>更具体的内容听说在下一节，哈哈</p><h2 id="4-2-Replica-数据备份"><a href="#4-2-Replica-数据备份" class="headerlink" title="4.2. Replica 数据备份"></a>4.2. Replica 数据备份</h2><ul><li>通常的做法是：一式三份（重要的事情说三遍）</li><li>Replica同时还能分摊读请求</li></ul><p>剩下的内容听说也在下一节，哈哈</p><h1 id="5-缓存淘汰算法："><a href="#5-缓存淘汰算法：" class="headerlink" title="5. 缓存淘汰算法："></a>5. 缓存淘汰算法：</h1><p>缓存调度算法，缓存页面调度算法：先分配一定的页面空间，使用页面的时候首先去查询空间是否有该页面的缓存，如果有的话直接拿出来，如果没有的话先查询，如果页面空间没有满的时候，使用新页面的时候，就释放旧的页面空间，把新页面缓存起来，以便下次使用同样的页面的时候方便调用。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">def <span class="title">getUser</span><span class="params">(user_id)</span>:</span></div><div class="line"><span class="function">user </span>= cache.get(user_id)</div><div class="line">    <span class="keyword">if</span> user :</div><div class="line">      <span class="keyword">return</span> user</div><div class="line">    user = database.get(user_id)</div><div class="line">    cache.set(key, user)</div><div class="line">    <span class="keyword">return</span> user</div><div class="line">  </div><div class="line"><span class="function">def <span class="title">setUser</span><span class="params">(user)</span>:</span></div><div class="line"><span class="function">  cache.<span class="title">delete</span><span class="params">(user.user_id)</span></span></div><div class="line"><span class="function">  database.<span class="title">set</span><span class="params">(user)</span></span></div></pre></td></tr></table></figure><p><code>cache</code> 一般是有有效期的，也就是如果缓存中这个数据过期了，那就从缓存中清理出去。而<code>cache</code> 的实现过程和淘汰机制不同，会导致不同的性能表现。常见的就是IFIO，LRU，LFU缓存过期策略。</p><ol><li>FIFO(First In First Out) : 先进先出。淘汰掉很久以前进来的数据，而新数据等到之后再淘汰。也就是一个队列。</li><li>LRU (Least recently used) : 最近最少使用。淘汰最近不适用的数据</li><li>LFU (Least frequently used) : 最近使用次数最少。淘汰掉使用次数最少的页面。</li></ol><h2 id="5-1-FIFO"><a href="#5-1-FIFO" class="headerlink" title="5.1. FIFO"></a>5.1. FIFO</h2><p>按照“先进先出（First In，First Out）”的原理淘汰数据，正好符合队列的特性，数据结构上使用队列Queue来实现。</p><p>如下图：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-54-58.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-54-58.png" alt="img"></a></p><ol><li>新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动；</li><li>淘汰FIFO队列头部的数据；</li></ol><h2 id="5-2-LRU-Cache"><a href="#5-2-LRU-Cache" class="headerlink" title="5.2. LRU Cache"></a>5.2. LRU Cache</h2><p>（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，因此优先将最近没有被访问的数据删掉。</p><p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-56-25.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-27-15-56-25.png" alt="img"></a></p><ol><li>新数据插入到链表头部；</li></ol><ol><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ol><p>leetcode题目： <a href="https://leetcode.com/problems/lru-cache" target="_blank" rel="external">LRU Cache</a></p><blockquote><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="external">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; LRUCache cache = new LRUCache( 2 /* capacity */ );</div><div class="line">&gt;</div><div class="line">&gt; cache.put(1, 1);</div><div class="line">&gt; cache.put(2, 2);</div><div class="line">&gt; cache.get(1);       // returns 1</div><div class="line">&gt; cache.put(3, 3);    // evicts key 2</div><div class="line">&gt; cache.get(2);       // returns -1 (not found)</div><div class="line">&gt; cache.put(4, 4);    // evicts key 1</div><div class="line">&gt; cache.get(1);       // returns -1 (not found)</div><div class="line">&gt; cache.get(3);       // returns 3</div><div class="line">&gt; cache.get(4);       // returns 4</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>简单的说，就是保证基本的get和set的功能的同时，还要保证最近访问(get或put)的节点保持在限定容量的Cache中，如果超过容量则应该把LRU(近期最少使用)的节点删除掉。</p><p>思路：</p><p>题目要求利用LRU缓存淘汰机制，在<script type="math/tex">O(1)</script> 时间复杂度下实现缓存的加入和删除操作</p><p>代码：</p><h2 id="5-2-LFU-Cache"><a href="#5-2-LFU-Cache" class="headerlink" title="5.2. LFU Cache"></a>5.2. <a href="https://leetcode.com/problems/lfu-cache" target="_blank" rel="external">LFU Cache</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Design User System用户系统&lt;ul&gt;
&lt;li&gt;Mencached 优化数
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java常用笔记</title>
    <link href="http://yoursite.com/2018/01/27/Java%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/27/Java常用笔记/</id>
    <published>2018-01-27T14:51:05.000Z</published>
    <updated>2018-02-08T07:05:26.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA集合类ArrayList删除指定值元素"><a href="#JAVA集合类ArrayList删除指定值元素" class="headerlink" title="JAVA集合类ArrayList删除指定值元素"></a>JAVA集合类ArrayList删除指定值元素</h2><h3 id="错误做法："><a href="#错误做法：" class="headerlink" title="错误做法："></a>错误做法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i = 0, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    if(list.get(i) == 1) &#123;  </div><div class="line">       list.remove(i);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为删除了元素，但是未改变迭代的下标，这样当迭代到最后一个的时候就会抛异常。</p><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </div><div class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>)&#123;  </div><div class="line">       list.remove(i);  </div><div class="line">       len--;</div><div class="line">       i--;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>更好的一个做法</li></ul><p>List接口内部实现了Iterator接口，提供开发者一个iterator()得到当前list对象的一个iterator对象。所以我们还有一个更好的做法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </div><div class="line">    <span class="keyword">int</span> i = iterator.next();  </div><div class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </div><div class="line">        iterator.remove();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="比较、排序Comparator-Comparable"><a href="#比较、排序Comparator-Comparable" class="headerlink" title="比较、排序Comparator/Comparable"></a>比较、排序Comparator/Comparable</h2><h3 id="1-自定义的类后面需要按指定属性实现排序等操作"><a href="#1-自定义的类后面需要按指定属性实现排序等操作" class="headerlink" title="1.自定义的类后面需要按指定属性实现排序等操作"></a>1.自定义的类后面需要按指定属性实现排序等操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">double</span> salary;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.salary);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-已有模板，定义排序顺序（最大堆、最小堆）"><a href="#2-已有模板，定义排序顺序（最大堆、最小堆）" class="headerlink" title="2.已有模板，定义排序顺序（最大堆、最小堆）"></a>2.已有模板，定义排序顺序（最大堆、最小堆）</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//先定义一个比较器</span></div><div class="line">Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1,Integer e2)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> e1 - e2;<span class="comment">//最小堆，默认</span></div><div class="line">         <span class="comment">//return e2-e1;最大堆</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure><p>Long型数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div></pre></td></tr></table></figure><h2 id="string和int相互转化"><a href="#string和int相互转化" class="headerlink" title="string和int相互转化"></a>string和int相互转化</h2><h3 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h3><ol><li>int i = Integer.parseInt(String s);</li><li>int i = Integer.valueOf(String s).intValue();</li></ol><h3 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h3><ol><li>String s = String.valueOf(i);</li><li>String s = Integer.toString(i);</li><li>String s= “”+i;</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA集合类ArrayList删除指定值元素&quot;&gt;&lt;a href=&quot;#JAVA集合类ArrayList删除指定值元素&quot; class=&quot;headerlink&quot; title=&quot;JAVA集合类ArrayList删除指定值元素&quot;&gt;&lt;/a&gt;JAVA集合类ArrayList删
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章系统设计】新鲜事系统</title>
    <link href="http://yoursite.com/2018/01/27/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%96%B0%E9%B2%9C%E4%BA%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/01/27/【九章系统设计】新鲜事系统/</id>
    <published>2018-01-27T13:14:27.000Z</published>
    <updated>2018-02-08T07:05:26.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统涉及面试的两种形式及常见问题"><a href="#系统涉及面试的两种形式及常见问题" class="headerlink" title="系统涉及面试的两种形式及常见问题"></a>系统涉及面试的两种形式及常见问题</h2><h3 id="设计某某系统"><a href="#设计某某系统" class="headerlink" title="设计某某系统"></a>设计某某系统</h3><p>设计微博、滴滴、微信、短网址系统、nosql数据库</p><h3 id="找问题"><a href="#找问题" class="headerlink" title="找问题"></a>找问题</h3><ul><li>网站挂了怎么办</li><li>网站太慢怎么办</li><li>流量增长怎么</li></ul><h3 id="面试官：请设计Twitter"><a href="#面试官：请设计Twitter" class="headerlink" title="面试官：请设计Twitter"></a>面试官：请设计Twitter</h3><h3 id="系统设计问题的4S分析法"><a href="#系统设计问题的4S分析法" class="headerlink" title="系统设计问题的4S分析法"></a>系统设计问题的4S分析法</h3><ul><li>Scenario场景<ul><li>需要设计哪些功能，设计的多牛</li><li>向面试官提问：features/QPS/DAU(日活跃用户)/inerfaces</li></ul></li><li>Servece服务<ul><li>将大系统拆分成小服务</li><li>Split/Application/Module</li></ul></li><li>Storage存储<ul><li>数据如何存储与访问</li><li>Schema(表头字段)/data/sql/nosql/File System</li></ul></li><li>Scale升级<ul><li>解决缺陷，处理可能遇到的问题</li><li>Sharding/optimize/soecial case</li></ul></li></ul><h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><h4 id="Scenario场景-Ask"><a href="#Scenario场景-Ask" class="headerlink" title="Scenario场景-Ask"></a>Scenario场景-Ask</h4><p>询问面试官：</p><ol><li>需要设计哪些功能</li><li>需要承受多大的访问量？<ol><li>日活跃用户DAU</li><li>Twitter:MAU ：313M+ DAU：150M+（一般MAU是DAU的2倍）</li></ol></li></ol><h4 id="Scenario场景-Analyze-amp-predict"><a href="#Scenario场景-Analyze-amp-predict" class="headerlink" title="Scenario场景-Analyze&amp;predict"></a>Scenario场景-Analyze&amp;predict</h4><ul><li>根据DAU计算并发用户数：<ul><li><code>日活跃*每个用户平均请求次数/一天多少秒 = 150M*60/86400 ~100k</code></li><li>峰值peak = 3*QPS ~300k</li><li>快速增长的产品：<ul><li>max peak users in 3 months = peak users*2</li></ul></li></ul></li><li>读频率Read QPS(Queries per second)<ul><li>300k</li></ul></li><li>写频率Write QPS<ul><li>5k</li></ul></li></ul><h4 id="QPS有什么用"><a href="#QPS有什么用" class="headerlink" title="QPS有什么用"></a>QPS有什么用</h4><ul><li>QPS = 100<ul><li>用笔记本做web服务器就可以</li></ul></li><li>QPS = 1k<ul><li>用一台好一点的web服务器就差不多</li><li>需要考虑Single Point Failure</li></ul></li><li>QPS = 1m<ul><li>需要假设一个1000台web服务器的集群</li><li>需要考虑如何Maintanance(某一台挂了怎么办)</li></ul></li><li>QPS和web server/database之间的关系<ul><li>一台web service 承受量是1k QPS</li><li>一台SQL Database 承受量是1k QPS</li><li>一台 no SQL Database 承受量是10k QPS</li></ul></li></ul><h4 id="Scenario场景-需要设计哪些功能"><a href="#Scenario场景-需要设计哪些功能" class="headerlink" title="Scenario场景-需要设计哪些功能"></a>Scenario场景-需要设计哪些功能</h4><ul><li><p>step1:列举需要的功能</p><ul><li>注册、登录</li><li>用户信息展示、编辑</li><li>上传照片、视频</li><li>搜索</li><li>发送、分享推文</li><li>时间轴</li><li>关注、取关用户</li></ul></li><li><p>step2:sort按功能优先级排序</p><p>​</p></li></ul><h3 id="Service服务"><a href="#Service服务" class="headerlink" title="Service服务"></a>Service服务</h3><p>将大的系统拆分为小服务</p><ol><li>replay重放需求</li><li>merge归并需求</li></ol><p><img src="https://i.loli.net/2018/01/17/5a5ec793139ea.png" alt=""> </p><h3 id="storage存储——数据如何存储与访问（最重点占50-）"><a href="#storage存储——数据如何存储与访问（最重点占50-）" class="headerlink" title="storage存储——数据如何存储与访问（最重点占50%）"></a>storage存储——数据如何存储与访问（最重点占50%）</h3><ul><li>关系型数据库SQL Database（结构化数据）MySQL<ul><li>用户信息</li></ul></li><li>非关系型数据库（非结构化数据）MangoDB<ul><li>推文</li><li>社交图谱</li></ul></li><li>文件系统<ul><li>图片、视频（Media files）</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/17/5a5ec9773713d.png" alt=""> </p><p>Step1：为每个service选择合适的存储结构</p><p>Step2：选好合适的存储结构之后，设计数据表的结果，需要存储哪些字段</p><p><img src="https://i.loli.net/2018/01/17/5a5eca2f1b538.png" alt=""> </p><h3 id="新鲜事系统News-Feed"><a href="#新鲜事系统News-Feed" class="headerlink" title="新鲜事系统News Feed"></a>新鲜事系统News Feed</h3><ul><li>什么是新鲜事News Feed?<ul><li>登录Faebook/Twitter/朋友圈之后看到的信息流</li><li>你的所有朋友发的信息的集合</li></ul></li><li>典型新鲜事系统<ul><li>Facebook</li><li>Twitter</li><li>朋友圈</li><li>RSS Reader（头条）</li></ul></li><li>新鲜事系统的核心因素<ul><li>关注与被关注</li><li>每个人看到的新鲜事是不同的</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>Pull模型：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用merge K sorted arrays的思想</div><div class="line">用户的时间线：-&gt;整合成-&gt;feed流</div><div class="line">A：An1,An2,...↘</div><div class="line">B: Bn1,Bn2,...    →An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：Cn1,Cn2,... ↗</div><div class="line">...</div></pre></td></tr></table></figure><ul><li>当用户查看News Feed时，获取其每一个好友的最近100条推文，merge这些推文，按时间排序展示给用户</li><li>复杂度分析：<ul><li>News Feed:加入用户关注了N个对象，则时间为N此DB read的时间（读取数据库）+ N路归并的时间（在内存中计算的O(logK)，时间忽略）读取数据库耗时很长</li><li>Post a tweet:一次DB write（写入数据库）时间</li></ul></li></ul></li><li><p>Push模型：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">用户的News Feed List：用户D\E\F发了tweet，推送到其好友的List中</div><div class="line">A：D,E...↘</div><div class="line">B: F,...    →An1,n2,Bn1,Cn1,Cnw,Bn2.....</div><div class="line">C：E,F,... ↗</div><div class="line">...</div></pre></td></tr></table></figure><ul><li><p>为每个用户建立一个List存储池存储其好友的News Feed信息，当用户发送一个tweet之后，将该推文推送到每一个关注了他的用户的News Feed中.用户需要查看News Feed时只需要从他的News Feed中读取最近的100条即可</p><p><strong>关键词：Fanout</strong></p></li><li><p>复杂度分析</p><ul><li>News Feed：1次DB read(相比push模型快很多)</li><li>post a tweet：N个粉丝需要N次DB writes<ul><li>如果粉丝数量N巨大，写入粉丝News Feed List耗时大</li><li>但好处是可以用异步任务在后台执行，无需用户等待</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/18/5a5f76ad915ab.png" alt=""> </p><p>所有的用户公用一个表格，当一个用户发送推文时，他自己和他的关注着都将看到，所以插入n+1条数经验，owner_id为他自己和他的好友们，然后读取时在数据表中select owner_id为自己的。</p><p><img src="https://i.loli.net/2018/01/18/5a5f76056f895.png" alt=""> </p><p>Web Server 到Asynct是通过消息队列发送，比如RabitMQ，拿到任务后，先去好友关系表中拿到发文用户的关注者们，然后把消息加入News Feed Table</p><p>缺陷：</p><ol><li><p>浪费数据库，但硬盘很便宜，不需要考虑存储数据量大</p></li><li><p>如果粉丝数量很大，异步操作需要时间，有些粉丝不能及时看到大V发送的tweet</p><p>​</p></li></ol></li></ul></li></ul><h2 id="Design-Twitter"><a href="#Design-Twitter" class="headerlink" title="Design Twitter"></a><a href="https://leetcode.com/problems/design-twitter" target="_blank" rel="external">Design Twitter</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTwitter</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,User&gt; UsersList;</div><div class="line">        <span class="keyword">int</span> tweetTimeStamp = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> id;</div><div class="line">            <span class="keyword">int</span> userId;</div><div class="line">            <span class="keyword">int</span> timeStamp;</div><div class="line">            Tweet(<span class="keyword">int</span> id,<span class="keyword">int</span> useId,<span class="keyword">int</span> timeStamp)&#123;</div><div class="line">                <span class="keyword">this</span>.id = id;</div><div class="line">                <span class="keyword">this</span>.userId = useId;</div><div class="line">                <span class="keyword">this</span>.timeStamp = timeStamp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> uid;</div><div class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;Integer&gt; followers = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//被谁关注</span></div><div class="line">            List&lt;Integer&gt; followees = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//关注了谁</span></div><div class="line">            User(<span class="keyword">int</span> uid)&#123;</div><div class="line">                <span class="keyword">this</span>.uid = uid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</div><div class="line">            UsersList = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Compose a new tweet. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">            &#125;</div><div class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(tweetId,userId,tweetTimeStamp);</div><div class="line">            UsersList.get(userId).tweets.add(tweet);</div><div class="line">            tweetTimeStamp++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">            List&lt;Integer&gt; feeds = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(userId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(userId);</div><div class="line">                UsersList.put(userId,user);</div><div class="line">                <span class="keyword">return</span> feeds;</div><div class="line">            &#125;</div><div class="line">            Comparator&lt;Tweet&gt; cmp = <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet t1,Tweet t2)</span></span>&#123;</div><div class="line">                    <span class="keyword">return</span> t2.timeStamp - t1.timeStamp;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Queue&lt;Tweet&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>,cmp);</div><div class="line">            <span class="comment">//先处理自己的新鲜事</span></div><div class="line">            List&lt;Tweet&gt; ownTweets = UsersList.get(userId).tweets;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = ownTweets.size()-<span class="number">1</span>;i &gt;= ownTweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                heap.add(ownTweets.get(i));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//处理关注的人的新鲜事</span></div><div class="line">            List&lt;Integer&gt; followees = UsersList.get(userId).followees;</div><div class="line">            <span class="keyword">for</span>(Integer followee : followees)&#123;</div><div class="line">                List&lt;Tweet&gt; tweets = UsersList.get(followee).tweets;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tweets.size()-<span class="number">1</span>;i &gt;= tweets.size() - <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">                    heap.add(tweets.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> k = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty())&#123;</div><div class="line">                feeds.add(heap.poll().id);</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> feeds;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="comment">//如果没有用户，新建用户</span></div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followeeId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followeeId);</div><div class="line">                UsersList.put(followeeId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!UsersList.containsKey(followerId))&#123;</div><div class="line">                User user = <span class="keyword">new</span> User(followerId);</div><div class="line">                UsersList.put(followerId,user);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || UsersList.get(followerId).followees.contains(followeeId))&#123;<span class="keyword">return</span>;&#125;</div><div class="line">            <span class="comment">//更新用户关注和被关注列表</span></div><div class="line">            UsersList.get(followeeId).followers.add(followerId);</div><div class="line">            UsersList.get(followerId).followees.add(followeeId);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(followeeId == followerId || !UsersList.containsKey(followeeId) || !UsersList.containsKey(followerId) ||</div><div class="line">                    !UsersList.get(followerId).followees.contains(followeeId) || !UsersList.get(followeeId).followers.contains(followerId))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator =  UsersList.get(followeeId).followers.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator.next();</div><div class="line">                <span class="keyword">if</span>(i == followerId)&#123;</div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; iterator2 =  UsersList.get(followerId).followees.iterator();</div><div class="line">            <span class="keyword">while</span>(iterator2.hasNext())&#123;</div><div class="line">                <span class="keyword">int</span> i = iterator2.next();</div><div class="line">                <span class="keyword">if</span>(i == followeeId)&#123;</div><div class="line">                    iterator2.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Twitter obj = <span class="keyword">new</span> Twitter();</div><div class="line">        obj.postTweet(<span class="number">1</span>,<span class="number">5</span>);</div><div class="line">        List&lt;Integer&gt; param_2 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.follow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        obj.postTweet(<span class="number">2</span>,<span class="number">6</span>);</div><div class="line">        List&lt;Integer&gt; param_3 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">        obj.unfollow(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">        List&lt;Integer&gt; param_4 = obj.getNewsFeed(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        DesignTwitter test = <span class="keyword">new</span> DesignTwitter();</div><div class="line">        test.test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实这里有个问题，就是follow unfollow post这些都是用户的操作，应该放在用户类里面的，然后再外部调用。有时间重写一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统涉及面试的两种形式及常见问题&quot;&gt;&lt;a href=&quot;#系统涉及面试的两种形式及常见问题&quot; class=&quot;headerlink&quot; title=&quot;系统涉及面试的两种形式及常见问题&quot;&gt;&lt;/a&gt;系统涉及面试的两种形式及常见问题&lt;/h2&gt;&lt;h3 id=&quot;设计某某系统&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="http://yoursite.com/2018/01/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/01/24/Java垃圾回收机制/</id>
    <published>2018-01-24T07:12:30.000Z</published>
    <updated>2018-01-24T07:12:31.002Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】图与搜索</title>
    <link href="http://yoursite.com/2018/01/23/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E5%9B%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/01/23/【九章算法基础班】图与搜索/</id>
    <published>2018-01-23T02:52:30.000Z</published>
    <updated>2018-02-08T07:05:26.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><ul><li><p>graph</p><ul><li>Clone Graph</li><li>Topological Sorting</li></ul></li><li><p>Search</p><ul><li><p>DFS</p></li><li><p>BFS:（O(m+n)m为边树，n为点数)</p><ul><li><p>遍历图</p><p>树的BFS需要用队列，在图中除了要用队列还需要用到hash表，用来存储节点是否被访问过</p><p>BFS还可以用于求深度，最短路径</p></li><li><p>简单图求最短路径</p></li><li><p>拓扑排序</p></li></ul></li></ul></li></ul><h2 id="BFS例题"><a href="#BFS例题" class="headerlink" title="BFS例题"></a>BFS例题</h2><h3 id="1-Clone-Graph"><a href="#1-Clone-Graph" class="headerlink" title="1. Clone Graph"></a>1. <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">Clone Graph</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p><p>OJ’s undirected graph serialization:</p><p>Nodes are labeled uniquely.</p><p> We use <code>#</code>as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.</p><p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.</p><p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p><ol><li>First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.</li><li>Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.</li><li>Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.</li></ol><p>Visually, the graph looks like the following:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;        1</div><div class="line">&gt;       / \</div><div class="line">&gt;      /   \</div><div class="line">&gt;     0 --- 2</div><div class="line">&gt;          / \</div><div class="line">&gt;          \_/</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定图中的一个节点，克隆整个图</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>考点：</p><ol><li>从一个点出发，把整张图的所有节点找到（BFS）nodes</li><li>获得nodes之后复制所有的点，将新老节点建立映射关系，存入hashmap中</li><li>根据老节点之间的关系和新老节点的映射关系，复制所有的边</li><li>最后返回给定的node对应的新节点</li></ol><p>还可以用DFS：</p><p>递归调用复制节点和邻居关系。</p><p>DFS的输入是旧结点，返回值是新节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphClone</span> </span>&#123;</div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> label;</div><div class="line">         List&lt;UndirectedGraphNode&gt; neighbors;</div><div class="line">         UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</div><div class="line">     &#125;</div><div class="line">     HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//用于存储新旧节点映射关系</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; oldNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//旧结点</span></div><div class="line">     List&lt;UndirectedGraphNode&gt; newNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新节点</span></div><div class="line"></div><div class="line">    <span class="comment">//bfs获取图中所有的点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node)</span></span>&#123;</div><div class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        HashSet&lt;UndirectedGraphNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        queue.add(node);</div><div class="line">        set.add(node);</div><div class="line">        <span class="comment">//BFS</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            UndirectedGraphNode temp = queue.poll();</div><div class="line">            UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(temp.label);</div><div class="line">            oldNodes.add(temp);<span class="comment">//加入旧点集</span></div><div class="line">            newNodes.add(newNode);<span class="comment">//加入新点集</span></div><div class="line">            nodeMap.put(temp,newNode);<span class="comment">//加入mapping</span></div><div class="line"></div><div class="line">            <span class="comment">//遍历当前节点的所有邻居</span></div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : temp.neighbors)&#123;</div><div class="line">                <span class="comment">//如果已经加入结合了，跳过</span></div><div class="line">                <span class="keyword">if</span>(set.contains(neighbor))&#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果还未加入</span></div><div class="line">                queue.add(neighbor);</div><div class="line">                set.add(neighbor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取图中所有的节点</span></div><div class="line">        bfs(node);</div><div class="line">        <span class="comment">//复制所有的边</span></div><div class="line">        <span class="keyword">for</span>(UndirectedGraphNode oldNode : oldNodes)&#123;</div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode neighbor : oldNode.neighbors)&#123;</div><div class="line">                nodeMap.get(oldNode).neighbors.add(nodeMap.get(neighbor));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回node对应的新节点</span></div><div class="line">        <span class="keyword">return</span> nodeMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DFS：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">dfs</span><span class="params">(UndirectedGraphNode node,HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(map.containsKey(node))&#123;</div><div class="line">        <span class="keyword">return</span> map.get(node);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新建节点</span></div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node,newNode);</div><div class="line">    <span class="comment">//遍历邻居节点</span></div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">        newNode.neighbors.add(dfs(neighbor,map));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">    HashMap&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(node,map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h3><p>下面这个图假设是一种上课顺序，比如上1之前必须上0。求这个图的任意一个拓扑排序（按照这个顺序上课则可以上完所有课）</p><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></a></p><p>拓扑排序很好的参考资料：<a href="http://www.stoimen.com/blog/2012/10/01/computer-algorithms-topological-sort-of-a-graph/" target="_blank" rel="external">Topological Sort of a Graph</a></p><p>拓扑排序的思路如下：</p><ol><li>统计当前入度为0的点，加入队列</li><li>将当前所有入度为0的点删掉，并将这些点的下一点的连线删掉，将其下一个节点的入度减1</li><li>重复1和2，直到所有的点都被删掉</li><li>如果不能拓扑排序说明图中一定有环</li></ol><p><a href="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" target="_blank" rel="external"><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" alt="img"></a></p><h3 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a><a href="http://www.lintcode.com/en/problem/topological-sorting/" target="_blank" rel="external">Topological Sorting</a></h3><blockquote><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p><ul><li>For each directed edge <code>A -&gt; B</code> in graph, A must before B in the order list.</li><li>The first node in the order can be any node in the graph with no nodes direct to it.</li></ul><p>Find any topological order for the given graph.</p><p>Example</p><p>For graph as follow:</p></blockquote><p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt="img"></p><blockquote><p>The topological order can be:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [0, 1, 2, 3, 4, 5]</div><div class="line">&gt; [0, 2, 3, 1, 5, 4]</div><div class="line">&gt; ...</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>核心就是根据拓扑排序给出一条合理的路径，能够遍历图中所有的点，且不违背箭头顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    HashMap&lt;DirectedGraphNode,Integer&gt; degreeIn = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    Queue&lt;DirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    ArrayList&lt;DirectedGraphNode&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//计算入度出度</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode nodeFrom : graph) &#123;</div><div class="line">        <span class="keyword">for</span> (DirectedGraphNode nodeEnd : nodeFrom.neighbors) &#123;</div><div class="line">            <span class="comment">//计算NodeEnd入度</span></div><div class="line">            <span class="keyword">if</span> (!degreeIn.containsKey(nodeEnd)) &#123;</div><div class="line">                degreeIn.put(nodeFrom, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                degreeIn.put(nodeEnd, degreeIn.get(nodeEnd) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs</span></div><div class="line">    <span class="comment">//queue.add(graph.get(0));</span></div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">        <span class="keyword">if</span>(!degreeIn.containsKey(node))&#123;</div><div class="line">            queue.offer(node);</div><div class="line">            results.add(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        DirectedGraphNode node = queue.poll();</div><div class="line">        <span class="comment">//results.add(node);</span></div><div class="line">        <span class="keyword">for</span>(DirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">            degreeIn.put(neighbor,degreeIn.get(neighbor)-<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(degreeIn.get(neighbor) == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(neighbor);</div><div class="line">                results.add(neighbor);</div><div class="line">                <span class="comment">//numNodes--;</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule" target="_blank" rel="external">Course Schedule</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0]]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 2, [[1,0],[0,1]]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p></blockquote><p>给定课程门数，和课程之间的依赖关系，判断是否可以无冲突完成课程。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>BFS和DFS都可以做</p><p>BFS：</p><p>拓扑排序的思想，如果最后所有的点都被访问到了，就是可以的，反之不可以。</p><p>DFS：</p><p>用DFS的核心思想就是遇到某条路径上有环就可以返回false，不用继续判断了。所以需要用一个visited数组来保存节点的访问状态。当沿着某一条路径前进时遇到之前已经访问过的节点，就返回false，如果一直没有出现环则在最后返回true。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] classDegreeIn = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录入度</span></div><div class="line">        <span class="keyword">int</span>[] classDegreeOut = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//记录出度</span></div><div class="line">        HashMap&lt;Integer,List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            classDegreeIn[edgeEnd]++;</div><div class="line">            classDegreeOut[edgeFrom]++;</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom,<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom,listTemp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//寻找入度为0的点入栈</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numCourses;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(classDegreeIn[i] == <span class="number">0</span>)&#123;</div><div class="line">                queue.add(i);</div><div class="line">                counter++;</div><div class="line">                <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">                hasVisited[i] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> classID = queue.poll();</div><div class="line">            <span class="keyword">if</span>(edges.getOrDefault(classID,<span class="keyword">new</span> ArrayList&lt;&gt;()).size() == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遍历classID的所有邻居，将其入度-1</span></div><div class="line">            <span class="keyword">for</span>(Integer neighbor : edges.get(classID))&#123;</div><div class="line">                classDegreeIn[neighbor]--;</div><div class="line">                <span class="comment">//如果入度为0,入栈</span></div><div class="line">                <span class="keyword">if</span>(classDegreeIn[neighbor] == <span class="number">0</span>)&#123;</div><div class="line">                    queue.add(neighbor);</div><div class="line">                    counter++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter == numCourses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DFS：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] used,HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges,Integer node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(used[node])&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(edges.containsKey(node)) &#123;</div><div class="line">            used[node] = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(Integer next: edges.get(node))&#123;</div><div class="line">                <span class="keyword">if</span>(!dfs(used,edges,next))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            used[node] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line"></div><div class="line">        <span class="comment">//遍历所有的点记录入度和出度,加入边集和</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> edgeFrom = prerequisites[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> edgeEnd = prerequisites[i][<span class="number">1</span>];</div><div class="line">            List&lt;Integer&gt; listTemp = edges.getOrDefault(edgeFrom, <span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            listTemp.add(edgeEnd);</div><div class="line">            edges.put(edgeFrom, listTemp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Integer node : edges.keySet())&#123;</div><div class="line">            <span class="keyword">if</span>(!dfs(used,edges,node))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p></blockquote><p>求从起点到终点的最短路径长度</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>求路径长度一般用BFS，从起点开始把相差一个字母的单词一次入队列，知道遇到结束词时， 此时bfs的深度就是最短路径长度。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(beginWord);</div><div class="line">        <span class="keyword">int</span> step = <span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> queueSize = queue.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;</div><div class="line">                String temp  = queue.peek();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">                        <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;</div><div class="line">                            <span class="keyword">return</span> step;</div><div class="line">                        &#125;</div><div class="line">                        queue.add(wordList.get(j));</div><div class="line">                        isUsed[j] = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                queue.poll();</div><div class="line">            &#125;</div><div class="line">            step++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">        <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a><a href="https://leetcode.com/problems/word-ladder-ii" target="_blank" rel="external">Word Ladder II</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>Return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</div><div class="line">&gt;     [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</div><div class="line">&gt;   ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>返回所有的路径长度最短的合法路径。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>找到合法路径，考虑用BFS，找到所有合法的路径，考虑用DFS，这道题目要求找到路径最短的所有合法路径，所以是一道BFS和DFS的综合题目。</p><p>如果只用DFS找的话，要遍历所有的路径，势必会超时（我试了，真的超时）</p><p>所以采用dfs和bfs结合的办法：</p><p>先从endWord到beginWord用BFS找到最短的路径是多少，同时标记经过的点到endWord的最短距离是多少</p><p>然后再用DFS从beginWord到endWord找到确定的路径，此时只需要遍历之前遍历过的点，其余的没有经过的点无需遍历，而且可以按距离顺序来遍历，将所有合法的路径加入的结果结合中。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] disToBegin;<span class="comment">//记录距离起点的距离</span></div><div class="line"></div><div class="line">    <span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">                diffSum++;</div><div class="line">                <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//bfs从后向前寻找最短路径长度,标记点到终点的距离</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(endWord);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//endword深度为0</span></div><div class="line">        <span class="comment">//bfs</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            depth++;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">                String temp = queue.poll();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;wordList.size();i++)&#123;</div><div class="line">                    String word = wordList.get(i);</div><div class="line">                    <span class="comment">//如果单词已经加入过队列了，或者和当前节点相差不为1，跳过</span></div><div class="line">                    <span class="keyword">if</span>(word.equals(endWord) || disToBegin[i] &gt; <span class="number">0</span> || !isValid(temp,word))&#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(word.equals(beginWord))&#123;</div><div class="line">                        <span class="keyword">return</span> depth;<span class="comment">//begin节点深度</span></div><div class="line">                    &#125;</div><div class="line">                    queue.add(word);</div><div class="line">                    disToBegin[i] = depth;</div><div class="line">                &#125;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//从前向后dfs确定具体路径</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String tempWord, String endWord,List&lt;String&gt; wordList,<span class="keyword">int</span> depth)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            temp.add(endWord);</div><div class="line">            results.add(temp);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disToBegin.length;i++)&#123;</div><div class="line">            String wordNext = wordList.get(i);</div><div class="line">            <span class="comment">//寻找深度和字母都符合的单词</span></div><div class="line">            <span class="keyword">if</span>(disToBegin[i] != depth || !isValid(tempWord,wordNext))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(wordNext);</div><div class="line">            dfs(wordNext,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//List&lt;String&gt; words = new ArrayList&lt;&gt;(wordList);</span></div><div class="line">        wordList.add(beginWord);</div><div class="line">        disToBegin = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size()];</div><div class="line">        <span class="keyword">int</span> depth = bfs(beginWord,endWord,wordList);</div><div class="line">        result.add(beginWord);</div><div class="line">        dfs(beginWord,endWord,wordList,depth-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="DFS排列组合"><a href="#DFS排列组合" class="headerlink" title="DFS排列组合"></a>DFS排列组合</h2><p>排列：</p><p><a href="https://leetcode.com/problems/permutations" target="_blank" rel="external">Permutations</a>   </p><p><a href="https://leetcode.com/problems/permutations-ii" target="_blank" rel="external">Permutations II</a>   </p><p>组合：</p><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning" target="_blank" rel="external">Palindrome Partitioning</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,<br>Return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>DFS，对字符串进行分割</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            i++;j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//规定左段包含i,右段不包含i</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end;i++)&#123;</div><div class="line">            String left = s.substring(start,i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(!Palindrome(left))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            result.add(left);</div><div class="line">            helper(s,i+<span class="number">1</span>,end);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        helper(s,<span class="number">0</span>,s.length()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/combination-sum" target="_blank" rel="external">Combination Sum</a> </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>找所有方案的问题一般都是DFS，90%的DFS是排列或者组合。</p><h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 <a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="external">Matrix</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p><p>The distance between two adjacent cells is 1.</p><p><strong>Example 1: </strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 0 0 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2: </strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 1 1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 0 0 0</div><div class="line">&gt; 0 1 0</div><div class="line">&gt; 1 2 1</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>计算每个点距离最近的0的距离</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法一:</p><p>用BFS，先将所有0的位置放入队列，然后出队列，将其周围点置位1，如队列，然后出队，将其周围点置为2，以此类推。</p><p>方法二：</p><p>动态规划，先从左上到右下计算每个点离最近的0的距离</p><p>然后从右下到左上再来一遍</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>BFS:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">  <span class="keyword">int</span> rows = matrix.length;</div><div class="line">  <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</div><div class="line">        dist[i][j] = <span class="number">0</span>;</div><div class="line">        queue.add(i*cols+j);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        dist[i][j] = -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size&gt;<span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> location = queue.poll();</div><div class="line">      <span class="keyword">int</span> row = location/cols;</div><div class="line">      <span class="keyword">int</span> col = location%cols;</div><div class="line">      <span class="keyword">int</span>[] rdelta = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">      <span class="keyword">int</span>[] cdelta = &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> new_row = row+rdelta[i];</div><div class="line">        <span class="keyword">int</span> new_col = col+cdelta[i];</div><div class="line">        <span class="keyword">if</span>(new_row &gt;=<span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_col &lt; cols &amp;&amp; dist[new_row][new_col] == -<span class="number">1</span>)&#123;</div><div class="line">          dist[new_row][new_col] = depth;</div><div class="line">          queue.add(new_row * cols + new_col);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dist;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dist;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</div><div class="line">        <span class="comment">//First pass: check for left and top</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</div><div class="line">                    dist[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    dist[i][j] = rows+cols;</div><div class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</div><div class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//Second pass: check for bottom and right</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span>)</div><div class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dist;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Pacific-Atlantic-Water-Flow"><a href="#Pacific-Atlantic-Water-Flow" class="headerlink" title="Pacific Atlantic Water Flow"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="external">Pacific Atlantic Water Flow</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p><p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p><p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p><p><strong>Note:</strong></p><ol><li>The order of returned grid coordinates does not matter.</li><li>Both <em>m</em> and <em>n</em> are less than 150.</li></ol><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given the following 5x5 matrix:</div><div class="line">&gt;</div><div class="line">&gt;   Pacific ~   ~   ~   ~   ~ </div><div class="line">&gt;        ~  1   2   2   3  (5) *</div><div class="line">&gt;        ~  3   2   3  (4) (4) *</div><div class="line">&gt;        ~  2   4  (5)  3   1  *</div><div class="line">&gt;        ~ (6) (7)  1   4   5  *</div><div class="line">&gt;        ~ (5)  1   1   2   4  *</div><div class="line">&gt;           *   *   *   *   * Atlantic</div><div class="line">&gt; Return:</div><div class="line">&gt; [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>矩阵左上是pacific 右下是atlantic,找出所有水能够同时流向两个ocean的位置</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用dfs，对pacific ocean从边缘的每一个点向内dfs搜索可以到达的点，就是考虑每一个点的上下左右四个邻居是否比自己高，如果比自己高而且之前还没有遍历过，就继续dfs。对atlantic做同样的操作。两边都可以到达的加入结果集。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] pacific,<span class="keyword">boolean</span>[][] used)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; rows || j &gt; cols)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        pacific[i][j] = <span class="keyword">true</span>;</div><div class="line">        used[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span>[] r_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] c_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> id = <span class="number">0</span> ; id  &lt; <span class="number">4</span>; id++)&#123;</div><div class="line">            <span class="keyword">int</span> new_row = i + r_delta[id];</div><div class="line">            <span class="keyword">int</span> new_col = j + c_delta[id];</div><div class="line">            <span class="keyword">if</span>(new_row &gt;= <span class="number">0</span> &amp;&amp; new_col &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; rows &amp;&amp; new_col &lt; cols &amp;&amp; !used[new_row][new_col] &amp;&amp;matrix[new_row][new_col] &gt;= matrix[i][j])&#123;</div><div class="line">                <span class="comment">//pacific[new_row][new_col] = true;</span></div><div class="line">                dfs(matrix,new_row,new_col,pacific,used);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rows = matrix.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] pacific = n，ew <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理pacific</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[0][i] = true;</span></div><div class="line">            dfs(matrix,<span class="number">0</span>,i,pacific,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][0] = true;</span></div><div class="line">            dfs(matrix,i,<span class="number">0</span>,pacific,used);</div><div class="line">        &#125;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        <span class="comment">//处理atlantic</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cols;i++)&#123;</div><div class="line">            <span class="comment">//pacific[rows-1][i] = true;</span></div><div class="line">            dfs(matrix,rows-<span class="number">1</span>,i,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)&#123;</div><div class="line">            <span class="comment">//pacific[i][cols-1] = true;</span></div><div class="line">            dfs(matrix,i,cols-<span class="number">1</span>,atlantic,used);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//两个都是true的位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])&#123;</div><div class="line">                    results.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="external">Minesweeper</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定棋盘和点击的点，返回点击之后的棋盘</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>分两种情况讨论，如果点到的地雷，就显示地雷即可；</p><p>如果没有点到地雷，则要从这个点开始dfs计算其周围的每个点周围的8个点处有多少个地雷，如果没有就改成B，如果有的话显示数字。对于显示数字的点就无需继续dfs其周围的点了。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minesweeper</span> </span>&#123;</div><div class="line">    <span class="comment">//计算某个位置周围有多少个地雷</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calSweeper</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">            <span class="keyword">if</span>(i+x_delta[ii] &lt; <span class="number">0</span> || j+y_delta[ii] &lt; <span class="number">0</span> || i+x_delta[ii] &gt;= rows || j+y_delta[ii] &gt;= cols)&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(board[i+x_delta[ii]][j+y_delta[ii]] == <span class="string">'M'</span>)&#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = board.length;</div><div class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</div><div class="line">        <span class="comment">//如果出界了，返回</span></div><div class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || board[i][j] == <span class="string">'B'</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'E'</span>)&#123;</div><div class="line">            <span class="keyword">int</span> sum = calSweeper(board,i,j);</div><div class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                board[i][j] = <span class="string">'B'</span>;</div><div class="line">                <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">                <span class="keyword">int</span>[] y_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>;ii++)&#123;</div><div class="line">                    <span class="comment">//如果还没点过，计算它周围有多少个地雷</span></div><div class="line">                    dfs(board,i+x_delta[ii],j+y_delta[ii]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                board[i][j] = Integer.toString(sum).charAt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="comment">//如果点到地雷</span></div><div class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)&#123;</div><div class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没点到地雷</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            dfs(board,click[<span class="number">0</span>],click[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Minesweeper test = <span class="keyword">new</span> Minesweeper();</div><div class="line">        <span class="keyword">char</span>[][] board = &#123;&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'M'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;&#125;;</div><div class="line">        <span class="keyword">char</span>[][] result = test.updateBoard(board,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">0</span>&#125;);</div><div class="line">        System.out.print(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Height-Trees"><a href="#Minimum-Height-Trees" class="headerlink" title="Minimum Height Trees"></a><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="external">Minimum Height Trees</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p><p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p><p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p><p><strong>Example 1:</strong></p><p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;         0</div><div class="line">&gt;         |</div><div class="line">&gt;         1</div><div class="line">&gt;        / \</div><div class="line">&gt;       2   3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[1]</code></p><p><strong>Example 2:</strong></p><p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      0  1  2</div><div class="line">&gt;       \ | /</div><div class="line">&gt;         3</div><div class="line">&gt;         |</div><div class="line">&gt;         4</div><div class="line">&gt;         |</div><div class="line">&gt;         5</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return <code>[3, 4]</code></p></blockquote><p>选取图中某一点作为root，使得形成的树高度最小，返回所有高度最小的root点。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用BFS计算了每一个点作为root的深度，超时了。。。。</p><p>逐层去掉叶子节点，留下的就是作为root树高最小的节点。思路不难，但还是写了好久</p><p>步骤：</p><ol><li>存储图中节点的度数和点边关系</li><li>把度数为1的节点加入叶子节点集合</li><li>遍历叶子节点，将与之相连的节点的度数-1，然后将叶子节点删除，同时，如果有节点的度数为1，说明是下一层的叶子节点，加入新叶子集合</li><li>当新叶子集合的大小&lt;=2时，说明找到了最终的MHT的root</li></ol><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界条件处理</span></div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            res.add(<span class="number">0</span>);</div><div class="line">            res.add(<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储点边关系</span></div><div class="line">        List&lt;HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            map.add(<span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="keyword">int</span>[] edgesNum = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储节点的度数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;edges.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> node1 = edges[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> node2 = edges[i][<span class="number">1</span>];</div><div class="line">            edgesNum[node1]++;</div><div class="line">            edgesNum[node2]++;</div><div class="line">            map.get(node1).add(node2);</div><div class="line">            map.get(node2).add(node1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> counter = n;</div><div class="line">      <span class="comment">//叶子节点加入结合</span></div><div class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(edgesNum[i] == <span class="number">1</span>)&#123;</div><div class="line">                leaves.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//遍历叶子节点，将与之相连的点的度数-1，删去叶子节点</span></div><div class="line">        <span class="keyword">while</span> (counter &gt; <span class="number">2</span>)&#123;</div><div class="line">            counter -= leaves.size();</div><div class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存储下一轮的新叶子节点</span></div><div class="line">            <span class="keyword">for</span>(Integer leave : leaves)&#123;</div><div class="line">                edgesNum[leave]--;</div><div class="line">                <span class="keyword">for</span>(Integer node : map.get(leave))&#123;</div><div class="line">                    edgesNum[node]--;</div><div class="line">                    <span class="keyword">if</span>(edgesNum[node] == <span class="number">1</span>)&#123;<span class="comment">//遇到度数为1的节点就是下一轮的叶子节点</span></div><div class="line">                        newLeaves.add(node);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            leaves = newLeaves;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Maze"><a href="#The-Maze" class="headerlink" title="The Maze"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="external">The Maze</a></h3><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><blockquote><p>There is a <strong>ball</strong> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <strong>up</strong>, <strong>down</strong>, <strong>left</strong> or <strong>right</strong>, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p><p>Given the ball’s <strong>start position</strong>, the <strong>destination</strong> and the <strong>maze</strong>, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of <strong>empty spaces</strong> traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p><p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p><p><strong>Example 1</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (4, 4)</div><div class="line">&gt;</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: One shortest way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</div><div class="line">&gt;              The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input 1: a maze represented by a 2D array</div><div class="line">&gt;</div><div class="line">&gt; 0 0 1 0 0</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt; 0 0 0 1 0</div><div class="line">&gt; 1 1 0 1 1</div><div class="line">&gt; 0 0 0 0 0</div><div class="line">&gt;</div><div class="line">&gt; Input 2: start coordinate (rowStart, colStart) = (0, 4)</div><div class="line">&gt; Input 3: destination coordinate (rowDest, colDest) = (3, 2)</div><div class="line">&gt;</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: There is no way for the ball to stop at the destination.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>矩阵中1是障碍，0是通的，小球从start滚到destination，不遇到障碍或者边界小球不会停下来，返回小球是否可以从start滚到end</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>BFS，小球从起点开始可以向上下左右四个方向滚，每次滚到障碍或者边界处，滚到终点就返回true</p><p>另外需要一个数组记录小球是否到过该节点，如果到过，后续就无需再走这里了。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">if</span>(node[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; node[<span class="number">1</span>] == destination[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt; <span class="number">4</span>;ii++)&#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">while</span>(newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>)&#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]])&#123;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii],newStartY - y_delta[ii]&#125;);</div><div class="line">                    visited[newStartX-x_delta[ii]][newStartY-y_delta[ii]] = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Maze-II"><a href="#The-Maze-II" class="headerlink" title="The Maze II"></a><a href="https://leetcode.com/problems/the-maze-ii" target="_blank" rel="external">The Maze II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>跟上一题一样，这个题要求返回从起点滚到终点的最短路径长度。如果滚不到就返回-1</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>用一个二维数组记录地图中的点到start的距离。BFS更新计算start到能够到达的点的最小距离，最后返回二维数组中的终点的值。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = maze.length;</div><div class="line">        <span class="keyword">int</span> cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;distance.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; distance[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                distance[i][j] = Integer.MAX_VALUE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] x_delta = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右</span></div><div class="line">        <span class="keyword">int</span>[] y_delta = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line">        queue.add(start);</div><div class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] node = queue.poll();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</div><div class="line">                <span class="keyword">int</span> newStartX = node[<span class="number">0</span>] + x_delta[ii];</div><div class="line">                <span class="keyword">int</span> newStartY = node[<span class="number">1</span>] + y_delta[ii];</div><div class="line">                <span class="comment">//走的通的方向，一直走到尽头</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录走了多少步</span></div><div class="line">                <span class="keyword">while</span> (newStartX &gt;= <span class="number">0</span> &amp;&amp; newStartY &gt;= <span class="number">0</span> &amp;&amp; newStartX &lt; rows &amp;&amp; newStartY &lt; cols &amp;&amp; maze[newStartX][newStartY] == <span class="number">0</span>) &#123;</div><div class="line">                    newStartX += x_delta[ii];</div><div class="line">                    newStartY += y_delta[ii];</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//如果这条路径到达该点比之前的距离短，更新该点的最短距离</span></div><div class="line">                <span class="keyword">if</span> (distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count &lt; distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]]) &#123;</div><div class="line">                    distance[newStartX - x_delta[ii]][newStartY - y_delta[ii]] = distance[node[<span class="number">0</span>]][node[<span class="number">1</span>]] + count;</div><div class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStartX - x_delta[ii], newStartY - y_delta[ii]&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] &lt; Integer.MAX_VALUE ? distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;graph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clone Graph&lt;/li&gt;
&lt;li&gt;T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】BFS问题</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90leetcode%E3%80%91BFS%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/20/【leetcode】BFS问题/</id>
    <published>2018-01-20T14:42:20.000Z</published>
    <updated>2018-02-08T07:05:26.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares" target="_blank" rel="external">Perfect Squares</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>典型的BFS题目</p><p>方法：</p><p>需要一个队列记录当前剩余的和。</p><p>首先将n加入队列，然后n出队列，计算小于他的最大平方数，然后递减计算剩余的数字差，如如队列，层数+1</p><p>当队列中有某一层出现剩余的和为0的时候说明找到了一条合法相加形式，此时就是所需的最少数组组合，返回此时的depth即可。</p><p>优化：DP</p><p>dp[n]：记录n可以由几个平方数加和得到</p><p>递推公式：dp[n] = min(dp[n-1]+1,dp[n-4]+1,dp[n-9]+1,……)</p><p>初始化：</p><p>​    dp[0] = 0;</p><p>​    dp[1] = 1;</p><p>返回值：dp[n]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(n);</div><div class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    depth++;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = queue.poll();</div><div class="line">      <span class="comment">//计算小于等于n的最大的平方数</span></div><div class="line">      <span class="keyword">int</span> maxSquare = (<span class="keyword">int</span>) Math.sqrt(temp);</div><div class="line">      <span class="keyword">while</span>(maxSquare &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> sumLeft = temp - maxSquare*maxSquare;</div><div class="line">        <span class="keyword">if</span>(sumLeft == <span class="number">0</span>)&#123;<span class="comment">//和等于0了</span></div><div class="line">          <span class="keyword">return</span> depth;</div><div class="line">        &#125;</div><div class="line">        queue.add(sumLeft);</div><div class="line">        maxSquare--;</div><div class="line">      &#125;</div><div class="line">      size--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//动态规划</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)&#123;</div><div class="line">    <span class="keyword">int</span> dpMinTemp = dp[i-<span class="number">1</span>] +<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= i;j++)&#123;</div><div class="line">      dpMinTemp = Math.min(dpMinTemp,dp[i - j*j] +<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    dp[i] = dpMinTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Perfect-Squares&quot;&gt;&lt;a href=&quot;#Perfect-Squares&quot; class=&quot;headerlink&quot; title=&quot;Perfect Squares&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/pe
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【leetcode】DFS问题</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90leetcode%E3%80%91DFS%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/20/【leetcode】DFS问题/</id>
    <published>2018-01-20T14:31:36.000Z</published>
    <updated>2018-02-08T07:05:26.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p><p>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p><p>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-20-21-52-42.png" alt=""> </p><p>如上图的例子，DFS访问数组为：ABDECFG。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。</p><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，</p><p>这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>思路比较简单，就是从root开始，先将root值加入结果集，然后先对其做左节点递归调用做DFS，然后是对右节点DFS。当遇到空节点时，返回上层。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDFS</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSRecurtionHelper</span><span class="params">(TreeNode root,List&lt;Integer&gt; results)</span></span>&#123;</div><div class="line">        <span class="comment">//遇到空节点，返回</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//root放入results,递归处理左右节点</span></div><div class="line">        results.add(root.val);</div><div class="line">        DFSRecurtion(root.left);</div><div class="line">        DFSRecurtion(root.right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSRecurtion</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        DFSRecurtionHelper(root,results);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="非递归（栈）"><a href="#非递归（栈）" class="headerlink" title="非递归（栈）"></a>非递归（栈）</h4><p>因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFSwithStack</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">        TreeNode temp = stack.pop();</div><div class="line">        results.add(temp.val);</div><div class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(temp.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     struct TreeLinkNode &#123;</div><div class="line">&gt;       TreeLinkNode *left;</div><div class="line">&gt;       TreeLinkNode *right;</div><div class="line">&gt;       TreeLinkNode *next;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li></ul><p>For example,<br>Given the following perfect binary tree,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2    3</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4  5  6  7</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>After calling your function, the tree should look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1 -&gt; NULL</div><div class="line">&gt;        /  \</div><div class="line">&gt;       2 -&gt; 3 -&gt; NULL</div><div class="line">&gt;      / \  / \</div><div class="line">&gt;     4-&gt;5-&gt;6-&gt;7 -&gt; NULL</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>就是将同一层上的节点的next指向右边的节点</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>tag是DFS，但我一开始想到的是BFS。</p><ol><li>BFS：</li></ol><p>将每一层节点加入队列，出队列时，左边节点的next指向右边节点。</p><p>但DFS会更快一些</p><ol><li>DFS：</li></ol><p>用DFS的核心思想是对于一个节点来说，将其左孩子的next指向右孩子，其右孩子的next指向其本身next节点的左孩子。</p><p>题目要求不能引入额外的空间，所以更应该用dfs的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersinEachNode</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> val;</div><div class="line">         TreeLinkNode left, right, next;</div><div class="line">         TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">     &#125;</div><div class="line"><span class="comment">//BFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">        Queue&lt;TreeLinkNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> len = queue.size();</div><div class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//如果是本层最后一个了，其next指向NULL</span></div><div class="line">                TreeLinkNode temp = queue.poll();</div><div class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</div><div class="line">                    temp.next = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果不是本层最后一个，其next指向下一个节点</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    temp.next = queue.peek();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">                    queue.add(temp.right);</div><div class="line">                &#125;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//DFS</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfshelper</span><span class="params">(TreeLinkNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</div><div class="line">            root.left.next = root.right;</div><div class="line">            <span class="keyword">if</span>(root.next !=<span class="keyword">null</span>)&#123;</div><div class="line">                root.right.next = root.next.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                root.right.next = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            dfshelper(root.left);</div><div class="line">            dfshelper(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//DFS</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDFS</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">         root.next = <span class="keyword">null</span>;</div><div class="line">         dfshelper(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \      \</div><div class="line">&gt;         7    2      1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p></blockquote><p>给定二叉树和一个整数sum,返回二叉树中是否存在一条从root到叶子的路径，长度为sum</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>DFS，分别对节点的左右孩子做DFS，sum需减掉当前节点的值。</p><p>当遇到叶子节点，且该点的值==sum时，即找到了一条合法路径，返回true</p><p>这里需要注意的是测试样例中有负数的情况，所以不能根据剩余的sum值进行剪枝。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfshelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="comment">//sum == root且root是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(sum == root.val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.left, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(dfshelper(root.right, sum - root.val))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dfshelper(root,sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Path Sum II</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; sum = 22</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;               5</div><div class="line">&gt;              / \</div><div class="line">&gt;             4   8</div><div class="line">&gt;            /   / \</div><div class="line">&gt;           11  13  4</div><div class="line">&gt;          /  \    / \</div><div class="line">&gt;         7    2  5   1</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>return</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [</div><div class="line">&gt;    [5,4,11,2],</div><div class="line">&gt;    [5,8,4,5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>跟上一题一样的，这次要把合法路径全都记录下来返回。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            result.add(root.val);</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            temp.addAll(result);</div><div class="line">            results.add(temp);</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.add(root.val);</div><div class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.left,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</div><div class="line">                helper(root.right,sum - root.val);</div><div class="line">            &#125;</div><div class="line">            result.remove(result.size()-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;</div><div class="line">        helper(root,sum);</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii" target="_blank" rel="external">Path Sum III</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</div><div class="line">&gt;</div><div class="line">&gt;       10</div><div class="line">&gt;      /  \</div><div class="line">&gt;     5   -3</div><div class="line">&gt;    / \    \</div><div class="line">&gt;   3   2   11</div><div class="line">&gt;  / \   \</div><div class="line">&gt; 3  -2   1</div><div class="line">&gt;</div><div class="line">&gt; Return 3. The paths that sum to 8 are:</div><div class="line">&gt;</div><div class="line">&gt; 1.  5 -&gt; 3</div><div class="line">&gt; 2.  5 -&gt; 2 -&gt; 1</div><div class="line">&gt; 3. -3 -&gt; 11</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>跟前面两道的不同是：起止点不一定是root和leaf可以是树中的任意两点</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>方法一：双层递归</p><p>对树中的每一个节点都进行搜索，从该点开始是否有合法路径。</p><p>可以转化为，对根节点搜索sum合法路径，然后对根节点的左右节点分别搜索sum合法路径，其中对其左右节点搜索合法路径时，也需要对其自身和其左右节点分别搜索，这是外层递归</p><p>搜索路径长度本身又是一层递归，每次减掉当前节点val，这是第二层递归</p><p>方法二：前缀长度</p><p>计算从root到每一个节点的路径长度，存储在一个hashmap中，key为root到树种节点的路径长度，value为出现次数。</p><p>当计算到某一个节点时，从root到该节点的路径长度为len，则以该节点为结尾的合法路径的个数为map中key为sum-len的value值。</p><p>注意：每次回退时需要将root到这点的路径长度在hashmap中的value-1。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>方法一：双层递归</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果到当前点已经是合法路径了，res+1</span></div><div class="line">        <span class="keyword">if</span>(root.val == sum)&#123;</div><div class="line">            res++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//接续沿着左右节点寻找是否还有合法路径</span></div><div class="line">        res += helper(root.left,sum - root.val);</div><div class="line">        res += helper(root.right,sum - root.val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：前缀搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumIII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left, right;</div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum,<span class="keyword">int</span> fromR)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = fromR + root.val;</div><div class="line">        res += map.getOrDefault(temp - sum,<span class="number">0</span>);</div><div class="line">        map.put(temp,map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</div><div class="line">        res = res + helper(root.left,sum,temp)+helper(root.right,sum,temp);</div><div class="line">        map.put(temp,map.get(temp)-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="comment">//从当前节点开始和为sum 和从左、右节点开始和为sum</span></div><div class="line">        <span class="keyword">return</span> helper(root,sum,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Path-Sum-IV"><a href="#Path-Sum-IV" class="headerlink" title="Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv" target="_blank" rel="external">Path Sum IV</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>If the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.</p><p>For each integer in this list:</p><ol><li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li><li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree.</li><li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li></ol><p>Given a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 215, 221]</div><div class="line">&gt; Output: 12</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is:</div><div class="line">&gt;     3</div><div class="line">&gt;    / \</div><div class="line">&gt;   5   1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 5) + (3 + 1) = 12.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [113, 221]</div><div class="line">&gt; Output: 4</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The tree that the list represents is: </div><div class="line">&gt;     3</div><div class="line">&gt;      \</div><div class="line">&gt;       1</div><div class="line">&gt;</div><div class="line">&gt; The path sum is (3 + 1) = 4.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>以数组的形式给定一棵二叉树，用三位数表示节点，其中百位代表层数，十位代表在某一层中从左到右的位置，各位代表节点数值，计算从root到每一个leaf的路径长度之和。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>假设一个几点的百位和十位是xy，则其左孩子和右孩子分别是：</p><p>left：(x+1)(2y-1)</p><p>right：(x+1)(2y)</p><p>可以根据这个性质，将数组中的节点放入hashmap中，key为百位十位，value为节点值。然后在map中寻找左右节点进行DFS，当遍历到叶子节点时，将本条路径长度加入路径长度总和。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> sum;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> root,<span class="keyword">int</span> res)</span></span>&#123;</div><div class="line">  res += map.get(root);</div><div class="line">  <span class="keyword">int</span> left = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> right = (root/<span class="number">10</span>+<span class="number">1</span>) * <span class="number">10</span> + (root%<span class="number">10</span>)*<span class="number">2</span>;</div><div class="line">  <span class="comment">//如果左右都没有了路径了，是叶子节点</span></div><div class="line">  <span class="keyword">if</span>(!map.containsKey(left) &amp;&amp; !map.containsKey(right))&#123;</div><div class="line">    sum += res;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果左边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(left))&#123;</div><div class="line">    dfs(map,left,res);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果右边有路径</span></div><div class="line">  <span class="keyword">if</span>(map.containsKey(right))&#123;</div><div class="line">    dfs(map,right,res);</div><div class="line">  &#125;</div><div class="line">  res -= map.get(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;nums.length;i++)&#123;</div><div class="line">    map.put(nums[i]/<span class="number">10</span>,nums[i] % <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">  dfs(map,<span class="number">11</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">Flatten Binary Tree to Linked List</a></h4><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;          1</div><div class="line">&gt;         / \</div><div class="line">&gt;        2   5</div><div class="line">&gt;       / \   \</div><div class="line">&gt;      3   4   6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>The flattened tree should look like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    1</div><div class="line">&gt;     \</div><div class="line">&gt;      2</div><div class="line">&gt;       \</div><div class="line">&gt;        3</div><div class="line">&gt;         \</div><div class="line">&gt;          4</div><div class="line">&gt;           \</div><div class="line">&gt;            5</div><div class="line">&gt;             \</div><div class="line">&gt;              6</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>将二叉树压到一条右子树上</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是要将每个节点左子树的前序遍历插入到右子树前面。</p><p>所以我的思路是如果遇到节点root有右子树，就先把右子树存下来，然后dfs处理左子树，当左子树处理完之后，再将右子树插入到左子树。</p><p>DSF的时候，把原来的左子树放到节点的右边，然后节点向下移动，递归处理左子树。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreetoLinkedList</span> </span>&#123;</div><div class="line">    TreeNode temp;<span class="comment">//记录当前节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果右节点不空，先把右边节点存下来</span></div><div class="line">        TreeNode right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            right = <span class="keyword">new</span> TreeNode(root.right.val);</div><div class="line">            right.left = root.right.left;</div><div class="line">            right.right = root.right.right;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果左子树非空，将左子树挪到右边，左子树置为空，temp下移，继续dfs temp的左子树</span></div><div class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = temp.left;</div><div class="line">            temp.left = <span class="keyword">null</span>;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果右节点非空，将之前记录下来的右子树放到temp右边，然后temp下移，继续dfs</span></div><div class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</div><div class="line">            temp.right = right;</div><div class="line">            temp = temp.right;</div><div class="line">            dfs(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        temp = root;</div><div class="line">        dfs(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的深度优先遍历&quot;&gt;&lt;a href=&quot;#二叉树的深度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的深度优先遍历&quot;&gt;&lt;/a&gt;二叉树的深度优先遍历&lt;/h2&gt;&lt;p&gt;DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回文问题</title>
    <link href="http://yoursite.com/2018/01/19/%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/19/回文问题/</id>
    <published>2018-01-19T05:55:25.000Z</published>
    <updated>2018-02-08T07:05:26.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串-Longest-Palindromic-Substring"><a href="#最长回文子串-Longest-Palindromic-Substring" class="headerlink" title="最长回文子串 Longest Palindromic Substring"></a>最长回文子串 <a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="external">Longest Palindromic Substring</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最长回文子串-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#最长回文子串-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串 Longest Palin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】数据结构</title>
    <link href="http://yoursite.com/2018/01/19/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/19/【九章算法基础班】数据结构/</id>
    <published>2018-01-19T03:44:41.000Z</published>
    <updated>2018-02-11T11:35:37.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ul><li>线性数据结构<ul><li>Queue</li><li>Stack</li><li>HashTable</li></ul></li><li>树形数据结构<ul><li>Heap/Priority Queue</li><li>TreeMap</li></ul></li></ul><h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><ul><li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li><li>考点：宽度优先搜索BFS</li><li>多做做BFS就可以了</li></ul><h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><ul><li>支持操作：Push/Pop/Top，时间复杂度都是<script type="math/tex">O(1)</script></li><li>考点：非递归实现DFS</li></ul><h3 id="例题Min-Stack"><a href="#例题Min-Stack" class="headerlink" title="例题Min Stack"></a>例题<a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="external">Min Stack</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; MinStack minStack = new MinStack();</div><div class="line">&gt; minStack.push(-2);</div><div class="line">&gt; minStack.push(0);</div><div class="line">&gt; minStack.push(-3);</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -3.</div><div class="line">&gt; minStack.pop();</div><div class="line">&gt; minStack.top();      --&gt; Returns 0.</div><div class="line">&gt; minStack.getMin();   --&gt; Returns -2.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>要求实现一个stack能够在0(1)时间内实现push(x),pop(),top(),getMin()获取最小值</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>额外维护一个stack，存储最小值</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; queue;</div><div class="line">    Stack&lt;Integer&gt; minqueue;</div><div class="line">    <span class="comment">//int min = Integer.MAX_VALUE;</span></div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        minqueue = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">if</span>(minqueue.isEmpty())&#123;</div><div class="line">            min = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (x &lt; minqueue.peek()) &#123;</div><div class="line">                min = x;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> min = minqueue.peek();</div><div class="line">        &#125;</div><div class="line">        minqueue.add(min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue.pop();</div><div class="line">        minqueue.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minqueue.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="external">Implement Queue using Stacks</a></h3><blockquote><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) — Push element x to the back of queue.</li><li>pop() — Removes the element from in front of queue.</li><li>peek() — Get the front element.</li><li>empty() — Return whether the queue is empty.</li></ul></blockquote><p>用stack实现queue</p><p>stack：先进后出</p><p>queue：先进先出</p><p>需要两个stack实现一个queue。</p><p>push时先将元素压入stack1，然后当pop时，如果stack2非空，就从stack2中pop出一个，否则将stack1中元素全部加入stcak2之后再pop</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack1;</div><div class="line">    Stack&lt;Integer&gt; stack2;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x to the back of queue. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        stack1.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the front element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                stack2.push(stack1.pop());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; stack1.isEmpty())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">Largest Rectangle in Histogram</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="img"></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="img"></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return <code>10</code>.</p></blockquote><p>求直方图中的最大举行的面积。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>baseline：</p><p>两个指针i和j分别从前往后扫描，k在i和j之间扫描，找i和j中间最低的柱子Kmin，计算Kmin*(j-i)的最大值。时间复杂度<script type="math/tex">O(n^3)</script></p><p>优化：</p><p>K从左向右遍历，在每一位置，向左看，找到左边第一个比它小的位置i，向右看，找到右边第一个比他小的位置j，此时矩形面积为<script type="math/tex">K*(j-i-1)</script> ，找到最小的即可。时间复杂度<script type="math/tex">O(n^2)</script></p><p>Stack：</p><p>对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左以及向右第一个小于bar n的bar的索引位置。</p><p>我们可以从左到右遍历所有bar，并将其push到一个stack中，如果当前bar的高度小于栈顶bar，我们pop出栈顶的bar，同时以该bar计算矩形面积。那么我们如何知道该bar的ln和rn呢？rn就是当前遍历到的bar的索引，而ln则是弹出当前元素之后的栈顶bar的索引，因为此时栈顶中的元素都是递增的。</p><p>为了更好的处理最后一个bar的情况，我们在实际中会插入一个高度为0的bar，这样就能pop出最后一个bar并计算了。</p><p>stack中存储的是下标！！！</p><p>时间复杂度<script type="math/tex">O(n)</script></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.length;i++)&#123;</div><div class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> size = heights[stack.pop()] * (i-stack.peek()-<span class="number">1</span>);</div><div class="line">                max = Math.max(max,size);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> size = heights[stack.pop()] * (heights.length-stack.peek()-<span class="number">1</span>);</div><div class="line">            max = Math.max(max,size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="external">Maximal Rectangle</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; 1 0 1 0 0</div><div class="line">&gt; 1 0 1 1 1</div><div class="line">&gt; 1 1 1 1 1</div><div class="line">&gt; 1 0 0 1 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>题目给定一个01矩阵，要求求出矩阵中面积最大的全1矩阵。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://upload-images.jianshu.io/upload_images/424375-2a5a361549e471e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>把每一行看作直方图的底，可以把这个题转化成上一道题，对每一行建立一个直方图，利用stack求直方图中的最大矩形，返回全局最大矩形的面积。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calMax</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span>[] heights)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights.length;j++)&#123;</div><div class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[j] &lt; heights[stack.peek()])&#123;</div><div class="line">                <span class="keyword">int</span> area = heights[stack.pop()] * (j - stack.peek()- <span class="number">1</span>);</div><div class="line">                max = Math.max(max,area);</div><div class="line">            &#125;</div><div class="line">            stack.push(j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">int</span> area = heights[stack.pop()] * (heights.length - stack.peek()- <span class="number">1</span>);</div><div class="line">            max = Math.max(max,area);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;matrix.length;i++)&#123;</div><div class="line">            <span class="comment">//计算本行heights</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</div><div class="line">                    heights[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heights[j] += <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxArea = Math.max(maxArea,calMax(matrix,heights));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="external">Implement Stack using Queues</a></h3><blockquote><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>empty() — Return whether the stack is empty.</li></ul></blockquote><p>题目要求用队列实现栈。</p><p>方法一：</p><p>用两个queue实现，push时间复杂度<script type="math/tex">O(1)</script> , pop时间复杂度<script type="math/tex">O(n)</script></p><p>push的时候加入queue1:</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-45-34.png" alt=""> </p><p>pop的时候利用queue1，每次pop的时候将queue1中的元素放到queue2，保留一个pop，然后再把queue1和queue2交换，此时queue2又是空的了。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-48-38.png" alt=""> </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue1.add(x);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.poll();</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> size = queue1.size();</div><div class="line">  <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">    size--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> res = queue1.peek();</div><div class="line">  queue2.add(queue1.remove());</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><p>用两个queue实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p><p>push时先将元素push进queue2,然后将queue2中元素加入queue2，然后交换queue1和queue2</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-02.png" alt=""> </p><p>pop时直接pop q1中元素</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-28-22-49-27.png" alt=""> </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue1;</div><div class="line">Queue&lt;Integer&gt; queue2;</div><div class="line"></div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Push element x onto stack. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  queue2.add(x);</div><div class="line">  <span class="keyword">while</span>(!queue1.isEmpty())&#123;</div><div class="line">    queue2.add(queue1.remove());</div><div class="line">  &#125;</div><div class="line">  Queue&lt;Integer&gt; temp = queue1;</div><div class="line">  queue1 = queue2;</div><div class="line">  queue2 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.poll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get the top element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.peek();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> queue1.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法三：</p><p>用一个队列实现，push时间复杂度<script type="math/tex">O(n)</script> , pop时间复杂度<script type="math/tex">O(1)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</div><div class="line">    Queue&lt;Integer&gt; queue;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Push element x onto stack. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        queue.add(x);</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</div><div class="line">            queue.add(queue.poll());</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.poll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get the top element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.peek();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Next-Greater-Element-I"><a href="#Next-Greater-Element-I" class="headerlink" title="Next Greater Element I"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="external">Next Greater Element I</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>‘s elements in the corresponding places of <code>nums2</code>.</p><p>The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</div><div class="line">&gt; Output: [-1,3,-1]</div><div class="line">&gt; Explanation:</div><div class="line">&gt;     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</div><div class="line">&gt;     For number 1 in the first array, the next greater number for it in the second array is 3.</div><div class="line">&gt;     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums1 = [2,4], nums2 = [1,2,3,4].</div><div class="line">&gt; Output: [3,-1]</div><div class="line">&gt; Explanation:</div><div class="line">&gt;     For number 2 in the first array, the next greater number for it in the second array is 3.</div><div class="line">&gt;     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定数组nums2,nums1中的元素来自nums2,返回nums1中的元素在nums2中右边第一个比它的大元素。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>baseline：两层循环，在nums2中寻找右边第一个比它大的,时间复杂度<script type="math/tex">O(m*n)</script></p><p>优化：利用栈+hashmap</p><p>将nums2中元素依次入栈：</p><ol><li>如果当前元素&lt;栈顶元素,压栈</li><li>当前元素i&gt;栈顶元素j，弹出栈顶元素i，此时i右边第一个大于i的元素为j，可以加入hashmap中</li><li>一次出栈之后如果还是满足当前元素i&gt;栈顶元素j，重复2知道栈为空或者站顶元素&gt;当前元素，将i压栈</li></ol><p>时间复杂度<script type="math/tex">O(m+n)</script></p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">    LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums1.length;i++)&#123;</div><div class="line">        map.put(nums1[i],-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums2.length;i++)&#123;</div><div class="line">        <span class="comment">//如果栈空，入栈</span></div><div class="line">        <span class="keyword">if</span>(stack.isEmpty() || nums2[i] &lt; stack.peek())&#123;</div><div class="line">            stack.push(nums2[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</div><div class="line">                <span class="keyword">int</span> val = stack.pop();</div><div class="line">                <span class="keyword">if</span>(map.containsKey(val))&#123;</div><div class="line">                    map.put(val,nums2[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            stack.push(nums2[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(Integer val:map.values())&#123;</div><div class="line">        result[ii] = val;</div><div class="line">        ii++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Next-Greater-Element-II"><a href="#Next-Greater-Element-II" class="headerlink" title="Next Greater Element II"></a><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="external">Next Greater Element II</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,1]</div><div class="line">&gt; Output: [2,-1,2]</div><div class="line">&gt; Explanation: The first 1&apos;s next greater number is 2; </div><div class="line">&gt; The number 2 can&apos;t find next greater number; </div><div class="line">&gt; The second 1&apos;s next greater number needs to search circularly, which is also 2.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个循环数组，返回数组中每个数字x右边第一个比x大的数字</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>和上一题一样的思路，但这次需要吧数组扩大2倍，做同样的操作</p><p>加入stack的元素是数组的下标，这样可以方便后面存储比x大的数字。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    Arrays.fill(result,-<span class="number">1</span>);</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>*nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(stack.isEmpty() || nums[stack.peek()] &gt;= nums[i%nums.length])&#123;</div><div class="line">            stack.push(i%nums.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i%nums.length])&#123;</div><div class="line">                <span class="keyword">int</span> idx = stack.pop();</div><div class="line">                result[idx] = nums[i%nums.length];</div><div class="line">            &#125;</div><div class="line">            stack.push(i%nums.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Decode-String"><a href="#Decode-String" class="headerlink" title="Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="external">Decode String</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an encoded string, return it’s decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</div><div class="line">&gt; s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</div><div class="line">&gt; s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>利用stack，从左向右遍历字符串：</p><ol><li>遇到数字：数字可能不止一位，因此继续遍历，累加数字，直到遇到非数字，将数字入栈</li><li>遇到字母和’[‘：入栈</li><li>遇到’]’：出栈，将字母加入字符串直到遇见’[‘，将’[‘弹出，将前面的数字弹出，计算完字符串之后入栈</li><li>重复上面操作，最后将stack中的字符串弹出连接成最终结果</li></ol><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder reusult = <span class="keyword">new</span> StringBuilder();</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; s.length())&#123;</div><div class="line">            <span class="comment">//数字</span></div><div class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                    num = num * <span class="number">10</span> + (s.charAt(i)-<span class="string">'0'</span>);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                stack.push(String.valueOf(num));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//字母和‘[’</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) != <span class="string">']'</span>)&#123;</div><div class="line">                stack.push(<span class="string">""</span> + s.charAt(i));</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                StringBuilder temp = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">while</span>(!stack.peek().equals(<span class="string">"["</span>))&#123;</div><div class="line">                    temp.insert(<span class="number">0</span>,stack.pop());</div><div class="line">                &#125;</div><div class="line">                stack.pop();</div><div class="line">                <span class="keyword">int</span> times = Integer.parseInt(stack.pop());</div><div class="line">                StringBuilder ntemp = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">while</span> (times &gt; <span class="number">0</span>)&#123;</div><div class="line">                    ntemp = ntemp.append(temp);</div><div class="line">                    times--;</div><div class="line">                &#125;</div><div class="line">                stack.push(ntemp.toString());</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            reusult.insert(<span class="number">0</span>,stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> reusult.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Remove-Duplicate-Letters"><a href="#Remove-Duplicate-Letters" class="headerlink" title="Remove Duplicate Letters"></a><a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank" rel="external">Remove Duplicate Letters</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p><p><strong>Example:</strong></p><p>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p><p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p></blockquote><p>移除字符串中重复的字母，保证字母间的相对顺序不变，返回结果中字典序最小的结果。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>这道题让我们移除重复字母，使得每个字符只能出现一次，而且结果要按字母顺序排，前提是不能打乱其原本的相对位置。我们的解题思路是：先建立一个哈希表来统计每个字母出现的次数，还需要一个visited数字来纪录每个字母是否被访问过，我们遍历整个字符串，对于遍历到的字符，先在哈希表中将其值减一，然后看visited中是否被访问过，若访问过则继续循环，说明该字母已经出现在结果中并且位置已经安排妥当。如果没访问过，我们和结果中最后一个字母比较，如果该字母的ASCII码小并且结果中的最后一个字母在哈希表中的值不为0(说明后面还会出现这个字母)，那么我们此时就要在结果中删去最后一个字母且将其标记为未访问，然后加上当前遍历到的字母，并且将其标记为已访问，以此类推直至遍历完整个字符串s，此时结果里的字符串即为所求。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">        map[s.charAt(i)-<span class="string">'a'</span>]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;<span class="keyword">if</span>(visited[s.charAt(i)-<span class="string">'a'</span>])&#123;</div><div class="line">            map[s.charAt(i)-<span class="string">'a'</span>]--;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; s.charAt(i) &lt; stack.peek().charAt(<span class="number">0</span>) &amp;&amp; map[stack.peek().charAt(<span class="number">0</span>)-<span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</div><div class="line">                visited[stack.peek().charAt(<span class="number">0</span>)-<span class="string">'a'</span>] = <span class="keyword">false</span>;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">            stack.push(String.valueOf(s.charAt(i)));</div><div class="line">            visited[s.charAt(i)-<span class="string">'a'</span>] = <span class="keyword">true</span>;</div><div class="line">            map[s.charAt(i)-<span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">        res.insert(<span class="number">0</span>,stack.pop());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Basic-Calculator"><a href="#Basic-Calculator" class="headerlink" title="Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="external">Basic Calculator</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <strong>non-negative</strong>integers and empty spaces ``.</p><p>You may assume that the given expression is always valid.</p><p>Some examples:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;1 + 1&quot; = 2</div><div class="line">&gt; &quot; 2-1 + 2 &quot; = 3</div><div class="line">&gt; &quot;(1+(4+5+2)-3)+(6+8)&quot; = 23</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>这道题让我们实现一个基本的计算器来计算简单的算数表达式，而且题目限制了表达式中只有加减号，数字，括号和空格。我们需要一个栈来辅助计算，用个变量sign来表示当前的符号，由于有括号的存在，所以用变量res存储当前括号中计算的结果，将之前计算结果存在栈里。</p><p>我们遍历给定的字符串s：</p><ol><li>如果遇到了数字，由于可能是个多位数，所以我们要用while循环把之后的数字都读进来，然后用sign*num来更新结果res；</li><li>如果遇到了加号，则sign赋为1，如果遇到了符号，则赋为-1；</li><li>如果遇到了左括号，则把当前结果res和符号sign压入栈，res重置为0，sign重置为1；</li><li>如果遇到了右括号，结果res乘以栈顶的符号，栈顶元素出栈，结果res加上栈顶的数字，栈顶元素出栈。</li></ol><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; s.length())&#123;</div><div class="line">        <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i &lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                sum = sum*<span class="number">10</span> + s.charAt(i)-<span class="string">'0'</span>;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            res += sum * sign;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span>)&#123;</div><div class="line">            sign = -<span class="number">1</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">            stack.push(res);</div><div class="line">            stack.push(sign);</div><div class="line">            i++;</div><div class="line">            res = <span class="number">0</span>;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</div><div class="line">            res *= stack.pop();</div><div class="line">            res += stack.pop();</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">      <span class="keyword">else</span>&#123;i++;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Basic-Calculator-II"><a href="#Basic-Calculator-II" class="headerlink" title="Basic Calculator II"></a><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="external">Basic Calculator II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces ``. The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid.</p><p>Some examples:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; &quot;3+2*2&quot; = 7</div><div class="line">&gt; &quot; 3/2 &quot; = 1</div><div class="line">&gt; &quot; 3+5 / 2 &quot; = 5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>加减乘除运算，没有括号，求结果</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>用一个变量sign存储符号，用stack存储计算完的值。</p><p>遍历字符串：</p><ol><li>遇到符号：更新sign</li><li>遇到数字，计算数字num，根据sign的值入栈：<ol><li>sign==’+’:num入栈</li><li>sign==’-‘:-num入栈</li><li>sign==’*’:和栈顶元素做乘法后入栈</li><li>sign==’/‘:和栈顶元素做除法后入栈</li></ol></li><li>最后将栈中所有元素弹出做加法得到result</li></ol><p>总之核心思想就是将减法转化成相反数入栈，将*和/计算之后入栈，最后就都转化成加法了</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</div><div class="line">            <span class="comment">//记录符号</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'*'</span> || s.charAt(i) == <span class="string">'/'</span>)&#123;</div><div class="line">                sign = s.charAt(i);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果是数字</span></div><div class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</div><div class="line">                    sum = sum*<span class="number">10</span> + (s.charAt(i)-<span class="string">'0'</span>);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                i--;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</div><div class="line">                    stack.push(sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</div><div class="line">                    stack.push(-sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</div><div class="line">                    stack.push(stack.pop() * sum);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</div><div class="line">                    stack.push(stack.pop()/sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            res += stack.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Flatten-Nested-List-Iterator"><a href="#Flatten-Nested-List-Iterator" class="headerlink" title="Flatten Nested List Iterator"></a><a href="https://leetcode.com/problems/flatten-nested-list-iterator/" target="_blank" rel="external">Flatten Nested List Iterator</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a nested list of integers, implement an iterator to flatten it.</p><p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p><p><strong>Example 1:</strong><br>Given the list <code>[[1,1],2,[1,1]]</code>,</p><p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,1,2,1,1]</code>.</p><p><strong>Example 2:</strong><br>Given the list <code>[1,[4,[6]]]</code>,</p><p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,4,6]</code>.</p></blockquote><p>给定一个list，里面元素是nestedInteger,可能是Integer，也可能是个IntegerList,要求实现hasNext()和next()函数</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>利用stack</p><ol><li><p>初始化：将给定list中的元素都放入stack</p></li><li><p>在hasNext()中，如果栈顶元素是Integer直接返回true,如果不是Integer则是个List,遍历这个List将元素入栈。</p><p>循环上面的操作，直到栈空如果依然没有integer则返回false</p></li><li><p>next()函数直接pop()</p></li></ol><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenNestedListIterator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</div><div class="line">        <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line">        <span class="comment">// Return null if this NestedInteger holds a nested list</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line">        <span class="comment">// Return null if this NestedInteger holds a single integer</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack();</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = nestedList.size()-<span class="number">1</span>;i &gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">                stack.push(nestedList.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> stack.pop().getInteger();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (stack.peek().isInteger()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    List&lt;NestedInteger&gt; list = stack.pop().getList();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                        stack.push(list.get(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Simplify-Path"><a href="#Simplify-Path" class="headerlink" title="Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="external">Simplify Path</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an absolute path for a file (Unix-style), simplify it.</p><p>For example,<br><strong>path</strong> = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br><strong>path</strong> = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code></p><p><a href="https://leetcode.com/problems/simplify-path/description/#" target="_blank" rel="external">click to show corner cases.</a></p><p>Corner Cases:</p><ul><li>Did you consider the case where <strong>path</strong> = <code>&quot;/../&quot;</code>?<br>In this case, you should return <code>&quot;/&quot;</code>.</li><li>Another corner case is the path might contain multiple slashes <code>&#39;/&#39;</code> together, such as <code>&quot;/home//foo/&quot;</code>.<br>In this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</li></ul></blockquote><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>linux系统中<code>“../”</code>代表上层文件夹，<code>“./”</code>代表当前文件夹</p><p>利用stack存储路径</p><p>将给定字符串按“/”分割：</p><ol><li>遇到.和空字符串跳过，遇到“..”pop栈顶字符串</li><li>遇到正常字符串push(“/“+str)</li></ol><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(path.length()==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(String str : path.split(<span class="string">"/"</span>))&#123;</div><div class="line">            <span class="comment">//遇到..</span></div><div class="line">            <span class="keyword">if</span>(str.equals(<span class="string">".."</span>))&#123;</div><div class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">                    stack.pop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遇到.或者空字符串，跳过</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"."</span>) || str.equals(<span class="string">""</span>))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                stack.push(<span class="string">"/"</span>+str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</div><div class="line">            res.insert(<span class="number">0</span>,stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.length() == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="Verify Preorder Sequence in Binary Search Tree"></a><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/" target="_blank" rel="external">Verify Preorder Sequence in Binary Search Tree</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>验证一个序列是否是BST的中序遍历</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>BST根节点左边的元素都比根节点小，右边的元素都比跟节点大</p><p>利用这个性质，用一个栈和一个low变量来维护遍历过程</p><p>当出现比根大的元素之后，说明在根节点的右子树，此后就不可能出现比根小的元素了</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : preorder)&#123;</div><div class="line">            <span class="keyword">if</span>(p &lt; low)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; p&gt;stack.peek())&#123;</div><div class="line">                low = stack.pop();</div><div class="line">            &#125;</div><div class="line">            stack.push(p);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Mini-Parser"><a href="#Mini-Parser" class="headerlink" title="Mini Parser"></a><a href="https://leetcode.com/problems/mini-parser/" target="_blank" rel="external">Mini Parser</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p><p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p><p><strong>Note:</strong> You may assume that the string is well-formed:</p><ul><li>String is non-empty.</li><li>String does not contain white spaces.</li><li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given s = &quot;324&quot;,</div><div class="line">&gt;</div><div class="line">&gt; You should return a NestedInteger object which contains a single integer 324.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given s = &quot;[123,[456,[789]]]&quot;,</div><div class="line">&gt;</div><div class="line">&gt; Return a NestedInteger object containing a nested list with 2 elements:</div><div class="line">&gt;</div><div class="line">&gt; 1. An integer containing value 123.</div><div class="line">&gt; 2. A nested list containing two elements:</div><div class="line">&gt;     i.  An integer containing value 456.</div><div class="line">&gt;     ii. A nested list with one element:</div><div class="line">&gt;          a. An integer containing value 789.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>利用stack，每次遇到’[‘就新建一个nest放入stack,遇到，或者‘]’代表一个数字结束，放入栈顶的nest里</p><p>如果遇到的是‘]’还需要将栈顶的第一个nest嵌套入前一个nest中，最后栈中只有一个nest</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></div><div class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></div><div class="line"><span class="comment"> * public interface NestedInteger &#123;</span></div><div class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></div><div class="line"><span class="comment"> *     public NestedInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></div><div class="line"><span class="comment"> *     public NestedInteger(int value);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line"><span class="comment"> *     public boolean isInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></div><div class="line"><span class="comment"> *     public Integer getInteger();</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></div><div class="line"><span class="comment"> *     public void setInteger(int value);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></div><div class="line"><span class="comment"> *     public void add(NestedInteger ni);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></div><div class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) != <span class="string">'['</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.parseInt(s));</div><div class="line">        &#125;</div><div class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="comment">//NestedInteger nest = new NestedInteger();//存储当前未入栈nest</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</div><div class="line">            <span class="comment">//遇到'['新建一个NestedInteger放入栈里</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>)&#123;</div><div class="line">                stack.push(<span class="keyword">new</span> NestedInteger());</div><div class="line">                left = i+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//遇到','||']'将left和i之间的数字放入栈顶的nestedInteger里</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">','</span> || s.charAt(i) == <span class="string">']'</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(left &lt; i)&#123;</div><div class="line">                    NestedInteger nest = <span class="keyword">new</span> NestedInteger(Integer.parseInt(s.substring(left,i)));</div><div class="line">                    NestedInteger top = stack.pop();</div><div class="line">                    top.add(nest);</div><div class="line">                    stack.push(top);</div><div class="line">                &#125;</div><div class="line">                left = i+<span class="number">1</span>;</div><div class="line">              <span class="comment">//遇到']'，将stack中nested嵌套，最后只剩一个nest</span></div><div class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">']'</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(stack.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">                        NestedInteger first = stack.pop();</div><div class="line">                        NestedInteger second = stack.pop();</div><div class="line">                        second.add(first);</div><div class="line">                        stack.push(second);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="Verify Preorder Serialization of a Binary Tree"></a><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="external">Verify Preorder Serialization of a Binary Tree</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;      _9_</div><div class="line">&gt;     /   \</div><div class="line">&gt;    3     2</div><div class="line">&gt;   / \   / \</div><div class="line">&gt;  4   1  #  6</div><div class="line">&gt; / \ / \   / \</div><div class="line">&gt; # # # #   # #</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>#</code>represents a null node.</p><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p><p>Each comma separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing <code>null</code> pointer.</p><p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>&quot;1,,3&quot;</code>.</p><p><strong>Example 1:</strong><br><code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code><br>Return <code>true</code></p><p><strong>Example 2:</strong><br><code>&quot;1,#&quot;</code><br>Return <code>false</code></p><p><strong>Example 3:</strong><br><code>&quot;9,#,#,1&quot;</code><br>Return <code>false</code></p></blockquote><p>给定一个二叉树的前序遍历，#代表空节点，判断是否是一个二叉树</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用stack</p><p>遍历节点，压栈，如果遇到“#”，且当前栈顶也是“#”说明栈顶#前面的那个节点已经有两个空子节点了，则将栈顶的#和前一个节点弹出，压入一个“#”表示空节点，有点类似于剪枝，下面的如果是二叉树，就剪枝。</p><p>过程中如果有stack为空，则不是二叉树</p><p>最后如果栈里只剩一个“#”了就是二叉树</p><p>方法二：</p><p>根据节点的出度和入度</p><p>二叉树中，每增加一个非叶子节点增加2个出度1个入度，增加一个叶子节点增加0个出度1个入度</p><p>用一个变量diff记录出度-入度的差</p><p>跟节点时diff=1;</p><p>每增加一个非叶子节点diff+1;</p><p>每增加一个叶子节点diff-1;</p><p>在这个过程中diff应该恒大于0.</p><p>最后满二叉树的出度应该等于入度</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</div><div class="line">    String[] str = preorder.split(<span class="string">","</span>);</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length;i++)&#123;</div><div class="line">        <span class="keyword">while</span> (str[i].equals(<span class="string">"#"</span>) &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek().equals(<span class="string">"#"</span>))&#123;</div><div class="line">            stack.pop();</div><div class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        stack.push(str[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stack.size()==<span class="number">1</span> &amp;&amp; stack.peek().equals(<span class="string">"#"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</div><div class="line">    String[] str = preorder.split(<span class="string">","</span>);</div><div class="line">    <span class="keyword">int</span> diff = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length;i++)&#123;</div><div class="line">        diff--;</div><div class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!str[i].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            diff+=<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> diff==<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Closest-Binary-Search-Tree-Value-II"><a href="#Closest-Binary-Search-Tree-Value-II" class="headerlink" title="Closest Binary Search Tree Value II"></a><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="external">Closest Binary Search Tree Value II</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>给定一个BST，一个target，一个k</p><p>返回BST中和target最接近的k个节点的值。</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>根据性质BST的中序遍历是递增序列</p><p>所以用栈实现BST的中序遍历。又因为求k个最接近的，也就是差值的绝对值最小的k个，可以用维护一个最大堆的方法。</p><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> val;</div><div class="line">            <span class="keyword">double</span> delta;</div><div class="line">            Node(<span class="keyword">int</span> val,<span class="keyword">double</span> delta)&#123;</div><div class="line">                <span class="keyword">this</span>.delta = delta;</div><div class="line">                <span class="keyword">this</span>.val = val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Comparator&lt;Node&gt; cmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o2.delta &gt; o1.delta)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</div><div class="line">        <span class="comment">//中序遍历</span></div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        TreeNode curt = root;</div><div class="line">        <span class="keyword">while</span> (curt != <span class="keyword">null</span> || !stack.isEmpty())&#123;</div><div class="line">            <span class="keyword">while</span>(curt!= <span class="keyword">null</span>)&#123;</div><div class="line">                stack.push(curt);</div><div class="line">                curt = curt.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">                curt = stack.pop();</div><div class="line">                <span class="keyword">int</span> val = curt.val;</div><div class="line">                <span class="comment">//System.out.println(val);</span></div><div class="line">                <span class="keyword">double</span> delta = Math.abs(target-val);</div><div class="line">                <span class="keyword">if</span>(heap.size() == k &amp;&amp; delta &gt; heap.peek().delta)&#123;</div><div class="line">                    <span class="comment">//System.out.println("hh");</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    heap.add(<span class="keyword">new</span> Node(val,delta));</div><div class="line">                    <span class="keyword">if</span>(heap.size() &gt; k)&#123;</div><div class="line">                        heap.poll();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                curt = curt.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</div><div class="line">            res.add(heap.poll().val);</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="哈希表Hash"><a href="#哈希表Hash" class="headerlink" title="哈希表Hash"></a>哈希表Hash</h1><h3 id="hash-特性"><a href="#hash-特性" class="headerlink" title="hash 特性"></a>hash 特性</h3><ul><li>支持操作：Insert/Find/Delete,时间复杂度都是<script type="math/tex">O(1)</script></li><li>Hash Table/Hash Map/Hash Set的区别是什么？<ul><li>hash set 只有key没有value</li><li>hash table是线程安全的数据结构，hash map线程不安全</li><li>多线程和多进程的区别：线程之间共享同一片内存</li><li>hash table有锁，可以保证同一时间只有一个进程对其进行操作，因此是线程安全的</li></ul></li></ul><h3 id="hash-Table实现"><a href="#hash-Table实现" class="headerlink" title="hash Table实现"></a>hash Table实现</h3><p>通过一个Hash function将key映射到一个大数组中，查找的时候计算下标，直接获取<script type="math/tex">O(1)</script></p><p>Hash function的设计：</p><ul><li>无冲突</li><li>大数组的长度大概是key数量的10倍以上才是安全的</li></ul><p>Hash 函数解决冲突的两种办法：</p><ol><li><p>open hashing</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-20-31.png" alt=""> </p><p>每个位置可以维护一个链表，插入时，遇到冲突就加到链表里；查找时，查找下标对应的链表</p></li><li><p>closed hashing</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-19-12-23-30.png" alt=""> </p><p>占坑，如果hash函数计算完发现自己的坑被占了，就依次向后找到空位放进去；查找时，hash函数计算应该在的位置，如果不是该元素，继续向后寻找直到空</p></li></ol><p>rehashing问题</p><p>当已经存储的元素个数已经超过大数组的1/10l了就需要扩大hash表数组了，这就是rehashing问题。</p><p>需要把hash表中现有的元素全部扫描一遍，重新计算其在新的大hash表中的位置，放到新位置。</p><h3 id="Max-Points-on-a-Line"><a href="#Max-Points-on-a-Line" class="headerlink" title="Max Points on a Line"></a><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="external">Max Points on a Line</a></h3><p>给定2维坐标平面上n个点，求最多有多少个点共线</p><p>遍历每一个点，针对每一个点，用hashmap记录其余跟该点共线的点的个数，key是斜率，value是个数，因为斜率相等的一定在同一直线。遇到跟该点重合的点需要单独累加个数</p><p>其中斜率要用分数形式存储，存分子和分母，这就需要计算最大公约数了。</p><p>计算最大公约数的方法：辗转相除法</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//求最大公约数，递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">if</span> (x%y == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> gcd(y,x%y);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">//求最大公约数，非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">while</span> (x%y != <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">int</span> temp = y;</div><div class="line">      y = x%y;</div><div class="line">      x = temp;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"> <span class="comment">//求最大公约数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> y;</div><div class="line">        <span class="keyword">while</span>(x%y != <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = x%y;</div><div class="line">            x = y;</div><div class="line">            y = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (points.length &lt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> points.length;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历每一个点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.length;i++)&#123;</div><div class="line">            HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap();<span class="comment">//存储斜率和个数</span></div><div class="line">            Point p = points[i];</div><div class="line">            <span class="keyword">int</span> selfoverlap = <span class="number">0</span>;<span class="comment">//记录与本身重合的点的个数</span></div><div class="line">            <span class="keyword">int</span> lineNum = <span class="number">0</span>;</div><div class="line">            <span class="comment">//遍历后面的点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; points.length;j++)&#123;</div><div class="line">                Point q = points[j];</div><div class="line">                <span class="keyword">int</span> delta_x = p.x-q.x;</div><div class="line">                <span class="keyword">int</span> delta_y = p.y-q.y;</div><div class="line">                <span class="comment">//重合的点，单独计算</span></div><div class="line">                <span class="keyword">if</span>(delta_x == <span class="number">0</span> &amp;&amp; delta_y == <span class="number">0</span>)&#123;</div><div class="line">                    selfoverlap++;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> maxCommon = gcd(delta_x,delta_y);</div><div class="line">                delta_x = delta_x/maxCommon;</div><div class="line">                delta_y = delta_y/maxCommon;</div><div class="line"></div><div class="line">                String k = delta_x +<span class="string">"/"</span>+ delta_y;</div><div class="line">                <span class="keyword">int</span> count = map.getOrDefault(k,<span class="number">0</span>)+<span class="number">1</span>;</div><div class="line">                map.put(k,count);</div><div class="line">                lineNum = Math.max(lineNum,count);</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res,lineNum + selfoverlap + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul><li><p>支持操作：Add <script type="math/tex">O(logN)</script>/Remove<script type="math/tex">O(logN)</script>/Min or Max<script type="math/tex">O(1)</script></p></li><li><p>heap可以用来求最大值或者最小值，不能同时求最大和最小值。</p></li><li><p>Heap结构：</p><p>一颗尽量填满的二叉树，每次插入节点时，插到最后一行的最左端的空余位置，如果本层没有空余位置了，另起一行。因此节点数目为N的堆对应的二叉树高度为<script type="math/tex">O(logN)</script></p></li></ul><ul><li><p>MaxHeap vs MinHeap</p><ul><li>MaxHeap：父亲节点比左右孩子都大</li><li>MinHeap：父亲节点比左右孩子都小</li></ul><p>因此当取最大或最小时，将root值取出即可，因此getMin/Max的时间复杂度为<script type="math/tex">O(1)</script></p></li><li><p>堆的存储</p><p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p><p>对于元素A[i]：</p><ul><li>父节点：A[i-2/2] (右移1)</li><li>左孩子：A[2i+1] (左移1，可得到2i)</li><li>右孩子：A[2i+2] (左移1，低位+1，可得到2i+1)</li></ul></li><li><p>插入操作</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中插入元素：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span><span class="number">3</span></div><div class="line">插入<span class="number">0</span>，因为第二行已经满了，加入到第三行最左边：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">2</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">0</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此，先交换<span class="number">0</span>和<span class="number">2</span>：</div><div class="line"><span class="number">1</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">0</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line"><span class="number">0</span></div><div class="line">  ↙  ↘</div><div class="line"> <span class="number">1</span><span class="number">3</span></div><div class="line">↙</div><div class="line"><span class="number">2</span></div><div class="line">此时满足最小堆条件了，因此，需要交换最多 O(logN)次，插入的时间复杂度为O(logN)</div></pre></td></tr></table></figure><p>​</p></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">例子：在最小堆中删除元素：</div><div class="line">      <span class="number">1</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span><span class="number">2</span></div><div class="line"> ↙  ↘       ↙  ↘</div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span><span class="number">100</span></div><div class="line">删除堆顶元素<span class="number">1</span>，用堆中最后一个节点替换堆顶元素：</div><div class="line">     <span class="number">100</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span><span class="number">2</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span></div><div class="line">此时这个堆已经不满足最小堆的条件（父亲节点都比孩子小）了，因此将堆顶元素下沉，选择左右孩子中较小的交换：</div><div class="line">      <span class="number">2</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span>  <span class="number">100</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">10</span></div><div class="line">此时仍然不满足最小堆条件，继续交换：</div><div class="line">      <span class="number">2</span></div><div class="line">    ↙  ↘</div><div class="line">   <span class="number">3</span>  <span class="number">10</span></div><div class="line"> ↙  ↘       ↙  </div><div class="line"><span class="number">4</span>      <span class="number">5</span> <span class="number">100</span></div><div class="line"></div><div class="line">好了，删好了</div></pre></td></tr></table></figure><p>PriorityQueue支持<script type="math/tex">O(logN)</script> 删除堆顶元素，但对于删除除root外的任意一点的操作，PriorityQueue的时间复杂度会降到<script type="math/tex">O(N)</script></p><p>Java中还有另外一种数据结构TreeMap，支持<script type="math/tex">O(logN)</script> 删除任意元素，而且支持同时获取最大和最小。</p><p>TreeMap是一平衡二叉搜索树，因此插入和删除任意元素的时间复杂度都是<script type="math/tex">O(logN)</script></p><p>|               | 用    | 原理          | 实现   |<br>| ——————- | —— | —————- | —— |<br>| TreeMap       | 必会   | 平衡二叉搜索树，红黑树 | 不需要  |<br>| PriorityQueue | 必会   | heap，二叉树    | 选做   |</p></li></ul><h2 id="leetcode相关习题"><a href="#leetcode相关习题" class="headerlink" title="leetcode相关习题"></a>leetcode相关习题</h2><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number" target="_blank" rel="external">Ugly Number</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p><p>Note that <code>1</code> is typically treated as an ugly number.</p></blockquote><p>检验输入数组num是否是unly number：因子只有2,3,5</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>思路就是把num中的2、3、5全部除掉，最后==1了就是ugly number，如果最后不是1，说明还有其他因数，因此返回false</p><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">            num /= <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="external">Ugly Number II</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p><p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p></blockquote><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>从1开始分别乘{2,3,5}，得到2,3,5是ugly number，然后对于2，依次乘2,3,5，得到4,6,10是ugly number，此时ugly number有：1,2,3,4,5,6,10，1,2处理过了，继续处理3，由此，我们需要一个最小堆来维护现有ugly number中还未与2,3,5相乘的最小的，相乘之后加入该堆，同时需要一个hashmap记录已经计算过的ugly number，以免重复入堆。</p><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumberII</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        Comparator&lt;Long&gt; cmp = <span class="keyword">new</span> Comparator&lt;Long&gt;()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long e1,Long e2)</span></span>&#123;</div><div class="line">                <span class="keyword">return</span> Long.compare(e1,e2);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue(cmp);</div><div class="line">        Long[] prime = &#123;Long.valueOf(<span class="number">2</span>),Long.valueOf(<span class="number">3</span>),Long.valueOf(<span class="number">5</span>)&#125;;</div><div class="line">        heap.add(Long.valueOf(<span class="number">1</span>));</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</div><div class="line">            Long ugly = heap.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i:prime)&#123;</div><div class="line">                <span class="keyword">if</span>(!set.contains(ugly*i))&#123;</div><div class="line">                    heap.add(ugly*i);</div><div class="line">                    set.add(ugly*i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> heap.peek().intValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Outline&quot;&gt;&lt;a href=&quot;#Outline&quot; class=&quot;headerlink&quot; title=&quot;Outline&quot;&gt;&lt;/a&gt;Outline&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;线性数据结构&lt;ul&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS &amp; DFS</title>
    <link href="http://yoursite.com/2018/01/16/BFS-DFS/"/>
    <id>http://yoursite.com/2018/01/16/BFS-DFS/</id>
    <published>2018-01-16T13:57:03.000Z</published>
    <updated>2018-02-08T07:05:26.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder" target="_blank" rel="external">Word Ladder</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p>For example,</p><p>Given:<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.</p></blockquote><p>给定起始单词和结束单词，利用wordlist中的单词爬梯子，每次只允许改变一个字母，返回能够到达结束词的最短路径长度</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一开始用了回溯，相当于暴力了所有可能，超时了，看了解答，这道题应该用广度优先搜索（BFS）：</p><p>需要用到队列<code>Queue</code></p><p>因为要求最短路径，如果我们用深度优先搜索的话必须遍历所有的路径才能确定哪个是最短的，而用广度优先搜索的话，一旦搜到目标就可以提前终止了，而且根据广度优先的性质，我们肯定是先通过较短的路径搜到目标。另外，为了避免产生环路和重复计算，我们找到一个存在于字典的新的词时，就要把它从字典中移去。这么做是因为根据广度优先，我们第一次发现词A的路径一定是从初始词到词A最短的路径，对于其他可能再经过词A的路径，我们都没有必要再计算了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] isUsed;</div><div class="line"></div><div class="line"><span class="comment">//判断两个单词是否只相差一个字母</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word1, String word2)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(word1.length() != word2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> diffSum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</div><div class="line">      diffSum++;</div><div class="line">      <span class="keyword">if</span>(diffSum &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</div><div class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.add(beginWord);</div><div class="line">  <span class="keyword">int</span> step = <span class="number">2</span>;<span class="comment">//记录层数</span></div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> queueSize = queue.size();<span class="comment">//当前queue长度</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; queueSize;i++)&#123;<span class="comment">//遍历queue中元素，将其后续节点入队列</span></div><div class="line">      String temp  = queue.peek();</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;wordList.size();j++)&#123;</div><div class="line">        <span class="comment">//如果该词与队列顶端元素只相差一个字母，入队列，标记为使用过</span></div><div class="line">        <span class="keyword">if</span>(!isUsed[j] &amp;&amp; isValid(temp,wordList.get(j)))&#123;</div><div class="line">          <span class="keyword">if</span>(wordList.get(j).equals(endWord))&#123;<span class="comment">//一旦找到了endword结束搜索，返回当前层数</span></div><div class="line">            <span class="keyword">return</span> step;</div><div class="line">          &#125;</div><div class="line">          queue.add(wordList.get(j));</div><div class="line">          isUsed[j] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      queue.poll();</div><div class="line">    &#125;</div><div class="line">    step++;<span class="comment">//层数+1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">  isUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</div><div class="line">  <span class="keyword">return</span> solve(beginWord,endWord,wordList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Word-Ladder&quot;&gt;&lt;a href=&quot;#Word-Ladder&quot; class=&quot;headerlink&quot; title=&quot;Word Ladder&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【DSP系统】Java UDP通信模拟监听模块</title>
    <link href="http://yoursite.com/2018/01/10/%E3%80%90DSP%E7%B3%BB%E7%BB%9F%E3%80%91Java-UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%8B%9F%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/01/10/【DSP系统】Java-UDP通信模拟监听模块/</id>
    <published>2018-01-10T15:52:29.000Z</published>
    <updated>2018-01-10T16:10:52.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ul><li>无连接，不可靠，会造成数据丢失</li><li>速度快，因为无需进行三次握手</li><li>限制数据传输大小64K</li></ul><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p>发送端模拟ADx发送竞价请求，这里采用从文件中按行读取数据，然后发送给接收端的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//DatagramSocket类表示用来发送和接收(udp)数据报包的套接字。</span></div><div class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</div><div class="line"></div><div class="line">  <span class="comment">//获取本机ip地址</span></div><div class="line">  String localIp = InetAddress.getLocalHost().getHostAddress();</div><div class="line"></div><div class="line">  <span class="comment">//读取文件名</span></div><div class="line">  String fileName = <span class="string">"D://datasets//ipinyou.contest.dataset//ipinyou.contest.dataset//training2nd//training2nd//conv.20130610.txt"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// read file content from file</span></div><div class="line">  <span class="comment">//StringBuffer sb= new StringBuffer("");</span></div><div class="line">  FileReader reader = <span class="keyword">new</span> FileReader(fileName);</div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">  String str = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//sb.append(str+"/n");</span></div><div class="line">    System.out.println(str);</div><div class="line"></div><div class="line">    <span class="comment">//需要发送的数据</span></div><div class="line">    <span class="comment">//byte[] buf = "Hello Udp".getBytes();</span></div><div class="line">    <span class="keyword">byte</span>[] buf = str.getBytes();</div><div class="line"></div><div class="line">    <span class="comment">//将数据传送到本地ip，端口为9999</span></div><div class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getByName(localIp), <span class="number">9999</span>);</div><div class="line"></div><div class="line">    <span class="comment">//发送数据报包</span></div><div class="line">    ds.send(dp);</div><div class="line">  &#125;</div><div class="line">  br.close();</div><div class="line">  reader.close();</div><div class="line"></div><div class="line">  <span class="comment">//关闭资源</span></div><div class="line">  ds.close();</div><div class="line">  System.out.println(<span class="string">"Done."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenModule</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建udp服务对象，指定接收端口号为9999的报包</span></div><div class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</div><div class="line"></div><div class="line">        <span class="comment">//构造空的数据报包， 用于存储待会接收到的数据报包</span></div><div class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//接收数据</span></div><div class="line">            ds.receive(dp);</div><div class="line"></div><div class="line">            <span class="comment">//显示数据</span></div><div class="line">            String ipAddress = dp.getAddress().getHostAddress();</div><div class="line">            <span class="keyword">int</span> port = dp.getPort();</div><div class="line">            String datas = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line">            <span class="comment">//System.out.println(ipAddress + "::" + datas + "::" + port);</span></div><div class="line">            System.out.println(datas);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ds.close();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行时先运行接收端，后运行发送端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UDP特点&quot;&gt;&lt;a href=&quot;#UDP特点&quot; class=&quot;headerlink&quot; title=&quot;UDP特点&quot;&gt;&lt;/a&gt;UDP特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无连接，不可靠，会造成数据丢失&lt;/li&gt;
&lt;li&gt;速度快，因为无需进行三次握手&lt;/li&gt;
&lt;li&gt;限制数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DSP系统mysql数据库搭建</title>
    <link href="http://yoursite.com/2018/01/09/DSP%E7%B3%BB%E7%BB%9Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/01/09/DSP系统mysql数据库搭建/</id>
    <published>2018-01-09T06:38:41.000Z</published>
    <updated>2018-01-09T06:38:41.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h2><h3 id="执行sql脚本方法："><a href="#执行sql脚本方法：" class="headerlink" title="执行sql脚本方法："></a>执行sql脚本方法：</h3><ol><li>cmd执行</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：</div><div class="line">mysql –uroot –p123456 -D database_name &lt; d:\<span class="built_in">test</span>\ss.sql</div></pre></td></tr></table></figure><ol><li>进入mysql的控制台后，使用source命令执行</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">Mysql&gt;</span><span class="bash"><span class="built_in">source</span> 【sql脚本文件的路径全名】 或 Mysql&gt;\. 【sql脚本文件的路径全名】，示例：</span></div><div class="line">source d:\test\ss.sql 或者 \. d:\test\ss.sql</div></pre></td></tr></table></figure><h3 id="从文件导入数据表"><a href="#从文件导入数据表" class="headerlink" title="从文件导入数据表"></a>从文件导入数据表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx;</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE xx (colA,colB);</div></pre></td></tr></table></figure><h3 id="auto-increment实现自动递增编号"><a href="#auto-increment实现自动递增编号" class="headerlink" title="auto_increment实现自动递增编号"></a>auto_increment实现自动递增编号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1.建表</div><div class="line">CREATE TABLE IF NOT EXISTS `Bid`(</div><div class="line">  `ID` bigint primary key not NULL auto_increment,</div><div class="line">  `BidId` varchar(255) DEFAULT NULL,</div><div class="line">)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</div><div class="line"><span class="meta">#</span><span class="bash"> AUTO_INCREMENT=0设置开始值</span></div><div class="line">2.导入数据</div><div class="line">LOAD DATA LOCAL INFILE "xxx.txt" INTO TABLE Bid (BidId);</div><div class="line">！！需要注意：利用auto_increment生成的列不能导入数据，只导入后面的字段</div></pre></td></tr></table></figure><h3 id="从一个表选取部分数据插入到另一个表"><a href="#从一个表选取部分数据插入到另一个表" class="headerlink" title="从一个表选取部分数据插入到另一个表"></a>从一个表选取部分数据插入到另一个表</h3><p>两个表都带有auto_increment列</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `bid_1458`;</div><div class="line">CREATE TABLE bid_1458 LIKE bid;</div><div class="line">insert into bid_1458 (colA,colB) select colA,colB from bid where AdvertiserID=1458;</div></pre></td></tr></table></figure><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="shell脚本调用sql"><a href="#shell脚本调用sql" class="headerlink" title="shell脚本调用sql"></a>shell脚本调用sql</h3><ol><li>脚本中执行mysql命令</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1、通过mysql的 -e 参数实现</div><div class="line">mysql -uuser -ppasswd -e "show databases;show databases;"</div><div class="line"></div><div class="line">2、通过echo实现</div><div class="line">echo "show databases;show databases"|mysql -uuser -ppassword</div><div class="line"></div><div class="line">3、通过EOF指定要执行的sql</div><div class="line">mysql -uroot  -ppassword &lt;&lt;EOF</div><div class="line">show databases;</div><div class="line">show databases;</div><div class="line">EOF</div><div class="line"></div><div class="line">关于EOF的说明：</div><div class="line">在主shell执行命令，进入其他的命令（如mysql），后面的输入，想作为其他命令（如mysql）的输入，而不是主shell的输入，使用&lt;&lt;EOF，告诉主shell，后续的输入，是其他命令或者子shell的输入，直到遇到EOF为止，再回到主shell。</div></pre></td></tr></table></figure><ol><li>脚本中执行mysql的sql文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">1. mysql -uroot -ppassword -e "source /root/temp.sql" </div><div class="line">2. mysql -uroot -ppassword &lt;/root/temp.sql</div></pre></td></tr></table></figure><h3 id="shell脚本字符串连接"><a href="#shell脚本字符串连接" class="headerlink" title="shell脚本字符串连接"></a>shell脚本字符串连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">AAA="abc"</div><div class="line">BBB="def"</div><div class="line">CCC=$AAA$BBB"ghi"</div><div class="line">echo $ccc</div></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">echo $contetn &gt; write.txt#写入</div><div class="line">echo $contetn &gt;&gt; write.txt#追加写入</div></pre></td></tr></table></figure><h2 id="ipinyou2nd数据分析"><a href="#ipinyou2nd数据分析" class="headerlink" title="ipinyou2nd数据分析"></a>ipinyou2nd数据分析</h2><h3 id="广告主"><a href="#广告主" class="headerlink" title="广告主"></a>广告主</h3><p>一共有5个广告主，其中有转化数据的只有3个：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; select distinct AdvertiserId from click;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3476 |</div><div class="line">|         3358 |</div><div class="line">|         3386 |</div><div class="line">|         3427 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select distinct AdvertiserId from conv;</div><div class="line">+--------------+</div><div class="line">| AdvertiserId |</div><div class="line">+--------------+</div><div class="line">|         3358 |</div><div class="line">|         3476 |</div><div class="line">|         1458 |</div><div class="line">+--------------+</div><div class="line">3 rows in set (0.06 sec)</div><div class="line">其中3476的数据相对较少</div></pre></td></tr></table></figure><p>AdvertiserID_3476</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">bid:<span class="number">6712268</span></div><div class="line">impression:<span class="number">1970360</span></div><div class="line">click:<span class="number">1092</span></div><div class="line">conv:<span class="number">27</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL操作&quot;&gt;&lt;a href=&quot;#MySQL操作&quot; class=&quot;headerlink&quot; title=&quot;MySQL操作&quot;&gt;&lt;/a&gt;MySQL操作&lt;/h2&gt;&lt;h3 id=&quot;执行sql脚本方法：&quot;&gt;&lt;a href=&quot;#执行sql脚本方法：&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】数与数组</title>
    <link href="http://yoursite.com/2017/12/24/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/12/24/【九章算法基础班】数与数组/</id>
    <published>2017-12-24T15:13:33.000Z</published>
    <updated>2018-02-08T07:05:26.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><ol><li>Sorted Array<ul><li>merge two sorted array<ul><li>Intersection of Two Arrays</li><li>Multiply Two Arrays</li></ul></li><li>median of two sorted array</li></ul></li><li>Subarray<ul><li>Best Time to Buy and Sekk Stoocks I,II,III</li><li>Subarrat I,II,III,IV</li></ul></li><li>Two pointers<ul><li>Two Sum,3Sum,4Sum,kSum,3Sum Closest</li><li>Partition Array</li></ul></li></ol><h1 id="排序数组Sorted-Array"><a href="#排序数组Sorted-Array" class="headerlink" title="排序数组Sorted Array"></a>排序数组Sorted Array</h1><h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array" target="_blank" rel="external">Merge Sorted Array</a></h3><blockquote><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong><br>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p></blockquote><p>给定两个排序数组nums1,nums2，合并到nums1</p><p>三个指针i,j,k分别指向nums1元素结尾，nums2结尾，nums1数组结尾</p><p>依次向前遍历，比较大小，插入nums1</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            k--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(j &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums2[j];</div><div class="line">                j--;</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(i &gt;=<span class="number">0</span>)&#123;</div><div class="line">                nums1[k] = nums1[i];</div><div class="line">                i--;</div><div class="line">                k--</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="external">Intersection of Two Arrays</a></h3><blockquote><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p><p><strong>Note:</strong></p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul></blockquote><p>给定两个数组，返回交集，返回的交集中在原数组中的相对位置保持不变，元素只出现一次。</p><p>方法:</p><ol><li>把两个数组排序</li><li>两指针分别遍历两个数组比较大小，如果两指针指向的元素相等，且与result中前一个元素不相等，加入result</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        <span class="comment">//排序</span></div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</div><div class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</div><div class="line">                <span class="keyword">if</span>(index == <span class="number">0</span> || nums1[i] != result[index-<span class="number">1</span>])&#123;</div><div class="line">                    result[index] = nums1[i];</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;nums2[j])&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                j++ ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>;idx &lt; index;idx++) &#123;</div><div class="line">            res[idx] = result[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Sparse-Matrix-Multiplication"><a href="#Sparse-Matrix-Multiplication" class="headerlink" title="Sparse Matrix Multiplication"></a><a href="https://leetcode.com/problems/sparse-matrix-multiplication/" target="_blank" rel="external">Sparse Matrix Multiplication</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank" rel="external">sparse matrices</a> <strong>A</strong> and <strong>B</strong>, return the result of <strong>AB</strong>.</p><p>You may assume that <strong>A</strong>‘s column number is equal to <strong>B</strong>‘s row number.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A = [</div><div class="line">&gt;   [ 1, 0, 0],</div><div class="line">&gt;   [-1, 0, 3]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; B = [</div><div class="line">&gt;   [ 7, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 0 ],</div><div class="line">&gt;   [ 0, 0, 1 ]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">&gt;      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</div><div class="line">&gt; AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</div><div class="line">&gt;                   | 0 0 1 |</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>逐个遍历计算</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">  <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">  <span class="keyword">int</span> A_rows = A.length;</div><div class="line">  <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">int</span> B_rows = B.length;</div><div class="line">  <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; A_cols;k++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i][k] != <span class="number">0</span> &amp;&amp; B[k][j] != <span class="number">0</span>)&#123;</div><div class="line">          result[i][j] = result[i][j] + A[i][k] * B[k][j];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优化</p><ol><li>遍历矩阵B，把B中值不为0的位置（注意是位置不是值）按每一列存下来</li><li>遍历A矩阵，寻找B中对应位置不为0的元素做乘积</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply2(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexB = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nonZeroIndexA = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</div><div class="line">    <span class="keyword">int</span> A_rows = A.length;</div><div class="line">    <span class="keyword">int</span> A_cols = A[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span> B_rows = B.length;</div><div class="line">    <span class="keyword">int</span> B_cols = B[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">    <span class="comment">//按列将B中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; B_cols;col++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; B_rows;row++)&#123;</div><div class="line">            <span class="keyword">if</span>(B[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(row);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexB.add(rowIndex);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//按行将A中的非零元素index存储下来</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; A_rows;row++)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; rowIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; A_cols;col++)&#123;</div><div class="line">            <span class="keyword">if</span>(A[row][col] != <span class="number">0</span>)&#123;</div><div class="line">                rowIndex.add(col);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonZeroIndexA.add(rowIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历矩阵A.B</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A_rows;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_cols;j++)&#123;</div><div class="line">           <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line">           <span class="keyword">int</span> jj = <span class="number">0</span>;;</div><div class="line">           <span class="keyword">while</span>(ii &lt; nonZeroIndexA.get(i).size() &amp;&amp; jj &lt; nonZeroIndexB.get(j).size())&#123;</div><div class="line">               <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) == nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   result[i][j] += A[i][nonZeroIndexA.get(i).get(ii)] * B[nonZeroIndexB.get(j).get(jj)][j];</div><div class="line">                   ii++;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nonZeroIndexA.get(i).get(ii) &lt; nonZeroIndexB.get(j).get(jj))&#123;</div><div class="line">                   ii++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> &#123;</div><div class="line">                   jj++;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array" target="_blank" rel="external">Kth Largest Element in an Array</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>在前面的课程里讲过可以利用堆Heap</p><p>方法二：</p><p>利用quickselect的方法，来源于quicksort</p><p>quicksort核心思想：每次选一个数字作为基准，比它小的放到左边，比它大的放到右边，然后再递归对左右两边数组做quicksort</p><p>步骤：从数组中选取一个数字作为“基准”pivot，找第K大的元素时可以跟基准比较：</p><ol><li>pivot左边元素个数 = K-1，该基准元素就是第K大元素</li><li>pivot左边元素个数 &gt; K-1，丢弃右边全部元素，在左边元素中继续寻找</li><li>pivot左边元素个数 &lt; K-1，丢弃左边全部元素，在右边元素中继续寻找</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="comment">//快速排序，寻找pivot应该放置的位置</span></div><div class="line">  <span class="keyword">int</span> i = start;</div><div class="line">  <span class="keyword">int</span> j = end;</div><div class="line">  <span class="keyword">int</span> pivot = nums[i];</div><div class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    nums[i] = nums[j];</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    nums[j]</div><div class="line">  nums[i] = pivot;</div><div class="line">  <span class="comment">//start~i-1的元素都小于等于pivot，一共用i-start个</span></div><div class="line">  <span class="comment">//i+1到end的元素都大于等于pivot，一共end-i个</span></div><div class="line">  <span class="keyword">if</span>(i-start == k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> quickselect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> quickselect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length+<span class="number">1</span>-k);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Median"><a href="#Median" class="headerlink" title="Median"></a><a href="http://www.lintcode.com/en/problem/median/" target="_blank" rel="external">Median</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a unsorted array with integers, find the median of it.</p><p>A median is the middle number of the array after it is sorted.</p><p>If there are even numbers in the array, return the <code>N/2</code>-th number after sorted.</p><p>Example</p><p>Given <code>[4, 5, 1, 2, 3]</code>, return <code>3</code>.</p><p>Given <code>[7, 9, 4, 5]</code>, return <code>5</code>.</p></blockquote><p>返回给定数组中位数</p><p>和上一题思路一样，K=nums.length/2</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = start;</div><div class="line">    <span class="keyword">int</span> j = end;</div><div class="line">    <span class="keyword">int</span> pivot = nums[i];</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        nums[i] = nums[j];</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        nums[j] = nums[i];</div><div class="line">    &#125;</div><div class="line">    nums[i] = pivot;</div><div class="line">    <span class="keyword">if</span>(i - start == k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i-start &gt; k-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,start,i-<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> quickSelect(nums,i+<span class="number">1</span>,end,k-(i-start+<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length - nums.length/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><blockquote><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 3]</div><div class="line">&gt; nums2 = [2]</div><div class="line">&gt;</div><div class="line">&gt; The median is 2.0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; nums1 = [1, 2]</div><div class="line">&gt; nums2 = [3, 4]</div><div class="line">&gt;</div><div class="line">&gt; The median is (2 + 3)/2 = 2.5</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>这道题在二分法里面讲过了，先将找中点的问题转化成找第k大的问题，然后继续沿用二分法中的思路。详见<a href="https://siyaozhang.github.io/2017/12/07/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/" target="_blank" rel="external">【九章算法基础班】二分法</a></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthInTwo</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> start1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> start2,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//end1中没有元素了，返回nums2中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start1 &gt;= nums1.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//end2中没有元素了，返回nums1中的第k个</span></div><div class="line">      <span class="keyword">if</span>(start2 &gt;= nums2.length)&#123;</div><div class="line">          <span class="keyword">return</span> nums1[start1+k-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line"><span class="comment">//边界条件，递归出口</span></div><div class="line">      <span class="keyword">if</span>(k ==<span class="number">1</span>)&#123;</div><div class="line">          <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//nums1中剩余元素不足K/2个,nums2的前K/2个元素一定在前k个中，</span></div><div class="line">      <span class="comment">// 去掉nums2的前K/2个元素</span></div><div class="line">      <span class="keyword">if</span>(nums1.length - start1 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(nums2.length - start2 &lt; k/<span class="number">2</span>)&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">     </div><div class="line">      <span class="keyword">if</span>(nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] &lt; nums2[start2 + k/<span class="number">2</span> - <span class="number">1</span>])&#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1+k/<span class="number">2</span>,nums2,start2,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,start1,nums2,start2+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> len = nums1.length+nums2.length;</div><div class="line">      <span class="comment">//偶数个元素</span></div><div class="line">      <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">int</span> k1 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>);</div><div class="line">          <span class="keyword">int</span> k2 = findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">          <span class="keyword">return</span> (<span class="keyword">double</span>) (k1+k2)/<span class="number">2.0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//奇数个元素</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> findKthInTwo(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h1 id="子数组-Subarray"><a href="#子数组-Subarray" class="headerlink" title="子数组 Subarray"></a>子数组 Subarray</h1><h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="external">Maximum Subarray</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p></blockquote><p>最大子数组，找到子数组（连续），和最大</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>前缀和数组prefixSum：<code>sum[i] = SUM(nums[0~i])</code></p><p>数组中从i到j的数组和：<code>sum[i~j] = sum[j]-sum[i-1]</code></p><p>以当前位置i为结尾的最大子数组是sum[i]-min(sum[0]~sum[i-1])</p><p>所以思路就是：从前向后遍历，三个变量存储信息：</p><ol><li>从起点到当前元素的和，前缀和</li><li>截止目前的最大子数组</li><li>前面的最小和</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录前缀和</span></div><div class="line">  <span class="keyword">int</span> min_before = <span class="number">0</span>;<span class="comment">//记录前面最小和,初始化为0,</span></div><div class="line">  <span class="keyword">int</span> max = Integer.MIN_VALUE;<span class="comment">//记录最大子数组</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    sum += nums[i];<span class="comment">//从0到当前元素的前缀和</span></div><div class="line">    max = Math.max(max,sum-min_before);<span class="comment">//更新最大子数组</span></div><div class="line">    min_before = Math.min(min_before,sum);<span class="comment">//更新前面最小和</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二维数组的Maximum-Subarray"><a href="#二维数组的Maximum-Subarray" class="headerlink" title="二维数组的Maximum Subarray"></a>二维数组的Maximum Subarray</h3><p>前缀和</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  i-1  i           x</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">j-1*---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line"> j *-[i,j]-*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">y  *---*---*---*-[x,y]</div><div class="line"></div><div class="line"></div><div class="line">sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</div></pre></td></tr></table></figure><h3 id="Range-Sum-Query-2D-Immutable"><a href="#Range-Sum-Query-2D-Immutable" class="headerlink" title="Range Sum Query 2D - Immutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-immutable" target="_blank" rel="external">Range Sum Query 2D - Immutable</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p><p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given matrix = [</div><div class="line">&gt;   [3, 0, 1, 4, 2],</div><div class="line">&gt;   [5, 6, 3, 2, 1],</div><div class="line">&gt;   [1, 2, 0, 1, 5],</div><div class="line">&gt;   [4, 1, 0, 1, 7],</div><div class="line">&gt;   [1, 0, 3, 0, 5]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt; sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">&gt; sumRegion(1, 1, 2, 2) -&gt; 11</div><div class="line">&gt; sumRegion(1, 2, 2, 4) -&gt; 12</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><ol><li>You may assume that the matrix does not change.</li><li>There are many calls to <em>sumRegion</em> function.</li><li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li></ol></blockquote><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>利用二维数组的前缀和，给定左上和右下的坐标为(row1, col1)， (row2, col2)</p><p>那么和为sum[i,j - x,y] = sum[x,y] - sum[x,j-1] - sum[i-1,y] + sum[i-1,j-1]</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] Matrix;</div><div class="line">    <span class="keyword">int</span>[][] Sum;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.Matrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">this</span>.Sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        Sum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix.length;i++)&#123;</div><div class="line">            Sum[i][<span class="number">0</span>] = Sum[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; matrix[<span class="number">0</span>].length;i++)&#123;</div><div class="line">            Sum[<span class="number">0</span>][i] = Sum[<span class="number">0</span>][i-<span class="number">1</span>] + matrix[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; matrix.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">                Sum[i][j] = Sum[i-<span class="number">1</span>][j] + Sum[i][j-<span class="number">1</span>] - Sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row2][col1 -<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Sum[row2][col2] - Sum[row1-<span class="number">1</span>][col2] - Sum[row2][col1 -<span class="number">1</span>] + Sum[row1-<span class="number">1</span>][col1 -<span class="number">1</span> ];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Range-Sum-Query-2D-Mutable"><a href="#Range-Sum-Query-2D-Mutable" class="headerlink" title="Range Sum Query 2D - Mutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-mutable" target="_blank" rel="external">Range Sum Query 2D - Mutable</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row</em>1, <em>col</em>1) and lower right corner (<em>row</em>2, <em>col</em>2).</p><p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="Range Sum Query 2D"><br>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Given matrix = [</div><div class="line">  [3, 0, 1, 4, 2],</div><div class="line">  [5, 6, 3, 2, 1],</div><div class="line">  [1, 2, 0, 1, 5],</div><div class="line">  [4, 1, 0, 1, 7],</div><div class="line">  [1, 0, 3, 0, 5]</div><div class="line">]</div><div class="line"></div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">update(3, 2, 2)</div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 10</div></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The matrix is only modifiable by the <em>update</em> function.</li><li>You may assume the number of calls to <em>update</em> and <em>sumRegion</em> function is distributed evenly.</li><li>You may assume that <em>row</em>1 ≤ <em>row</em>2 and <em>col</em>1 ≤ <em>col</em>2.</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> delta = val  - Matrix[row][col];<span class="comment">//更新值和原来差值</span></div><div class="line">  <span class="keyword">this</span>.Matrix[row][col] = val;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = row;i &lt; Matrix.length;i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = col;j  &lt; Matrix[<span class="number">0</span>].length;j++)&#123;</div><div class="line">      Sum[i][j] += delta;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="最小子数组"><a href="#最小子数组" class="headerlink" title="最小子数组"></a><a href="http://www.lintcode.com/en/problem/minimum-subarray/" target="_blank" rel="external">最小子数组</a></h3><blockquote><p>Given an array of integers, find the subarray with smallest sum.</p><p>Return the sum of the subarray.</p><p>Example</p><p>For <code>[1, -1, -2, 1]</code>, return <code>-3</code>.</p></blockquote><p>和最大子数组相同的思路</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArray</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> minsub = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">int</span> maxbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size();i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        minsub = Math.min(minsub,sum - maxbefore);</div><div class="line">        maxbefore = Math.max(maxbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minsub;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum" target="_blank" rel="external">Minimum Size Subarray Sum</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p></blockquote><p>求和大于等于s的连续子数组的最小长度</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口来做。</p><p>两个指针i和j分别指向子数组的头和尾</p><p>sumi代表从nums[0]到nums[i]的和</p><p>sumj代表从nums[0]到nums[j]的和</p><p>如果sumj-sumi &gt;= s，将i向后移动，直至sumj-sumi &lt; s，此时子数组和&gt;=s的长度为j-i+2，更新最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sumj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sumi = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length;j++)&#123;</div><div class="line">            sumj += nums[j];</div><div class="line">            <span class="keyword">int</span> delta = sumj - sumi;</div><div class="line">            <span class="keyword">while</span>(delta &gt;= s)&#123;</div><div class="line">                sumi += nums[i];</div><div class="line">                i++;</div><div class="line">                delta = sumj - sumi;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//跳出时sumj-sumi &lt; s</span></div><div class="line">            <span class="keyword">if</span>(sumj &gt;= s)&#123;</div><div class="line">                minlen = Math.min(minlen,j-i+<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minlen != Integer.MAX_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> minlen;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Subarray-II"><a href="#Maximum-Subarray-II" class="headerlink" title="Maximum Subarray II"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-ii/" target="_blank" rel="external">Maximum Subarray II</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of integers, find two non-overlapping subarrays which have the largest sum.<br>The number in each subarray should be contiguous.<br>Return the largest sum.</p><p>Example</p><p>For given <code>[1, 3, -1, 2, -1, 2]</code>, the two subarrays are <code>[1, 3]</code> and <code>[2, -1, 2]</code> or <code>[1, 3, -1, 2]</code> and <code>[2]</code>, they both have the largest sum <code>7</code>.</p></blockquote><p>求数组中两个不相交的最大子数组的和最大</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两个数组不相交，两个数组中间必然存在一个分割线，分割线左边求一个maxsubarray，右边求一个maxsubarray，两个子数组的和加在一起，就是当前分割线的最大子数组和</p><p>从左向右遍历分割线，分别求左边和右边的最大子数组，求和，记录最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubarray</span><span class="params">(List&lt;Integer&gt; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (start == end) &#123;</div><div class="line">        <span class="keyword">return</span> nums.get(start);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">int</span> minbefore = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</div><div class="line">        sum += nums.get(i);</div><div class="line">        maxSum = Math.max(maxSum,sum - minbefore);</div><div class="line">        minbefore = Math.min(minbefore,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTwoSubArrays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> sum = MaxSubarray(nums,<span class="number">0</span>,i) + MaxSubarray(nums,i+<span class="number">1</span>,nums.size()-<span class="number">1</span>);</div><div class="line">        maxSum = Math.max(maxSum,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray" target="_blank" rel="external">Maximum Product Subarray</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p></blockquote><p>求乘积最大的子数组</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>子数组乘积最大值的可能性为：累乘的最大值碰到了一个正数；或者，累乘的最小值（负数），碰到了一个负数。所以每次要保存累乘的最大（正数）和最小值（负数）。同时还有一个选择起点的逻辑，如果之前的最大和最小值同当前元素相乘之后，没有当前元素大（或小）那么当前元素就可作为新的起点，比如遇到了0。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//局部最大最小</span></div><div class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">    <span class="comment">//全局最大</span></div><div class="line">    <span class="keyword">int</span> global_max = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//计算局部最大和最小与当前数字的乘积</span></div><div class="line">        <span class="keyword">int</span> a = max * nums[i];</div><div class="line">        <span class="keyword">int</span> b = min * nums[i];</div><div class="line">        <span class="comment">//更新局部最大和最小，必在a,b,nums[i]之中</span></div><div class="line">        max = Math.max(Math.max(a,b),nums[i]);</div><div class="line">        min = Math.min(Math.min(a,b),nums[i]);</div><div class="line">        <span class="comment">//更新全局最大</span></div><div class="line">        global_max = Math.max(global_max,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>  global_max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="最大子数组差"><a href="#最大子数组差" class="headerlink" title="最大子数组差"></a><a href="http://www.lintcode.com/en/problem/maximum-subarray-difference/" target="_blank" rel="external">最大子数组差</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array with integers.</p><p>Find two <em>non-overlapping</em> subarrays <em>A</em> and <em>B</em>, which <code>|SUM(A) - SUM(B)|</code> is the largest.</p><p>Return the largest difference.</p><p>The subarray should contain at least one number</p><p>Example</p><p>For <code>[1, 2, -3, 1]</code>, return <code>6</code>.</p></blockquote><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两个不相交的数字，中间必然存在分割线，对分割线左右两边一编求最大一边求最小，<code>|SUM(A) - SUM(B)|</code>最大有两种情况：</p><ol><li>max_sum(A) - min_sum(B)</li><li>min_sum(A) - max_sum(B)</li></ol><p>遍历分割线，计算，取1,2的绝对值的最大值</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        max = Math.max(max,sum - min_before);</div><div class="line">        min_before = Math.min(min_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == end)&#123;<span class="keyword">return</span> nums[start];&#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max_before = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        min = Math.min(min,sum - max_before);</div><div class="line">        max_before = Math.max(max_before,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDiffSubArrays</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max_abs = Integer.MIN_VALUE;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> left_max = maxSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> left_min = minSubarray(nums,<span class="number">0</span>,i);</div><div class="line">        <span class="keyword">int</span> right_max = maxSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> right_min = minSubarray(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> max = Math.max(Math.abs(left_max - right_min),Math.abs(left_min - right_max));</div><div class="line">        max_abs = Math.max(max_abs,max);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max_abs;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="子数组之和"><a href="#子数组之和" class="headerlink" title="子数组之和"></a><a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="external">子数组之和</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an integer array, find a subarray where the sum of numbers is <strong>zero</strong>. Your code should return the index of the first number and the index of the last number.</p><p>There is at least one subarray that it’s sum equals to zero.</p><p>Given <code>[-3, 1, 2, -3, 4]</code>, return <code>[0, 2]</code> or <code>[1, 3]</code>.</p></blockquote><p>返回和为0的子数组开始和结尾所对应的idx</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>计算出每一个位置的前缀和，然后二重循环计算每一个子数组的和sum[i,j]，遇到有等于0的就返回，时间复杂度<script type="math/tex">O(n^2)</script>，超时了</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            prefixSum[i] = sum;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        prefixSum[nums.length] = sum;</div><div class="line">        System.out.println(prefixSum);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</div><div class="line">                <span class="keyword">if</span>(prefixSum[i] - prefixSum[j] == <span class="number">0</span>)&#123;</div><div class="line">                    result.add(j);</div><div class="line">                    result.add(i-<span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>改进，利用HashMap</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">根据给的例子：[-3, 1, 2, -3, 4]，其累加和:</div><div class="line"></div><div class="line">nums [-3, 1,  2, -3,  4]</div><div class="line">      0   1   2   3   4</div><div class="line">sum  [-3，-2， 0， -3， 1]</div><div class="line">       i           j</div><div class="line">1. i=2出现了一个数0 -&gt; sum[0,i] = 0  ,是一个答案</div><div class="line"></div><div class="line">2. 同时在i,j发现两个-3   -&gt; sum[i+1,j] = 0 ,是一个答案</div><div class="line">因此前缀和中如果有0或者有两个相等的，即为所求</div></pre></td></tr></table></figure><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="number">0</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">            result.add(map.get(sum)+<span class="number">1</span>);</div><div class="line">            result.add(i);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        map.put(sum,i);<span class="comment">//key是前缀和，value是idx</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k" target="_blank" rel="external">Subarray Sum Equals K</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:nums = [1,1,1], k = 2</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol></blockquote><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>跟上一题类似的思路，利用HashMap，存储前缀和的值和出现的次数，当有相同的前缀和出现时，result增加的数量就是当前map里面改值出现的次数。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="comment">//如果之前出现过该值</span></div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">                result += map.get(sum-k);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</div><div class="line">                map.put(sum,map.get(sum)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果之前没有出现过该值，加入map</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                map.put(sum,<span class="number">1</span>);<span class="comment">//key是前缀和，value是出现次数，初始化为1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Maximum-Size-Subarray-Sum-Equals-k"><a href="#Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="Maximum Size Subarray Sum Equals k"></a><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k" target="_blank" rel="external">Maximum Size Subarray Sum Equals k</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>nums</em> and a target value <em>k</em>, find the maximum length of a subarray that sums to <em>k</em>. If there isn’t one, return 0 instead.</p><p><strong>Note:</strong><br>The sum of the entire <em>nums</em> array is guaranteed to fit within the 32-bit signed integer range.</p><p><strong>Example 1:</strong></p><p>Given <em>nums</em> = <code>[1, -1, 5, -2, 3]</code>, <em>k</em> = <code>3</code>,<br>return <code>4</code>. (because the subarray <code>[1, -1, 5, -2]</code> sums to 3 and is the longest)</p><p><strong>Example 2:</strong></p><p>Given <em>nums</em> = <code>[-2, -1, 2, 1]</code>, <em>k</em> = <code>1</code>,<br>return <code>2</code>. (because the subarray <code>[-1, 2]</code> sums to 1 and is the longest)</p><p><strong>Follow Up:</strong><br>Can you do it in O(<em>n</em>) time?</p></blockquote><p>计算和为k的子数组的最大长度</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>利用hashmap将出现过的前缀和第一次出现所在的index记录下来，在hashmap中寻找sum[i]-k，若找到，子数组的长度为<code>i - map.get(sum-k)</code> ，记录下满足条件的子数组的最大长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//用以记录子数组的最大长度</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; nums.length;i++)&#123;</div><div class="line">        sum += nums[i];</div><div class="line">        <span class="comment">//如果之前出现过sum-k</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</div><div class="line">            maxlen = Math.max(maxlen,i - map.get(sum-k));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该值在map中没有出现过</span></div><div class="line">        <span class="keyword">if</span>(!map.containsKey(sum))&#123;</div><div class="line">            map.put(sum,i);<span class="comment">//key是前缀和，value是index</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Subarray-Sum-Closest"><a href="#Subarray-Sum-Closest" class="headerlink" title="Subarray Sum Closest "></a><a href="http://www.lintcode.com/en/problem/subarray-sum-closest/" target="_blank" rel="external">Subarray Sum Closest </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number</p><p>Example</p><p>Given <code>[-3, 1, 1, -3, 5]</code>, return <code>[0, 2]</code>, <code>[1, 3]</code>, <code>[1, 1]</code>, <code>[2, 2]</code> or <code>[0, 4]</code>.</p></blockquote><p>给定数组，返回和最接近0的子数组的开始和结束位置的index</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>计算前缀和，排序，取每一个位置的前缀和和相邻前缀和的差的最大值，记录其起点终点，取最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * @param nums: A list of integers</span></div><div class="line"><span class="comment">     * @return: A list of integers includes the index of the first number and the index of the last number</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">node</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> sum;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.sum = sum;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(node b)</span> </span>&#123;<span class="comment">// Comparable接口中的方法</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sum- b.sum; <span class="comment">// 按书的id比较大小，用于默认排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        node[] prefixSum = <span class="keyword">new</span> node[nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            prefixSum[i] = <span class="keyword">new</span> node(sum,i);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(prefixSum);</div><div class="line">        <span class="keyword">int</span> min = Math.abs(prefixSum[<span class="number">0</span>].sum);</div><div class="line">        <span class="keyword">int</span> min_a = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> min_b = prefixSum[<span class="number">0</span>].idx;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum);</div><div class="line">                min_a = -<span class="number">1</span>;</div><div class="line">                min_b = prefixSum[i].idx;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum) &lt; min)&#123;</div><div class="line">                min = Math.abs(prefixSum[i].sum - prefixSum[i-<span class="number">1</span>].sum);</div><div class="line">                min_a = prefixSum[i].idx;</div><div class="line">                min_b = prefixSum[i-<span class="number">1</span>].idx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> min_idx = Math.min(min_a,min_b);</div><div class="line">        <span class="keyword">int</span> max_idx = Math.max(min_a,min_b);</div><div class="line">      result[<span class="number">0</span>] = min_idx+<span class="number">1</span>;</div><div class="line">      result[<span class="number">1</span>] = max_idx;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Contiguous-Array"><a href="#Contiguous-Array" class="headerlink" title="Contiguous Array"></a><a href="https://leetcode.com/problems/contiguous-array" target="_blank" rel="external">Contiguous Array</a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [0,1,0]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p></blockquote><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>计算从0到i位中0的个数<code>zeroSum</code>和1的个数<code>oneSum</code>，以及0比1多多少<code>zeroMoreThanOne</code></p><p>利用hashmap将zeroMoreThanOne和index存储起来，当遇到zeroMoreThanOne == 0或者map.containsKey(zeroMoreThanOne )时说明遇到了01数量相等的子数组，记录最大长度</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</div><div class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存储0比1多多少idx</span></div><div class="line">    <span class="keyword">int</span> zeroSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> oneSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> zeroMoreThanOne = <span class="number">0</span>;</div><div class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">            zeroSum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            oneSum++;</div><div class="line">        &#125;</div><div class="line">        zeroMoreThanOne = zeroSum - oneSum;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(zeroMoreThanOne))&#123;</div><div class="line">            <span class="keyword">int</span> len = i - map.get(zeroMoreThanOne);</div><div class="line">            maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            map.put(zeroMoreThanOne,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Continuous-Increasing-Subsequence"><a href="#Longest-Continuous-Increasing-Subsequence" class="headerlink" title="Longest Continuous Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence" target="_blank" rel="external">Longest Continuous Increasing Subsequence</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,3,5,4,7]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </div><div class="line">&gt; Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,2,2,2]</div><div class="line">&gt; Output: 1</div><div class="line">&gt; Explanation: The longest continuous increasing subsequence is [2], its length is 1. </div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong> Length of the array will not exceed 10,000.</p></blockquote><p>求最长递增子数组</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从前向后遍历，两个变量<code>maxlen</code>，<code>len_local</code> 分别记录全局最长递增子数组和局部最长递增子数组的长度，如果</p><ol><li>nums[i]&gt;nums[i-1]，len_local++,更新maxlen</li><li>nums[i]&gt;nums[i-1]，len_local重置为1</li></ol><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxlen = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> len_local = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">            len_local++;</div><div class="line">            maxlen = Math.max(maxlen,len_local);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            len_local = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Degree-of-an-Array"><a href="#Degree-of-an-Array" class="headerlink" title="Degree of an Array"></a><a href="https://leetcode.com/problems/degree-of-an-array" target="_blank" rel="external">Degree of an Array</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a non-empty array of non-negative integers <code>nums</code>, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p><p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1, 2, 2, 3, 1]</div><div class="line">&gt; Output: 2</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The input array has a degree of 2 because both elements 1 and 2 appear twice.</div><div class="line">&gt; Of the subarrays that have the same degree:</div><div class="line">&gt; [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</div><div class="line">&gt; The shortest length is 2. So return 2.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [1,2,2,3,1,4,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><p><code>nums.length</code> will be between 1 and 50,000.</p><p><code>nums[i]</code> will be an integer between 0 and 49,999.</p></blockquote><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>方法一：利用hashmap存储元素出现的次数和第一次出现的idx，从前向后遍历，更新出现次数最多的元素和最小子数组长度</p><p>方法二：遍历数组，用left[val]和right[val]存储val出现的第一次和最后一次，记录出现次数最多的元素和最短长度</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> earlyIdx;</div><div class="line">    <span class="keyword">int</span> nums;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> nums)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.earlyIdx = idx;</div><div class="line">        <span class="keyword">this</span>.nums = nums;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;<span class="comment">//记录元素出现的最多次数</span></div><div class="line">    <span class="keyword">int</span> minlen = <span class="number">1</span>;<span class="comment">//记录最短长度</span></div><div class="line">    HashMap&lt;Integer,node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</div><div class="line">        <span class="comment">//如果之前有此元素了</span></div><div class="line">        <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</div><div class="line">            <span class="comment">//算上这次跟当前出现最多次数的元素一样</span></div><div class="line">            <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> == maxNum) &#123;</div><div class="line">                minlen = Math.min(minlen,i - map.get(nums[i]).earlyIdx+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//算上这次比当前出现最多次数的元素还多</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map.get(nums[i]).nums + <span class="number">1</span> &gt; maxNum) &#123;</div><div class="line">                maxNum = map.get(nums[i]).nums + <span class="number">1</span>;<span class="comment">//更新最多次数</span></div><div class="line">                minlen = i - map.get(nums[i]).earlyIdx+<span class="number">1</span>;<span class="comment">//更新最短长度</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//更新map</span></div><div class="line">            node newNode = <span class="keyword">new</span> node(map.get(nums[i]).earlyIdx,map.get(nums[i]).nums+<span class="number">1</span>);</div><div class="line">            map.put(nums[i],newNode);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            map.put(nums[i],<span class="keyword">new</span> node(i,<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water</a></h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p></blockquote><p>给定数组<em>a1</em>, <em>a2</em>, …, <em>an</em>,表示边界高度，选取其中两个作为边界，求能够容纳水的最大量。</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>若选取i,j作为边界，能够容纳的水量是：<script type="math/tex">(j-i) * min(a_i,a_j)</script></p><p>步骤：</p><ol><li>初始化：i指向height[0],j指向height[len-1]</li><li>两指针由外向内移动，记录最大的容水量：<ol><li>如果height[i] &lt; height[j],i++</li><li>如果height[i] &gt;= height[j],j—</li></ol></li></ol><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</div><div class="line">            max = Math.max(max,(j-i) *height[i]);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            max = Math.max(max,(j-i) * height[j]);</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Array-Nesting"><a href="#Array-Nesting" class="headerlink" title="Array Nesting"></a><a href="https://leetcode.com/problems/array-nesting" target="_blank" rel="external">Array Nesting</a></h3><blockquote><p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p><p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: A = [5,4,0,3,1,6,2]</div><div class="line">&gt; Output: 6</div><div class="line">&gt; Explanation: </div><div class="line">&gt; A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</div><div class="line">&gt;</div><div class="line">&gt; One of the longest S[K]:</div><div class="line">&gt; S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong></p><ol><li>N is an integer within the range [1, 20,000].</li><li>The elements of A are all distinct.</li><li>Each element of A is an integer within the range [0, N-1].</li></ol></blockquote><p>求数组中能够成环的最大长度</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>i从头向后遍历，以i为入口访问环，把访问过的标记为-1，记录最大长度</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;<span class="comment">//记录最大长度</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; nums.length;i ++)&#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//记录以i为入口的环长度</span></div><div class="line">            <span class="keyword">int</span> j = i;</div><div class="line">            <span class="keyword">while</span>(nums[j] != -<span class="number">1</span>)&#123;</div><div class="line">                len++;</div><div class="line">                <span class="keyword">int</span> temp = j;</div><div class="line">                j = nums[j];</div><div class="line">                nums[temp] = -<span class="number">1</span>;<span class="comment">//访问过的元素标记</span></div><div class="line">            &#125;</div><div class="line">           maxlen = Math.max(maxlen,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxlen;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Find-Pivot-Index"><a href="#Find-Pivot-Index" class="headerlink" title="Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index" target="_blank" rel="external">Find Pivot Index</a></h3><blockquote><p>Given an array of integers <code>nums</code>, write a method that returns the “pivot” index of this array.</p><p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p><p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 7, 3, 6, 5, 6]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation: </div><div class="line">&gt; The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.</div><div class="line">&gt; Also, 3 is the first index where this occurs.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: </div><div class="line">&gt; nums = [1, 2, 3]</div><div class="line">&gt; Output: -1</div><div class="line">&gt; Explanation: </div><div class="line">&gt; There is no index that satisfies the conditions in the problem statement.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>先计算数组的全部元素和<code>sum</code> ，再遍历一次，计算前缀和<code>prefixsum</code>，二者做差是右边的和，prefixsum-nums[i]是左边的和，二者相等就返回</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</div><div class="line">    sum += nums[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> prefixsum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</div><div class="line">    prefixsum += nums[i];</div><div class="line">    <span class="keyword">if</span>(sum - prefixsum == prefixsum - nums[i])&#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="external">Product of Array Except Self</a></h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>要分三种情况讨论：</p><ol><li>如果没有0，计算总乘积、当前乘积</li><li>有1个0，除了0位置不为0，其余位置都是0</li><li>有2个以上0，所有位置都为0</li></ol><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="keyword">int</span> zeros = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> zeroloc = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">      zeros += <span class="number">1</span>;</div><div class="line">      zeroloc = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      product *= nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(zeros == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;res.length;i++)&#123;</div><div class="line">      res[i] = product/nums[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(zeros == <span class="number">1</span>)&#123;</div><div class="line">    res[zeroloc] = product;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h1><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">Best Time to Buy and Sell Stock</a></h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 1, 5, 3, 6, 4]</div><div class="line">&gt; Output: 5</div><div class="line">&gt;</div><div class="line">&gt; max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [7, 6, 4, 3, 1]</div><div class="line">&gt; Output: 0</div><div class="line">&gt;</div><div class="line">&gt; In this case, no transaction is done, i.e. max profit = 0.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p> 第i天卖出所获的最大利润为：</p><p>prices[i] - min(prices[0]~prices[i-1])</p><p>步骤：从前向后遍历，更新到当前天的价格最低值，更新到当前天的利润最大值</p><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//记录最大利润</span></div><div class="line">  <span class="keyword">int</span> maxprofit = Integer.MIN_VALUE;</div><div class="line">  <span class="comment">//记录当前最低价格，初始化不能是0，应该是第一天的价格</span></div><div class="line">  <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">    maxprofit = Math.max(maxprofit,prices[i] - minprice);<span class="comment">//更新最大利润</span></div><div class="line">    minprice = Math.min(minprice,prices[i]);<span class="comment">//更新最低价格</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxprofit;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a></h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p></blockquote><p>相比Best Time to Buy and Sell Stock I，可以多次买卖，计算可获得的最大利润</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>计算每一天跟前一天的价格差，将价格差大于0 的利润累加，就是获得的最大利润</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> delta = prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(delta &gt; <span class="number">0</span>)&#123;</div><div class="line">            max += delta;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p></blockquote><p>可以交易两次，设计算法求出最大利润</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>可以交易两次，可将数组分成左右两段，分别计算左段和右段的最大值</p><p>可以采用两次遍历，第一次从左向右，计算从0到i的最大利润，存在<code>maxprofits[i]</code>里。</p><p>第二次从右向左，计算从i到0的最大利润</p><p>maxprofit[i] = maxprofitfromleft[i]+maxprofitfromright[i]</p><p>以第i天为分割点的最大利润 = 从0到i的最大利润+从i到末尾的最大利润之和</p><p>以第i天为分割点在左右同时计算，包含了只交易一次，即第i天不买不卖的操作</p><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxresult = <span class="number">0</span>;<span class="comment">//最终结果</span></div><div class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitfromleft = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] maxprofits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];<span class="comment">//记录从0到i的最大利润</span></div><div class="line">        <span class="comment">//计算从前到i最大利润</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">            minprice = Math.min(minprice,prices[i]);</div><div class="line">            maxprofitfromleft = Math.max(maxprofitfromleft,prices[i] - minprice);</div><div class="line">            maxprofits[i] = maxprofitfromleft;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//计算从后到i最大利润+从前导i-1最大利润和</span></div><div class="line">        <span class="keyword">int</span> maxprice = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">int</span> maxprofitformright = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</div><div class="line">            maxprice = Math.max(maxprice,prices[i]);<span class="comment">//从后向前最高价格</span></div><div class="line">            maxprofitformright = Math.max(maxprofitformright,maxprice - prices[i]);<span class="comment">//从后向前最大利润</span></div><div class="line">            maxresult = Math.max(maxresult,maxprofitformright + maxprofits[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxresult;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="external">Best Time to Buy and Sell Stock with Transaction Fee</a></h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p><p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p><p>Return the maximum profit you can make.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The maximum profit can be achieved by:</div><div class="line">&gt; Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>不限制交易次数，但需支付交易费用，求最大利润</p><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：</div><div class="line">cash:在第i天不持股所获最大利润</div><div class="line">hold:在第i天持股所获最大利润</div><div class="line"></div><div class="line">转移方程：</div><div class="line">在第i天cash状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天cash，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天hold，第i天卖出，收益prices[i]</div><div class="line">在第i天hold状态的例如来源于两个方面：</div><div class="line">  <span class="number">1</span>.前一天hold，第i天不操作</div><div class="line">  <span class="number">2</span>.前一天cash，第i天买入，扣去prices[i]和交易费用fee</div><div class="line">因此状态转移方程为：</div><div class="line">temp = cash</div><div class="line">cash = max(cash,hold + price[i])</div><div class="line">hold = max(hold,cash - price[i] - fee)</div><div class="line">  </div><div class="line">返回值：</div><div class="line">cash 最后一天结束时不持股的最大利润</div><div class="line"></div><div class="line">初始化：</div><div class="line">cash = <span class="number">0</span> 第<span class="number">0</span>天不持股，利润为<span class="number">0</span></div><div class="line">hold = -prices[<span class="number">0</span>] - fee 为了使第一天买入时利润为<span class="number">0</span>，将第<span class="number">0</span>天持股，利润设置为 ：-prices[<span class="number">0</span>] - fee</div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>] - fee;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">        <span class="keyword">int</span> temp = cash;</div><div class="line">            cash = Math.max(cash,hold + prices[i]);</div><div class="line">            hold = Math.max(hold,temp - prices[i] - fee);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cash;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费,扣交易费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，第i天买入，花费prices[i]+fee</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]-fee)</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[<span class="number">0</span>][<span class="number">1</span>] = -Infinity; </div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> profit[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  profit[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>] - fee;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">    profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">    profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] - fee);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="external">Best Time to Buy and Sell Stock with Cooldown</a></h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; prices = [1, 2, 3, 0, 2]</div><div class="line">&gt; maxProfit = 3</div><div class="line">&gt; transactions = [buy, sell, cooldown, buy, sell]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>买卖股票存在一天的冷却期，卖出股票后第二天不可以买入，需要冷却一天，求最大利润。</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][<span class="number">0</span>]表示到第i天，第i天不持股</div><div class="line">T[i][<span class="number">1</span>]表示到第i天，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">2</span>天不持股，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">0</span>],T[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][<span class="number">1</span>]，T[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>] = T[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">1</span>] = T[-<span class="number">1</span>][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>],-prices[<span class="number">1</span>]);</div><div class="line">        profit[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.length+<span class="number">1</span>;i++)&#123;</div><div class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">2</span>]);</div><div class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i-<span class="number">2</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit[prices.length+<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="external">Best Time to Buy and Sell Stock IV</a></h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p></blockquote><p>最多可以买卖k次，求最大收益</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>动态规划的思想，下面是一种通用解法，前面的题目也同样适用</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">规定：</div><div class="line"><span class="number">1</span>.买入时计算交易次数，扣费</div><div class="line"><span class="number">2</span>.卖出时计算收益</div><div class="line"></div><div class="line">符号定义：T表示收益</div><div class="line">T[i][k][<span class="number">0</span>]表示到第i天，交易k次，第i天不持股</div><div class="line">T[i][k][<span class="number">1</span>]表示到第i天，交易k次，第i天持股</div><div class="line"></div><div class="line">转移方程：</div><div class="line">【第i天交易k次不持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不卖：第i-<span class="number">1</span>天不持股，之前操作k次，第i天不操作</div><div class="line">    <span class="number">2</span>.卖：第i-<span class="number">1</span>天持股，之前操作k次，第i天卖掉，得到收益prices[i]</div><div class="line"></div><div class="line">【第i天交易k次持股】的状态可以由两种情况可以产生：</div><div class="line">    <span class="number">1</span>.不买：第i-<span class="number">1</span>天持股，之前操作k次，第i天不操作  </div><div class="line">    <span class="number">2</span>.买：第i-<span class="number">1</span>天不持股，之前操作k-<span class="number">1</span>次，第i天买入，花费prices[i]</div><div class="line"></div><div class="line">综上，转移方程为：</div><div class="line">T[i][k][<span class="number">0</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">0</span>],T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</div><div class="line">T[i][k][<span class="number">1</span>] = Math.max(T[i-<span class="number">1</span>][k][<span class="number">1</span>]，T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</div><div class="line">  </div><div class="line">初始化：</div><div class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = T[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//前i天无操作，利润为0；没有股票利润为0</span></div><div class="line">T[i][<span class="number">0</span>][<span class="number">1</span>] = T[-<span class="number">1</span>][k][<span class="number">1</span>] = -Infinity; <span class="comment">//前i天无操作持股，没有股票持股，不可能，利润为负无穷</span></div><div class="line"></div><div class="line">返回值：</div><div class="line">T[i][k][<span class="number">0</span>]:最后一天用光所有交易次数不持股的最大利润</div></pre></td></tr></table></figure><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(prices.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(prices[i] &gt;= prices[i-<span class="number">1</span>])&#123;</div><div class="line">        profit += prices[i] - prices[i-<span class="number">1</span>];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> profit;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[][][] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= prices.length;i++)&#123;<span class="comment">//前i天无操作，持股，不可能</span></div><div class="line">    profit[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k;i++)&#123;<span class="comment">//没有股票持股，不可能</span></div><div class="line">    profit[<span class="number">0</span>][i][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">1</span> ; kk &lt;= k ; kk++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= prices.length;i++)&#123;</div><div class="line">      profit[i][kk][<span class="number">0</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">0</span>],profit[i-<span class="number">1</span>][kk][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</div><div class="line">      profit[i][kk][<span class="number">1</span>] = Math.max(profit[i-<span class="number">1</span>][kk][<span class="number">1</span>],profit[i-<span class="number">1</span>][kk-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> profit[prices.length][k][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Two-Sum问题"><a href="#Two-Sum问题" class="headerlink" title="Two Sum问题"></a>Two Sum问题</h1><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum</a></h3><blockquote><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">&gt;</div><div class="line">&gt; Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">&gt; return [0, 1].</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>方法一：遍历，用hash表存储下来，然后遍历数组i,在hash表中查找是否有target-i</p><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">11</span>  <span class="number">18</span> ,target=<span class="number">16</span></div><div class="line">↑                ↑</div><div class="line">i                j</div><div class="line">步骤：</div><div class="line"><span class="number">1</span>. 排序，需要把元素在原来数组中的idx存下来</div><div class="line"><span class="number">2</span>. 两个指针i,j，i指向头，j指向尾</div><div class="line"><span class="number">3</span>.<span class="keyword">if</span>(nums[i]+nums[j] &lt; targert) i++</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] &gt; targert) j--</div><div class="line">  <span class="keyword">if</span>(nums[i]+nums[j] == targert) <span class="keyword">return</span></div></pre></td></tr></table></figure><p>若给定数组是有序的<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="external">Two Sum II - Input array is sorted</a>用方法二就非常简单了</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    Arrays.sort(nums);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</div><div class="line">            result[<span class="number">0</span>] = i;</div><div class="line">            result[<span class="number">1</span>] = j;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum</a></h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1, 0, 1],</div><div class="line">&gt;   [-1, -1, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法一：hash + 遍历 , 空间<script type="math/tex">O(n)</script> + 时间<script type="math/tex">O(n^2)</script></p><p>方法二：排序后two pointer，空间<script type="math/tex">O(1)</script> + 时间<script type="math/tex">O(n^2)</script></p><ol><li>排序</li><li>求a+b+c = target<br>固定a ， 然后对b + c利用Two Sum方法</li><li>需要注意的是遍历时要跳过重复的元素</li></ol><h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length -<span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到了一组解</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] == <span class="number">0</span>)&#123;</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        result.add(nums[a]);</div><div class="line">        result.add(nums[b]);</div><div class="line">        result.add(nums[c]);</div><div class="line">        results.add(result);</div><div class="line">        b++;</div><div class="line">        c--;</div><div class="line">        <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] == nums[b - <span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[c] == nums[c + <span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c]+ nums[a] &lt; <span class="number">0</span>)&#123;</div><div class="line">        b++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        c--;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a><a href="https://leetcode.com/problems/3sum-closest" target="_blank" rel="external">3Sum Closest</a></h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;     For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line">&gt;</div><div class="line">&gt;     The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>跟上一题一样的思路，计算nums[b] + nums[c] + nums[a] - target的值：</p><ol><li>nums[b] + nums[c] + nums[a] - target == 0，最小差为0，直接返回</li><li>nums[b] + nums[c] + nums[a] - target &lt; 0,跟新最小差，b++</li><li>nums[b] + nums[c] + nums[a] - target &gt; 0,跟新最小差，c—</li></ol><h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="keyword">int</span> min_delta = Integer.MAX_VALUE;<span class="comment">//记录最小差值</span></div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录最小差值时三个数字和</span></div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="comment">//找到和target相等的情况</span></div><div class="line">      <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] - target == <span class="number">0</span>)&#123;</div><div class="line">        sum = target;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        b++;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">          b++;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> delta = Math.abs(nums[b] + nums[c] + nums[a] - target);</div><div class="line">        <span class="keyword">if</span>(delta &lt; min_delta)&#123;</div><div class="line">          min_delta = delta;</div><div class="line">          sum = nums[b] + nums[c] + nums[a];</div><div class="line">        &#125;</div><div class="line">        c--;</div><div class="line">        <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[c] == nums[c+<span class="number">1</span>])&#123;</div><div class="line">          c--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3Sum-Smaller"><a href="#3Sum-Smaller" class="headerlink" title="3Sum Smaller"></a><a href="https://leetcode.com/problems/3sum-smaller" target="_blank" rel="external">3Sum Smaller</a></h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of <em>n</em> integers <em>nums</em> and a <em>target</em>, find the number of index triplets <code>i, j, k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p><p>For example, given <em>nums</em> = <code>[-2, 0, 1, 3]</code>, and <em>target</em> = 2.</p><p>Return 2. Because there are two triplets which sums are less than 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; [-2, 0, 1]</div><div class="line">&gt; [-2, 0, 3]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Follow up:</strong><br>Could you solve it in <em>O</em>(<em>n</em>2) runtime?</p></blockquote><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>这道题没有说清楚，重复的元素也可以，步骤如下：</p><ol><li>排序</li><li>从0到len-3遍历a，b从a+1到len-2，c从len-1到b+1</li><li>确定a和b的位置之后，c从后向前遍历，寻找第一个满足nums[b] + nums[c] + nums[a] &lt; target的位置，则从当前的b+1到找到的c的位置之间的c-b个位置都可以作为c，使得nums[b] + nums[c] + nums[a] &lt; target</li></ol><h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++) &#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (b &lt; c) &#123;</div><div class="line">      <span class="keyword">while</span> (b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &gt;= target) &#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[b] + nums[c] + nums[a] &lt; target,或者b==c了</span></div><div class="line">      <span class="comment">//找到了第一个c的位置使得nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[b] + nums[c] + nums[a] &lt; target)&#123;</div><div class="line">        res += c - b;<span class="comment">//b+1~c之间的元素都可以做c满足nums[b] + nums[c] + nums[a] &lt; target</span></div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a><a href="https://leetcode.com/problems/4sum" target="_blank" rel="external">4Sum</a></h3><blockquote><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p><p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</div><div class="line">&gt;</div><div class="line">&gt; A solution set is:</div><div class="line">&gt; [</div><div class="line">&gt;   [-1,  0, 0, 1],</div><div class="line">&gt;   [-2, -1, 1, 2],</div><div class="line">&gt;   [-2,  0, 0, 2]</div><div class="line">&gt; ]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>跟前面一样的思路，固定a，b对c,d做2Sum</p><h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="comment">//排序</span></div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">3</span>;a++)&#123;</div><div class="line">    <span class="comment">//跳过重复元素</span></div><div class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b = a+<span class="number">1</span>;b &lt; nums.length - <span class="number">2</span>;b++)&#123;</div><div class="line">      <span class="comment">//跳过重复元素</span></div><div class="line">      <span class="keyword">if</span>(b &gt; a+<span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//c和d做TwoSum</span></div><div class="line">      <span class="keyword">int</span> c = b+<span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> d = nums.length-<span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span>(c &lt; d)&#123;</div><div class="line">        <span class="comment">//找到了一组解</span></div><div class="line">        <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] == target)&#123;</div><div class="line">          ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">          result.add(nums[a]);</div><div class="line">          result.add(nums[b]);</div><div class="line">          result.add(nums[c]);</div><div class="line">          result.add(nums[d]);</div><div class="line">          results.add(result);</div><div class="line">          c++;</div><div class="line">          d--;</div><div class="line">          <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[c] == nums[c - <span class="number">1</span>])&#123;</div><div class="line">            c++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">while</span> (c &lt; d &amp;&amp; nums[d] == nums[d + <span class="number">1</span>])&#123;</div><div class="line">            d--;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] + nums[a] &lt; target)&#123;</div><div class="line">          c++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          d--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4Sum-II"><a href="#4Sum-II" class="headerlink" title="4Sum II"></a><a href="https://leetcode.com/problems/4sum-ii" target="_blank" rel="external">4Sum II</a></h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; A = [ 1, 2]</div><div class="line">&gt; B = [-2,-1]</div><div class="line">&gt; C = [-1, 2]</div><div class="line">&gt; D = [ 0, 2]</div><div class="line">&gt;</div><div class="line">&gt; Output:</div><div class="line">&gt; 2</div><div class="line">&gt;</div><div class="line">&gt; Explanation:</div><div class="line">&gt; The two tuples are:</div><div class="line">&gt; 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</div><div class="line">&gt; 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给四个数组，从每个数组中选一个数字，和为0的选择方案有多少</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>方法一：直接遍历四个数组，复杂度<script type="math/tex">O(n^4)</script></p><p>方法二：AB为一组，CD为一组，用两个hashmap记录两组中出现的和及其出现次数，互为相反数的和为0。</p><p>改进：存储两个hashmap再遍历速度很慢，所以只计算AB的和存入hashmap，然后计算CD时去AB的hashmap中寻找-sum出现的次数累加到result上即可。</p><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Integer,Integer&gt; mapab = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="comment">//计算AB的和，存入hashmap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sumab = A[i]+B[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(sumab))&#123;</div><div class="line">                    mapab.put(sumab,mapab.get(sumab)+<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    mapab.put(sumab,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length;j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum = C[i] + D[j];</div><div class="line">                <span class="keyword">if</span>(mapab.containsKey(-sum))&#123;</div><div class="line">                    result += mapab.get(-sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Valid-Triangle-Number"><a href="#Valid-Triangle-Number" class="headerlink" title="Valid Triangle Number"></a><a href="https://leetcode.com/problems/valid-triangle-number" target="_blank" rel="external">Valid Triangle Number</a></h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: [2,2,3,4]</div><div class="line">&gt; Output: 3</div><div class="line">&gt; Explanation:</div><div class="line">&gt; Valid combinations are: </div><div class="line">&gt; 2,3,4 (using the first 2)</div><div class="line">&gt; 2,3,4 (using the second 2)</div><div class="line">&gt; 2,2,3</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>选取三个数组作为三边长度，返回能够组成三角形的选取方案数</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>构成三角形条件：两边之和大于第三边</p><ol><li>排序，两个小边之和大于第三边</li><li>固定a，遍历b、c，寻找第一个nums[a] + nums[b] &gt; nums[c]的位置</li><li>bc之间的位置都可以作为c，使得nums[a] + nums[b] &gt; nums[c]，result+= c-b。</li></ol><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">  Arrays.sort(nums);</div><div class="line">  <span class="comment">//遍历a</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length - <span class="number">2</span>;a++)&#123;</div><div class="line">    <span class="comment">//b和c做TwoSum</span></div><div class="line">    <span class="keyword">int</span> b = a+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> c = nums.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b &lt; c)&#123;</div><div class="line">      <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &lt;= nums[c])&#123;</div><div class="line">        c--;</div><div class="line">      &#125;<span class="comment">//跳出时nums[a] + nums[b] &gt; nums[c]或者b==c</span></div><div class="line">      <span class="keyword">if</span>(b &lt; c &amp;&amp; nums[a] + nums[b] &gt; nums[c])&#123;</div><div class="line">        result += c-b;</div><div class="line">      &#125;</div><div class="line">      b++;</div><div class="line">      c = nums.length - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Partition类问题"><a href="#Partition类问题" class="headerlink" title="Partition类问题"></a>Partition类问题</h1><p>不开额外的空间，用两个指针分成两个、三个部分，利用quicksort的思想</p><h3 id="partition-Array"><a href="#partition-Array" class="headerlink" title="partition Array"></a><a href="http://www.lintcode.com/en/problem/partition-array/" target="_blank" rel="external">partition Array</a></h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array <code>nums</code> of integers and an int <code>k</code>, partition the array (i.e move the elements in “nums”) such that:</p><ul><li>All elements &lt; <em>k</em> are moved to the <em>left</em></li><li>All elements &gt;= <em>k</em> are moved to the <em>right</em></li></ul><p>Return the partitioning index, i.e the first index <em>i</em> nums[<em>i</em>] &gt;= <em>k</em>.</p><p>Example</p><p>If nums = <code>[3,2,2,1]</code> and <code>k=2</code>, a valid answer is <code>1</code>.</p></blockquote><h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>利用quicksort的思想，两指针一前一后向中间遍历，前面遇到大的，后面遇到小的交换，最后判断nums[j]和target的大小关系，返回结果。</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2018-01-02-10-28-18.png" alt=""> </p><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; k)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= k)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;<span class="comment">//j右边都&gt;=k</span></div><div class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[i];</div><div class="line">            nums[i] = nums[j];</div><div class="line">            nums[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(nums[j] &gt;= k)&#123;</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个指针，利用快速排序</p><h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a><a href="https://leetcode.com/problems/sort-colors" target="_blank" rel="external">Sort Colors</a></h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p></blockquote><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>方法一：计数排序，遍历，记录0,1,2出现的个数，然后重新输出，时间复杂度<script type="math/tex">O(n)</script></p><p>方法二：两次partition，先把0分一堆，1，2分一堆，然后再把1,2分开</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColorsPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">1</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">1</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">    <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对右半段，分成成左边都&lt;2，右边&gt;=2</span></div><div class="line">  j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; <span class="number">2</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇了</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt;= <span class="number">2</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇了</span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[j];</div><div class="line">      nums[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法三：背程序，三个指针三分法。</p><ol><li>i，j指向头和尾，mid在中间</li><li>mid向后遍历，遇到0与i交换，遇到2与j交换</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(mid &lt;= j)&#123;</div><div class="line">    <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">1</span>)&#123;</div><div class="line">      mid++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt;= j &amp;&amp; nums[mid] == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[i];</div><div class="line">      nums[i] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      mid++;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">int</span> temp = nums[j];</div><div class="line">      nums[j] = nums[mid];</div><div class="line">      nums[mid] = temp;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Sort-Colors-II"><a href="#Sort-Colors-II" class="headerlink" title="Sort Colors II"></a><a href="http://www.lintcode.com/en/problem/sort-colors-ii/" target="_blank" rel="external">Sort Colors II</a></h3><blockquote><p>Given an array of <em>n</em> objects with <em>k</em> different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k.</p><p>Example</p><p>Given colors=<code>[3, 2, 2, 1, 4]</code>, <code>k=4</code>, your code should sort colors in-place to <code>[1, 2, 2, 3, 4]</code>.</p></blockquote><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors2</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(colors.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = colors.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> kk = <span class="number">2</span>;</div><div class="line">    <span class="comment">//先分成左边都&lt;1，右边&gt;=1</span></div><div class="line">    <span class="keyword">while</span>(kk &lt;= k)&#123;</div><div class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[i] &lt; kk)&#123;</div><div class="line">                i++;</div><div class="line">            &#125;<span class="comment">//i是第一个&gt;=1的位置，或者是与j相遇且过了</span></div><div class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; colors[j] &gt;= kk)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;<span class="comment">//j是第一个&lt;1的位置，或者是与i相遇且过了</span></div><div class="line">            <span class="comment">//如果还未相遇，交换ij元素，如果恰好相遇，</span></div><div class="line">            <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">                <span class="keyword">int</span> temp = colors[i];</div><div class="line">                colors[i] = colors[j];</div><div class="line">                colors[j] = temp;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        j = colors.length-<span class="number">1</span>;</div><div class="line">        kk++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Sort-Letters-by-Case"><a href="#Sort-Letters-by-Case" class="headerlink" title="Sort Letters by Case"></a><a href="http://www.lintcode.com/en/problem/sort-letters-by-case/" target="_blank" rel="external">Sort Letters by Case</a></h3><h4 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string which contains only letters. Sort it by lower case first and upper case second.</p><p>For <code>&quot;abAcD&quot;</code>, a reasonable answer is <code>&quot;acbAD&quot;</code></p></blockquote><p>给一串字母，把小写的排在左边，大写的排在右边</p><h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortLetters</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</div><div class="line">  <span class="comment">// write your code here</span></div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = chars.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[i] &gt;= <span class="string">'a'</span>)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; chars[j] &lt;= <span class="string">'Z'</span>)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</div><div class="line">      <span class="keyword">char</span> temp = chars[i];</div><div class="line">      chars[i] = chars[j];</div><div class="line">      chars[j] = temp;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Interleaving-Positive-and-Negative-Numbers"><a href="#Interleaving-Positive-and-Negative-Numbers" class="headerlink" title="Interleaving Positive and Negative Numbers"></a><a href="http://www.lintcode.com/en/problem/interleaving-positive-and-negative-numbers/" target="_blank" rel="external">Interleaving Positive and Negative Numbers</a></h3><blockquote><p>Given an array with positive and negative integers. Re-range it to interleaving with positive and negative integers.</p><p>Example</p><p>Given <code>[-1, -2, -3, 4, 5, 6]</code>, after re-range, it will be <code>[-1, 5, -2, 4, -3, 6]</code> or any other reasonable answer.</p></blockquote><p>把正的和负的先都挑出来，然后交替放入数组。如果正的多余负的，先放正的，否则先放负的。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rerange</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] zheng = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="keyword">int</span>[] fu = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> zhengi = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fui = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; A.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)&#123;</div><div class="line">            fu[fui] = A[i];</div><div class="line">            fui++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            zheng[zhengi] = A[i];</div><div class="line">            zhengi++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fui &lt; zhengi)&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = zheng[zhengj];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> zhengj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> fuj = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; A.length-<span class="number">2</span>)&#123;</div><div class="line">            A[i] = fu[fuj];</div><div class="line">            fuj++;</div><div class="line">            i++;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">            zhengj++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        A[i] = fu[fuj];</div><div class="line">        i++;</div><div class="line">        <span class="keyword">if</span>(A.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            A[i] = zheng[zhengj];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Two-pointer问题"><a href="#Two-pointer问题" class="headerlink" title="Two pointer问题"></a>Two pointer问题</h1><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></h3><h4 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code>is a <em>subsequence</em> and not a substring.</p></blockquote><p>给定一个字符串，计算不包含重复字母的最长子串</p><h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>用滑动窗口做，窗口边界left、right，用数组<code>int[] map = new int[256]</code>存储当前窗口内出现的元素，用maxlen、len_local记录最大长度和当前窗口长度</p><ol><li>初始化left,right=0</li><li>right向后滑动，直至遇到窗口中已经存在该元素</li><li>left向后滑动，窗口缩小，直至将已经出现过的元素挪到窗口外面</li><li>循环更新local长度和全局最大长度</li></ol><h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> s.length();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  <span class="keyword">int</span> len_local = <span class="number">0</span>;<span class="comment">//局部长度</span></div><div class="line">  <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">  <span class="keyword">while</span>(right &lt; s.length())&#123;</div><div class="line">    <span class="comment">//如果字母还未出现过</span></div><div class="line">    <span class="keyword">if</span>(map[s.charAt(right)] == <span class="number">0</span>)&#123;</div><div class="line">      <span class="comment">//存入字母表</span></div><div class="line">      map[s.charAt(right)]++;</div><div class="line">      <span class="comment">//更新局部长度和全局最大长度</span></div><div class="line">      len_local++;</div><div class="line">      maxlen = Math.max(maxlen,len_local);</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//出现过</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//寻找之前该元素出现的位置</span></div><div class="line">      <span class="keyword">while</span> (s.charAt(left) != s.charAt(right))&#123;</div><div class="line">        <span class="comment">//路上把滑窗缩减的字母从字母表中去掉</span></div><div class="line">        map[s.charAt(left)]--;</div><div class="line">        left++;</div><div class="line">        len_local--;</div><div class="line">      &#125;<span class="comment">//跳出时left和right字母相等</span></div><div class="line">      left++;</div><div class="line">      right++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">Implement strStr()</a></h3><h4 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</div><div class="line">&gt; Output: 2</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</div><div class="line">&gt; Output: -1</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h4><p>方法一：双指针遍历比较判断每一个字符是否一样</p><p>方法二：<code>return haystack.indexOf(needle);</code></p><p>方法三：<code>haystack.substring(i, i + needle.length()).equals(needle)</code></p><h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(j &lt; haystack.length())&#123;</div><div class="line">    <span class="comment">//遇到相等的字母</span></div><div class="line">    <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(k))&#123;</div><div class="line">      <span class="comment">//j和k同时向后移动</span></div><div class="line">      <span class="keyword">while</span>(j &lt; haystack.length() &amp;&amp; k &lt; needle.length() &amp;&amp; haystack.charAt(j) == needle.charAt(k))&#123;</div><div class="line">        j++;</div><div class="line">        k++;</div><div class="line">      &#125;<span class="comment">//跳出时或者到头了或者有不相等的了</span></div><div class="line">      <span class="comment">//如果k到头了，说明已经包含了needls</span></div><div class="line">      <span class="keyword">if</span>(k == needle.length())&#123;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//j到头了，剩下的字符串不够长了，不可能包含了</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == haystack.length())&#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        i++;</div><div class="line">        j = i;</div><div class="line">        k = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不是相等的字母，ij向后移动</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      i++;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Vowels-of-a-String"><a href="#Reverse-Vowels-of-a-String" class="headerlink" title="Reverse Vowels of a String"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="external">Reverse Vowels of a String</a></h3><h4 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><p><strong>Example 1:</strong><br>Given s = “hello”, return “holle”.</p><p><strong>Example 2:</strong><br>Given s = “leetcode”, return “leotcede”.</p><p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p></blockquote><p>对换元音字母</p><h4 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h4><p>两指针一前一后向中间遍历，遇到元音对换即可。</p><p>这里需要注意的是java的String是不可更改的，需要用StringBuilder复制一份再做修改：<code>result.setCharAt(i,s.charAt(j))</code>;</p><h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseVowelsofaString</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span></div><div class="line">                || ch == <span class="string">'A'</span> || ch == <span class="string">'E'</span> || ch == <span class="string">'I'</span> || ch == <span class="string">'O'</span> || ch == <span class="string">'U'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(s);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(i)))&#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !isVowel(s.charAt(j)))&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">char</span> temp = s.charAt(i);</div><div class="line">            result.setCharAt(i,s.charAt(j));</div><div class="line">            result.setCharAt(j,temp);</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="external">Valid Palindrome</a></h3><h4 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.</p></blockquote><p>有效回文串，判断字符串中的有效字符是否可以构成有效回文串，其中有效字符仅包括字母和数字，大小写算同一个字母</p><h4 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h4><p>步骤</p><ol><li>需要一个确定是否是有效字符的函数<code>isvalid</code>,利用java中的<code>Character.isLetter()</code>和<code>Character.isDigit()</code></li><li>两指针一前一后遍历，遇到无效字符跳过，比较两指针指向的字符是否相等，如果不相等直接返回false</li></ol><h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isvalid</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Character.isLetter(c) || Character.isDigit(c);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(i)))&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//全是invalid字符的情况</span></div><div class="line">    <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; !isvalid(s.charAt(j)))&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    i++;j--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Valid-Palindrome-II"><a href="#Valid-Palindrome-II" class="headerlink" title="Valid Palindrome II"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="external">Valid Palindrome II</a></h3><h4 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;aba&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: &quot;abca&quot;</div><div class="line">&gt; Output: True</div><div class="line">&gt; Explanation: You could delete the character &apos;c&apos;.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定字符串，判断如果最多可以去掉一个字符，改字符串是否可以成为回文串</p><h4 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h4><p>跟上一题的思路有点不太一样，没有想到巧妙的方法</p><p>两指针指向头尾，如果两个指针指向元素相等，则i++;j—</p><p>如果两指针指向元素不相等，那么s[i+1]~s[j]和s[i]~s[j-1]中必然有一个是回文串</p><h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否是回文串</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(start == end)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> left = start;</div><div class="line">  <span class="keyword">int</span> right = end;</div><div class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    left++;</div><div class="line">    right--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s.length() &lt;= <span class="number">2</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = s.length() -<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">    <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> isPalindrome(s,i,j-<span class="number">1</span>) || isPalindrome(s,i+<span class="number">1</span>,j);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Longest-Word-in-Dictionary-through-Deleting"><a href="#Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="Longest Word in Dictionary through Deleting"></a><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="external">Longest Word in Dictionary through Deleting</a></h3><h4 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;apple&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:</div><div class="line">&gt; s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class="line">&gt;</div><div class="line">&gt; Output: </div><div class="line">&gt; &quot;a&quot;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定一个字符串s和一个字符串数组d,返回d中字符串是s的子序列的最长字符串，如果有长度相同的则返回在字母表中顺序最靠前的</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>遍历d中的字符串，看其是否能够由s的子序列构成，如果能，更新最大长度，如果和当前最大长度相等，取字典序小的</p><h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断是否能够是s的子序列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issubqueue</span><span class="params">(String s,String stemp)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> si = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> stempi = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; stempi &lt; stemp.length())&#123;</div><div class="line">    <span class="keyword">while</span>(si &lt; s.length() &amp;&amp; s.charAt(si) != stemp.charAt(stempi))&#123;</div><div class="line">      si++;</div><div class="line">    &#125;<span class="comment">//跳出时si==len或者遇到相等的了</span></div><div class="line">    <span class="keyword">if</span>(si == s.length())&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    si++;</div><div class="line">    stempi++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> stempi == stemp.length();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">  String result = <span class="keyword">new</span> String();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.size();i++)&#123;</div><div class="line">    String stemp = d.get(i);</div><div class="line">    <span class="keyword">int</span> len = stemp.length();</div><div class="line">    <span class="keyword">boolean</span> flag = issubqueue(s,stemp);</div><div class="line">    <span class="keyword">if</span>(flag)&#123;</div><div class="line">      <span class="keyword">if</span>(len &gt; maxlen)&#123;</div><div class="line">        maxlen = len;</div><div class="line">        result= stemp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(len == maxlen &amp;&amp; stemp.compareTo(result) &lt; <span class="number">0</span>)&#123;</div><div class="line">        result = stemp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里判断t是否是s的子序列存在优化的空间，可以利用Java的String中的indexOf(char,indexfrom)来判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//s是否包含t</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(String s,String t)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(t.length() &gt; s.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length();i++)&#123;</div><div class="line">    pos = s.indexOf(t.charAt(i),pos);</div><div class="line">    <span class="keyword">if</span>(pos != -<span class="number">1</span>)&#123;</div><div class="line">      pos++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Permutation-in-String"><a href="#Permutation-in-String" class="headerlink" title="Permutation in String"></a><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="external">Permutation in String</a></h3><h4 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</div><div class="line">&gt; Output:True</div><div class="line">&gt; Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</div><div class="line">&gt; Output: False</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>给定字符串s1和s2，返回s2中是否包含一个子串，使得该子串可以由s1中字母的某种排列方式构成。</p><h4 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h4><p>滑动窗口法，窗口长度设置为s1的长度，在s2中寻找s1的排列子串</p><p>窗口向右滑动，直到窗口内出现的字母以及每个字母出现的次数和s1中一样，此时找到了满足条件的子数组。</p><p>将s1中出现的字母和每个字母出现的次数记录在一个hashtable中，因为只有26个字母，可以用一个长度为26的数组记录每个字母出现的次数</p><h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span>[] s1map,<span class="keyword">int</span>[] s2map)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] != s2map[i])&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">if</span>(isSame(s1map,s2map))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    s2map[s2.charAt(s1.length()+i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isSame(s1map,s2map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>这里判断字符串相等还有可以优化的空间，用变量count表示当前窗口内和s1出现相同次数的字母的个数，当count == 26，则所有的字母都出现相同次数了，找到了解。当滑窗向后移动时，需要更新count</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion2</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length();i++)&#123;</div><div class="line">    s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(s1map[i] == s2map[i])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s2.length() - s1.length();i++)&#123;</div><div class="line">    <span class="keyword">int</span> r = s2.charAt(s1.length()+i) - <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">int</span> l = s2.charAt(i) - <span class="string">'a'</span>;</div><div class="line">    <span class="comment">//所有字母出现次数相等</span></div><div class="line">    <span class="keyword">if</span>(count == <span class="number">26</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//窗口将右边元素加入</span></div><div class="line">    s2map[r]++;</div><div class="line">    <span class="keyword">if</span>(s1map[r] == s2map[r])&#123;<span class="comment">//新加入元素后这个元素变得个数相等了</span></div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s2map[r] == s1map[r]+<span class="number">1</span>)&#123;<span class="comment">//新加入元素后比s1多一个了</span></div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">////窗口将左边元素去掉</span></div><div class="line">    s2map[l]--;</div><div class="line">    <span class="keyword">if</span>(s1map[l] == s2map[l])&#123;</div><div class="line">      count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1map[l] == s2map[l]+<span class="number">1</span>)&#123;</div><div class="line">      count--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count == <span class="number">26</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Subarray-Product-Less-Than-K"><a href="#Subarray-Product-Less-Than-K" class="headerlink" title="Subarray Product Less Than K"></a><a href="https://leetcode.com/problems/subarray-product-less-than-k" target="_blank" rel="external">Subarray Product Less Than K</a></h3><h4 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Your are given an array of positive integers <code>nums</code>.</p><p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: nums = [10, 5, 2, 6], k = 100</div><div class="line">&gt; Output: 8</div><div class="line">&gt; Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</div><div class="line">&gt; Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h4><p>滑窗+两指针i,j题:</p><p>如果窗口内乘积&gt;=k，i++,窗口缩小</p><p>如果滑窗内乘积&lt;k，窗口内包含的以j为结束的子数组个数为j-i+1</p><h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(start &lt; end &amp;&amp; end &lt; nums.length)&#123;</div><div class="line">    product *= nums[end];</div><div class="line">    <span class="keyword">while</span> (start &lt; end &amp;&amp; product &gt;= k)&#123;</div><div class="line">      product /= nums[start];</div><div class="line">      start++;</div><div class="line">    &#125;</div><div class="line">    count += end - start +<span class="number">1</span>;</div><div class="line">    end++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Wiggle-Sort-II"><a href="#Wiggle-Sort-II" class="headerlink" title="Wiggle Sort II"></a><a href="https://leetcode.com/problems/wiggle-sort-ii" target="_blank" rel="external">Wiggle Sort II</a></h3><blockquote><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p><p><strong>Example:</strong><br>(1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.<br>(2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</p><p><strong>Note:</strong><br>You may assume all input has valid answer.</p><p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p></blockquote><h4 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>这道题给了我们一个无序数组，让我们排序成摆动数组，满足nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…，并给了我们例子。我们可以先给数组排序，然后在做调整。调整的方法是找到数组的中间的数，相当于把有序数组从中间分成两部分，然后从前半段的末尾取一个，在从后半的末尾取一个，这样保证了第一个数小于第二个数，然后从前半段取倒数第二个，从后半段取倒数第二个，这保证了第二个数大于第三个数，且第三个数小于第四个数，以此类推直至都取完。</p><p>follow up：要求空间复杂度O(1)，没做上，要问下邓邓</p><h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid = end/<span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(idx &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</div><div class="line">                copy[idx] = nums[mid];</div><div class="line">                mid--;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                copy[idx] = nums[end];</div><div class="line">                end--;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            idx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            nums[i] = copy[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Super-Ugly-Number"><a href="#Super-Ugly-Number" class="headerlink" title="Super Ugly Number"></a><a href="https://leetcode.com/problems/super-ugly-number" target="_blank" rel="external">Super Ugly Number</a></h3><h4 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the nth super ugly number.</p><p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list <code>primes</code> of size <code>k</code>. For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]</code>is the sequence of the first 12 super ugly numbers given <code>primes</code> = <code>[2, 7, 13, 19]</code> of size 4.</p><p><strong>Note:</strong><br>(1) <code>1</code> is a super ugly number for any given <code>primes</code>.<br>(2) The given numbers in <code>primes</code> are in ascending order.<br>(3) 0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 106, 0 &lt; <code>primes[i]</code> &lt; 1000.<br>(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.</p></blockquote><p>给定n和素数序列，返回第n个ugly number:因子只能出现在素数序列中</p><h4 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h4><p>用上面的hashmap+heap的方法会超时，看了九章的答案和网上大神们给出的答案，才看明白啥意思</p><p>以上一题prime只有三个数字2,3,5为例，我们知道丑陋数序列可以拆分为下面3个子列表：</p><p>(1) <strong>1x2</strong>,  2x2, <strong>2x2</strong>, 3x2, <strong>3x2</strong>, <strong>4x2</strong>, 5x2…</p><p>(2) 1x3,  <strong>1x3</strong>, 2x3, 2x3, <strong>2x3</strong>, 3x3, <strong>3x3</strong>…</p><p>(3) 1x5,  1x5, 1x5, <strong>1x5,</strong> 2x5, 2x5, 2x5…</p><p>仔细观察上述三个列表，我们可以发现每个子列表都是一个丑陋数分别乘以2,3,5，而要求的丑陋数就是从已经生成的序列中取出来的，我们每次都从三个列表中取出当前最小的那个加入序列，比如第一次，ugly number当前只有1，分别于2,3,5相乘之后得到2,3,5三个数字，此时除1外，最小的是2，因此先把2加入ugly number 里，然后此时2就可以与当前ugly number中比1大的下一个数字相乘，与上一轮的3,5，进行比较了，。。。</p><p>因此，上面的规律总结起来就是：</p><ol><li>一共进行n轮计算和选择</li><li>每轮计算a*b，其中b是给定的prime列表中的数字，a是ugly number中的数字</li><li>每一轮选择本轮（本列）最小的元素加入ugly number,下一轮该行所选取的”a”的idx后移一位。</li></ol><h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] uglyNumbers = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];</div><div class="line">        uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; primes.length;j++)&#123;</div><div class="line">                min = Math.min(min,primes[j] * uglyNumbers[idx[j]]);</div><div class="line">            &#125;</div><div class="line">            uglyNumbers[i] = min;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; primes.length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(min == primes[j] * uglyNumbers[idx[j]])&#123;</div><div class="line">                    idx[j]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> uglyNumbers[n-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="external">Meeting Rooms II</a></h3><h4 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p><p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p></blockquote><p>给定一个interval序列，代表会议的开始和结束时间，返回需要的最大会议室数量，也就是同时开会的最大数量。</p><h4 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h4><p>方法一：扫描线的思路+heap实现</p><p>将会议的开始和结束时间排序，然后从较小的开始遍历，初始sum=0,遇到start+1,遇到end-1，过程中最大的sum即为同时召开的最大会议数量。要注意的是，遇到同一时刻既有会议开始也有会议结束时应该先访问end，将sum-1,然后再访问start.</p><p>需要用小顶堆维护会议开始和结束时间，小顶堆的判断依据为time和Start or End</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>方法二：</p><p>将所有开始时间和结束时间分别放入两个数组，分别排序，然后两指针一个指向开始数组i，一个指向结束数组j，初始化sum = 0;</p><p>i后移时sum++;</p><p>j后移时sum—;</p><p>当指向开始数组的指针&gt;=结束数组指针所指的值时，结束数组向后移动一位，否则开始指针后移。</p><h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</div><div class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        <span class="keyword">boolean</span> isStart;</div><div class="line">        Node(<span class="keyword">int</span> time,<span class="keyword">boolean</span> isStart)&#123;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.isStart = isStart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">        Comparator&lt;Node&gt; tmp = <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(o1.time != o2.time) <span class="keyword">return</span> o1.time - o2.time;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(o1.isStart == <span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(tmp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].start,<span class="keyword">true</span>));</div><div class="line">            heap.add(<span class="keyword">new</span> Node(intervals[i].end,<span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(heap.poll().isStart)&#123;</div><div class="line">                sum++;</div><div class="line">                max = Math.max(max,sum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;sum--;&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.length;i++)&#123;</div><div class="line">        starts[i] = intervals[i].start;</div><div class="line">        ends[i] = intervals[i].end;</div><div class="line">    &#125;</div><div class="line">    Arrays.sort(starts);</div><div class="line">    Arrays.sort(ends);</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; starts.length &amp;&amp; j &lt; ends.length)&#123;</div><div class="line">        <span class="keyword">if</span>(starts[i] &lt; ends[j])&#123;</div><div class="line">            sum++;</div><div class="line">            max = Math.max(max,sum);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            j++;</div><div class="line">            sum--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="The-Skyline-Problem"><a href="#The-Skyline-Problem" class="headerlink" title="The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem" target="_blank" rel="external">The Skyline Problem</a></h3><h4 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p><p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt="Buildings"> </p><p><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt="Skyline Contour"></p><p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p><p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p><p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p><p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p></blockquote><p>给定建筑物的坐标和高度，有重叠，计算轮廓</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>扫描线</p><h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;outline&quot;&gt;&lt;a href=&quot;#outline&quot; class=&quot;headerlink&quot; title=&quot;outline&quot;&gt;&lt;/a&gt;outline&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Sorted Array&lt;ul&gt;
&lt;li&gt;merge two sorted array&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>【九章算法基础班】课程笔记——链表</title>
    <link href="http://yoursite.com/2017/12/11/%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%8F%AD%E3%80%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/12/11/【九章算法基础班】链表/</id>
    <published>2017-12-11T14:39:23.000Z</published>
    <updated>2017-12-23T07:47:14.008Z</updated>
    
    <content type="html"><![CDATA[<p>考点重要程度：链表 -&gt; DFS/BFS -&gt;DP</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>test:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//print() 打印完整链表</span></div><div class="line">ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line"></div><div class="line">ListNode head = node1;</div><div class="line">node1.next = node2;</div><div class="line">node2.next = node3;</div><div class="line"></div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line">node1 = node2;</div><div class="line">print(head);</div><div class="line"><span class="comment">//1-&gt;2-&gt;3</span></div><div class="line"></div><div class="line">ListNode包括一个值和一个指针，head占<span class="number">4</span>Byte(<span class="number">32</span>bit)空间，head实际上是一个指针，通过head所指向的地址去找对应节点存储的值和下一个指针。</div><div class="line"></div><div class="line">链表结构：</div><div class="line">    [<span class="number">1</span>,] -&gt;  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,]  </div><div class="line">      ↑        ↑       ↑</div><div class="line">   head,n1     n2     n3</div><div class="line">   <span class="number">4</span><span class="keyword">byte</span>     <span class="number">4</span><span class="keyword">byte</span>   <span class="number">4</span><span class="keyword">byte</span></div><div class="line">   </div><div class="line">node1和node2都是指向节点的指针，如果令node1 = node2,那么只是node1存储的地址和node2存储的地址一样了，但是链表的机构没有改变，所以输出依然是:</div><div class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span> </div><div class="line">  </div><div class="line">如果要改变链表的结构，需要node.next = balabala</div></pre></td></tr></table></figure><a id="more"></a><h2 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h2><h3 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>删掉链表中有重复的节点，保留一个</p><p>因为删除某个节点node，需要让node的前序节点.next = node.next，因此需要构造一个dummy node，让其指向前序节点，这样需要删除head的时候就可以令dummy.next = node.next。初始化时令dummy.next=head</p><p>最后返回dummy.next</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev;<span class="comment">//用于记录重复元素第一次出现的位置</span></div><div class="line">  ListNode curt = head;<span class="comment">//用于向后遍历链表</span></div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      prev = curt;<span class="comment">//记录第一个出现的元素</span></div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，curt继续后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="external">Remove Duplicates from Sorted List II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p><p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p></blockquote><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>删除链表中重复出现的节点，全部删掉一个都不保留</p><p>因为删除某个节点node，需要让node的前序节点.next = node.next，删除全部重复的元素可能删掉head元素，因此需要构造一个dummy node，让其指向head的前序节点，也就是dummy.next = head。这样需要删除head的时候就可以令dummy.next = head.next。</p><p>最后反回dummy.next</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//虚拟节点用于指向head</span></div><div class="line">  dummy.next = head;</div><div class="line"></div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="comment">//遇到重复元素</span></div><div class="line">    <span class="keyword">if</span>(curt.next != <span class="keyword">null</span> &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      <span class="keyword">int</span> val = curt.val;<span class="comment">//存储当前节点的值，用于后续判断是否和当前值相等</span></div><div class="line">      <span class="comment">//curt向后移动，直到和curt值不相等停止</span></div><div class="line">      <span class="keyword">while</span> (curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//curt == null || curt.val != val;此时curt指向后面第一个和它值不相等的元素</span></div><div class="line">      <span class="comment">//将prev.next指向第一个不相等的元素</span></div><div class="line">      prev.next = curt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有遇到重复元素，prev和curt都后移一位</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev = prev.next;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="external">Reverse Linked List</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Reverse a singly linked list.、</p><p>Hint:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p></blockquote><p>链表反转</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑</div><div class="line"> prev   curt</div><div class="line"> </div><div class="line"><span class="number">1</span>. 用temp记录下curt.next（因为后面要修改curt.next）</div><div class="line"> <span class="keyword">null</span>   [<span class="number">1</span>,] -&gt; [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"> </div><div class="line"><span class="number">2</span>. 将curt.next指向其前序节点prev，此时原来的后续链断掉:</div><div class="line"> <span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">  ↑       ↑      ↑</div><div class="line"> prev   curt    temp</div><div class="line"><span class="number">3</span>. 将prev移到curt位置，curt移动到原来的curt.next,即temp:</div><div class="line"><span class="keyword">null</span> &lt;- [<span class="number">1</span>,]  [<span class="number">2</span>,] -&gt; [<span class="number">3</span>,] -&gt; [<span class="number">4</span>,] -&gt; [,<span class="number">5</span>,]</div><div class="line">         ↑      ↑       ↑</div><div class="line">        prev   curt    temp</div><div class="line"></div><div class="line">ListNode temp = curt.next;</div><div class="line">curt.next = prev</div><div class="line">prev = curt;</div><div class="line">curt = temp;</div></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  ListNode prev = <span class="keyword">null</span>;</div><div class="line">  ListNode curt = head;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    ListNode temp = curt.next;</div><div class="line">    curt.next = prev;</div><div class="line">    prev = curt;</div><div class="line">    curt = temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii" target="_blank" rel="external">Reverse Linked List II</a></h3><blockquote><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p><p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p><strong>Note:</strong><br>Given <em>m</em>, <em>n</em> satisfy the following condition:<br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p></blockquote><p>将链表的第m-n位置上的元素反转</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[<span class="number">1</span>,]-&gt;[<span class="number">2</span>,]-&gt;...-&gt;[m-<span class="number">1</span>,]-&gt;[m,]-&gt;...-&gt;[n,]-&gt;[n+<span class="number">1</span>,]-&gt;...</div><div class="line">翻转m和n之间的部分，分为三个步骤：</div><div class="line"><span class="number">1</span>. 找到m-<span class="number">1</span>和m的点，设为prev和curt</div><div class="line"><span class="number">2</span>. 将m~n反转</div><div class="line"><span class="number">3</span>. 把m-<span class="number">1</span>.next指向n;把m.next指向n.next</div></pre></td></tr></table></figure><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-12-00-49-23.png" alt=""></p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt = head;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="comment">//寻找第m个节点</span></div><div class="line">        <span class="keyword">while</span> (i &lt; m)&#123;</div><div class="line">            curt = curt.next;</div><div class="line">            prev = prev.next;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时prev指向第m-1个节点，curt指向第m个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//记录下m节点和m-1节点位置，用于反转后连接</span></div><div class="line">        ListNode m_node = curt;</div><div class="line">        ListNode m_prev = prev;</div><div class="line"></div><div class="line">        <span class="comment">//将m到n反转</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= n)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="comment">//此时curt指向第n+1个节点，prev指向第n个节点</span></div><div class="line"></div><div class="line">        <span class="comment">//将m的前序节点的next指向第n个节点</span></div><div class="line">        m_prev.next = prev;</div><div class="line">        <span class="comment">//将m节点的next指向第n+1个节点</span></div><div class="line">        m_node.next = curt;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a><a href="https://leetcode.com/problems/partition-list" target="_blank" rel="external">Partition List</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p><p>给定一个链表和一个数x，将链表中比x小的排在左边，大于等于x的数字排在右边，数字的相对顺序保持不变</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>将链表排成两队，小于x的一队，大于等于x的一队，然后把两个链表连起来。</p><p>链表的结构会发生变化，所以需要两个dummy node，一个用来指向小的队dummy_low，一个用来指向大的队dummy_high。</p><p><strong>解题步骤：</strong></p><ol><li>遍历数组，将比x小的元素放到dummy_low队伍后面，将比x大的元素放到dummy_high队伍后面</li><li>结束后将两个链表连接起来：dummy_low.next指向dummy_high.next</li><li>将链表结尾置空：tail.next = null,否则会保留原始节点的next。</li><li>返回dummy_low.next;</li></ol><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        ListNode next;</div><div class="line"></div><div class="line">        ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">establish</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode curt = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item : array)&#123;</div><div class="line">            ListNode node = <span class="keyword">new</span> ListNode(item);</div><div class="line">            curt.next = node;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        curt.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        ListNode dummy_low = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode dummy_high = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line"></div><div class="line">        ListNode prev_low = dummy_low;<span class="comment">//用于向小链表插入</span></div><div class="line">        ListNode prev_high = dummy_high;<span class="comment">//用于向大链表插入</span></div><div class="line"></div><div class="line">        <span class="comment">//分别放到两个队伍里</span></div><div class="line">        ListNode curt = head;</div><div class="line">        <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt.val &lt; x)&#123;</div><div class="line">                prev_low.next = curt;</div><div class="line">                prev_low = prev_low.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev_high.next = curt;</div><div class="line">                prev_high = prev_high.next;</div><div class="line">            &#125;</div><div class="line">            curt = curt.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将两链表连接</span></div><div class="line">        prev_low.next = dummy_high.next;</div><div class="line">        prev_high.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy_low.next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">            System.out.println(head.val);</div><div class="line">            System.out.println(<span class="string">" -&gt; "</span>);</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        PartitionList test = <span class="keyword">new</span> PartitionList();</div><div class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line">        ListNode head = test.establish(array);</div><div class="line">        head = test.partition(head,x);</div><div class="line">        test.printList(head);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">Merge Two Sorted Lists</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">&gt; Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>链表结构可能改变， 所以需要dummy node</p><p>需要一个prev指针记录当前节点，初始化指向dummy_node两个curt指针分别指向两个链表当前节点，用于比较，将比较小的接在prev后面，知道两个curt中有一个为空，将另一个链表的后面直接接到prev后面。</p><p>最后返回dummy.next</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt1 = l1;</div><div class="line">        ListNode curt2 = l2;</div><div class="line">        <span class="keyword">while</span> (curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(curt1.val &lt; curt2.val)&#123;</div><div class="line">                prev.next = curt1;</div><div class="line">                curt1 = curt1.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                prev.next = curt2;</div><div class="line">                curt2 = curt2.next;</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a><a href="https://leetcode.com/problems/sort-list" target="_blank" rel="external">Sort List</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p><p>将链表排序，时间复杂度为 <em>O</em>(<em>n</em> log <em>n</em>)</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>时间复杂度为nlogn的排序：quick sort\merge sort\heap sort</p><p>quick sort和merge sort的区别：</p><ol><li><p>算法流程</p><p>quik sort：整体有序 -&gt; 局部有序、不稳定排序</p><ul><li>整体有序：选定一个元素，比它小的都在它左边，比它大的都在它右边</li><li>局部有序：然后再对左段和右段分别做快排</li></ul><p>merge sort：局部有序 -&gt; 整体有序、稳定排序</p><ul><li>局部有序：选取中点将序列分成左右两段，对左右两边分别排序</li><li>整体有序：将左右两边sort list 进行merge操作使得整个list有序</li></ul></li></ol><ol><li><p>排序的稳定性</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[2 , 1&apos; , 1&apos;&apos;, 1&apos;&apos;&apos; , 4 , 3&apos; , 3&apos;&apos;]</div><div class="line">merge sort的merge操作不会改变元素的相对顺序，所以是稳定排序</div><div class="line">quick sort会改变元素的相对位置，所以不是稳定排序</div></pre></td></tr></table></figure><p>​</p></li><li><p>时间复杂度</p><p>quick sort平均时间复杂度<script type="math/tex">O(nlogn)</script>，最坏时间复杂度<script type="math/tex">O(n^2)</script></p><p>merge sort时间复杂度：<script type="math/tex">O(nlogn)</script></p></li><li><p>空间复杂度</p><p>quick sort：<script type="math/tex">O(1)</script></p><p>merge sort：<script type="math/tex">O(n)</script> ，但是在链表中不需要开辟额外的空间</p></li></ol><p><strong>解题步骤：</strong></p><p>merge sort</p><p>​    具体步骤：</p><ol><li>merge sort在链表中找中点，有两种方法：<ol><li>遍历一遍，得到链表的长度n，则中间位置是n/2，再从头遍历一遍，到n/2的位置停止，找到中点</li><li>设置两个错位指针，一个slow一个fast，初始化都指向head，slow每次向右移动一位，fast每次向右移动两位，fast移动到末尾的时候，head指向中间，取到链表中点</li></ol></li><li>对左右两段递归进行排序</li><li>merge两段有序链表</li></ol><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">merge sort:</div><div class="line"><span class="comment">//寻找链表中点,中间偏前</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  ListNode slow = head;</div><div class="line">  ListNode fast = head;</div><div class="line">  <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//merge两段有序链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode left_h,ListNode right_h)</span></span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt_l = left_h;</div><div class="line">  ListNode curt_r = right_h;</div><div class="line">  <span class="keyword">while</span> (curt_l != <span class="keyword">null</span> &amp;&amp; curt_r != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(curt_l.val &lt; curt_r.val)&#123;</div><div class="line">      prev.next = curt_l;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_l = curt_l.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      prev.next = curt_r;</div><div class="line">      prev = prev.next;</div><div class="line">      curt_r = curt_r.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_l == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_r;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(curt_r == <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt_l;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归调用merge sort</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//寻找链表中点mid</span></div><div class="line">  ListNode mid = findMid(head);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点.next之后的链表排序</span></div><div class="line">  ListNode right = sortList(mid.next);</div><div class="line"></div><div class="line">  <span class="comment">//链表中点之前包括中点的链表排序</span></div><div class="line">  mid.next = <span class="keyword">null</span>;</div><div class="line">  ListNode left = sortList(head);</div><div class="line"></div><div class="line">  <span class="comment">//merge两段有序链表</span></div><div class="line">  ListNode res = merge(left,right);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="external">Reorder List</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,</p><p>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>You must do this in-place without altering the nodes’ values.</p><p>For example,</p><p>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p></blockquote><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>题目需要从后向前访问链表，但是链表是单向的，所以需要reverse反转操作，再和原链表merge。</p><p><strong>具体步骤：</strong></p><ol><li>找到链表中点，mid</li><li>将mid之后的链表反转</li><li>将mid之前的链表和mid之后反转的链表做merge操作</li></ol><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//找到中间位置的元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    ListNode slow = head;</div><div class="line">    ListNode fast = head;</div><div class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//链表反转</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode prev = <span class="keyword">null</span>;</div><div class="line">    ListNode curt = head;</div><div class="line">    <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">        ListNode temp = curt.next;</div><div class="line">        curt.next = prev;</div><div class="line">        prev = curt;</div><div class="line">        curt = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prev;</div><div class="line">&#125;</div><div class="line"><span class="comment">//交替merge</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">    ListNode prev = left;</div><div class="line">    ListNode curt1 = left.next;</div><div class="line">    ListNode curt2 = right;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(curt1 != <span class="keyword">null</span> &amp;&amp; curt2 != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            prev.next = curt2;</div><div class="line">            curt2 = curt2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = curt1;</div><div class="line">            curt1 = curt1.next;</div><div class="line">        &#125;</div><div class="line">        prev = prev.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(curt1 == <span class="keyword">null</span>)&#123;</div><div class="line">        prev.next = curt2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = curt1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="comment">//边界条件</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//找到mid</span></div><div class="line">    ListNode mid = findMid(head);</div><div class="line"></div><div class="line">    <span class="comment">//将mid之后的部分反转</span></div><div class="line">    ListNode right = reverse(mid.next);</div><div class="line">    mid.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//前半部分和反转后的后半部分merge</span></div><div class="line">    merge(head,right);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Fast-slow-pointer"><a href="#Fast-slow-pointer" class="headerlink" title="Fast-slow pointer"></a>Fast-slow pointer</h2><h3 id="1-Middle-of-Linked-List"><a href="#1-Middle-of-Linked-List" class="headerlink" title="1. Middle of Linked List"></a>1. Middle of Linked List</h3><p>寻找指针链表中点，快慢指针，快指针每次走两步，慢指针每次走一步，快指针走到链表结尾时，慢指针在中间</p><h3 id="2-Remove-Nth-Node-From-End-of-List"><a href="#2-Remove-Nth-Node-From-End-of-List" class="headerlink" title="2 .Remove Nth Node From End of List"></a>2 .<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">Remove Nth Node From End of List</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;    Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line">&gt;</div><div class="line">&gt;    After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p></blockquote><p>删除掉从末尾开始第n个节点</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>两个指针，fast先走n+！步slow再出发，当fast==null时，slow指向倒数第n+1个节点，删掉slow后面的节点：slow.next = slow.next.next</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    dummy.next = head;</div><div class="line">    ListNode slow = dummy;</div><div class="line">    ListNode fast = dummy;</div><div class="line">    <span class="comment">//fast先走n+1步</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</div><div class="line">        fast = fast.next;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast、slow同时向后遍历</span></div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</div><div class="line">        fast =fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除节点</span></div><div class="line">    slow.next = slow.next.next；</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-Linked-List-Cycle"><a href="#3-Linked-List-Cycle" class="headerlink" title="3. Linked List Cycle"></a>3. <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p></blockquote><p>给定一个链表，判断是否有圈</p><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>判断node是否有被重复访问</p><p>从head出发，把所有访问过的点放到一个hash表里，空间复杂度O(n)</p><p>方法二：</p><p>一个快指针一个慢指针，如果路径上有环，快慢指针一定会相遇</p><p>初始化：slow = head;fast = head.next</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ListNode fast = head.next;</div><div class="line">    ListNode slow = head;</div><div class="line">    <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">        <span class="comment">//fast走到null</span></div><div class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow =slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fast和slow相遇了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-Linked-List-Cycle-II"><a href="#4-Linked-List-Cycle-II" class="headerlink" title="4. Linked List Cycle II"></a>4. <a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">Linked List Cycle II</a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p></blockquote><p>是否有环，如果有，找到环的入口</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>slow从快慢指针相遇的地方出发，fast指针从初始地方出发，两个指针每次走一步，直到相遇，就是环的入口</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  ListNode fast = head.next;</div><div class="line">  ListNode slow = head;</div><div class="line">  <span class="keyword">while</span>(fast != slow)&#123;</div><div class="line">    <span class="comment">//fast走到null</span></div><div class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    fast = fast.next.next;</div><div class="line">    slow = slow.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//fast和slow相遇了</span></div><div class="line">  slow = head;</div><div class="line">  fast = fast.next;</div><div class="line">  <span class="keyword">while</span>(slow != fast)&#123;</div><div class="line">    slow = slow.next;</div><div class="line">    fast = fast.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-Rotate-List"><a href="#5-Rotate-List" class="headerlink" title="5. Rotate List"></a>5. <a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="external">Rotate List</a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</div><div class="line">&gt; return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>将链表向后移k次</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Given <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL and k = <span class="number">2</span>,</div><div class="line">            ↑  ↑  ↑</div><div class="line">node.next=head ↑  ↑</div><div class="line">      dummy.next tail.next=head</div></pre></td></tr></table></figure><p>求解步骤：</p><ol><li>求链表长度len，如果k&gt;len,k = k%len;</li><li>找到从后往前数第k个元素，也就是从前往后数第len-k个元素node，和末尾元素tail</li><li>tail.next = dummy.next;dummy.next = node.next;node.next = null</li></ol><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">           <span class="keyword">return</span> head;</div><div class="line">       &#125;</div><div class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">       dummy.next = head;</div><div class="line">       ListNode tail = dummy;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>)&#123;</div><div class="line">           tail = tail.next;</div><div class="line">           len++;</div><div class="line">       &#125;</div><div class="line">       k = k % len;</div><div class="line">       ListNode node = dummy;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span>(i &lt;= len - k)&#123;</div><div class="line">           node = node.next;</div><div class="line">           i++;</div><div class="line">       &#125;</div><div class="line">       tail.next = dummy.next;</div><div class="line">       dummy.next = node.next;</div><div class="line">       node.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">Merge k Sorted Lists</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p></blockquote><p>merge k 个有序链表</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>一共三种方法，都需要掌握：</p><p>方法一：heap</p><p>用PriorityQueue实现</p><p>第一个参数 - 第二个参数：升序，最小堆</p><p>第二个参数 - 第一个参数：降序，最大堆</p><p>初始化：将链表头放进去</p><p>每次弹出最小的元素，放到结果链表后面，然后将其next入堆，重复上述</p><p>N：所有数的个数</p><p>K：链表个数</p><p>时间复杂度：<script type="math/tex">O(NlogK)</script> ，heap中最多有k各元素，插入操作时间复杂度是<script type="math/tex">O(logk)</script></p><p>空间复杂度：<script type="math/tex">O(K)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//heap</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> k = lists.length;</div><div class="line">        PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</div><div class="line">           <span class="comment">// @Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.val - o2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</div><div class="line">            ListNode head = lists[i];</div><div class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(head);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</div><div class="line">            ListNode curt = minHeap.poll();</div><div class="line">            prev.next = curt;</div><div class="line">            <span class="keyword">if</span>(curt.next != <span class="keyword">null</span>)&#123;</div><div class="line">                minHeap.add(curt.next);</div><div class="line">            &#125;</div><div class="line">            prev = prev.next;</div><div class="line">        &#125;</div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法二：分治法</p><p>merge k 个链表</p><ul><li>拆分成merge前k/2个链表得到list1和merge后k/2个链表得到list2</li><li>合并list1和 list2，得到结果</li></ul><p>递归调用求解上述子问题</p><p>时间复杂度：<script type="math/tex">O(NlogK)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     result</div><div class="line">     ↗    ↖</div><div class="line">   ↗      ↗ ↖</div><div class="line">↗  ↖    ↗   ↗  ↖</div><div class="line"><span class="number">1</span><span class="number">2</span> |<span class="number">3</span> |<span class="number">4</span><span class="number">5</span></div><div class="line"> </div><div class="line"></div><div class="line">    <span class="comment">//分治</span></div><div class="line">    <span class="comment">//merge两个List</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergeTwoList</span><span class="params">(ListNode left,ListNode right)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode prev1 = left;</div><div class="line">        ListNode prev2 = right;</div><div class="line">        <span class="keyword">while</span>(prev1 != <span class="keyword">null</span> &amp;&amp; prev2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(prev1.val &lt; prev2.val)&#123;</div><div class="line">                prev.next = prev1;</div><div class="line">                prev1 = prev1.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                prev.next = prev2;</div><div class="line">                prev2 = prev2.next;</div><div class="line">                prev = prev.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev1 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(prev2 == <span class="keyword">null</span>)&#123;</div><div class="line">            prev.next = prev1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//分治法mergek个数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">divideMergeKList</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(start == end)&#123;</div><div class="line">            <span class="keyword">return</span> lists[start];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//拆分成两部分</span></div><div class="line">        ListNode left = divideMergeKList(lists,start,start+(end-start)/<span class="number">2</span>);</div><div class="line">        ListNode right = divideMergeKList(lists,start+(end-start)/<span class="number">2</span>+<span class="number">1</span>,end);</div><div class="line">        <span class="comment">//合并两部分结果返回</span></div><div class="line">        <span class="keyword">return</span> MergeTwoList(left,right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用分治法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">DividemergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> len = lists.length;</div><div class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> divideMergeKList(lists,<span class="number">0</span>,len-<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法三：两两合并</p><p>1、2合并，3、4合并，….n</p><p>向上递归合并</p><p>时间复杂度：<script type="math/tex">O(NlogK)</script></p><p>如果是1、2合并，然后忽然3合并，…n</p><p>时间复杂度O(NK)</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//两两合并</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsOneByOne</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(lists.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  List&lt;ListNode&gt; newlists = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length;i++) &#123;</div><div class="line">    newlists.add(lists[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (newlists.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">    List&lt;ListNode&gt; listTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+<span class="number">1</span> &lt; newlists.size();i+=<span class="number">2</span>)&#123;</div><div class="line">      listTemp.add(MergeTwoList(newlists.get(i),newlists.get(i+<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newlists.size() % <span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">      listTemp.add(newlists.get(newlists.size()-<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    newlists = listTemp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newlists.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="external">Copy List with Random Pointer</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><blockquote><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p></blockquote><p>给定一个链表，每个节点除包含一个next指针以外，还有一个指向任意节点的random pointer，clone链表</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>hash_map</p><p>先按next指针复制链表，把原链表老节点和新链表新节点的映射关系存入hash_map，再遍历一遍原链表，按照hash_map中的对应关系，把random pointer在对应的新节点中标出。</p><p>空间复杂度<script type="math/tex">O(n)</script></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">       RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">       RandomListNode prevNew = dummy;</div><div class="line">       RandomListNode prev = head;</div><div class="line">       HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">       <span class="comment">//将链表和next指针复制，对应点存入hashmap</span></div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           RandomListNode temp = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">           prevNew.next = temp;</div><div class="line">           map.put(prev,prevNew.next);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//复制random poiner</span></div><div class="line">       prev = head;</div><div class="line">       prevNew = dummy.next;</div><div class="line">       <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">           prevNew.random = map.get(prev.random);</div><div class="line">           prev = prev.next;</div><div class="line">           prevNew = prevNew.next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> dummy.next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>方法二：</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-57-14.png" alt=""> </p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList2</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">  RandomListNode prev = head;</div><div class="line">  <span class="comment">//将每个元素都复制一份，插在原来元素的后面一位上</span></div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    RandomListNode node = <span class="keyword">new</span> RandomListNode(prev.label);</div><div class="line">    node.next = prev.next;</div><div class="line">    prev.next = node;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//加入random pointer</span></div><div class="line">  prev = head;</div><div class="line">  <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(prev.random != <span class="keyword">null</span>)&#123;</div><div class="line">      prev.next.random = prev.random.next;</div><div class="line">    &#125;</div><div class="line">    prev = prev.next.next;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//删掉原来元素；</span></div><div class="line">  RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">  dummy.next = head;</div><div class="line">  prev = dummy;</div><div class="line">  RandomListNode curt = head;</div><div class="line">  <span class="keyword">while</span>(curt != <span class="keyword">null</span>)&#123;</div><div class="line">    prev.next = curt.next;</div><div class="line">    curt.next = curt.next.next;</div><div class="line">    prev = prev.next;</div><div class="line">    curt = curt.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-14-23-55-46.png" alt=""> </p><h2 id="leetcode-相关习题"><a href="#leetcode-相关习题" class="headerlink" title="leetcode 相关习题"></a>leetcode 相关习题</h2><h3 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">Palindrome Linked List</a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Given a singly linked list, determine if it is a palindrome.</p><p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p></blockquote><p>给定链表，判读是否是回文串，要求时间复杂度<script type="math/tex">O(n)</script>，空间复杂度<script type="math/tex">O(1)</script></p><h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>方法一：</p><p>利用stack，先进后出的性质：</p><ol><li>找到终点，过程中将前半部分链表入栈</li><li>继续向后遍历，出栈，对比元素是否一致</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeStack</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="comment">//空链表和只有一个元素</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//快慢指针寻找中点,前半部分元素入栈</span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        stack.push(head.val);</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            stack.push(mid.val);</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是奇数个元素，将mid弹出，无须比较</span></div><div class="line">        <span class="keyword">if</span>(tail.next == <span class="keyword">null</span>)&#123;</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        mid = mid.next;</div><div class="line">        <span class="keyword">while</span>(mid != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">int</span> temp = stack.peek();</div><div class="line">            <span class="keyword">if</span>(temp != mid.val)&#123;</div><div class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            stack.pop();</div><div class="line">            mid = mid.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>方法二：</p><ol><li>先找到中点</li><li>将后半部分的链表反转</li><li>对比前后两部分是否一致</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//快慢指针寻找中点</span></div><div class="line">        ListNode mid = head;</div><div class="line">        ListNode tail = head;</div><div class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span> &amp;&amp; tail.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">            mid = mid.next;</div><div class="line">            tail = tail.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//反转后半个链表</span></div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        ListNode curt = mid.next;</div><div class="line">        <span class="keyword">while</span>(curt !=  <span class="keyword">null</span>)&#123;</div><div class="line">            ListNode temp = curt.next;</div><div class="line">            curt.next = prev;</div><div class="line">            prev = curt;</div><div class="line">            curt = temp;</div><div class="line">        &#125;</div><div class="line">        mid.next = prev;</div><div class="line">        <span class="comment">//对比两段元素是否一致</span></div><div class="line">        ListNode first = head;</div><div class="line">        ListNode second = mid.next;</div><div class="line">        <span class="keyword">while</span>(second != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(first.val != second.val)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            first = first.next;</div><div class="line">            second = second.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">160.Intersection of Two Linked Lists</a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; A:          a1 → a2</div><div class="line">&gt;                    ↘</div><div class="line">&gt;                      c1 → c2 → c3</div><div class="line">&gt;                    ↗            </div><div class="line">&gt; B:     b1 → b2 → b3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>begin to intersect at node c1.</p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul></blockquote><p>找到两个链表相交的地方</p><h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><p>是个技巧题，想到了就能做出来，想不到就做不出来</p><p><img src="http://omaby2s5z.bkt.clouddn.com/2017-12-22-20-02-17.png" alt=""> </p><p>方法：</p><p>两个指针分别遍历，一个先A后B，一个先B后A，两指针指向节点相等即为相交处</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode n1 = headA;</div><div class="line">        ListNode n2 = headB;</div><div class="line">        <span class="comment">//记录是否遍历第二个链表</span></div><div class="line">        <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//两个指针都遍历结束了，没有相交节点</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; flag1)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n1遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; !flag1)&#123;</div><div class="line">                 n1 = headB;</div><div class="line">                 flag1 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//n2遍历完一个数组</span></div><div class="line">            <span class="keyword">if</span>(n2 == <span class="keyword">null</span> &amp;&amp; !flag2)&#123;</div><div class="line">                n2 = headA;</div><div class="line">                flag2 = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (n1 == n2)&#123;</div><div class="line">                <span class="keyword">return</span> n1;</div><div class="line">            &#125;</div><div class="line">            n1 = n1.next;</div><div class="line">            n2 = n2.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> idx = Math.abs(nums[i]);</div><div class="line">            <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> idx;</div><div class="line">            &#125;</div><div class="line">            nums[idx] = -nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考点重要程度：链表 -&amp;gt; DFS/BFS -&amp;gt;DP&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;test:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//print() 打印完整链表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode node1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode node2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode node3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode head = node1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node1.next = node2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node2.next = node3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(head);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node1 = node2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(head);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode包括一个值和一个指针，head占&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;Byte(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;bit)空间，head实际上是一个指针，通过head所指向的地址去找对应节点存储的值和下一个指针。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;链表结构：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,] -&amp;gt;  [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,] -&amp;gt; [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,]  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      ↑        ↑       ↑&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   head,n1     n2     n3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node1和node2都是指向节点的指针，如果令node1 = node2,那么只是node1存储的地址和node2存储的地址一样了，但是链表的机构没有改变，所以输出依然是:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;如果要改变链表的结构，需要node.next = balabala&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
